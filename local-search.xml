<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/10/11/KMP/"/>
    <url>/2023/10/11/KMP/</url>
    
    <content type="html"><![CDATA[<p>j</p><p>将模式串指针j的回溯 看作整个模式串向后移动来匹配主串</p><p>当i j不匹配的时候有两种做法，第一是模式串移动到当前串的后面（对应的其实是next数组移动到0的位置的时候 也就是全不匹配的时候）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>          <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>第二种 移动到下一个公共子串的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>    <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>即主串的后缀集合与模式串的前缀集合有交集的时候</p><p>j指针回溯的位置是A后缀和B前缀交集里最长的元素（这样不会遗漏）最长元素的长度就是j回溯的位置</p><p>匹配失败 但是A和B串存在一段相同的子串 j回溯的位置只与B有关（A、B相同子串的前后缀 其实就是B子串的前后缀） 因此可以先求出B放入next数组</p><p>next[i]表示B[1]~B[i]最长公共前后缀的长度</p><p>匹配步骤</p><p>i, j初始化为0</p><p>1.如果A[i + 1] &#x3D;&#x3D; B[j + 1] i++,j++</p><p>2.如果不相等 不断回溯j到next[j] 直到A[i + 1] &#x3D;&#x3D; B[j + 1]   或者j回溯到next[0] &#x3D; -1了 此时直接让i++（）意思是B移到A后面</p><p>3.j &#x3D; m 匹配成功输出位置 </p><p>构建next数组  </p><p>求B[1]~B[i]最长公共后缀长度</p><p>如果匹配 next[i] &#x3D; j + 1  (j 表示B串前缀的指针 也就是当前字符匹配之前的最长公共前后缀长度 匹配成功就+1)</p><p>匹配不成功 回溯j指针j &#x3D; next[j]直到成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(string p, <span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i] = j<br>&#125;<br>        <span class="hljs-keyword">else</span><br>           j = next[j]<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">KMP</span>(string s, string p, <span class="hljs-type">int</span> next[])<br>&#123;<br>    <span class="hljs-built_in">getnext</span>(p,next);<br>    <br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j = next[j]<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == p_len)<span class="hljs-keyword">return</span> i - j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课题组学习</title>
    <link href="/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）"><a href="#分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）" class="headerlink" title="分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></h1><h2 id="压缩表示"><a href="#压缩表示" class="headerlink" title="压缩表示"></a>压缩表示</h2><p>集合用二进制表示，从高到低第i位为1表示i在集合中。如{0,2,3}可以表示为1101，压缩成一个数字 13</p><h2 id="集合与集合"><a href="#集合与集合" class="headerlink" title="集合与集合"></a>集合与集合</h2><p>集合的交并补差</p><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><p>“&lt;&lt;”代表左移，相当于乘2 ^ i</p><p>“&gt;&gt;”代表右移， 相当于除2 ^ i</p><p>补集~s</p><p>全集 (1&lt;&lt;n) - 1</p><p>属于  (s &gt;&gt; i) &amp; 1 &#x3D; 1</p><p>不属于 (s &gt;&gt; i) &amp; 1 &#x3D; 0</p><p>添加元素 s | (1 &lt;&lt; i)</p><p>删除元素 s &amp; ~ (1 &lt;&lt; i)  (比如i &#x3D; 2 变成0100 取反变成 1011 然后和s并起来  这样才可以保证 只删除目标位而不影响其他位)</p><p>删除最小元素 s &amp; (s - 1) ((s - 1)可以使得最低位的1变为0 并且其右边的所有0变为1  然后&amp;s 使得 最低位的1以及后面的所有0全部变成0)</p><p>lowbit  &#x3D; s &amp; (-s)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">     s = <span class="hljs-number">101100</span><br>    ~s = <span class="hljs-number">010011</span><br>(~s)+<span class="hljs-number">1</span> = <span class="hljs-number">010100</span> <span class="hljs-regexp">//</span> 根据补码的定义，这就是 -s   最低 <span class="hljs-number">1</span> 左侧取反，右侧不变<br>s &amp; -s = <span class="hljs-number">000100</span> <span class="hljs-regexp">//</span> lowbit<br></code></pre></td></tr></table></figure><h3 id="部分库函数"><a href="#部分库函数" class="headerlink" title="部分库函数"></a>部分库函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">s.bit_count() <span class="hljs-comment"># 集合大小</span><br>s.bit_length() <span class="hljs-comment"># 二进制长度</span><br>(s&amp;-s).bit_length()-<span class="hljs-number">1</span> <span class="hljs-comment"># 集合中的最小元素</span><br></code></pre></td></tr></table></figure><h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-comment"># 如果i在s中</span><br>    <span class="hljs-keyword">if</span> (s &gt;&gt; i) &amp; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="枚举集合"><a href="#枚举集合" class="headerlink" title="枚举集合"></a>枚举集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 从空集枚举到全集U</span><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 设集合为s 从大到小枚举s的所有非空子集sub</span><br>sub = s<br><span class="hljs-keyword">while</span> sub:<br>    <span class="hljs-comment"># pass</span><br>    <br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s <span class="hljs-comment"># （如何证明？）</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">跳过非子集的集合！</span><br><span class="hljs-string">意思是，把10100 的最低位1变0，它的后面有两位 00， 都是0。这时候按照普通二进制，会把这两个 00 都变成 11，如果按照压缩版，就只把原来集合里有的 1 变成 1 （因为求的是子集），其余的还是 0，原有的集合是 10101，最后两位是 01，所以只保留 01。综合起来就是 10100 先变 10000，然后保留 01，变成 10001。</span><br><span class="hljs-string"></span><br><span class="hljs-string">这样做的效果是从 10100 直接跳到 10001，把中间的 10011 和10010 忽略掉了（普通减法顺序是 10100 - 10011 - 10010 - 10001），因为10011 和 10010不是有效的子集。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 所有子集</span><br><span class="hljs-keyword">while</span> sub:<br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s<br>    <span class="hljs-keyword">if</span> sub == s:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h1 id="136-只出现一次的数字-力扣（LeetCode）"><a href="#136-只出现一次的数字-力扣（LeetCode）" class="headerlink" title="136. 只出现一次的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></h1><p>一个数字出现一次 其他数字出现两次   用异或操作 因为a^0 &#x3D; a a ^ a &#x3D; 0 所以两个一样的数异或就为0 </p><p>并且a ^ b ^ c 满足交换律  </p><p>即所有的数都是相同的凑成一对 变为0   然后剩下的目标数字^0 &#x3D; 目标  输出即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            ret ^= x<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="137-只出现一次的数字-II-力扣（LeetCode）"><a href="#137-只出现一次的数字-II-力扣（LeetCode）" class="headerlink" title="137. 只出现一次的数字 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-ii/description/">137. 只出现一次的数字 II - 力扣（LeetCode）</a></h1><p>一个数字出现三次  目标数字出现三次</p><p>所以每个比特位的1的数量必定是3的倍数  不是3的倍数的 就是ans的比特位 </p><p>注意python这种对有符号整型和无符号整型不区分的语言 需要特判最高位</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = [<span class="hljs-number">0</span>] * <span class="hljs-number">33</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>                ret[i] += ((x&gt;&gt;i) &amp; <span class="hljs-number">1</span>)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>            <span class="hljs-keyword">if</span> ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">31</span>:<br>                    ans -= (<span class="hljs-number">1</span> &lt;&lt; i)<br>                <span class="hljs-keyword">else</span>:<br>                    ans |= (<span class="hljs-number">1</span> &lt;&lt; i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            &#123;<br>                ret[i] += ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>)<br>                ans += (<span class="hljs-number">1</span> &lt;&lt; i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="260-只出现一次的数字-III-力扣（LeetCode）"><a href="#260-只出现一次的数字-III-力扣（LeetCode）" class="headerlink" title="260. 只出现一次的数字 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-iii/description/">260. 只出现一次的数字 III - 力扣（LeetCode）</a></h1><p>每个元素只出现两次  有两个只出现一次的数 要找出这两个数 </p><p>由于这两个数不同  必然有一个(以上)的比特位不同  那么就求这个比特位 </p><p>然后把所有在这个比特位上 是1 的 异或到一起 （包含所有 这个比特位上是1 的两个两个的数  和 这个比特位上是1 的目标数）  把所有这个比特位上是0 的异或到一起…</p><p>注意取  lowbit   lowbit &#x3D;  a &amp; (-a)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        xorsum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            xorsum ^= x<br>        ans1 = ans2 = <span class="hljs-number">0</span><br>        lb = xorsum &amp; (-xorsum)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> lb &amp; x:<br>                ans1 ^= x<br>            <span class="hljs-keyword">else</span>:<br>                ans2 ^= x<br><br>        <span class="hljs-keyword">return</span> [ans1, ans2]<br></code></pre></td></tr></table></figure><h1 id="78-子集-力扣（LeetCode）"><a href="#78-子集-力扣（LeetCode）" class="headerlink" title="78. 子集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></h1><p>子集的形式与二进制数非常相似 可以考虑用二进制来写</p><p>1 &lt; (1 &lt;&lt; n)就是小于2的n次方</p><p>i&gt;&gt;j 就是把i这个二进制数往右移动j位</p><p>比如0001  移动0位是1  移动1位是0 移动两位是0 三位是0</p><p>就是用这种方式 代表每个位置上的数选或不选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        rets = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; (<span class="hljs-number">1</span>&lt;&lt;n):<br>            ret = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:<br>                    ret.append(nums[j])<br>            rets.append(ret)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> rets<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch环境</title>
    <link href="/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="配个环境配了一天-人麻了"><a href="#配个环境配了一天-人麻了" class="headerlink" title="配个环境配了一天 人麻了"></a>配个环境配了一天 人麻了</h1><p>不知道为什么只有这个版本可以用 下次重建conda虚拟环境的时候要用这个下载 </p><p>并且在下载之前记得</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> cpuonly<br>conda uninstall cpuonly<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">1</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> cudatoolkit=<span class="hljs-number">11</span>.<span class="hljs-number">3</span> -c pytorch<br></code></pre></td></tr></table></figure><h1 id="艹-在conda虚拟环境要用conda-install"><a href="#艹-在conda虚拟环境要用conda-install" class="headerlink" title="艹 在conda虚拟环境要用conda install"></a>艹 在conda虚拟环境要用conda install</h1><p>为什么我疯狂用pip install啊啊啊</p><h1 id="pip开代理可能会出现路径错误"><a href="#pip开代理可能会出现路径错误" class="headerlink" title="pip开代理可能会出现路径错误"></a>pip开代理可能会出现路径错误</h1><p>到底还有多少离谱的问题啊</p><h1 id="下不下来的包-居然可以直接复制粘贴文件夹吗？（😀"><a href="#下不下来的包-居然可以直接复制粘贴文件夹吗？（😀" class="headerlink" title="下不下来的包 居然可以直接复制粘贴文件夹吗？（😀"></a>下不下来的包 居然可以直接复制粘贴文件夹吗？（😀</h1>]]></content>
    
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基环树</title>
    <link href="/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    <url>/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>一般来说就是先存反图 算入度 </p><p>然后拓扑排序 剩下的就是基环</p><p>第三步 分别对每个基环进行操作 找基环的方式为模板（如下题）</p><h1 id="2127-参加会议的最多员工数-力扣（LeetCode）"><a href="#2127-参加会议的最多员工数-力扣（LeetCode）" class="headerlink" title="2127. 参加会议的最多员工数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/">2127. 参加会议的最多员工数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumInvitations</span>(<span class="hljs-params">self, favorite: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(favorite)<br>        deg = [<span class="hljs-number">0</span>] * n<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(favorite):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br><br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = favorite[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            m_depth = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    m_depth = <span class="hljs-built_in">max</span>(m_depth, rdfs(y) + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> m_depth<br><br>        <br>        max_ring_size = sum_chine_size = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 找基环的套路</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            res = <span class="hljs-number">0</span><br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                res += <span class="hljs-number">1</span><br>                deg[x] = -<span class="hljs-number">1</span><br>                x = favorite[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">2</span>:<br>                sum_chine_size += rdfs(i) + rdfs(favorite[i])<br>            <span class="hljs-keyword">else</span>:<br>                max_ring_size = <span class="hljs-built_in">max</span>(max_ring_size, res)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_ring_size, sum_chine_size)<br></code></pre></td></tr></table></figure><h1 id="2876-有向图访问计数-力扣（LeetCode）"><a href="#2876-有向图访问计数-力扣（LeetCode）" class="headerlink" title="2876. 有向图访问计数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/description/">2876. 有向图访问计数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countVisitedNodes</span>(<span class="hljs-params">self, g: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(g)<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        deg = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(g):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br>        <br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = g[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br>        <br>        ans = [<span class="hljs-number">0</span>] * n<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x, depth</span>):<br>            ans[x] = depth<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    rdfs(y, depth + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 找基环的操作</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            ring = []<br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ring.append(x)<br>                deg[x] = -<span class="hljs-number">1</span><br>                x = g[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ring:<br>                rdfs(x, <span class="hljs-built_in">len</span>(ring))<br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="股票问题系列通解（转载翻译）-力扣（LeetCode）"><a href="#股票问题系列通解（转载翻译）-力扣（LeetCode）" class="headerlink" title="股票问题系列通解（转载翻译） - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/qiAgHn/">股票问题系列通解（转载翻译） - 力扣（LeetCode）</a></h1><p>首先，通用状态表示是dp[i] [k] [0]和dp[i] [k] [1]表示第i天时 交易k次 手上有0&#x2F;1只股票的时候的最大利润 </p><p>状态计算，dp[i] [k] [0] &#x3D; max(dp[i - 1] [k] [0], dp[i - 1] [k] [1] + price[i]])</p><p>第i天手上有0只股票的最大收益为 第i - 1天手上有0只股票 和 第i - 1天手上有1只股票并且卖掉的最大收益 </p><p>dp[i] [k] [1] &#x3D; max(dp[i - 1] [k] [1], dp[i - 1] [k - 1] [0] - price[i]])</p><p>第i天手上有1只股票的最大收益为 第i - 1天手上有1只股票 和 第i - 1天手上有0只股票并且买入的最大收益 注意 要减掉一次交易次数</p><p>当k &gt;&#x3D; n &#x2F;&#x2F; 2时 就相当于k无限 因为买入卖出算一次交易 那么最多前面一半全买入 后面一半全卖出</p><p>手续费直接减掉</p><p>冷冻期就跳过一天  加入i - 2天这个变量 买入的时候要从第i - 2天转移过来</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合题解</title>
    <link href="/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>并查集模板</p><p>看两个数是不是在一个集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, p  = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> fa[x] == x:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    union(a, b)<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> find(a) == find(b):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Loading-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#Loading-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1536">Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>不是看两个数是不是在一个集合 而是计算一共有多少个集合</p><p>计算还需要修几条路才能把所有村子连接起来 其实就是求现在的集合数 连起来的村子当同一个村子 当fa[i] &#x3D;&#x3D; i 的时候 cnt + 1  因为每个集合有且仅有一个 fa[i] &#x3D;&#x3D; i 因此可以用来计数 最后 村子数减一就是道路数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    n = l[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    m = l[<span class="hljs-number">1</span>]<br>    fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        union(a, b)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> fa[i] == i:<br>            cnt += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(cnt - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>为每个字符串求一个hash值 直接放入列表中 排序列表 然后看相邻的两个数的值是否一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">base = <span class="hljs-number">131</span><br>prime = <span class="hljs-number">233317</span><br>mod = <span class="hljs-number">212370440130137957</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hashe</span>(<span class="hljs-params">s</span>):<br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>        ans = (ans * base + <span class="hljs-built_in">ord</span>(char)) % mod + prime<br>    <span class="hljs-keyword">return</span> ans<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    s = <span class="hljs-built_in">input</span>()<br>    a.append(hashe(s))<br><br>a.sort()<br>ans = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> a[i] != a[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P3405 USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P3405 <a href="https://www.luogu.com.cn/problem/P3405">USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求城市对数 算出每个城市的hash值（只需要看前两位） 如果AB不是同一座城市  那么A B就是一个城市对 先放入mp中存起来  而B A可以直接加到答案里（题目要求有两个城市互为对的时候才算一个 比如MIAMT FL  和 FLINT 和 MI 算一对）所以每次遇到A B都先存着  知道遇到B  A再一次取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>ans = <span class="hljs-number">0</span><br>mp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">676</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">676</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a, b = <span class="hljs-built_in">input</span>().split()<br>    A = (<span class="hljs-built_in">ord</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    B = (<span class="hljs-built_in">ord</span>(b[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(b[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> A != B:<br>        mp[A][B] += <span class="hljs-number">1</span>  <br>        ans += mp[B][A]<br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>计数 然后看mp中有没有A - k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>mp = &#123;&#125;<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> mp:<br>        mp[x] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        mp[x] = <span class="hljs-number">1</span><br><br>ans = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mp.items():<br>    <span class="hljs-keyword">if</span> key - k <span class="hljs-keyword">in</span> mp:<br>       ans += mp[key - k] * value<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1525 NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1525 <a href="https://www.luogu.com.cn/problem/P1525">NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>带权并查集   并且一共只有两个集合  判断每个集合里面要放哪些</p><p>首先定义fa数组和Enemy（空数组） 对所有囚犯的怒气值从大到小排序 把最大的分别放到不同的集合 直到出现冲突（比如有个人A 和B   前面有一个在1监狱已经放好 而且B被放到2监狱（因为1和B的仇恨更大）这个人没办法 只能被放到1 和B仇恨较小的那个监狱）由于排序了 这个值就是最大值  带权值的并查集 只要用结构体加上w就行</p><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fo,to,w</span>):<br>        self.fo = fo<br>        self.to = to<br>        self.w = w<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-keyword">if</span> fa[k] == k:<br>        <span class="hljs-keyword">return</span> k<br>    fa[k] = find(fa[k])<br>    <span class="hljs-keyword">return</span> fa[k]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>p = [node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    p[i].fo = u<br>    p[i].to = v<br>    p[i].w = w<br><br>p.sort(key=<span class="hljs-keyword">lambda</span> x: -x.w)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    <span class="hljs-comment"># 如果已经在同一监狱</span><br>    t1, t2 = find(p[i].fo), find(p[i].to)<br>    <span class="hljs-keyword">if</span> t1 == t2:<br>        <span class="hljs-built_in">print</span>(p[i].w)<br>        sys.exit()<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].fo] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].fo] = p[i].to<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].fo], p[i].to)<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].to] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].to] = p[i].fo<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].to], p[i].fo)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h1 id="P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1621">P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最终的集合数其实就是算素数的个数  因为非素数都会被合并  每次合并总集合都减去一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>a, b, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>ans = b - a + <span class="hljs-number">1</span><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>prime = [<span class="hljs-number">0</span>] * (b + <span class="hljs-number">1</span>)<br>prime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> prime[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> i &gt;= p:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> j - i &gt;= a <span class="hljs-keyword">and</span> find(j) != find(j - i):<br>                    union(j, j - i)<br>                    ans -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1892 BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1892 <a href="https://www.luogu.com.cn/problem/P1892">BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    op, a, b = <span class="hljs-built_in">input</span>().split()<br>    a = <span class="hljs-built_in">int</span>(a)<br>    b = <span class="hljs-built_in">int</span>(b)<br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;E&#x27;</span>:<br>        <span class="hljs-keyword">if</span> Enemy[a] == <span class="hljs-number">0</span>:<br>            Enemy[a] = find(b)<br>        <span class="hljs-keyword">else</span>:<br>            union(Enemy[a], b)<br>        <span class="hljs-keyword">if</span> Enemy[b] == <span class="hljs-number">0</span>:<br>            Enemy[b] = find(a)<br>        <span class="hljs-keyword">else</span>:<br>            union(a, Enemy[b])<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;F&#x27;</span>:<br>        union(a,b)<br><br>count = [<span class="hljs-number">0</span>] * <span class="hljs-number">1001</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    count[find(i)] = <span class="hljs-number">1</span><br><br>cnt= <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt += count[i]<br><br><span class="hljs-built_in">print</span>(cnt)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赛题题解</title>
    <link href="/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-C-Codeforces"><a href="#Problem-C-Codeforces" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/C">Problem - C - Codeforces</a></h1><p>先给每一圈赋一个权重dis</p><p>算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> dis[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; nums;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        nums.<span class="hljs-built_in">emplace_back</span>(s);<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res += dis[<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i, j), <span class="hljs-built_in">min</span>(<span class="hljs-number">9</span> - i, <span class="hljs-number">9</span> - j))];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/E">Problem - E - Codeforces</a></h1><p>赛时调了半天没调出来，寄，害的F也没调出来&#x2F;kk </p><p>二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mid - nums[i] &gt;= <span class="hljs-number">0</span>)<br>            res += (mid - nums[i]);<br>        <span class="hljs-keyword">if</span> (res &gt; m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(nums));<br>    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>, mid;<br><br>    <span class="hljs-keyword">while</span> (l &lt;= r)<br>    &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>        &#123;<br>            res = mid;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br><br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-G-Codeforces"><a href="#Problem-G-Codeforces" class="headerlink" title="Problem - G - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/G">Problem - G - Codeforces</a></h1><p>AB-&gt;BC BA-&gt;CB</p><p>那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 </p><p>如果有两个B连在一起的话只可能是B..BB…B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B </p><p>如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span> || s[n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;A&#x27;</span>)<br>                sum++, cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            &#123;<br>                minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>                    flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>        <span class="hljs-keyword">if</span> (flag)<br>        &#123;<br>            cout &lt;&lt; sum &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (minn != <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>                cout &lt;&lt; sum - minn &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/H">Problem - H - Codeforces</a></h1><p>寻找基环树（套路）因为这个题不仅要判断环 而且需要储存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, a, b; <span class="hljs-comment">// a is M b is V</span><br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 存无向图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        graph[u].<span class="hljs-built_in">pb</span>(v);<br>        graph[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">incircle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>    <br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (v == fa)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-comment">// 第二次经过代表有环</span><br>            &#123;<br>                ok = <span class="hljs-literal">true</span>;<br>                incircle[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记在环上</span><br>                <span class="hljs-type">int</span> x = u;<br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    incircle[x] = <span class="hljs-number">1</span>;<br>                    x = pre[x];<br>                &#125; <span class="hljs-keyword">while</span> (x != v); <span class="hljs-comment">// 标记环上的所有点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                vis[v] = <span class="hljs-number">1</span>;<br>                pre[v] = u;<br>                <span class="hljs-built_in">dfs</span>(v, u);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 如果已经在环上了</span><br>    <span class="hljs-keyword">if</span> (incircle[b]) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> goal = <span class="hljs-number">-1</span>, gdis = <span class="hljs-number">-1</span>;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-comment">// 清空vis数组</span><br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;b, <span class="hljs-number">0</span>&#125;);<br>    vis[b] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (incircle[v])<br>            &#123;<br>                goal = v;<br>                gdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">goto</span> end;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>end:;<br>    <span class="hljs-keyword">if</span> (goal == a)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> tdis = <span class="hljs-number">-1</span>;<br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;a, <span class="hljs-number">0</span>&#125;);<br>    vis[a] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (v == goal)<br>            &#123;<br>                tdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (tdis &lt;= gdis)<br>                    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="5153-删除-AcWing题库"><a href="#5153-删除-AcWing题库" class="headerlink" title="5153. 删除 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5156/">5153. 删除 - AcWing题库</a></h1><p>一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除<br>而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推<br>所以只需要枚举1 2 3 位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;8&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;8&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                cout &lt;&lt; a &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; k++)<br><br>            &#123;<br>                <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">100</span> + (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                    cout &lt;&lt; a &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1878/problem/D">Problem - D - Codeforces</a></h1><p>给出区间 然后反转 可以用差分 当这个下标被旋转奇数次的时候就需要旋转 被旋转偶数次的时候 就相当于没动 不用旋转 </p><p>每次旋转要找到唯一一个i 使得a[i] &lt;&#x3D; x &amp;&amp; b[i] &gt;&#x3D; x 然后旋转a[i] b[i] 的元素 </p><p>可以用cnt（类似差分数组）记录x出现的次数   并且不需要根据x寻找第二行所说的那个区间 而是遍历区间 找到这个区间的x</p><p>遍历区间 然后取出子串 从left到mid依次与right到mid交换 （根据sum的奇偶来判断）sum就是当前位置和对称位被交换次数之和（累计   因为是差分）然后输出子串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br><br>using namespace std;<br><br>using ll = long long;<br>using PII = pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;;<br><br><span class="hljs-comment">#define pb push_back</span><br><span class="hljs-comment">#define all(x) (x).begin(), (x).end()</span><br><span class="hljs-comment">#define fi first</span><br><span class="hljs-comment">#define se second</span><br><span class="hljs-comment">#define endl &#x27;\n&#x27;</span><br><br><span class="hljs-comment">#define debug(x)                          \</span><br>    &#123;                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; \</span><br>    &#125;<br><span class="hljs-comment">#define debugfull(x)                                                      \</span><br>    &#123;                                                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; (line &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; endl; \</span><br>    &#125;<br><br>/*-------------------------------------------*/<br><br>void solve()<br>&#123;<br>    <span class="hljs-built_in">int</span> n, k;<br>    string s;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    cin &gt;&gt; s;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; a(k), b(k);<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; cnt(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; a[i], a[i]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; b[i], b[i]--;<br>    <span class="hljs-built_in">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> x;<br>        cin &gt;&gt; x;<br>        cnt[x - <span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    &#123;<br>        string s1 = s.substr(a[i], b[i] - a[i] + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l = a[i];<br>        <span class="hljs-built_in">int</span> r = b[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = l; j &lt;= (l + r) / <span class="hljs-number">2</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">sum</span> += cnt[j] + cnt[r - j + l];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> % <span class="hljs-number">2</span>)<br>                swap(s1[j - l], s1[r - j]);<br>        &#125;<br>        cout &lt;&lt; s1;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    // clock_t st = clock(), ed;<br>    ios::sync_with_stdio(<span class="hljs-number">0</span>);<br>    cin.tie(<span class="hljs-number">0</span>);<br>    // cout &lt;&lt; setprecision(<span class="hljs-number">15</span>) &lt;&lt; fixed;<br>    <span class="hljs-built_in">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        solve();<br><br>    // ed = clock();<br>    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;<br>    // cout &lt;&lt; <span class="hljs-string">&quot;Total time: &quot;</span> &lt;&lt; endtime &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100019-将数组分割成最多数目的子数组-力扣（LeetCode）"><a href="#100019-将数组分割成最多数目的子数组-力扣（LeetCode）" class="headerlink" title="100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/description/">100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）</a></h1><p>按位与的结果只能越来越小 因此要求最小的按位与的子数组的和 就是全部与在一起的和 就是最小的 但是又特殊情况 就是 当全部的与为0时 可能中间有一部分已经为0了  这样就可以拆成很多个与为0的子数组   如果不为0  那必然整个数组的与就是最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarrays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        t = nums[<span class="hljs-number">0</span>]<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>                cnt += <span class="hljs-number">1</span><br>                t = nums[i]<br>            t&amp;=nums[i]<br>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cnt <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）"><a href="#2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）" class="headerlink" title="2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/2464559/javapython3cshen-du-you-xian-sou-suo-tan-3r78/">2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）</a></h1><p>由于题目说了 整棵树所有结点的和一定为k的倍数 那么从中取出一棵节点和为k的倍速的子树  剩下的部分的结点和一定也为k的倍数  </p><p>因此可以自底向上递归  每次找到一棵节点和为k的倍数的子树 就直接加入答案 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxKDivisibleComponents</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 建树</span><br>        self.link = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> edges:<br>            self.link[s].append(e)<br>            self.link[e].append(s)<br>        self.res = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 递归</span><br>        self.dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, values, k)<br>        <span class="hljs-keyword">return</span> self.res<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, node, parent, values, k</span>):<br>            node_sum = values[node]<br>            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.link[node]:<br>                <span class="hljs-comment"># 因为建的是无向图 要去掉父节点</span><br>                <span class="hljs-keyword">if</span> child == parent:<br>                    <span class="hljs-keyword">continue</span><br>                child_sum = dfs(child, node, values, k)<br>                <span class="hljs-keyword">if</span> child_sum % k == <span class="hljs-number">0</span>:<br>                    self.res += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    node_sum += child_sum<br>            <span class="hljs-keyword">return</span> node_sum<br></code></pre></td></tr></table></figure><h1 id="100086-有序三元组中的最大值-II-力扣（LeetCode）"><a href="#100086-有序三元组中的最大值-II-力扣（LeetCode）" class="headerlink" title="100086. 有序三元组中的最大值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">100086. 有序三元组中的最大值 II - 力扣（LeetCode）</a></h1><p>遍历j 算出j的前缀的最大值和j的后缀的最大值 因为求得是(nums[i] - nums[j]) * nums[k] 所以i k要尽量大</p><p>后缀就是从n - 1往前 求出每一个j值所对应的最大后缀  前缀同理</p><p>最后直接计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumTripletValue</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        surmax = [-<span class="hljs-number">1</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            surmax[i] = <span class="hljs-built_in">max</span>(surmax[i + <span class="hljs-number">1</span>], nums[i])<br>        premax = nums[<span class="hljs-number">0</span>]<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">max</span>(ans, (surmax[i + <span class="hljs-number">1</span>] * (premax - nums[i])))<br>            premax = <span class="hljs-built_in">max</span>(premax, nums[i])<br>        <span class="hljs-keyword">return</span> ans <br></code></pre></td></tr></table></figure><h1 id="100076-无限数组的最短子数组-力扣（LeetCode）"><a href="#100076-无限数组的最短子数组-力扣（LeetCode）" class="headerlink" title="100076. 无限数组的最短子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">100076. 无限数组的最短子数组 - 力扣（LeetCode）</a></h1><p>滑动窗口</p><p>子数组是连续的 要求最短的就是先看看 能凑成几个完整的原序列  然后再两个序列间 凑出剩余的</p><p>剩余的就用滑动窗口来算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSizeSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        total = <span class="hljs-built_in">sum</span>(nums)<br>        nums = nums + nums<br>        x = target // total<br>        target %= total<br>        s = l = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * <span class="hljs-number">2</span>):<br>            s += nums[i]<br>            <span class="hljs-keyword">while</span> s &gt; target:<br>                s -= nums[l]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s == target:<br>                ret = <span class="hljs-built_in">min</span>(ret, i - l + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ret + x * n<br>        <br></code></pre></td></tr></table></figure><h1 id="8028-执行操作使两个字符串相等-力扣（LeetCode）"><a href="#8028-执行操作使两个字符串相等-力扣（LeetCode）" class="headerlink" title="8028. 执行操作使两个字符串相等 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/">8028. 执行操作使两个字符串相等 - 力扣（LeetCode）</a></h1><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><p>首先 1的个数的奇偶不同就不能变成一样的 返回-1</p><p>用dfs计算加上@cache变为记忆化搜索</p><p>每次变都是两个一起变 操作1 第一个变的时候就记录这次变化的消耗  然后另一个就相当于可以免费变化  记录免费变化的次数</p><p>操作2 不能像操作1那样在任意位置变  而是 只要用了操作2 必定是连续的两个变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span> != s2.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>        n = <span class="hljs-built_in">len</span>(s1)<br>        <span class="hljs-comment"># 从前往后遍历 </span><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, pre_rever: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 到头了</span><br>            <span class="hljs-keyword">if</span> i == n:<br>                <span class="hljs-keyword">return</span> inf <span class="hljs-keyword">if</span> j <span class="hljs-keyword">or</span> pre_rever <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 不需要反转</span><br>            <span class="hljs-comment"># 当前不相等 但是前面有反转了 导致这两个相等</span><br>            <span class="hljs-keyword">if</span> s1[i] != s2[i] <span class="hljs-keyword">and</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <span class="hljs-comment"># 当前相等 并且前面没反转 这两个仍然相等</span><br>            <span class="hljs-keyword">if</span> s1[i] == s2[i] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <br>            <span class="hljs-comment"># 需要反转 分别用操作1 和 操作2 取最小值 记得加上反转的代价 操作1为x 操作2为1</span><br>            res = <span class="hljs-built_in">min</span>(dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>) + x, dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">True</span>) + <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment"># 操作1的免费反转（操作2的免费反转在上面）</span><br>            <span class="hljs-keyword">if</span> j:<br>                res = <span class="hljs-built_in">min</span>(res, dfs(i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, pre_rever))<br>            <br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>dp做法</p><p>把所有需要变的位置先写出来 然后每次消除  通过操作1 每次消除一个 消耗x&#x2F;2（最后必定是可以消完的因为不行的情况已经返回-1了）或者用操作2 每次消除两个 比如1，4位置需要变化 那就需要3次操作12 23 34 这样  需要消耗 p[i] - p[i - 1]</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1 == s2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = [i <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(s1, s2)) <span class="hljs-keyword">if</span> x != y]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(p)<br><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 递归出口  到-1 说明是正常退出 （操作1 的0 - 1  操作2 的1 - 2）</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 到-2说明有问题 返回inf代表这个答案不能用</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> inf<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(i - <span class="hljs-number">1</span>) + x, dfs(i - <span class="hljs-number">2</span>) + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>再翻译成递推 dfs(i) -&gt; f[i]   注意翻译的时候 i - 1和i - 2  如果是f[i - 1] 和 f[i - 2] 会导致最后 i &#x3D;&#x3D; -1 和i &#x3D;&#x3D; -2 无法表示  所以 每个下标加上2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        f = [<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>)<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        f[<span class="hljs-number">1</span>] = x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            new_f = <span class="hljs-built_in">min</span>(f[i] + x, f[i - <span class="hljs-number">1</span>] + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>           f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>]<br>            f[<span class="hljs-number">1</span>] = new_f<br>        <span class="hljs-keyword">return</span> f[m] // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>​     然后空间优化  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    f0, f1 = <span class="hljs-number">0</span>, x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            f0, f1 = f1, <span class="hljs-built_in">min</span>(f1 + x, f0 + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> f1 // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="2897-对数组执行操作使平方和最大-力扣（LeetCode）"><a href="#2897-对数组执行操作使平方和最大-力扣（LeetCode）" class="headerlink" title="2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/">2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）</a></h1><p>与 越与越小 或越或越大   而x^y + y ^ 2 &lt; (x - d)^2 + (y + d)^2  所以 要尽量做或操作 直到最大</p><p>用位运算思考 先记录所有数每个比特位上有多少个1  然后构造尽量大的数 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">max</span>(nums).bit_length()<br>        cnt = [<span class="hljs-number">0</span>] * m<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                cnt[i] += x &gt;&gt; i &amp; <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 构造出k个尽可能大的数</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            x = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> cnt[i]:<br>                    <span class="hljs-comment"># 消耗该比特位上的一个1</span><br>                    cnt[i] -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># x |= 就是直接把该位变成1 而1&lt;&lt;i就是对应位</span><br>                    x |= <span class="hljs-number">1</span> &lt;&lt; i <br>            ans += x * x<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="8026-构造乘积矩阵-力扣（LeetCode）"><a href="#8026-构造乘积矩阵-力扣（LeetCode）" class="headerlink" title="8026. 构造乘积矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/construct-product-matrix/description/">8026. 构造乘积矩阵 - 力扣（LeetCode）</a></h1><p>前后缀优化</p><p>类似的还有<a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><p>不能用乘积全部乘起来再除的方法 因为首先可能有0的情况 会导致错误 然后就是复杂度太高了</p><p>虽然说没有写循环 但是 乘积是高精度乘法 复杂度非常高所以会超时</p><p>同理  在每次计算前后缀的时候也需要取模防止数据过大超时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructProductMatrix</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        pre = suf = <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        ans = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        mod = <span class="hljs-number">12345</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans[i][j] = pre % mod<br>                pre = pre * grid[i][j] % mod<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                ans[i][j] = ans[i][j] * suf % mod<br>                suf = suf * grid[i][j] % mod<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="100101-找出满足差值条件的下标-II-力扣（LeetCode）"><a href="#100101-找出满足差值条件的下标-II-力扣（LeetCode）" class="headerlink" title="100101. 找出满足差值条件的下标 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">100101. 找出满足差值条件的下标 II - 力扣（LeetCode）</a></h1><p>这种题目 下标差 然后再找满足另一个条件的 就需要 储存前缀（或后缀）的最大值和最小值</p><p>类似于股票的第一题</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findIndices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], indexDifference: <span class="hljs-built_in">int</span>, valueDifference: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        max_idx = <span class="hljs-number">0</span><br>        min_idx = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(indexDifference, n):<br>            j = i - indexDifference<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[max_idx]:<br>                max_idx = j<br>            <span class="hljs-keyword">elif</span> nums[j] &lt; nums[min_idx]:<br>                min_idx = j<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[max_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, max_idx]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[min_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, min_idx]<br>        <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><h1 id="100077-最长相邻不相等子序列-II-力扣（LeetCode）"><a href="#100077-最长相邻不相等子序列-II-力扣（LeetCode）" class="headerlink" title="100077. 最长相邻不相等子序列 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/description/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></h1><p><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/solutions/2484023/python3zhu-ju-fen-xi-dong-tai-gui-hua-qi-gdss/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></p><h1 id="100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）"><a href="#100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）" class="headerlink" title="100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）</a></h1><p>滑动窗口 </p><p>一开始写的时候 出了好多错ww 下标什么的 while循环的条件带不带等号 还有最后更新忘记判断字典序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBeautifulSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        l = <span class="hljs-number">0</span><br>        cnt = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> cnt &gt; k:<br>                <span class="hljs-keyword">if</span> s[l] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    cnt -= <span class="hljs-number">1</span><br>                    l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; n <span class="hljs-keyword">and</span> s[l] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == k:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ans) == <span class="hljs-number">0</span>:<br>                    ans = s[l:i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> i - l + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(ans):<br>                    ans = s[l: i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">elif</span> i - l + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(ans):<br>                    <span class="hljs-keyword">if</span> s[l: i + <span class="hljs-number">1</span>] &lt; ans:<br>                        ans = s[l:i + <span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">return</span> ans<br>    <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论[课程]</title>
    <link href="/2023/09/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA-%E8%AF%BE%E7%A8%8B/"/>
    <url>/2023/09/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA-%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能的应用"><a href="#人工智能的应用" class="headerlink" title="人工智能的应用"></a>人工智能的应用</h1><h2 id="图像识别与分类"><a href="#图像识别与分类" class="headerlink" title="图像识别与分类"></a>图像识别与分类</h2><h3 id="什么是图像识别"><a href="#什么是图像识别" class="headerlink" title="什么是图像识别"></a>什么是图像识别</h3><p>一般而言，传统图像识别系统主要由图像分割、图像特征提取以及图像识别分类构成。图像分割将图像划分成为多个有意义的区域，然后将每个区域的图像进行特征提取，最后根据提取的图像特征对图像进行分类。</p><h3 id="ImageNet数据集"><a href="#ImageNet数据集" class="headerlink" title="ImageNet数据集"></a>ImageNet数据集</h3><p>是一个人工标定的数据集，包含1400多万张图片，2万多个类别。关于图像分类定位检测等研究大多基于此数据集展开，几乎成为目前深度学习图像领域算法性能检验的标准数据集。</p><h3 id="卷积神经网络工作过程"><a href="#卷积神经网络工作过程" class="headerlink" title="卷积神经网络工作过程"></a>卷积神经网络工作过程</h3><p>1、对输入的真是图像运用不同的图像算子（包括边缘检测等）进行扫描来提取图像当中的不同特征；</p><p>2、通过采样对特征进行压缩（防止特征数量过于庞大）</p><p>3、进行多次特征提取和采样</p><p>4、全连接层为每个节点的输出指定一个标签</p><h3 id="图像识别的主要作用"><a href="#图像识别的主要作用" class="headerlink" title="图像识别的主要作用"></a>图像识别的主要作用</h3><p>智能家居、安防、金融、医疗、交通</p><h4 id="医学影像分析"><a href="#医学影像分析" class="headerlink" title="医学影像分析"></a>医学影像分析</h4><ul><li>通过深度学习和大数据等，在医学影像的基础上，完成对影像的分类目标检测图像分割和检索，帮助医生完成诊断治疗。</li><li>使用深度学习多层感知器，通过组合低层特征形成更加抽象的高级特征，提取出人体结构。对身体组织做明确分割精度比医生更高，可以更加精准地定量评价治疗前后的效果。</li><li>图像配准，图像融合，图像重建</li></ul><h4 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h4><ul><li>语音拨号、导航、室内设备控制</li><li>与其他自然语言处理技术结合可以构建更复杂的应用，如同声传译。</li><li>语音输入</li><li>语音助理</li></ul><h4 id="人脸识别和情感计算"><a href="#人脸识别和情感计算" class="headerlink" title="人脸识别和情感计算"></a>人脸识别和情感计算</h4><h4 id="人工智能与自动驾驶"><a href="#人工智能与自动驾驶" class="headerlink" title="人工智能与自动驾驶"></a>人工智能与自动驾驶</h4><ul><li>包括模块， 决策模型：障碍物识别、交通标志识别、车道识别</li></ul><h1 id="人无法知道机器思考的具体过程"><a href="#人无法知道机器思考的具体过程" class="headerlink" title="人无法知道机器思考的具体过程"></a>人无法知道机器思考的具体过程</h1><h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>能否保证人工智能的应用开发被用于正确目标。</li><li>智能系统开发时可能存在缺陷。人无法知道机器思考的具体过程 机器学习数据来源和质量问题可能教坏人工智能</li><li>人工智能研发者多元化，以此满足不同人群的需求</li><li>对人工智能服务群体进行指引和监督</li><li>让机器人和人类一样遵守伦理道德</li></ul><h2 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h2><ul><li>对人的认知的冲击</li><li>对人类思维的挑战</li><li>人工智能高度模拟人的思维方式，让人类失去学习热情</li><li>对人类社会结构和心理的冲击 机器人是否会取代人类</li><li>对隐私保护的冲击，大数据的发展使人们的隐私暴露</li><li>对经济市场的冲击</li></ul><h2 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h2><ul><li>就业问题，人类是否会被机器取代</li><li>安全问题，新技术失控或落入不法分子手中</li><li>责任于义务问题，人工智能事故由谁负责</li></ul><h1 id="AI艺术的定义"><a href="#AI艺术的定义" class="headerlink" title="AI艺术的定义"></a>AI艺术的定义</h1><p>捕获一定内容，通过机器学习或深度学习将其与某类风格进行融合</p><p>AI没有先验数据缺乏独创能力，本质上是对海量作品积累形成的数据，没有灵感迸发没有主客体审美</p><h1 id="人类艺术审美的特点"><a href="#人类艺术审美的特点" class="headerlink" title="人类艺术审美的特点"></a>人类艺术审美的特点</h1><p>具有个体差异性；</p><p>受到社会环境、文化和传统的深刻影响，是随着认知和思想不断发展变化的；</p><p>是人类的内在想法的主观表达，具有个人喜好，受到情感影响</p><p>具有创新性，具有自然性。</p><h1 id="人类审美和AI审美的异同"><a href="#人类审美和AI审美的异同" class="headerlink" title="人类审美和AI审美的异同"></a>人类审美和AI审美的异同</h1><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul><li>认知和情感</li></ul><p>人类审美是高度主观的，基于每个个体的情感，经验和文化背景的影响。</p><p>而AI审美是基于算法和数据的分析，没有情感和主观的偏好</p><ul><li>学习方式</li></ul><p>人类审美是通过学习和经验基类形成的，通过观察和感知各种艺术作品来培养审美感知</p><p>AI审美通过机器学习等算法实现，通过训练数据学习，生成特定的审美评估</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>学习方式</li></ul><p>都需要通过数据进行感知和学习，在学习中不断丰富和更新审美</p><ul><li>思考</li></ul><p>都可以对数据进行分析，最终得出审美评价。</p>]]></content>
    
    
    
    <tags>
      
      <tag>class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习</title>
    <link href="/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- This is explanation--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to write<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is Heading1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is Heading2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>MAX Heading is 6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is strong<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>single tag:next paragraph<br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>single tag:divider<br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>ATTENTION:single tag:next paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> This<br>    is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>same as strong<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>This is underline<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This is italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>This is delete<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You must have find that even if you wrap in vscode, it won&#x27;t wrap in Webpage<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert some medium<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to insert a photo<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 只写宽或高会等比例变换 两个都写可能变形 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./MD5.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;加载失败（替换文本示例）&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;This is title&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 下级目录 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;in/MD5.png&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 上级目录 就用../--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play music<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;刻在我心底的名字.mp3&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play video<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;a.mp4&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert hyperlink<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/?tn=15007414_8_dg&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;study1.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>study1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>js</tag>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构习题</title>
    <link href="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    <url>/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="First-week-PTA-程序设计类实验辅助教学平台-pintia-cn"><a href="#First-week-PTA-程序设计类实验辅助教学平台-pintia-cn" class="headerlink" title="[First week](PTA | 程序设计类实验辅助教学平台 (pintia.cn))"></a>[First week](<a href="https://pintia.cn/problem-sets/1700336300474802176/exam/problems/1700336300504162305?type=6&page=0">PTA | 程序设计类实验辅助教学平台 (pintia.cn)</a>)</h1><h2 id="减一运算"><a href="#减一运算" class="headerlink" title="减一运算"></a>减一运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//超级抽象的C语言题 不仅要动态申请内存 还要高精度运算</span><br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">MinusOne</span><span class="hljs-params">(<span class="hljs-type">int</span>* digits, <span class="hljs-type">int</span> digitsSize, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br>    <span class="hljs-type">int</span> num[<span class="hljs-number">2000</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; digitsSize; i++)<br>    &#123;<br>        num[i] = *(digits + i);<br>    &#125;<br>    <span class="hljs-type">int</span>* res = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1001</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">// 因为外面有free 所以要malloc</span><br><br>    <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; digitsSize == <span class="hljs-number">1</span>)<br>    &#123;<br>        *res = <span class="hljs-number">0</span>;<br>        *returnSize = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = digitsSize - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num[i] &gt;= <span class="hljs-number">1</span>)<br>        &#123;<br>            num[i] -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            num[i] = <span class="hljs-number">9</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    *returnSize = digitsSize;<br>    <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>    &#123;<br>        *returnSize -= <span class="hljs-number">1</span>; <span class="hljs-comment">// 记得更新returnSize</span><br>        flag = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag, j = <span class="hljs-number">0</span>; i &lt;= *returnSize; i++, j++)<br>    &#123;<br>        *(res + j) = num[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最大子列和"><a href="#最大子列和" class="headerlink" title="最大子列和"></a>最大子列和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在线算法 O(n) </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-type">int</span> qzh[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxi = -(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; nums[i];<br>&#125;<br>    <span class="hljs-comment">// 当now为当前子列和 如果当前子列和大于maxi就更新   注意一点 当now&lt;0的时候now=0 即可以之间不选</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>now += nums[i];<br><span class="hljs-keyword">if</span> (now &gt; maxi)<br>maxi = now;<br><span class="hljs-keyword">if</span> (now &lt; <span class="hljs-number">0</span>)<br>now = <span class="hljs-number">0</span>;<br>&#125;<br>cout &lt;&lt; maxi;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 跟上一个一样。。</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>maxi, maxn = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>cnt = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>    <span class="hljs-keyword">if</span> nums[i] &gt; nums[i - <span class="hljs-number">1</span>]:<br>        cnt += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> maxn &lt; cnt:<br>            maxi = i<br>            maxn = cnt<br>        cnt = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> maxn &lt; cnt:<br>    maxi = n<br>    maxn = cnt<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(maxi - maxn, maxi):<br>    <span class="hljs-keyword">if</span> i != maxi - <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(nums[i], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>         <span class="hljs-built_in">print</span>(nums[i],end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Second-week"><a href="#Second-week" class="headerlink" title="Second week"></a><a href="https://pintia.cn/problem-sets/1703316708057788416/exam/problems/type/6">Second week</a></h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2-1"></a>2-1</h2><p>注意顺序表的概念 需要是连续的 每次插入删除需要位移  不能插入在tail+1之后的位置 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C">List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span><br>&#123;<br>    List newList = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>    newList-&gt;Last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXSIZE; i++)<br>    &#123;<br>        newList-&gt;Data[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newList;<br>&#125;<br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">(List L, ElementType X)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= L-&gt;Last; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L-&gt;Data[i] == X)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(List L, ElementType X, Position P)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (L-&gt;Last == MAXSIZE - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FULL&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (P &gt; L-&gt;Last + <span class="hljs-number">1</span> || P &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ILLEGAL POSITION&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L-&gt;Last; j &gt;= P; j--)<br>    &#123;<br>        L-&gt;Data[j + <span class="hljs-number">1</span>] = L-&gt;Data[j];<br>    &#125;<br>    L-&gt;Data[P] = X;<br>    L-&gt;Last++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(List L, Position P)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (P &gt; L-&gt;Last || P &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;POSITION %d EMPTY&quot;</span>, P);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = P + <span class="hljs-number">1</span>; i &lt; L-&gt;Last; i++)<br>    &#123;<br>        L-&gt;Data[i - <span class="hljs-number">1</span>] = L-&gt;Data[i];<br>    &#125;<br>    L-&gt;Last--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p>求中位数的方法  具体证明看力扣</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">def <span class="hljs-title">GetKthElement</span><span class="hljs-params">(k)</span>:</span><br><span class="hljs-function">    global n</span><br><span class="hljs-function">    idx1, idx2 =</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> True:<br>        <span class="hljs-keyword">if</span> idx1 == n:<br>            <span class="hljs-keyword">return</span> nums2[idx2]<br>        <span class="hljs-keyword">if</span> idx2 == n:<br>            <span class="hljs-keyword">return</span> nums1[idx1]<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[idx1], nums2[idx2])<br>        nidx1, nidx2 = idx1 + k <span class="hljs-comment">// 2 - 1, idx2 + k // 2 - 1</span><br>        p1, p2 = nums1[nidx1], nums2[nidx2]<br>        <span class="hljs-keyword">if</span> p1 &lt;= p2:<br>            k -= nidx1 - idx1 + <span class="hljs-number">1</span><br>            idx1 = nidx1 + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            k -= nidx2 - idx2 + <span class="hljs-number">1</span><br>            idx2 = nidx2 + <span class="hljs-number">1</span><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-built_in">input</span>().<span class="hljs-built_in">split</span>()))<br>nums2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-built_in">input</span>().<span class="hljs-built_in">split</span>()))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">GetKthElement</span>(n))<br><br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>;<br><br><span class="hljs-type">int</span> n,head;<br>set&lt;<span class="hljs-type">int</span>&gt; vis;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br><span class="hljs-type">int</span> value, next;<br>&#125;nodes[maxn+<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;head,&amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,add,val,nex;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;add,&amp;val,&amp;nex);<br>        nodes[add]=&#123;add,val,nex&#125;;<br>    &#125;<br>    vector&lt;Node&gt; ans, another;<br>    <span class="hljs-type">int</span> now=head;<br>    Node node;<br>    <span class="hljs-keyword">while</span> (now!=<span class="hljs-number">-1</span>)&#123;<br>        node=nodes[now];<br>        <span class="hljs-keyword">if</span> (vis.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">abs</span>(node.value))==vis.<span class="hljs-built_in">end</span>())<br>            vis.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">abs</span>(node.value)),ans.<span class="hljs-built_in">push_back</span>(node);<br>        <span class="hljs-keyword">else</span><br>            another.<span class="hljs-built_in">push_back</span>(node);<br>        now=node.next;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ans.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>,ans[i].address,ans[i].value);<br>        <span class="hljs-keyword">if</span> (i!=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,ans[i+<span class="hljs-number">1</span>].address);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;another.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>,another[i].address,another[i].value);<br>        <span class="hljs-keyword">if</span> (i!=another.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,another[i + <span class="hljs-number">1</span>].address);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-7"><a href="#2-7" class="headerlink" title="2-7"></a>2-7</h2><p>链表去重 静态链表写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>;<br><br><span class="hljs-type">int</span> n,head;<br>set&lt;<span class="hljs-type">int</span>&gt; vis;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br><span class="hljs-type">int</span> value, next;<br>&#125;nodes[maxn+<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;head,&amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,add,val,nex;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;add,&amp;val,&amp;nex);<br>        nodes[add]=&#123;add,val,nex&#125;;<br>    &#125;<br>    vector&lt;Node&gt; ans, another;<br>    <span class="hljs-type">int</span> now=head;<br>    Node node;<br>    <span class="hljs-keyword">while</span> (now!=<span class="hljs-number">-1</span>)&#123;<br>        node=nodes[now];<br>        <span class="hljs-keyword">if</span> (vis.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">abs</span>(node.value))==vis.<span class="hljs-built_in">end</span>())<br>            vis.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">abs</span>(node.value)),ans.<span class="hljs-built_in">push_back</span>(node);<br>        <span class="hljs-keyword">else</span><br>            another.<span class="hljs-built_in">push_back</span>(node);<br>        now=node.next;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ans.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>,ans[i].address,ans[i].value);<br>        <span class="hljs-keyword">if</span> (i!=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,ans[i+<span class="hljs-number">1</span>].address);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;another.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>,another[i].address,another[i].value);<br>        <span class="hljs-keyword">if</span> (i!=another.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,another[i + <span class="hljs-number">1</span>].address);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-10"><a href="#2-10" class="headerlink" title="2-10"></a>2-10</h2><p>多项式除法 用map来储存次数和系数 通过次数找系数 </p><p>其实每次只需要最高次数的去除 被除数不断地被除 余数仍然放在被除数中 不断循环（每次循环得到一位商） 直到最高次小于除数的最高次 结束  最后就可以得到商和余数 </p><p>四舍五入的方法也很重要 （x*10 +&#x2F;- 0.5）&#x2F;10 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">// 注意 前面是指数 后面是系数</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;division;<span class="hljs-comment">// 除数</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;divided;<span class="hljs-comment">// 被除数</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;ans;<span class="hljs-comment">// 商</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> e;<br><span class="hljs-type">double</span> c;<br><span class="hljs-type">int</span> maxe1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxe2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mine2 = <span class="hljs-number">1000000</span>;<br><span class="hljs-type">int</span> maxe3 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; e &gt;&gt; c;<br>divided[e] += c;<br>maxe1 = <span class="hljs-built_in">max</span>(maxe1, e);<br>&#125;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; e &gt;&gt; c;<br>division[e] += c;<br>maxe2 = <span class="hljs-built_in">max</span>(maxe2, e);<br>mine2 = <span class="hljs-built_in">min</span>(mine2, e);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxe1; i &gt;= maxe2; i--)<br>&#123;<br><span class="hljs-type">int</span> sub = i - maxe2;<br><span class="hljs-type">double</span> div = <span class="hljs-number">1.0</span> * divided[i] / division[maxe2];<br>ans[sub] = div;<br>maxe3 = <span class="hljs-built_in">max</span>(maxe3, sub);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = maxe2; j &gt;= <span class="hljs-number">0</span>; j--)<br>&#123;<br><span class="hljs-keyword">if</span>(div)<br>divided[j + sub] -= division[j] * div;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxe3; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>ans[i] = <span class="hljs-built_in">double</span>(<span class="hljs-built_in">int</span>(ans[i] * <span class="hljs-number">10</span> + (ans[i] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0.5</span> : <span class="hljs-number">-0.5</span>)) / <span class="hljs-number">10.0</span>);<br><span class="hljs-keyword">if</span> (ans[i] != <span class="hljs-number">0</span>)cnt++;<br>&#125;<br><span class="hljs-keyword">if</span> (!cnt)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0 0.0&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; cnt;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxe3; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (ans[i])<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %.1lf&quot;</span>, i, ans[i]);<br>&#125;<br>cout &lt;&lt; endl;<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxe1; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>divided[i] = <span class="hljs-built_in">double</span>(<span class="hljs-built_in">int</span>(divided[i] * <span class="hljs-number">10</span> + (divided[i] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0.5</span> : <span class="hljs-number">-0.5</span>)) / <span class="hljs-number">10.0</span>);<br><span class="hljs-keyword">if</span> (divided[i] != <span class="hljs-number">0</span>)cnt++;<br>&#125;<br><span class="hljs-keyword">if</span> (!cnt)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0 0.0&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; cnt;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxe1; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (divided[i])<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %.1lf&quot;</span>, i, divided[i]);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Third-Week"><a href="#Third-Week" class="headerlink" title="Third Week"></a><a href="https://pintia.cn/problem-sets/1706269130417893376/exam/problems">Third Week</a></h1><p>3-1</p><p>注意写题的时候 类型一般是ElementType </p><p>然后申请空间的时候 像栈等 就是 先申请一个Stack类型的  再去申请Stack里面的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C">Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">(<span class="hljs-type">int</span> MaxSize)</span><br>&#123;<br>    Stack st = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    st-&gt;Data = (ElementType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElementType) * (MaxSize - <span class="hljs-number">1</span>));<span class="hljs-comment">//注意是ElementType不是int</span><br>    st-&gt;MaxSize = MaxSize;<br>    <br>    st-&gt;Top1 = <span class="hljs-number">-1</span>;<br>    st-&gt;Top2 = st-&gt;MaxSize;<br>    <span class="hljs-keyword">return</span> st;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(Stack S, ElementType X, <span class="hljs-type">int</span> Tag)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (Tag == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (S-&gt;Top1 + <span class="hljs-number">1</span> == S-&gt;Top2)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack Full\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            S-&gt;Data[++S-&gt;Top1] = X;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (S-&gt;Top1 == S-&gt;Top2 - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack Full\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            S-&gt;Data[--S-&gt;Top2] = X;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack S, <span class="hljs-type">int</span> Tag)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((Tag == <span class="hljs-number">1</span> &amp;&amp; S-&gt;Top1 == <span class="hljs-number">-1</span>) || (Tag == <span class="hljs-number">2</span> &amp;&amp; S-&gt;Top2 == S-&gt;MaxSize))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack %d Empty\n&quot;</span>, Tag);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Tag == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> S-&gt;Data[S-&gt;Top1--];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> S-&gt;Data[S-&gt;Top2++];<br>&#125;<br></code></pre></td></tr></table></figure><p>3-2</p><p>负数的时候 特判一下负号  由于减号后面是空格而负号后面是数字 用这个来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python">ElementType EvalPostfix(char* expr)<br>&#123;<br>    double stack[<span class="hljs-number">100010</span>];<br>    <span class="hljs-built_in">int</span> top = -<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = strlen(expr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (expr[i] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; expr[i + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>)<br>        &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expr[i] == <span class="hljs-string">&#x27;+&#x27;</span> || expr[i] == <span class="hljs-string">&#x27;-&#x27;</span> || expr[i] == <span class="hljs-string">&#x27;*&#x27;</span> || expr[i] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> Infinity;<br>            double b = stack[top--];<br>            double a = stack[top--];<br><br>            double ans;<br>            switch (expr[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                ans = a + b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                ans = a - b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                ans = a * b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> Infinity;<br>                ans = a / b;<br>                <span class="hljs-keyword">break</span>;<br>            default:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            stack[++top] = ans;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expr[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; expr[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        &#123;<br>            double a = atof(expr + i);<br>            <span class="hljs-keyword">while</span> (expr[i] != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; i &lt; <span class="hljs-built_in">len</span>)<br>            &#123;<br>                i++;<br>            &#125;<br>            <br>            stack[++top] = flag ? -a : a;<br>            flag = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> stack[top];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Infinity;<br>&#125;<br></code></pre></td></tr></table></figure><p>3-9</p><p>双端队列 有头插头删尾插尾删</p><p>注意由于这个多开辟了一个空间当D-&gt;front &#x3D;&#x3D; D-&gt;rear 的时候是空</p><p>D-&gt;front - 1 &#x3D;&#x3D; D-&gt;rear 的时候是满</p><p>index函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">int</span> i, Deque D)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (i + D-&gt;MaxSize) % (D-&gt;MaxSize);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(ElementType X, Deque D)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>((index(D-&gt;Front - <span class="hljs-number">1</span>, D) - D-&gt;Rear) ) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    D-&gt;Front = index(D-&gt;Front - <span class="hljs-number">1</span>, D);<br>    D-&gt;Data[D-&gt;Front] = X;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">(Deque D)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (D-&gt;Front == D-&gt;Rear)<span class="hljs-keyword">return</span> ERROR;<br>    ElementType x = D-&gt;Data[D-&gt;Front];<br>    D-&gt;Front = index(D-&gt;Front + <span class="hljs-number">1</span>, D);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">Inject</span><span class="hljs-params">(ElementType X, Deque D)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>((index(D-&gt;Front - <span class="hljs-number">1</span>, D) - D-&gt;Rear)) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    D-&gt;Data[D-&gt;Rear] = X;<br>    D-&gt;Rear = index(D-&gt;Rear + <span class="hljs-number">1</span>, D);<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>ElementType <span class="hljs-title function_">Eject</span><span class="hljs-params">(Deque D)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (D-&gt;Front == D-&gt;Rear)<span class="hljs-keyword">return</span> ERROR;<br>    <br>    D-&gt;Rear = index(D-&gt;Rear - <span class="hljs-number">1</span>, D);<br>    ElementType x = D-&gt;Data[index(D-&gt;Rear, D)];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>3-8</p><p>两个堆栈 大的用来放出队小的用来放入队  当出队的时候先把入队的全部倒着放到出队中 再出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElementType;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ElementType stko[<span class="hljs-number">1000</span>], stki[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> capacityo, capacityi;<br>cin &gt;&gt; capacityo &gt;&gt; capacityi;<br><span class="hljs-keyword">if</span> (capacityo &gt; capacityi)<span class="hljs-built_in">swap</span>(capacityo, capacityi);<br><span class="hljs-type">int</span> topo = <span class="hljs-number">-1</span>, topi = <span class="hljs-number">-1</span>;<br><span class="hljs-type">char</span> op;<br>cin &gt;&gt; op;<br><span class="hljs-keyword">while</span> (op != <span class="hljs-string">&#x27;T&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;A&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><span class="hljs-keyword">if</span> (topo == capacityo - <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (topi == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">while</span> (topo != <span class="hljs-number">-1</span>) <br>&#123;<br>stki[++topi] = stko[topo--];<br>&#125;<br>stko[++topo] = x;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ERROR:Full&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>stko[++topo] = x;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (topi != <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; stki[topi--] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (topo == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ERROR:Empty&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">while</span> (topo != <span class="hljs-number">-1</span>)<br>&#123;<br>stki[++topi] = stko[topo--];<br>&#125;<br>cout &lt;&lt; stki[topi--] &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>cin &gt;&gt; op;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3-3</p><p>中缀表达式转后缀表达式 </p><p>有几个注意的点 (栈为空就直接放)</p><p>首先是优先级问题 当顺着遇到+或-的时候优先级小于* 和 &#x2F; 所以要把栈顶的所有*  和&#x2F;先输出出来 然后再把+ - 放进去</p><p>遇到*  或&#x2F; 的时候就直接放进去  （直接放</p><p>遇到）的时候要一直输出符号 直到遇到（</p><p>数字直接当场输出</p><p>数字的处理 由于加减前面必须有数字  那么前面没有数字的加减 就是<strong>正负号</strong> i&#x3D;&#x3D;0 或者前一个是（ 都满足这个情况 然后数字和小数点都加上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;yxj;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>&#123;<br>flag += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>yxj.<span class="hljs-built_in">insert</span>(&#123; <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;);<br>yxj.<span class="hljs-built_in">insert</span>(&#123; <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;);<br>yxj.<span class="hljs-built_in">insert</span>(&#123; <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;);<br>yxj.<span class="hljs-built_in">insert</span>(&#123; <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;);<br>yxj.<span class="hljs-built_in">insert</span>(&#123; <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-number">0</span>&#125;);<br><br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>stack&lt;<span class="hljs-type">char</span>&gt;cal;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;)<br>&#123;<br><span class="hljs-keyword">if</span> (((s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="hljs-number">0</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>)) || ((s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || s[i] == <span class="hljs-string">&#x27;.&#x27;</span>))<br>&#123;<br><span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;+&#x27;</span>)<br>cout &lt;&lt; s[i];<br>i++;<br><span class="hljs-keyword">while</span> (((s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || s[i] == <span class="hljs-string">&#x27;.&#x27;</span>))<br>&#123;<br>cout &lt;&lt; s[i];<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>&#123;<br>cal.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">while</span> (cal.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>&#123;<br><span class="hljs-type">char</span> a = cal.<span class="hljs-built_in">top</span>();<br><span class="hljs-built_in">print</span>();<br>cout &lt;&lt; a;<br><br>cal.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cal.<span class="hljs-built_in">pop</span>();<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (!cal.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">char</span> a = cal.<span class="hljs-built_in">top</span>();<br><span class="hljs-type">char</span> b = s[i];<br><span class="hljs-keyword">while</span> (yxj[a] &gt;= yxj[b] &amp;&amp; !cal.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-built_in">print</span>();<br>cout &lt;&lt; a;<br><br>cal.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (cal.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">break</span>;<br>a = cal.<span class="hljs-built_in">top</span>();<br>&#125;<br>cal.<span class="hljs-built_in">push</span>(b);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cal.<span class="hljs-built_in">push</span>(s[i]);<br>&#125;<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!cal.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (cal.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">print</span>();<br>cout &lt;&lt; cal.<span class="hljs-built_in">top</span>();<br>&#125;<br>cal.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Math</title>
    <link href="/2023/09/11/Math/"/>
    <url>/2023/09/11/Math/</url>
    
    <content type="html"><![CDATA[<h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">如果i是primes[j]的倍数，跳出循环是因为在线性筛的过程中，我们的目标是找到小于等于n的所有素数，并且要保证每个合数只被标记一次。因此，在内层循环中，当i是primes[j]的倍数时，我们不需要再继续考虑primes[j] * i及其之后的倍数了，因为它们已经在之前的迭代中被标记过了。</span><br><span class="hljs-string"></span><br><span class="hljs-string">举个例子来说明：</span><br><span class="hljs-string"></span><br><span class="hljs-string">假设我们正在处理i=10，而primes[j]=2，也就是说10是2的倍数。那么在这一轮迭代中，我们会标记10、20、30、40、...等等所有10的倍数为非素数。但实际上，这些数在之前已经被标记过了，因为它们分别是2、4、6、8、...等等的倍数，而这些倍数在处理2的时候已经被标记过了。所以，为了避免重复标记，当i是primes[j]的倍数时，我们可以直接跳出内层循环，不再处理这个数及其后续的倍数。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_sieve</span>(<span class="hljs-params">n</span>):<br>    is_prime = [<span class="hljs-literal">True</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 初始化一个布尔数组，标记每个数是否为素数</span><br>    primes = []  <span class="hljs-comment"># 存储素数的列表</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i]:<br>            primes.append(i)  <span class="hljs-comment"># i是素数</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(primes)):<br>            <span class="hljs-comment"># 将已知素数primes[j]与当前数i相乘，标记其倍数为非素数</span><br>            <span class="hljs-keyword">if</span> primes[j] * i &gt; n:<br>                <span class="hljs-keyword">break</span><br>            is_prime[primes[j] * i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % primes[j] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果i是primes[j]的倍数，跳出循环</span><br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> primes<br><br>n = <span class="hljs-number">30</span>  <span class="hljs-comment"># 你可以设置需要查找素数的上限</span><br>primes = linear_sieve(n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小于等于&quot;</span>, n, <span class="hljs-string">&quot;的素数：&quot;</span>, primes)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二上</title>
    <link href="/2023/09/11/%E5%A4%A7%E4%BA%8C%E4%B8%8A/"/>
    <url>/2023/09/11/%E5%A4%A7%E4%BA%8C%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="学期"><a href="#学期" class="headerlink" title="学期"></a>学期</h1><h2 id="第一周先复习一下数据结构，不然python小测要寄掉了-痛苦"><a href="#第一周先复习一下数据结构，不然python小测要寄掉了-痛苦" class="headerlink" title="第一周先复习一下数据结构，不然python小测要寄掉了 [痛苦]"></a>第一周先复习一下数据结构，不然python小测要寄掉了 [痛苦]</h2><ul><li><p>首先，当然是上课辣[嘿嘿]</p></li><li><p>背单词，你也不想你看不懂cf题面的事情被大家知道吧~（&#x2F;ww</p></li><li><p>写算法题，[教练，我也要打div4]</p></li><li><p>学学js，js帅的嘞，我也要做好玩的东溪</p></li><li><p>学学机器学习，（谁偷走了我的AI女友，[大吼]</p></li><li><p>跑步，你小汁~再不动就等shi吧</p></li></ul><p>好好好，就先这样（</p><h2 id="好好好-成功苟到了第二周"><a href="#好好好-成功苟到了第二周" class="headerlink" title="好好好 成功苟到了第二周"></a>好好好 成功苟到了第二周</h2><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><ul><li>好像没怎么刷视频来着，但是效率好低，不知道为什么一下子就好几个小时过去了。awsl，其实周末挺摆的（呜呜呜为什么，不想活了</li><li>每门课都上了一点点 往后看了一点点</li><li>学会了基础的html语法 但是后面大概会先停一下子这样，本来以为时间挺多的，结果事情安排多了，还是做不完。</li><li>看了一点点机器学习，吴恩达老师讲的真好！确实没有虚假广告，比刷剧爽</li><li>背了单词，大概有接近两百个吧，好像有天晚上没背（</li><li>去跑步了，好累 每天都像从叙利亚打仗回来</li><li>算法看了一点点 看了吗 如看</li></ul><h3 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h3><ul><li>首先把洛谷的并查集和图论全部写完 一周25t 啊啊啊我tm直接拿下</li><li>没事看看机器学习</li><li>js就先不看了等国庆后再说</li><li>数据结构 大物 离散 数字逻辑 尽量当天就处理完 每天的知识复习以及作业（给我写快点啊喂）基础课还是得多花点时间的</li><li>好烦 两个sb发了消息都不回？特殊选课只能看运气了，，服了 以后不知道怎么办 </li><li>背单词和跑步</li><li>周末不要摆烂（哼！鲨了你哦</li></ul><p>主要是先学学算法 加训！！&#x2F;oh 你这个rating怎么睡得着的</p><h2 id="寄啦-开始摆烂了-我要完蛋了-哭"><a href="#寄啦-开始摆烂了-我要完蛋了-哭" class="headerlink" title="寄啦 开始摆烂了 我要完蛋了 [哭]"></a>寄啦 开始摆烂了 我要完蛋了 [哭]</h2><h3 id="第二周-1"><a href="#第二周-1" class="headerlink" title="第二周"></a>第二周</h3><ul><li>前三天写了PTA 难过 写了好久 最后整理了（还是有2个怪怪的</li><li>周三周四补了大物和离散复习了书然后写了作业  然后周三开始 就开始摆烂&#x2F;kk 虽然也在写 但是效率好低。。。</li><li>周五六更是这样 啊啊啊啊啊啊    完蛋了 毁了</li><li>好像有几天单词也没有背，有两三天没去跑步 。怎么办怎么办怎么办怎么办</li><li>好焦虑 要死掉了 哈哈</li><li>机器学习也只看了一点 算了  反正也没在学别的 继续看机器学习和js算了</li><li>然后写了很多题 还写了div4 整理了 虽然H没看懂</li></ul><h3 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h3><ul><li>如果没有pta的话 周一看数据结构的书 复习ADT</li><li>写题就写洛谷的提单 图论写完之后开始看算法书</li><li>不想写题了就看机器学习和js 写个烂简历 把js也写上了 寄</li><li>背单词 把六级的书拿过来写</li><li>跑步</li><li>课程内容正常上课和复习</li><li>写周计划好像没什么用  还是精确到小时的日计划 这周逝逝</li></ul><p>啊啊啊啊啊啊啊 再摆烂就等死吧啊啊啊啊啊啊啊啊啊啊啊啊啊啊wtm鲨鲨鲨鲨鲨鲨不能再看√8视频了</p><h2 id="假期结束"><a href="#假期结束" class="headerlink" title="假期结束"></a>假期结束</h2><h3 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h3><ul><li>大物的题要写完</li><li>数字逻辑的作业和复习（感觉写的好慢，，还有证明题</li><li>动态规划的题单</li><li>数据结构看书和复习 讲题</li><li>拿到六级的题之后 每周天写三套</li><li>背单词</li><li>跑步</li></ul><p>难过 ，，但是要用正向魔法！好！</p><h2 id="第五周呢？乌乌谁偷走了我的第五周"><a href="#第五周呢？乌乌谁偷走了我的第五周" class="headerlink" title="第五周呢？乌乌谁偷走了我的第五周"></a>第五周呢？乌乌谁偷走了我的第五周</h2><p>第五周太难过了 于是没有了</p><h2 id="第六周"><a href="#第六周" class="headerlink" title="第六周"></a>第六周</h2><p>感觉事情多一点的话效率还是会提高的这样子  这周前面在准备大物小测  看书的时候还是容易摆烂。。写题倒还好  后面在补大物的笔记什么的 还有课内的一些内容</p><h3 id="第七周"><a href="#第七周" class="headerlink" title="第七周"></a>第七周</h3><ul><li><p>后面先按计划写大物  写完之后 开始写大物的往年卷  只有两周了。。。</p></li><li><p>离散的话  要做离散的整理   一天做一点  大概能在考试前做完，，话说离散也有往年卷啊</p></li><li><p>然后  数据结构  开始准备写题  先写习题册上的</p></li><li><p>数字逻辑 记得复习ppt  然后也要开始写往年卷   </p></li><li><p>下周 下下周 先主要写大物 整理离散  看看最终考试是在什么时间  （其实都挤在第九周  说不定其他科比大物还早，，，</p></li><li><p>英语有时间就写。没时间就算了 卧槽 英语真啥也不会了。。 但是可以期中考完再写 英语是十二月考</p></li></ul><p>又要开始考试月了，写一堆题&#x2F;&#x2F;&#x2F;</p><p>对了  还有 动态规划的题解 和两场div3的题 还有力扣的题</p>]]></content>
    
    
    
    <tags>
      
      <tag>Plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论入门题解</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P5318">P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>用vector<int>graph[N]存图 类似于defaultdict(list)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>vis[x] = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[x][i]])<br>&#123;<br><span class="hljs-built_in">dfs</span>(graph[x][i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(x);<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[a].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[a][i]])<br>&#123;<br>vis[graph[a][i]] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(graph[a][i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">emplace_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">sort</span>(graph[i].<span class="hljs-built_in">begin</span>(), graph[i].<span class="hljs-built_in">end</span>());<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>有向图求每个点能到达的编号最大的点</p><p>图论的经典做法  存反图然后从最大的点开始遍历他能到达的所有点 更新  后续如果这个点已经更新过了 就不再更新了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;fgraph[N];<br><span class="hljs-type">int</span> dis[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>dis[x] = d;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fgraph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(fgraph[x][i], d);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>fgraph[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">dfs</span>(i, i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1113">P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>经典拓扑+动态规划</p><p>把前面的杂物干完才能干后面的事  拓扑排序</p><p>并且加上了动态规划（有点类似dijkstra）   完成所有杂物的最短时间 每次循环更新 到u这个任务需要的最短时间 （即f[u] &#x3D; max(f[u], f[x] + t[u]）到u的最短 即到源点到x的最短加上到x到u的最短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">500500</span>;<br><br>vector&lt;<span class="hljs-built_in">int</span>&gt;graph[N];<br><span class="hljs-built_in">int</span> deg[N];<br><span class="hljs-built_in">int</span> f[N];<br><span class="hljs-built_in">int</span> t[N];<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; t[i];<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v &amp;&amp; v)<br>&#123;<br>graph[v].push_back(u);<br>deg[u]++;<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-built_in">int</span>&gt;q;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(i);<br>f[i] = t[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.empty())<br>&#123;<br><span class="hljs-built_in">int</span> x = q.front();<br>q.pop();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].size(); i++)<br>&#123;<br><span class="hljs-built_in">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(u);<br>&#125;<br>f[u] = <span class="hljs-built_in">max</span>(f[u], f[x] + t[u]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求食物链的数量（食物链必须到最高消费者 即不被捕食的动物 即出度为0的）</p><p>拓扑排序+动态规划 </p><p>比如a-&gt;b-&gt;c   每次更新时 nums[b] &#x3D; nums[b] + nums[a] 把到第a的食物链条数全部累加到b中  最后把出度为0的点的条数加上 即为答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">80112002</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> deg[N], out[N], nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>deg[b]++;<br>out[a]++;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>nums[i] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(u);<br>&#125;<br>nums[u] = (nums[u] + nums[x]) % mod;<br>&#125;<br><br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>)<br>&#123;<br>ans = (nums[i] + ans)%mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1807">P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最长路问题   还是动态规划  d[i] &#x3D; max(d[x]  + mp[x ] [ i ], d[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000</span>, M = <span class="hljs-number">55000</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> d[N], mp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> u, v, w;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>mp[u][v] = <span class="hljs-built_in">max</span>(mp[u][v], w);<br>&#125;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (mp[x][i] &amp;&amp; d[i] &lt; d[x] + mp[x][i])<br>&#123;<br>d[i] = d[x] + mp[x][i];<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>&#125;<br>&#125;<br><br>cout &lt;&lt; d[n] &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2853 USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2853 <a href="https://www.luogu.com.cn/problem/P2853">USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求有几个地方 是所有的奶牛都可以的到达的</p><p>那每次走过的时候次数+1  当all[x] &#x3D;&#x3D; k 的时候就代表这个点都可以到达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> a[N], vis[N], all[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>vis[x] = <span class="hljs-number">1</span>;<br>all[x] += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> y = graph[x][i];<br><span class="hljs-keyword">if</span> (vis[y] == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(a[i]);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (all[i] == k)<br>ans += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1363">P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>无线的地图 那么只要它能够回到原点 就说明可以从一个点到另一个点  就可以无限走 就符合题意</p><p>用vis储存横纵坐标和是否访问  </p><p>每次进入先判断该点（是取模过的点 ***）是否已经访问过  如果访问过 并且x， y跟之前的不一样（只要有一个不一样就行）那就说明走到了另一个地图的原点 说明可以无限</p><p>如果访问过 并且是回到了原点 那就退回</p><p>标记该点为已访问 像四个方向拓展  lx和ly用来记录是否走出  要取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m, n, sx, sy, dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;, dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;, ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">bool</span> graph[N][N] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">int</span> vis[N][N][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> ly)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; (vis[lx][ly][<span class="hljs-number">0</span>] != x || vis[lx][ly][<span class="hljs-number">1</span>] != y))<br>&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; vis[lx][ly][<span class="hljs-number">0</span>] == x &amp;&amp; vis[lx][ly][<span class="hljs-number">1</span>] == y)<span class="hljs-keyword">return</span>;<br>vis[lx][ly][<span class="hljs-number">0</span>] = x; vis[lx][ly][<span class="hljs-number">1</span>] = y; vis[lx][ly][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nx, ny;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">4</span>; w++)<br>&#123;<br>nx = (lx + dx[w] + n) % n;<br>ny = (ly + dy[w] + m) % m;<br><span class="hljs-keyword">if</span> (graph[nx][ny])<span class="hljs-built_in">dfs</span>(x + dx[w], y + dy[w], nx, ny);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(graph, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(graph));<br>ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>)graph[i][j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;S&#x27;</span>)<br>&#123;<br>sx = i, sy = j;<br>graph[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> graph[i][j] = <span class="hljs-literal">false</span>;<br>&#125; <br>&#125;<br><span class="hljs-built_in">dfs</span>(sx, sy, sx, sy);<br><span class="hljs-keyword">if</span> (ans)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="省份数量-547-省份数量-力扣（LeetCode）"><a href="#省份数量-547-省份数量-力扣（LeetCode）" class="headerlink" title="[省份数量](547. 省份数量 - 力扣（LeetCode）)"></a>[省份数量](<a href="https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory">547. 省份数量 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>cities = <span class="hljs-built_in">len</span>(isConnected)<br>        province = <span class="hljs-number">0</span><br>        vis = [<span class="hljs-number">0</span>] * cities<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[j] <span class="hljs-keyword">and</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    vis[j] = <span class="hljs-number">1</span><br>                    dfs(j)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                vis[i] = <span class="hljs-number">1</span><br>                province += <span class="hljs-number">1</span><br>                dfs(i)<br><br>        <span class="hljs-keyword">return</span> province<br>    <br>   <span class="hljs-comment"># 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 </span><br><span class="hljs-comment"># 重点在并查集的写法</span><br>uf = UnionFind()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(isConnected)):<br>            uf.add(i)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    uf.merge(i,j)<br>        <span class="hljs-keyword">return</span> uf.num_of_sets<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.father = &#123;&#125;<br>        self.num_of_sets = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self,x</span>):<br>        root = x<br>        <span class="hljs-keyword">while</span> self.father[root] != <span class="hljs-literal">None</span>:<br>            root = self.father[root]<br><span class="hljs-comment"># 让并查集更宽 减少时间复杂度</span><br>        <span class="hljs-keyword">while</span> x != root:<br>            original_father = self.father[x]<br>            self.father[x] = root<br>            x = original_father<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self,x,y</span>):<br>        root_x, root_y = self.find(x),self.find(y)<br><br>        <span class="hljs-keyword">if</span> root_x != root_y:<br>            self.father[root_x] = root_y<br>            self.num_of_sets -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.father:<br>            self.father[x] = <span class="hljs-literal">None</span><br>            self.num_of_sets += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）"><a href="#找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="[找到最终的安全状态](802. 找到最终的安全状态 - 力扣（LeetCode）)"></a>[找到最终的安全状态](<a href="https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory">802. 找到最终的安全状态 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2</span><br><span class="hljs-string">一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全</span><br><span class="hljs-string">&quot;&quot;&quot;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>n = <span class="hljs-built_in">len</span>(graph)<br>        color = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>            <span class="hljs-comment"># 访问已经搜过的结点 1为有环 2为无环</span><br>            <span class="hljs-keyword">if</span> color[x] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span><br>            <span class="hljs-comment"># 如果是0</span><br>            color[x] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-comment"># 快速退出</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> safe(y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True</span><br>            color[x] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>       <br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> safe(i)]<br>    <br>    <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的</span><br><span class="hljs-string">    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序</span><br><span class="hljs-string">    循环结束后 所有入度为0的结点都是安全的</span><br><span class="hljs-string">    意思是，原图的出度为0的结点，和指向出度为0的结点的结点</span><br><span class="hljs-string">    （由于存了反图并拓扑排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> graph]<br>        <span class="hljs-comment"># 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0</span><br>        <span class="hljs-keyword">for</span>  x, ys <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:<br>rg[y].append(x)<br>        <span class="hljs-comment"># in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）</span><br>        in_deg = [<span class="hljs-built_in">len</span>(ys) <span class="hljs-keyword">for</span> ys <span class="hljs-keyword">in</span> graph]<br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>])<br><span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rg[q.popleft()]:<br>                in_deg[x] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[x] == <span class="hljs-number">0</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i, d  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="颜色交替的最短路径"><a href="#颜色交替的最短路径" class="headerlink" title=" 颜色交替的最短路径 "></a><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory"> 颜色交替的最短路径 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestAlternatingPaths</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, redEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], blueEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> redEdges:<br>            g[x].append((y,<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> blueEdges:<br>            g[x].append((y,<span class="hljs-number">1</span>))<br>        <br><br>        dis = [-<span class="hljs-number">1</span>] * n<br>        vis = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        q = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> x, color <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">if</span> dis[x] == -<span class="hljs-number">1</span>:<br>                    dis[x] = level<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-keyword">if</span> p[<span class="hljs-number">1</span>] != color <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        vis.add(p)<br>                        q.append(p)<br>            level += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dis<br></code></pre></td></tr></table></figure><h1 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间 "></a><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/">通知所有员工所需的时间 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            g[manager[i]].append(i)<br><br>        q = collections.deque()<br>        q.append((headID, <span class="hljs-number">0</span>))<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tid, val = q.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g[tid]) == <span class="hljs-number">0</span>:<br>                res = <span class="hljs-built_in">max</span>(res, val)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> ne <span class="hljs-keyword">in</span> g[tid]:<br>                    q.append((ne, val + informTime[tid]))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="1466-重新规划路线-力扣（LeetCode）"><a href="#1466-重新规划路线-力扣（LeetCode）" class="headerlink" title="1466. 重新规划路线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory">1466. 重新规划路线 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> connections:<br>            g[a].append((b, <span class="hljs-number">1</span>))<br>            g[b].append((a, <span class="hljs-number">0</span>))<br>        <br>        q = deque([<span class="hljs-number">0</span>])<br>        vis = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">while</span> q:<br>            cur = q.popleft()<br>            <span class="hljs-comment"># 遍历所有和cur相邻的边</span><br>            <span class="hljs-keyword">for</span> end, dirction <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g[cur]):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[end]:<br>                    vis[end] = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果方向不对就反转</span><br>                    res += dirction<br>                    q.append(end)<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <br><span class="hljs-comment"># 或者 用set一次遍历  有点问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = &#123;<span class="hljs-number">0</span>&#125;<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> connection:<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> s:<br>                s.add(l)<br>            <span class="hljs-comment"># 右边不通向0 并且左边通向0 （左边通向右边） 那就让r-&gt;l r就可以到0</span><br>            <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">in</span> s:<br>                s.add(r)<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>                <br>        <br></code></pre></td></tr></table></figure><h1 id="1192-查找集群内的关键连接-力扣（LeetCode）"><a href="#1192-查找集群内的关键连接-力扣（LeetCode）" class="headerlink" title="1192. 查找集群内的关键连接 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory">1192. 查找集群内的关键连接 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环 （此时的curnode为入口结点）</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="934-最短的桥-力扣（LeetCode）"><a href="#934-最短的桥-力扣（LeetCode）" class="headerlink" title="934. 最短的桥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory">934. 最短的桥 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两座相同的岛 先找到第一个不为0的数然后dfs标记这个岛的全部，然后用bfs搜索当第一次搜到第二个岛的step即是答案，注意dfs的时候要把第一个岛全部放入q（因为每个点都可能是距离第二个岛最近的点）搜完上下左右一圈后step + 1 （不需要vis数组记录 直接把走过的设为-1即可）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBridge</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = -<span class="hljs-number">1</span><br>            q.append((x, y))<br>            <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                    dfs(nx, ny)<br><br>        n = <span class="hljs-built_in">len</span>(grid)<br>        q = deque()<br>        i, j = <span class="hljs-built_in">next</span>((i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> grid[i][j])<br>        dfs(i, j)<br>        step = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x, y = q.popleft()<br>                <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n :<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">return</span> step<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">0</span>:<br>                            grid[nx][ny] = -<span class="hljs-number">1</span><br>                            q.append((nx, ny))<br>            step += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="127-单词接龙-力扣（LeetCode）"><a href="#127-单词接龙-力扣（LeetCode）" class="headerlink" title="127. 单词接龙 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=graph-theory">127. 单词接龙 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每次枚举26个字母 一一替换单词 直到找到wordList的单词 如果是end的话就直接返回 否则step+1放入q继续bfs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> beginWord == endWord:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        word = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)]<br>        q = deque([(beginWord, <span class="hljs-number">1</span>)])<br>        <span class="hljs-keyword">while</span> q:<br>            cur, step = q.popleft()<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cur):<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> word:<br>                    <span class="hljs-keyword">if</span> x != y:<br>                        nxt = cur[:i] + y + cur[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">in</span> wordList:<br>                            <span class="hljs-keyword">if</span> nxt == endWord:<br>                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                            q.append((nxt, step + <span class="hljs-number">1</span>))<br>                            wordList.remove(nxt)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="126-单词接龙-II-力扣（LeetCode）"><a href="#126-单词接龙-II-力扣（LeetCode）" class="headerlink" title="126. 单词接龙 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个方法相当于是每次把step=1的所有数都找出来并且加进去 把所有step=2的都找出来加进去这样（&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot; and &quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;）     当q（内层）取完之后表示当前步数可以链接的下一个单词已经全部找到 可以step+1 然后把s中暂存的给q 再次循环    直到end 加入答案 （当内层q为0的时候表示所有路径都已经加进去 就直接return） 当q（外层）取完（也就是sq交换的时候s为[]）之后表示所有路径都已经走过 但是还没有遇到end 这时返回[]</span><br><span class="hljs-comment"># 首先 建图方面 建立这个单词可以变的其他单词 变化处用* 表示 用defaultdict后面可以快速访问 </span><br><span class="hljs-comment"># 然后q用来存储当前值和当前路径 s与q相同 但是s是用来存储每轮的数据 每次开始时s都为[] （保证数据 相当于temp）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLadders</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> []<br>        dic = defaultdict(<span class="hljs-built_in">list</span>)<br>        n = <span class="hljs-built_in">len</span>(beginWord)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]].append(w)<br>        <br>        q, s = [(beginWord, [beginWord])], []<br>        res = []<br>        vis = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">while</span> q:<br>                w, path = q.pop()<br>                vis.add(w)<br>                <span class="hljs-keyword">if</span> w == endWord:<br>                    res.append(path)<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]]:<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                            s.append((nxt, path + [nxt]))<br>            <span class="hljs-keyword">if</span> res:<br>                <span class="hljs-keyword">return</span> res<br>            q, s = s, q<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="542-01-矩阵-力扣（LeetCode）"><a href="#542-01-矩阵-力扣（LeetCode）" class="headerlink" title="542. 01 矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/01-matrix/description/?envType=study-plan-v2&envId=graph-theory">542. 01 矩阵 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多起点的最短路问题 可以将所有的0 看成同一个源点 然后使用bfs 因为每次扩散一轮 所有的都加一时候再扩散下一轮（队列 先进先出）每次只需要搜索四个方向 然后再原来的ret的基础上加一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n, m = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        ret = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        q = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:<br>                    ret[i][j] = <span class="hljs-number">0</span><br>                    q.append([i,j])<br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j = q.popleft()<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> ret[ni][nj] == -<span class="hljs-number">1</span>:<br>                    ret[ni][nj] = ret[i][j] + <span class="hljs-number">1</span><br>                    q.append([ni, nj])<br><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="863-二叉树中所有距离为-K-的结点-力扣（LeetCode）"><a href="#863-二叉树中所有距离为-K-的结点-力扣（LeetCode）" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/?envType=study-plan-v2&envId=graph-theory">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distanceK</span>(<span class="hljs-params">self, root: TreeNode, target: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 首先用字典node_parent存储每个结点的父节点</span><br>        node_parent = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_find_parent</span>(<span class="hljs-params">node: TreeNode</span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">if</span> node.left:<br>                node_parent[node.left] = node<br>            <span class="hljs-keyword">if</span> node.right:<br>                node_parent[node.right] = node<br>            dfs_find_parent(node.left)<br>            dfs_find_parent(node.right)<br><br><br>        dfs_find_parent(root)<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [target.val]<br>        res = []<br><br>        q = deque()<br>        vis = <span class="hljs-built_in">set</span>()<br>        q.append(target)<br>        vis.add(target)<br>        <span class="hljs-comment"># 现在依次遍历和target距离为level的结点（波纹法 一层层搜索）</span><br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> level &lt; k:<br>            level += <span class="hljs-number">1</span> <span class="hljs-comment"># 先加还是后加取决于level初值</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [node_parent[x] <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> node_parent <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, x.left, x.right]: <span class="hljs-comment"># 遍历和当前点相邻的所有结点（每次搜索一层 注意要用set判重）</span><br>                    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">and</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        <span class="hljs-keyword">if</span> level == k:<br>                            res.append(y.val)<br>                        q.append(y)<br>                        vis.add(y)<br>        <span class="hljs-keyword">return</span> res<br><br>                <br></code></pre></td></tr></table></figure><h1 id="864-获取所有钥匙的最短路径-力扣（LeetCode）"><a href="#864-获取所有钥匙的最短路径-力扣（LeetCode）" class="headerlink" title="864. 获取所有钥匙的最短路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/?envType=study-plan-v2&envId=graph-theory">864. 获取所有钥匙的最短路径 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不同之处在于 并不是一个点只能走一次 而是可以多次走 找到最短的路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathAllKeys</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dis 用于记录每个点走的距离 不同的是 现在有3个状态 多了一个钥匙数的状态 </span><br>        dis = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0x3f3f3f3f</span>)<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>:<br>                    q = deque([(i, j, <span class="hljs-number">0</span>)])<br>                    dis[(i, j, <span class="hljs-number">0</span>)] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> grid[i][j].islower():<br>                    cnt += <span class="hljs-number">1</span><br><br><br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        <br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j, cur = q.popleft()<br>            step = dis[(i,  j, cur)]<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m:<br>                    c = grid[ni][nj]<br>                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 先将cur右移c位然后&amp;1判断是否为1</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> <span class="hljs-keyword">and</span> (cur &gt;&gt; (<span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    ncur = cur<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:<br>                        <span class="hljs-comment"># 标记为已有</span><br>                        ncur |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-keyword">if</span> ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 如果曾经走到过这里 并且步数更少的话 更新 （如果没有走到过的话 那就是0x3f3f3f3f 必定更新）</span><br>                    <span class="hljs-keyword">if</span> step + <span class="hljs-number">1</span> &lt; dis[(ni, nj, ncur)]:<br>                        dis[(ni, nj, ncur)] = step + <span class="hljs-number">1</span><br>                        q.append((ni, nj, ncur))<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一题题解</title>
    <link href="/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5166-对称山脉-AcWing题库"><a href="#5166-对称山脉-AcWing题库" class="headerlink" title="5166. 对称山脉 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5169/">5166. 对称山脉 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])</span><br><span class="hljs-comment"># 用ans记录每个长度j下的最小值</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>s = [[<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5010</span>)]<br>ans = [<span class="hljs-number">0x3f3f3f3f</span>] * <span class="hljs-number">5010</span><br>h = [<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    h[i+<span class="hljs-number">1</span>] =  nums[i]   <br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n-j+<span class="hljs-number">2</span>):<br>        s[i][i + j - <span class="hljs-number">1</span>] = s[i + <span class="hljs-number">1</span>][i + j - <span class="hljs-number">2</span>] + <span class="hljs-built_in">abs</span>(h[i] - h[i + j - <span class="hljs-number">1</span>])<br>        ans[j] = <span class="hljs-built_in">min</span>(ans[j], s[i][i + j - <span class="hljs-number">1</span>])<br><br>ans[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[j],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="5180-正方形泳池-AcWing题库"><a href="#5180-正方形泳池-AcWing题库" class="headerlink" title="5180. 正方形泳池 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5183/">5180. 正方形泳池 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>tree = []<br>tree.append([-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 占位</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,t + <span class="hljs-number">1</span>):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    tree.append([a, b])<br><br>tree.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>tree.append([<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>])<br>tree.append([n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>tree.append([n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>])<br>t += <span class="hljs-number">4</span> <span class="hljs-comment"># 四个顶点插入树 树的个数要加上</span><br><br>ans = -<span class="hljs-number">1</span><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]) <span class="hljs-comment">#  对x排序</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]</span><br><span class="hljs-string">不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）</span><br><span class="hljs-string">更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    d, u = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> x - a - <span class="hljs-number">1</span> &gt; u - d - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, x - a - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> y &gt;= b:<br>            u = <span class="hljs-built_in">min</span>(u, y)<br>        <span class="hljs-keyword">if</span> y &lt;= b:<br>            d = <span class="hljs-built_in">max</span>(d, y)<br><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    l, r = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> y - b - <span class="hljs-number">1</span> &gt; r - l - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, y - b - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x &gt;= a:<br>            r = <span class="hljs-built_in">min</span>(r, x)<br>        <span class="hljs-keyword">if</span> x &lt;= a:<br>            l = <span class="hljs-built_in">max</span>(l, x)<br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="1654-到家的最少跳跃次数-力扣（LeetCode）"><a href="#1654-到家的最少跳跃次数-力扣（LeetCode）" class="headerlink" title="1654. 到家的最少跳跃次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BFS 搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumJumps</span>(<span class="hljs-params">self, forbidden: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q,vis = deque([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]), <span class="hljs-built_in">set</span>([<span class="hljs-number">0</span>])<br>        lower, upper = <span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(forbidden) + a, x) + b<br>        forbiddenSet = <span class="hljs-built_in">set</span>(forbidden)<br>        <span class="hljs-keyword">while</span> q:<br>            position, direction, step = q.popleft()<br>            <span class="hljs-keyword">if</span> x == position:<br>                <span class="hljs-keyword">return</span> step<br>            nextposition = position + a<br>            nextdirection = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                vis.add(nextposition * nextdirection)<br>                q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 不能两次退后</span><br>            <span class="hljs-keyword">if</span> direction == <span class="hljs-number">1</span>:<br>                nextposition = position - b<br>                nextdirection = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                    vis.add(nextposition * nextdirection)<br>                    q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="823-带因子的二叉树-力扣（LeetCode）"><a href="#823-带因子的二叉树-力扣（LeetCode）" class="headerlink" title="823. 带因子的二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-trees-with-factors/">823. 带因子的二叉树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = <span class="hljs-built_in">set</span>(arr)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">val</span>):<br>            ans = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> s:<br>                    ans += dfs(x) * dfs(val // x)<br>            <span class="hljs-keyword">return</span> ans<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(dfs(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>    <br><span class="hljs-comment"># 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        idx = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr)&#125;<br>        f = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                val = arr[i]<br>                x = arr[j]<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> idx:<br>                    f[i] += f[j] * f[idx[val // x]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(f) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br><br></code></pre></td></tr></table></figure><h1 id="1761-一个图中连通三元组的最小度数-力扣（LeetCode）"><a href="#1761-一个图中连通三元组的最小度数-力扣（LeetCode）" class="headerlink" title="1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/">1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次</span><br><span class="hljs-comment"># 用邻接矩阵来储存 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minTrioDegree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        degree = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> edges:<br>            x, y = x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span><br>            g[x][y] = g[y][x] = <span class="hljs-number">1</span><br>            degree[x] += <span class="hljs-number">1</span><br>            degree[y] += <span class="hljs-number">1</span><br>        <br>        ans = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                <span class="hljs-keyword">if</span> g[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, n):<br>                        <span class="hljs-keyword">if</span> g[i][k] == g[j][k] == <span class="hljs-number">1</span>:<br>                            ans = <span class="hljs-built_in">min</span>(ans, degree[i] + degree[j] + degree[k] - <span class="hljs-number">6</span>)<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ans == inf <span class="hljs-keyword">else</span> ans<br><br></code></pre></td></tr></table></figure><h1 id="5183-好三元组-AcWing题库"><a href="#5183-好三元组-AcWing题库" class="headerlink" title="5183. 好三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5186/">5183. 好三元组 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。</span><br><span class="hljs-string">所有情况为n * (n - 1) * (n - 2) // 6</span><br><span class="hljs-string">当三个数在同一点上时 不合规</span><br><span class="hljs-string">两个点在同一点上 不合规</span><br><span class="hljs-string">三个点在同一个半圆内时 不合规</span><br><span class="hljs-string">同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规</span><br><span class="hljs-string">所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1</span><br><span class="hljs-string">最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>N = <span class="hljs-number">2000100</span><br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>p = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>cnt = [<span class="hljs-number">0</span>] * N<br>s = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt[p[i - <span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    cnt[p[i - <span class="hljs-number">1</span>] + c] += <span class="hljs-number">1</span><br><br>res = n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br><br>s[<span class="hljs-number">0</span>] = cnt[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * c):<br>    s[i] = s[i - <span class="hljs-number">1</span>] + cnt[i]<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c):<br>    <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">continue</span><br>    t = cnt[i]<br>    d = s[i + c // <span class="hljs-number">2</span>] - s[i]<br>    <br>    <span class="hljs-comment"># 其实不需要判断也行</span><br>    <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">3</span>:<br>            res -= t * (t - <span class="hljs-number">1</span>) * (t - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br>        res -= t * (t - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * d<br>    res -= t * d * (d - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c // <span class="hljs-number">2</span>):<br>        u, v = cnt[i], cnt[i + c // <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">2</span>:<br>            res += u * (u - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * v<br>        <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">2</span>:<br>            res += v * (v - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * u<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="5145-同色环-AcWing题库"><a href="#5145-同色环-AcWing题库" class="headerlink" title="5145. 同色环 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5148/">5145. 同色环 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> nums[N][N];<br><span class="hljs-type">bool</span> vis[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> ox, <span class="hljs-type">int</span> oy)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx = x + dx[i];<br>        <span class="hljs-type">int</span> ny = y + dy[i];<br><br>        <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m<br>            <span class="hljs-comment">// 这一句的意思是 不能退回</span><br>            &amp;&amp; !(nx == ox &amp;&amp; ny == oy)<br>            <span class="hljs-comment">// 颜色相同</span><br>            &amp;&amp; nums[nx][ny] == nums[x][y])<br>        &#123;<br>            <span class="hljs-comment">// 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况</span><br>            <span class="hljs-keyword">if</span> (vis[nx][ny] || <span class="hljs-built_in">dfs</span>(nx, ny, x, y))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            cin &gt;&gt; nums[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i][j])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1921-消灭怪物的最大数量-力扣（LeetCode）"><a href="#1921-消灭怪物的最大数量-力扣（LeetCode）" class="headerlink" title="1921. 消灭怪物的最大数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03">1921. 消灭怪物的最大数量 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eliminateMaximum</span>(<span class="hljs-params">self, dist: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(dist)<br>        <span class="hljs-comment"># 上取整</span><br>        arrivetime = [math.ceil(dist[i] / speed[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>        arrivetime.sort()<br>        <span class="hljs-keyword">for</span> attacktime, arrivetime <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arrivetime):<br>            <span class="hljs-keyword">if</span> attacktime &gt;= arrivetime:<br>                <span class="hljs-keyword">return</span> attacktime<br>        <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure><h1 id="统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛"><a href="#统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛" class="headerlink" title="统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛"></a><a href="https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/">统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Counter 返回字典 每个元素是键 出现次数为值</span><br><span class="hljs-comment"># dfs</span><br><span class="hljs-comment"># 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        mx = -<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        keys = <span class="hljs-built_in">list</span>(c.keys())<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, count, add, mul</span>):<br>            <span class="hljs-keyword">nonlocal</span> mx, ans<br>            <span class="hljs-keyword">if</span> count == k:<br>                <span class="hljs-keyword">if</span> add &gt; mx:<br>                    mx = add<br>                    ans = mul<br>                <span class="hljs-keyword">elif</span> add == mx:<br>                    ans += mul<br>                ans %= Mod<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> i + k - count &gt; <span class="hljs-built_in">len</span>(keys):<br>                <span class="hljs-keyword">return</span><br>            dfs(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, add + c[keys[i]], mul * c[keys[i]] % Mod)<br>            dfs(i + <span class="hljs-number">1</span>, count, add, mul)<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-comment"># 数学</span><br><span class="hljs-comment"># 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> comb<br>            Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>            values = <span class="hljs-built_in">sorted</span>(c.values(), reverse=<span class="hljs-literal">True</span>)<br>            ans = <span class="hljs-number">1</span><br>            c = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                <span class="hljs-keyword">if</span> values[i] &gt; values[k - <span class="hljs-number">1</span>]:<br>                    ans *= values[i]<br>                    ans %= Mod<br>                <span class="hljs-keyword">elif</span> values[i] == values[k - <span class="hljs-number">1</span>]:<br>                    c += <span class="hljs-number">1</span><br>                    ans *= values[i]<br>                    ans %= Mod<br>            <span class="hljs-keyword">return</span> ans * comb(values.count(values[k - <span class="hljs-number">1</span>]),c) % Mod<br><br></code></pre></td></tr></table></figure><h1 id="2605-从两个数字数组里生成最小数字-力扣（LeetCode）"><a href="#2605-从两个数字数组里生成最小数字-力扣（LeetCode）" class="headerlink" title="2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/">2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是看一下这个写法 s = set(nums1) &amp; set(nums2) 直接取出1 2 中的相同的数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minNumber</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        a = <span class="hljs-built_in">min</span>(nums1)<br>        b = <span class="hljs-built_in">min</span>(nums2)<br>        <span class="hljs-keyword">if</span> a &gt; b:<br>            a, b = b, a<br>        ret = a * <span class="hljs-number">10</span> + b<br><br>        s = <span class="hljs-built_in">set</span>(nums1) &amp; <span class="hljs-built_in">set</span>(nums2)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> ret <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(s)<br></code></pre></td></tr></table></figure><h1 id="5198-整理书籍-AcWing题库"><a href="#5198-整理书籍-AcWing题库" class="headerlink" title="5198. 整理书籍 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5201/">5198. 整理书籍 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算有几个L几个M 然后算有几个L不在前面 有几个M不在中间 然后至多需要交换这么多次 才能换好 但是当错位的L和M互换时 两次就只需要一次了 所以说取min(l,m)(这就是LM相互错位的个数)减掉就行</span><br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())<br>n = <span class="hljs-built_in">len</span>(nums)<br>cl, cm, cs = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        cl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        cm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;S&#x27;</span>:<br>        cs += <span class="hljs-number">1</span><br><br><br>wl, wm, lm, ml = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;L&#x27;</span>:<br>        wl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        lm += <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl, cl + cm):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;M&#x27;</span>:<br>        wm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        ml += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(wl + wm - <span class="hljs-built_in">min</span>(lm, ml))<br><br></code></pre></td></tr></table></figure><h1 id="2594-修车的最少时间-力扣（LeetCode）"><a href="#2594-修车的最少时间-力扣（LeetCode）" class="headerlink" title="2594. 修车的最少时间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/">2594. 修车的最少时间 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分最长的时间 计算这个时间每个人可以修的车的数量 和 cars比较 （并不需要实际地去算 应该给每个人安排多少车 而是求最大修车数 看能不能修完）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repairCars</span>(<span class="hljs-params">self, ranks: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], cars: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        right = cars * cars * <span class="hljs-built_in">min</span>(ranks)<br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(isqrt(mid // r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> ranks) &gt;= cars:<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><h1 id="Problem-F-Codeforces"><a href="#Problem-F-Codeforces" class="headerlink" title="Problem - F - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/F">Problem - F - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求一个数，他的约数的个数（同一个约数可能出现很多次）最多，遍历1~n，ans[j] += len(cs[i])。因为i的所有倍数上的点，都满足条件。所以把每个ans[j] 都加上i的个数。遍历到n的时候，就把所有的数都加上了</span><br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <br>    cs = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>        cs[x].append(i)<br>    ans = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    m = <span class="hljs-built_in">len</span>(cs)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        j = i<br>        <span class="hljs-keyword">while</span> j &lt;= n:<br>            ans[j] += <span class="hljs-built_in">len</span>(cs[i])<br>            j += i<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(ans))<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="210-课程表-II-力扣（LeetCode）"><a href="#210-课程表-II-力扣（LeetCode）" class="headerlink" title="210. 课程表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-ii/?envType=daily-question&envId=2023-09-10">210. 课程表 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拓扑排序(注意拓扑排序 是看是不是所有的都进入过q 或者说 最后是不是所有入度都为0) 首先建图 同时增加入度 然后把入度为0的都加入q 不断循环 每次pop的同时 numCourse-1 记录进入q的个数 如果全部进了代表没有环 那么就可以返回 而上课顺序 恰好是从q pop的顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        how = []<br>        <span class="hljs-keyword">while</span> q:<br>            pre = q.popleft()<br>            numCourses -= <span class="hljs-number">1</span><br>            how.append(pre)<br>            <span class="hljs-keyword">for</span> cur <span class="hljs-keyword">in</span> graph[pre]:<br>                in_deg[cur] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[cur] == <span class="hljs-number">0</span>:<br>                    q.append(cur)<br>        <br>        <span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> how<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="630-课程表-III-力扣（LeetCode）"><a href="#630-课程表-III-力扣（LeetCode）" class="headerlink" title="630. 课程表 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iii/?envType=daily-question&envId=2023-09-11">630. 课程表 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 贪心＋优先队列 （反悔贪心） 很容易想到要先对结束时间排序 结束时间越晚 就越晚做，因为开始晚的先做如果做得完，可能前面的做不完了，开始晚的先做如果做不完，那前面的肯定做不完了。开始晚的后做，不管做不做得完，前一个肯定是不受影响的。</span><br><span class="hljs-comment"># 接着是按顺序取课 用sum记录当前总时间 h为优先队列（注意 heap默认是小根堆  为了使其成为大根堆 每次存入和取出使用相反数），如果sum+dur &lt;= end 说明是可以都上的 那就加上 并且放入h  如果&gt;end 不能都上 那么就判断当前的dur和之前已经存在的时间最长的课哪个时间更长 如果原来的课比当前课时间长 就要和当前的课进行替换（总数不变 sum变小） 使得sum最小 那么就更有可能多上几节课 如果当前的时间长 那这节课肯定选不了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scheduleCourse</span>(<span class="hljs-params">self, courses: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        courses.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>        n = <span class="hljs-built_in">len</span>(courses)<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        h = []<br>        <span class="hljs-keyword">for</span> dur, end <span class="hljs-keyword">in</span> courses:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> + dur &lt;= end:<br>                <span class="hljs-built_in">sum</span> += dur<br>                heappush(h, -dur)<br>            <span class="hljs-keyword">elif</span> h <span class="hljs-keyword">and</span> -h[<span class="hljs-number">0</span>] &gt; dur:<br>                <span class="hljs-built_in">sum</span> -= -h[<span class="hljs-number">0</span>] - dur<br>                heappop(h)<br>                heappush(h, -dur)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br></code></pre></td></tr></table></figure><h1 id="1462-课程表-IV-力扣（LeetCode）"><a href="#1462-课程表-IV-力扣（LeetCode）" class="headerlink" title="1462. 课程表 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkIfPrerequisite</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">bool</span>]:<br>        <span class="hljs-comment"># 拓扑排序的思路仍然是先建图 存储入度 循环找点  不同的是 （有向图） 这次0-1-2-3 不仅0-1连通 0-3也连通 要反映这样的一种关系 需要建立一个二维数组表示他们的连通关系  每次pop取出一个点 这个点是x连向的所有点 即列表graph[x] 遍历里面的每个元素 （入度减一等操作） 遍历每一个numCourse的点 如果他跟x有连接 或者跟y有连接就为True （h-y or h-x-y）</span><br>        <span class="hljs-comment"># Toposort</span><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        ret = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                in_deg[y] -= <span class="hljs-number">1</span><br>                ret[x][y] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    ret[h][y] = ret[h][y] <span class="hljs-keyword">or</span> ret[h][x]<br>                <span class="hljs-keyword">if</span> in_deg[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br>        <span class="hljs-keyword">return</span> [ret[a][b] <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> queries]<br>    <br>    <br>        <span class="hljs-comment"># Floyd的思路 边权为True 建好图之后直接循环</span><br>        <span class="hljs-comment"># Floyd</span><br>        graph = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre][cur] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    graph[i][j] = (graph[i][k] <span class="hljs-keyword">and</span> graph[k][j]) <span class="hljs-keyword">or</span> graph[i][j]<br><br>        <span class="hljs-keyword">return</span> [graph[i][j] <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces（新二分板子）"><a href="#Problem-E-Codeforces（新二分板子）" class="headerlink" title="Problem - E - Codeforces（新二分板子）"></a><a href="https://codeforces.com/contest/1850/problem/E">Problem - E - Codeforces</a>（新二分板子）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 来自tllwtg的算法模板</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">更好记录答案 也更有逻辑</span><br><span class="hljs-string">if check():</span><br><span class="hljs-string">res = mid</span><br><span class="hljs-string">l = mid + 1</span><br><span class="hljs-string">else:</span><br><span class="hljs-string">r = mid - 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">return res</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>    l, r, res = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>, -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> l &lt;= r:<br>        mid = (l + r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-built_in">sum</span>([(nums[i] + <span class="hljs-number">2</span> * mid ) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]):<br>            res = mid <br>            l = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid - <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/D">Problem - D - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求去掉几个可以使连续的最大 就是求最大然后用n减去</span><br><span class="hljs-comment"># 用diff记录差值 但其实可以优化 毕竟排序之后 差值只需要和前一个比较即可</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    diff = [<span class="hljs-number">0</span>] * n<br>    diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># print(diff)</span><br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">if</span> diff[i] &lt;= k:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br>    <br><span class="hljs-comment"># 优化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    <br>    <br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    pre = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<span class="hljs-comment"># 0不看 因为cnt初始值为1 从1开始</span><br>        <span class="hljs-keyword">if</span> nums[i] - pre &gt; m:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            cnt += <span class="hljs-number">1</span><br>    pre = nums[i]<br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br>    <br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="5151-程序调用-AcWing题库"><a href="#5151-程序调用-AcWing题库" class="headerlink" title="5151. 程序调用 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5154/">5151. 程序调用 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 通过索引找值 再通过值找索引  并且实现交换 主要是两个数组 一个是原数组 一个是pos数组 注意每次交换的时候两个数组都要交换 知道值a pos[a]即为索引 那a的前一个数就是pos[a] - 1 然后交换</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m, k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; s[i];<br>f[s[i]] = i;<br>w[i] = (i - <span class="hljs-number">1</span>) / k + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>ret += w[f[x]];<br><br><span class="hljs-keyword">if</span> (f[x] == <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br><br><span class="hljs-built_in">swap</span>(s[f[x]], s[f[x] - <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">swap</span>(f[s[f[x]]], f[s[f[x] - <span class="hljs-number">1</span>]]);<br>&#125;<br>cout &lt;&lt; ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="213-打家劫舍-II-力扣（LeetCode）"><a href="#213-打家劫舍-II-力扣（LeetCode）" class="headerlink" title="213. 打家劫舍 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打家劫舍1是一个动态规划问题 用f[k]来表示 前k间房子最多能偷多少钱 当k=n的时候就是答案 状态转移方程为f[i] = max(f[i -  1], f[i - 2] + nums[i]) 选i-1或者选i-2 + nums[i]  最后 如下的写法是优化空间复杂度的写法 因为每次仅需要前两个数和当前这个数 所以可以交替使用</span><br><span class="hljs-comment"># 打家劫舍2在1的基础上把首尾相连成环 这就导致首尾选不选的问题 这样的环的问题其实可以先排除掉环的影响再来做 即分为两类 首部选或不选（必定可且仅可分为两类）选首部的时候 尾部不能选（第二个也不能选） 那就是[2:-1] 不选首部的时候 就是[1:]然后看看哪个更大（有点类似之前实训课做过的枚举）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob1</span>(<span class="hljs-params">self, nums:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>)-&gt;<span class="hljs-built_in">int</span>:<br>        f0 = f1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            f0, f1 = f1, <span class="hljs-built_in">max</span>(f0 + x, f1)<br>        <br>        <span class="hljs-keyword">return</span> f1<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>] + self.rob1(nums[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]), self.rob1(nums[<span class="hljs-number">1</span>:]))<br>        <br></code></pre></td></tr></table></figure><h1 id="337-打家劫舍-III-力扣（LeetCode）"><a href="#337-打家劫舍-III-力扣（LeetCode）" class="headerlink" title="337. 打家劫舍 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iii/discussion/">337. 打家劫舍 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 树形DP 还是一样分析 根节点选或者不选（注意根节点不选 下一个结点也不一定要选）求出 左子树不选根的最大值和左子树选根的最大值 和 右子树不选根的最大值和右子树选根的最大值 如果选根 那么总共的最大值就是根+左不选根+右不选根 如果不选根 那就是左子树最大（选根和不选根 的最大）和右子树最大 相加</span><br><span class="hljs-comment"># 注意先想好dfs是做什么的  从root开始 返回选root的最大值 和不选root的最大值</span><br><br><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>           l_rob, l_not_rob = dfs(root.left)<br>            r_rob, r_not_rob = dfs(root.right)<br>            rob = root.val + l_not_rob + r_not_rob<br>            not_rob = <span class="hljs-built_in">max</span>(l_rob, l_not_rob) + <span class="hljs-built_in">max</span>(r_rob, r_not_rob)<br>            <span class="hljs-keyword">return</span> rob, not_rob<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(root))<br></code></pre></td></tr></table></figure><h1 id="2560-打家劫舍-IV-力扣（LeetCode）"><a href="#2560-打家劫舍-IV-力扣（LeetCode）" class="headerlink" title="2560. 打家劫舍 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iv/solutions/2093952/er-fen-da-an-dp-by-endlesscheng-m558/">2560. 打家劫舍 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分答案 最小化能够抢到的最大值 类似的表述就是二分答案的套路</span><br><span class="hljs-comment"># 二分偷取的钱数（得到最小值）  当偷盗的房子数满足k的时候 就可以成为一个答案  本解还有贪心 只要遇到可偷的就立即偷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        minn = <span class="hljs-built_in">min</span>(nums)<br>        maxn = <span class="hljs-built_in">max</span>(nums)<br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> minn &lt;= maxn:<br>            mid = (maxn + minn) // <span class="hljs-number">2</span><br>            cnt = <span class="hljs-number">0</span><br>            vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis <span class="hljs-keyword">and</span> num &lt;= mid:<br>                    cnt += <span class="hljs-number">1</span><br>                    vis = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> cnt &lt; k:<br>                <br>                minn = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res = mid<br>                maxn = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>    <br><span class="hljs-comment"># 也可以用二分+动态规划 状态表示为从0~i可偷的房间数为f[i] 状态计算为f[i] = max(f[i - 1], f[i - 1] + 1) </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">mx: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            f0 = f1 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &lt;= mx:<br>                   f0, f1 = f1, <span class="hljs-built_in">max</span>(f1, f0 + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                    f0 = f1<br>           <span class="hljs-keyword">return</span>  f1<br>       <span class="hljs-keyword">return</span> bisect_left(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(nums)), k, key=solve)<br></code></pre></td></tr></table></figure><h1 id="2603-收集树中金币-力扣（LeetCode）"><a href="#2603-收集树中金币-力扣（LeetCode）" class="headerlink" title="2603. 收集树中金币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collectTheCoins</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(coins)<br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        deg = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">len</span>, graph))<br>        q = deque()<br>        res = n - <span class="hljs-number">1</span> <span class="hljs-comment"># 总边数</span><br>        <span class="hljs-comment"># 先把没有金币的叶子节点存入数组（相当于拓扑排序的放入入度为0的点</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">0</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 删除所有没有金币的叶子节点</span><br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            res -= <span class="hljs-number">1</span> <span class="hljs-comment"># 每次循环都会删掉一条边</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> coins[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br><br>        <span class="hljs-comment"># 删除最下面两层结点（叶子结点和叶子节点的父节点）（此时的叶子节点是含金币的因为不含的已经删除）</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">1</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 这一层的所有含金币的叶子都被删除了 那么这些线就不用走了 删除的总数就是len(q)      </span><br>        res -= <span class="hljs-built_in">len</span>(q)<br><br>        <span class="hljs-comment"># 接下来删除叶子节点的父节点（叶子在上面已经删除）</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q:<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span>:<br>                    res -= <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, res * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="1993-树上的操作-力扣（LeetCode）"><a href="#1993-树上的操作-力扣（LeetCode）" class="headerlink" title="1993. 树上的操作 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/operations-on-tree/?envType=daily-question&envId=2023-09-23">1993. 树上的操作 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockingTree</span>:<br><span class="hljs-comment"># 初始化需要有父节点和每个父节点的子节点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        n = <span class="hljs-built_in">len</span>(parent)<br>        self.parent = parent<br>        self.lockNodeUser = [-<span class="hljs-number">1</span>] * n<br>        self.children = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <br>        <span class="hljs-keyword">for</span> node, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(parent):<br>            <span class="hljs-keyword">if</span> p != -<span class="hljs-number">1</span>:<br>                self.children[p].append(node)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == -<span class="hljs-number">1</span>:<br>            self.lockNodeUser[num] = user<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == user:<br>            self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 难点主要是更新 如果该结点没有上锁 并且祖先没有上锁 并且孩子有上锁（同时解锁所有孩子） </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] == -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.haslockedansester(num) <span class="hljs-keyword">and</span> self.checkandlockdescendant(num)<br>        <span class="hljs-keyword">if</span> res:<br>            self.lockNodeUser[num] = user<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-comment"># 由父节点不断向上 直到根节点 如果有上锁的 就直接返回 否则就继续向上</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">haslockedansester</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.parent[num]<br>        <span class="hljs-keyword">while</span> num != -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.lockNodeUser[num] != -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                num = self.parent[num]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 如果找到了一个上锁的子节 就直接解锁  因为只要有上锁 就表示满足要求 需要解锁 而如果都没有上锁 那解锁操作也不会影响原来的结点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkandlockdescendant</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] != -<span class="hljs-number">1</span><br>        self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.children[num]:<br>            res |= self.checkandlockdescendant(child)<br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-comment"># Your LockingTree object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LockingTree(parent)</span><br><span class="hljs-comment"># param_1 = obj.lock(num,user)</span><br><span class="hljs-comment"># param_2 = obj.unlock(num,user)</span><br><span class="hljs-comment"># param_3 = obj.upgrade(num,user)</span><br></code></pre></td></tr></table></figure><h1 id="146-LRU-缓存-力扣（LeetCode）"><a href="#146-LRU-缓存-力扣（LeetCode）" class="headerlink" title="146. LRU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=daily-question&envId=2023-09-24">146. LRU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>, value=<span class="hljs-number">0</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        self.prev = <span class="hljs-literal">None</span><br>        self.key = key<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br>    <span class="hljs-comment"># 因为需要O(1) 的存取 所以使用双向链表加字典</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.head = Node()<br>        self.head.prev = self.head<br>        self.head.<span class="hljs-built_in">next</span> = self.head<br>        self.<span class="hljs-built_in">map</span> = <span class="hljs-built_in">dict</span>()<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 插入 如果已经在的话就修改 如果不在的话首先 在map中记录 如何插入链表头 如果大于capacity的话 就删除链表尾(因为一开始把每次访问的都放在头部了（LRU的特性）所以删除的时候就可以直接删除尾部)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span><br>        <br>        self.<span class="hljs-built_in">map</span>[key] = node = Node(key, value)<br>        self.push_front(node)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.<span class="hljs-built_in">map</span>) &gt; self.capacity:<br>            back_node = self.head.prev<br>            <span class="hljs-keyword">del</span> self.<span class="hljs-built_in">map</span>[back_node.key]<br>            self.remove(back_node)<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev = self.head<br>        x.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        self.head.<span class="hljs-built_in">next</span>.prev = x<br>        self.head.<span class="hljs-built_in">next</span> = x<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-comment"># 查找 如果key不在map的话 return None 否则把他放到链表头</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[Node]:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">map</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.<span class="hljs-built_in">map</span>[key]<br>        self.remove(node)<br>        self.push_front(node)<br>        <span class="hljs-keyword">return</span> node<br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="460-LFU-缓存-力扣（LeetCode）"><a href="#460-LFU-缓存-力扣（LeetCode）" class="headerlink" title="460. LFU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lfu-cache/?envType=daily-question&envId=2023-09-25">460. LFU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-comment"># 结点的定义 双向链表的结点加上字典的key和访问次数cnt</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>,value=<span class="hljs-number">0</span>,<span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>,prev=<span class="hljs-literal">None</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        self.prev = prev<br>        self.cnt = <span class="hljs-number">1</span><br>        self.key = key<br><br><span class="hljs-comment"># 需要建一个次数表 把访问次数相同的放在一起 用字典实现 key为访问次数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.key_to_node = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_node</span>()-&gt;Node:<br>            head = Node()<br>            head.<span class="hljs-built_in">next</span> = head<br>            head.prev = head<br>            <span class="hljs-keyword">return</span> head<br>        self.freq_to_head = defaultdict(new_node)<br>    <br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 当这本书已经存在的时候 修改值 否则要放入（访问一次）中（注意先判断是否已满）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-comment"># 如果已满就拿出访问min_freq次的最下面的书（最不常用）</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.key_to_node) == self.capacity:<br>            phead = self.freq_to_head[self.min_freq]<br>            back_node = phead.prev <span class="hljs-comment"># 最不常用的</span><br>            <span class="hljs-keyword">del</span> self.key_to_node[back_node.key]  <span class="hljs-comment"># 从字典删除</span><br>            self.remove(back_node) <span class="hljs-comment"># 从链表中删除</span><br>            <span class="hljs-comment"># 如果删除的是头结点 那就直接把整个链表删除了</span><br>            <span class="hljs-keyword">if</span> phead.prev == phead:<br>                <span class="hljs-keyword">del</span> self.freq_to_head[self.min_freq]<br>        <span class="hljs-comment"># 插入这本书</span><br>        self.key_to_node[key] = node = Node(key, value)<br>        <span class="hljs-comment"># 放到最上面</span><br>        self.push_front(self.freq_to_head[<span class="hljs-number">1</span>],node)<br>        <span class="hljs-comment"># 刚插入的访问次数必定为1</span><br>        self.min_freq = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, head:Node, x:Node</span>):<br>        x.prev = head<br>        x.<span class="hljs-built_in">next</span> = head.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x<br>        x.prev.<span class="hljs-built_in">next</span> = x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x:Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.key_to_node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.key_to_node[key]<span class="hljs-comment"># 找到这本书</span><br>        self.remove(node)<span class="hljs-comment"># 去掉</span><br>        phead = self.freq_to_head[node.cnt]<br>        <span class="hljs-comment"># 如果这本书原来所在的链表只有他一个 那就删除链表</span><br>        <span class="hljs-keyword">if</span> phead.prev == phead:<br>            <span class="hljs-keyword">del</span> self.freq_to_head[node.cnt]<br>            <span class="hljs-comment"># 如果这本书恰好是访问一次的链表 那么删除之后就没有访问一次的了 至少也是访问两次的</span><br>            <span class="hljs-keyword">if</span> self.min_freq == node.cnt:<br>                self.min_freq += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 这本书访问次数加1</span><br>        node.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 插到最上面</span><br>        self.push_front(self.freq_to_head[node.cnt], node)<br>        <span class="hljs-keyword">return</span> node<br>        <br><br><span class="hljs-comment"># Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LFUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="587-安装栅栏-力扣（LeetCode）"><a href="#587-安装栅栏-力扣（LeetCode）" class="headerlink" title="587. 安装栅栏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/erect-the-fence/description/">587. 安装栅栏 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outerTrees</span>(<span class="hljs-params">self, trees: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-comment"># 求扫过的面积 如果&lt;0 说明需要更新</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">cross</span>(<span class="hljs-params">p: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], q: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], r: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">return</span> (q[<span class="hljs-number">0</span>] - p[<span class="hljs-number">0</span>]) * (r[<span class="hljs-number">1</span>] - q[<span class="hljs-number">1</span>]) - (q[<span class="hljs-number">1</span>] - p[<span class="hljs-number">1</span>]) * (r[<span class="hljs-number">0</span>] - q[<span class="hljs-number">0</span>])<br>        <br>        n = <span class="hljs-built_in">len</span>(trees)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> trees<br><br>        trees.sort()<br><br>        hull = [<span class="hljs-number">0</span>]<br>        used = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-comment"># 求凸包下半部分</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                used[hull.pop()] = <span class="hljs-literal">False</span><br>            used[i] = <span class="hljs-literal">True</span><br>            hull.append(i)<br>        <span class="hljs-comment"># 求凸包的上半部分</span><br>        m = <span class="hljs-built_in">len</span>(hull)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[i]:<br>                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; m <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                    used[hull.pop()] = <span class="hljs-literal">False</span><br>                used[i] = <span class="hljs-literal">True</span><br>                hull.append(i)<br>        <span class="hljs-comment"># hull[0] 是起点 同时参加上半部分的检测 所以要删掉</span><br>        hull.pop()<br>        <span class="hljs-keyword">return</span> [trees[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hull]<br></code></pre></td></tr></table></figure><h1 id="2251-花期内花的数目-力扣（LeetCode）"><a href="#2251-花期内花的数目-力扣（LeetCode）" class="headerlink" title="2251. 花期内花的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solutions/1445000/chai-fen-pythonjavacgo-by-endlesscheng-wz35/?envType=daily-question&envId=2023-09-28">2251. 花期内花的数目 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 差分前缀和 不需要每次把每个区间全部加上 这样复杂度过高 而是只需要在区间开头处+1 在区间结尾处-1 然后排序保证访问的时候是遍历的顺序 计算前缀和  如第一个人第二分钟来 那就算出第二分钟有几朵花 就是第二分钟的前缀和 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        diff = Counter()<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> flowers:<br>            diff[s] += <span class="hljs-number">1</span><br>            diff[e + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br><br>        time = <span class="hljs-built_in">sorted</span>(diff.keys())<br>        s = j = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> p, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(people, <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(people)))):<br>            <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(time) <span class="hljs-keyword">and</span> time[j] &lt;= p:<br>                s += diff[time[j]]<br>                j += <span class="hljs-number">1</span><br>            people[i] = s<br><br>        <span class="hljs-keyword">return</span> people<br>    <br><span class="hljs-comment"># 或者更简单的 直接计算第i分钟的花的数量  用第i分钟开花的数量减去第j分钟开花的数量 对开花时间和结束时间排序获得start和end数组 通过二分寻找开花数和凋谢数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        start = <span class="hljs-built_in">sorted</span>(s <span class="hljs-keyword">for</span> s, _ <span class="hljs-keyword">in</span> flowers)<br>        end = <span class="hljs-built_in">sorted</span>(e <span class="hljs-keyword">for</span> _, e <span class="hljs-keyword">in</span> flowers)<br>        <span class="hljs-keyword">return</span> [bisect_right(start, p) - bisect_left(end, p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> people]<br>    <br></code></pre></td></tr></table></figure><h1 id="2731-移动机器人-力扣（LeetCode）"><a href="#2731-移动机器人-力扣（LeetCode）" class="headerlink" title="2731. 移动机器人 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/movement-of-robots/">2731. 移动机器人 - 力扣（LeetCode）</a></h1><p>发现 最后只需要计算机器人的间隔 左右相碰之后转向 其实也就可以视为两个之间互换了 之间的 距离不会受到影响 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">比如<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span>R <span class="hljs-selector-tag">b</span> <span class="hljs-number">2</span>L <span class="hljs-number">3s</span> <br><span class="hljs-number">1s</span> 时在<span class="hljs-number">1</span> 处相碰   转向 <span class="hljs-selector-tag">a</span>向左 <span class="hljs-selector-tag">b</span>向右<br>然后<span class="hljs-number">3s</span>后  <span class="hljs-selector-tag">a</span>在-<span class="hljs-number">1</span> <span class="hljs-selector-tag">b</span>在<span class="hljs-number">3</span><br>其实也就相当于  <span class="hljs-selector-tag">a</span>直接走<span class="hljs-number">3s</span>到<span class="hljs-number">3</span>  <span class="hljs-selector-tag">b</span>直接走<span class="hljs-number">3s</span>到-<span class="hljs-number">1</span>  距离不变  机器人间不需要区分<br></code></pre></td></tr></table></figure><p>然后计算距离  两两之间的差可以O(n)计算！！但是注意 必须有序</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1 3 4 8 9 之间的差为<br>3<span class="hljs-string">-1</span> + 4<span class="hljs-string">-1</span> + 8<span class="hljs-string">-1</span> + 9<span class="hljs-string">-1</span><br>      4<span class="hljs-string">-3</span> + 8<span class="hljs-string">-3</span> + 9<span class="hljs-string">-3</span> <br>            8<span class="hljs-string">-4</span> + 9<span class="hljs-string">-4</span><br>                  9<span class="hljs-string">-8</span><br>因此每次算一个即可  ans + i * nums[i] 表示排i的数共被加了几次 3 1次 4 两次 8 三次 9 四次<br>再减去s  s表示每次减去的数  第一次减1  第二次减4（1 + 3） 第三次减8 （1 + 3 + 4） 第四次减16（1 + 3 + 4 + 8）<br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumDistance</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], s: <span class="hljs-built_in">str</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            f = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            nums[i] += f * d<br>        nums.sort()<br><br>        ans = <span class="hljs-number">0</span><br>        s = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ans += i * nums[i] - s<br>            s += nums[i]<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="2512-奖励最顶尖的-K-名学生-力扣（LeetCode）"><a href="#2512-奖励最顶尖的-K-名学生-力扣（LeetCode）" class="headerlink" title="2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reward-top-k-students/?envType=daily-question&envId=2023-10-11">2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）</a></h1><p>不需要用结构体也可以 用zip来直接sort</p><p>用split分割单词</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topStudents</span>(<span class="hljs-params">self, positive_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], negative_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], report: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], student_id: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        score = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> positive_feedback:<br>            score[w] = <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> negative_feedback:<br>            score[w] = -<span class="hljs-number">1</span><br>        a = <span class="hljs-built_in">sorted</span>((-<span class="hljs-built_in">sum</span>(score[w] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> r.split()), i) <span class="hljs-keyword">for</span> r, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(report, student_id))<br><br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> _, i <span class="hljs-keyword">in</span> a[:k]]<br></code></pre></td></tr></table></figure><h1 id="1488-避免洪水泛滥-力扣（LeetCode）"><a href="#1488-避免洪水泛滥-力扣（LeetCode）" class="headerlink" title="1488. 避免洪水泛滥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/avoid-flood-in-the-city/">1488. 避免洪水泛滥 - 力扣（LeetCode）</a></h1><p>不是每次晴天就去寻找抽哪个  而是到了后面 发现他要发洪水之后 就去前面找他下雨之后的第一个晴天 把他的水抽干 如果没找到 就直接返回空数组</p><p>注意用bisect_left寻找该湖泊下雨后第一个晴天</p><p>用pop删除这个晴天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avoidFlood</span>(<span class="hljs-params">self, rains: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(rains)<br>        ans = [<span class="hljs-number">1</span>] * n<br>        sun_day = SortedList()<br>        full = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> rains[i] == <span class="hljs-number">0</span>:<br>                sun_day.add(i)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> rains[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> full:<br>                    full[rains[i]] = i<br>                <span class="hljs-keyword">else</span>:<br>                    j = sun_day.bisect_left(full[rains[i]])<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-built_in">len</span>(sun_day):<br>                        <span class="hljs-keyword">return</span> []<br>                    ans[sun_day.pop(j)] = rains[i]<br>                    full[rains[i]] = i<br>                ans[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="1726-同积元组-力扣（LeetCode）"><a href="#1726-同积元组-力扣（LeetCode）" class="headerlink" title="1726. 同积元组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组 - 力扣（LeetCode）</a></h1><p>不需要三重循环来找 a * b &#x2F;&#x2F; c 在字典里面的</p><p>而是计数  记录下同一个积的两个数 的组合有多少种  然后用a * (a - 1)  计算种数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mp = defaultdict(<span class="hljs-built_in">int</span>)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                mp[nums[i] * nums[j]] += <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(mp)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> mp.values():<br>            ans += x * (x - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="2316-统计无向图中无法互相到达点对数-力扣（LeetCode）"><a href="#2316-统计无向图中无法互相到达点对数-力扣（LeetCode）" class="headerlink" title="2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/">2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）</a></h1><p>主要是最后计算乘法超时了 乘法不需要再额外循环来计算 可以直接在 BFS循环里面算出前缀和  然后相乘  求得两两相乘的和</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countPairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">i</span>):<br>            q.append(i)<br>            s = <span class="hljs-number">1</span><br>            vis[i] = <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">while</span> q:<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[y]:<br>                        vis[y] = <span class="hljs-number">1</span><br>                        s += <span class="hljs-number">1</span><br>                        q.append(y)<br>            <span class="hljs-keyword">return</span> s<br>            <br>                    <br><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> (a, b) <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        vis = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        total = ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                size = bfs(i)<br>                ret += size * total<br>                total += size<br>        <span class="hljs-keyword">return</span> ret<br><br>        <br></code></pre></td></tr></table></figure><h1 id="1402-做菜顺序-力扣（LeetCode）"><a href="#1402-做菜顺序-力扣（LeetCode）" class="headerlink" title="1402. 做菜顺序 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reducing-dishes/description/">1402. 做菜顺序 - 力扣（LeetCode）</a></h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>每次有选和不选这道菜两种  用dp[i] [j] 表示前i道菜种选了j道菜  达到的最大值</p><p>当i &#x3D;&#x3D; j的时候必须选第i道菜</p><p>其他时候 就比较不选这道菜 dp[i - 1] [j]  和选这道菜dp[i -1 ] [j -1 ] + sa[i - 1] * j   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> dp[<span class="hljs-number">550</span>][<span class="hljs-number">550</span>];<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>public:<br>    <span class="hljs-built_in">int</span> maxSatisfaction(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; satisfaction) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">550</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">550</span>; j++)<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> n = satisfaction.size();<br>        sort(satisfaction.begin(), satisfaction.end());<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = satisfaction[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(i==j) <br>                        dp[i][j]= dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j);<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[n][i]);<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><em>s</em>1+2<em>s</em>0&gt;<em>s</em>0即<em>s</em>1+<em>s</em>0&gt;0</p><p><em>s</em>2+2<em>s</em>1+3<em>s</em>0&gt;<em>s</em>1+2<em>s</em>0即<em>s</em>2+<em>s</em>1+<em>s</em>0&gt;0</p><p>因此只需要反向遍历  找到前面加起来大于0的部分 的和就是最大的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">sa.sort(key=<span class="hljs-keyword">lambda</span> x:-x)<br>        s = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> sa:<br>            <span class="hljs-keyword">if</span> s + c &gt; <span class="hljs-number">0</span>:<br>                s += c<br>                ret += s<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA</title>
    <link href="/2023/08/22/LCA/"/>
    <url>/2023/08/22/LCA/</url>
    
    <content type="html"><![CDATA[<p>·最近公共祖先</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python">root = <span class="hljs-number">1</span><br>num = <span class="hljs-number">0</span><br>dep = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000010</span><br>f = [[<span class="hljs-number">0</span>] * <span class="hljs-number">21</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br>head = [-<span class="hljs-number">1</span>] * <span class="hljs-number">10000010</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, to, <span class="hljs-built_in">next</span></span>):<br>self.to = to<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addedge</span>(<span class="hljs-params">from_,to</span>):<br><span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    e[num] = Edge(to, head[from_])<br>    head[from_] = num<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">v, father</span>):<br>dep[v] = dep[father] + <span class="hljs-number">1</span><br>    f[v][<span class="hljs-number">0</span>] = father<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):<br>        f[v][i] = f[f[v][i-<span class="hljs-number">1</span>]][i-<span class="hljs-number">1</span>]<br>        <br>    i = head[v]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        p1 = e[i].to<br>        <span class="hljs-keyword">if</span> p1 == father:<br>            i = e[i].<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        dfs(p1,v)<br>        i = e[i].<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-keyword">if</span> dep[x] &lt; dep[y]:<br>        x, y = y, x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dep[f[x][i]] &gt;= dep[y]:<br>            x = f[x][i]<br>         <span class="hljs-keyword">if</span> x == y:<br><span class="hljs-keyword">return</span> x<br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> f[x][i] != f[y][i]:<br>            x = f[x][i]<br>            y = f[y][i]<br>            <br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]<br><br><br>n, m, root = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>e = [Edge(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    addedge(u, v)<br>    addedge(v, u)<br><br><span class="hljs-comment"># 建立 LCA 预处理</span><br>dfs(root, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 查询 LCA</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    result = lca(x, y)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[x] = father;<br>de[x] = de[father] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i; i = edge[i].next)<br>&#123;<br><span class="hljs-keyword">if</span> (edge[i].to != father)<br>&#123;<br><span class="hljs-built_in">dfs</span>(edge[i].to, x);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (x != y)<br>&#123;<br><span class="hljs-keyword">if</span> (de[x] &gt;= de[y])<br>&#123;<br>x = fa[x];<br>&#125;<br><span class="hljs-keyword">else</span><br>y = fa[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lca</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论相关算法</title>
    <link href="/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>单源点最短路，不可判负权和环</p><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>cnt = <span class="hljs-number">0</span><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>ans = [INF] * (n + <span class="hljs-number">1</span>)<br>vis = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>edge = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>edge[i] = INF<br><br><span class="hljs-comment"># 初始化到s点的距离为0</span><br>ans[s] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 重边取最小</span><br>    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">in</span> edge:<br>edge[a][b] = <span class="hljs-built_in">min</span>(edge[a].get(b, INF), c)<br>    <span class="hljs-keyword">else</span>:<br>        edge[a] = &#123;b:c&#125;<br>pos = s<br><br><span class="hljs-comment"># pos 未遍历时</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vis[pos]:<br>    minn = INF<br>    <span class="hljs-comment"># 标记</span><br>    vis[pos] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># pos 顶点在边上时</span><br>    <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> edge:<br>        <span class="hljs-comment"># 取pos顶点指向的顶点（设为终点（有向图））和权值</span><br>        <span class="hljs-keyword">for</span> to, wei <span class="hljs-keyword">in</span> edge[pos].items():<br><span class="hljs-comment"># 如果终点未访问并且终点的值大于pos+wei 那就更新终点值的最短路</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[to] <span class="hljs-keyword">and</span> ans[to] &gt; ans[pos] + wei:<br>                ans[to] = ans[pos] + wei<br>        <span class="hljs-comment"># 遍历所有未遍历的点  如果小于minn 就更新minn（最短路） 并且让pos = i（最短子路）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i] <span class="hljs-keyword">and</span> ans[i] &lt; minn:<br>                minn = ans[i]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-comment"># 邻接矩阵</span><br>graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    graph[u].append((v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br><span class="hljs-comment"># 距离 初始化为无穷  源点初始化为0</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><span class="hljs-comment"># 先放入源点 第一个参数d表示源点s到当前结点的最短路   第二个参数node表示当前节点编号</span><br>q = [(<span class="hljs-number">0</span>,s)]<br><span class="hljs-comment"># 队列不空的时候</span><br><span class="hljs-keyword">while</span> q:<br><span class="hljs-comment"># 取出源点和起点</span><br>    d, node = heapq.heappop(q)<br>    <span class="hljs-comment"># 当当前最短路小于源点到node的距离时 跳过</span><br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br><span class="hljs-keyword">continue</span><br>    <span class="hljs-comment"># 从图中取出node结点的终点和权值</span><br>    <span class="hljs-keyword">for</span> neighbor, wei <span class="hljs-keyword">in</span> graph[node]:<br><span class="hljs-keyword">if</span> dist[node] + wei &lt; dist[neighbor]:<br>dist[neighbor] = dist[node] + wei<br>             heapq.heappush(q,(dist[neighbor],neighbor))<br>                <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>edge = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 判重</span><br>    exist = <span class="hljs-literal">False</span><br>    i = head[u]<br>    <span class="hljs-keyword">while</span> i:<br>        <span class="hljs-keyword">if</span> edge[i][<span class="hljs-number">0</span>] == v:<br>            exist = <span class="hljs-literal">True</span><br>            edge[i] = (v, <span class="hljs-built_in">min</span>(edge[i][<span class="hljs-number">1</span>],w), edge[i][<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">break</span><br>        i = edge[i][<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:<br>        edge.append((v,w,head[u]))<br>        head[u] = <span class="hljs-built_in">len</span>(edge) - <span class="hljs-number">1</span><br><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>priority_queue = [(<span class="hljs-number">0</span>,s)]<br><br><span class="hljs-keyword">while</span> priority_queue:<br>    d,node = heapq.heappop(priority_queue)<br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br>        <span class="hljs-keyword">continue</span><br>    i = head[node]<br>    <span class="hljs-keyword">while</span> i:<br>        neighbor, weight, nextt = edge[i]<br>        <span class="hljs-keyword">if</span> dist[node] + weight &lt; dist[neighbor]:<br>            dist[neighbor] = dist[node] + weight<br>            heapq.heappush(priority_queue, (dist[neighbor],neighbor))<br>        i = nextt<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p>单源点最短路，可判负权和环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v, w</span>):<br>        self.v = v<br>        self.w = w<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br><br>graph = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> graph[u] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> graph[u].w &gt; w:<br>graph[u] = []<br>    graph[u].append(edge(v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>q = deque([s])<br><br><span class="hljs-comment"># 标记是否在队列中  以及计数 用来判断环</span><br>in_queue = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>in_queue[s] = <span class="hljs-literal">True</span><br>enqueue_count = [<span class="hljs-number">0</span>]  * (n + <span class="hljs-number">1</span>)<br>enqueue_count[s] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">while</span> q:<br>    <span class="hljs-comment"># 取出当前点 </span><br>    node = q.popleft()<br>    in_queue[node] = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 取当前点相连的所有边</span><br>    <span class="hljs-keyword">for</span> ed <span class="hljs-keyword">in</span> graph[node]:<br>        <span class="hljs-comment"># 取出终点和权值</span><br>        v, w = ed.v, ed.w<br>    <span class="hljs-keyword">if</span> dist[v] &gt;  dist[node] + w:<br>            dist[v] = dist[node] + w<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> in_queue[v]:<br>                q.append(v)<br>                in_queue[v] = <span class="hljs-literal">True</span><br>                enqueue_count[v] += <span class="hljs-number">1</span><br>                <br>                <span class="hljs-keyword">if</span> enqueue_count[v] &gt; n:<br>                    exit(<span class="hljs-number">0</span>)<br>                    <br></code></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>多源最短路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x3f3f3f3f</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>d = [[INF] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][i] = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], w)<br>    <span class="hljs-comment"># 同时要更新另一条边</span><br>    d[b][a] = <span class="hljs-built_in">min</span>(d[b][a], w)<br>    <br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k] + d[k][j])<br>            <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(d[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="Kahn"><a href="#Kahn" class="headerlink" title="Kahn"></a>Kahn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Kahn算法</span><br><span class="hljs-keyword">from</span> collection <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = []<br>din = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-comment"># 每次从队列取出 让他所有出边减一 当某点入度为0时加入队列  如果最后队列长n则有拓扑序 否则有环</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>(<span class="hljs-params">n</span>):<br>queue = deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> din[i] == <span class="hljs-number">0</span>:<br>queue.append(i)<br>    <span class="hljs-keyword">while</span> queue:<br>        x = queue.popleft()<br>        tp.append(x)<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>            din[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> din[y] == <span class="hljs-number">0</span>:<br>queue.append(y)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp) == n<br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    e[a].append(b)<br>    din[b] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> toposort(n):<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tp:<br><span class="hljs-built_in">print</span>(x,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = [<span class="hljs-number">0</span>] * N<br>c = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> tp<br>    c[x] = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>        <span class="hljs-keyword">if</span> c[y] &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> c[y]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(y):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    c[x] = <span class="hljs-number">1</span><br>    tp.append(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>():<br>    <span class="hljs-keyword">global</span> c, tp<br>    c = [<span class="hljs-number">0</span>] * N<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c[i]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    tp.reverse()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入为字典</span><br>activities = &#123;&#125;<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    name, duration, dependencies = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    activities[name] = &#123;<span class="hljs-string">&#x27;duration&#x27;</span>:duration, <span class="hljs-string">&#x27;dependencies&#x27;</span>:dependencies&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_early_late_times</span>(<span class="hljs-params">activities</span>):<br>    <span class="hljs-comment"># 初始化每个工作的最早开始时间和最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-comment"># 计算最早开始时间</span><br>    <span class="hljs-comment"># 遍历所有工作 如果依赖于前一项工作 就为前面所有工作的最早开始时间加上持续时间的最大值 如果没有依赖于其他工作则为0</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            max_dependency_end = <span class="hljs-built_in">max</span>([activities[dep][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[dep][<span class="hljs-string">&#x27;duration&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = max_dependency_end<br><br>    <span class="hljs-comment"># 计算最后完成的工作的最晚开始时间 为所有工作的最晚的（最早开始时间+持续时间）</span><br>    end_activity = <span class="hljs-built_in">max</span>(activities,key=<span class="hljs-keyword">lambda</span> activity: activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>])<br>    activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[end_activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>    <span class="hljs-comment"># 反向计算最晚开始时间</span><br>    <span class="hljs-comment"># 如果不依赖于其他工作 最晚开始时间为最后工作的最晚开始时间-持续时间  否则为最早的最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">list</span>(activities.key())):<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] - activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            min_dependency_start = <span class="hljs-built_in">min</span>([activities[dep][<span class="hljs-string">&#x27;LS&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = min_dependency_start<br><br><br><span class="hljs-comment"># 最早开始时间=最晚开始时间即为关键路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_critical_path</span>(<span class="hljs-params">activities</span>):<br>    critical_path = []<br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        <span class="hljs-keyword">if</span> activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] == activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>]:<br>            critical_path.append(activity)<br>    <span class="hljs-keyword">return</span> critical_path<br></code></pre></td></tr></table></figure><h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><p><a href="https://leetcode.cn/problems/critical-connections-in-a-network/solutions/?envType=study-plan-v2&envId=graph-theory">例题</a></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution:<br>    def criticalConnections(self, n: int, connections: List<span class="hljs-comment">[List<span class="hljs-comment">[int]</span>]</span>) -&gt; List<span class="hljs-comment">[List<span class="hljs-comment">[int]</span>]</span>:<br>        graph = defaultdict(list)<br>        for con in connections:<br>            graph<span class="hljs-comment">[con<span class="hljs-comment">[0]</span>]</span>.append(con<span class="hljs-comment">[1]</span>)<br>            graph<span class="hljs-comment">[con<span class="hljs-comment">[1]</span>]</span>.append(con<span class="hljs-comment">[0]</span>)<br><br>        <br>        idx = <span class="hljs-comment">[-1]</span> * n<br>        res = <span class="hljs-comment">[]</span><br><br>        def dfs(curnode, curid, parent):<br>            idx<span class="hljs-comment">[curnode]</span> = curid<br><br>            for nextnode in graph<span class="hljs-comment">[curnode]</span>:<br>                if nextnode == parent:<br>                    continue<br>                elif idx<span class="hljs-comment">[nextnode]</span> == -1:<br>                    idx<span class="hljs-comment">[curnode]</span> = min(dfs(nextnode,curid + 1, curnode),idx<span class="hljs-comment">[curnode]</span>)<br>                else:<br>                    idx<span class="hljs-comment">[curnode]</span> = min(idx<span class="hljs-comment">[curnode]</span>,idx<span class="hljs-comment">[nextnode]</span>)<br><br>            # 说明存在环<br>            if idx<span class="hljs-comment">[curnode]</span> == curid and curnode != 0:<br>                res.append((parent, curnode))<br>            # 记得返回idx<br>            return idx<span class="hljs-comment">[curnode]</span><br>        <br><br>        dfs(0,0,-1)<br>        return res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树题解</title>
    <link href="/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1827-USACO3-4-美国血统-American-Heritage"><a href="#P1827-USACO3-4-美国血统-American-Heritage" class="headerlink" title="[P1827 USACO3.4] 美国血统 American Heritage"></a>[P1827 <a href="https://www.luogu.com.cn/problem/P1827">USACO3.4] 美国血统 American Heritage</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 其实就是前中序转后序 递归 当前序为空的时候退出，否则取前序的第一个为根，再中序中找左边为左子树，右边为右子树。注意前序中，左边的前k个就是左子树的，后面就是右子树的。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(string pre, string inor)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">char</span> root = pre[<span class="hljs-number">0</span>];<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-type">int</span> k = inor.<span class="hljs-built_in">find</span>(root);<br>string leftinor = inor.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightinor = inor.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 注意这里</span><br>string leftpre = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightpre = pre.<span class="hljs-built_in">substr</span>(k);<br><br><span class="hljs-built_in">change</span>(leftpre, leftinor);<br><span class="hljs-built_in">change</span>(rightpre, rightinor);<br><br>cout &lt;&lt; root;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string pre, inor;<br>cin &gt;&gt; inor &gt;&gt; pre;<br><span class="hljs-built_in">change</span>(pre, inor);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="449-序列化和反序列化二叉搜索树-力扣（LeetCode）"><a href="#449-序列化和反序列化二叉搜索树-力扣（LeetCode）" class="headerlink" title="449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br>    <span class="hljs-comment"># 序列化比较简单 就是一个后序遍历 注意最后的return部分 &#x27; &#x27;.join(map(str, arr)) 首先是&#x27;&#x27;要有空格 然后是map的用法 把arr转str</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            postOrder(root.left)<br>            postOrder(root.right)<br>            arr.append(root.val)<br>        postOrder(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,arr))<br>        <br><span class="hljs-comment"># 对于二叉搜索树来说 每个点的位置确定 所以比反序列化普通二叉树简单</span><br>    <span class="hljs-comment"># 首先把data还原成arr 当到达叶子节点的时候（也就是当前点不能插入这个地方）返回None    从arr中取出一个数作为跟 然后取出一个数作为右孩子 取出一个数作为左孩子 （后序遍历 先右再左）然后返回根   注意 初始的时候不限范围  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, data.split()))<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">lower,upper</span>):<br>            <span class="hljs-keyword">if</span> arr == [] <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &lt; lower <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &gt; upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            val = arr.pop()<br>            root = TreeNode(val)<br>            root.right = construct(val, upper)<br>            root.left = construct(lower,val)<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> construct(-inf,inf)<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化-力扣（LeetCode）"><a href="#297-二叉树的序列化与反序列化-力扣（LeetCode）" class="headerlink" title="297. 二叉树的序列化与反序列化 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(root.val) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.left)) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.right)) <br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">dataList</span>):<br>            val = dataList.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> val == <span class="hljs-string">&#x27;None&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            root = TreeNode(<span class="hljs-built_in">int</span>(val))<br>            root.left = dfs(dataList)<br>            root.right = dfs(dataList)<br>            <span class="hljs-keyword">return</span> root<br>        dataList = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">return</span> dfs(dataList)<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树</title>
    <link href="/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><a href="https://www.luogu.com.cn/problem/P3369">平衡树</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, p, val;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> s[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> siz;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>cnt = siz = <span class="hljs-number">1</span>;<br>p = p1, v = v1;<br>&#125;<br>&#125;tree[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-comment">// 更新树的大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 旋转 旋转不仅使得x转到y处，x的其中一个儿子也要给y</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找到x的父节点y和y的父节点z，k判断x是否为y的右儿子 假设x为y的右儿子 k为1</span><br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = tree[y].s[<span class="hljs-number">1</span>] == x;<br><span class="hljs-comment">// 先转动使 y的右儿子处放上x的左儿子 然后让x的左儿子的父节点为y</span><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><span class="hljs-comment">// 然后使x的右儿子为y，y的父亲为x</span><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><span class="hljs-comment">// 如果z的右儿子为y 那么z的右儿子为x （x替代y） 然后x的父亲为z</span><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><span class="hljs-comment">//记得更新节点</span><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-comment">// splay 伸展结点，使x为k的儿子  k为0的时候使x为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br>        <span class="hljs-comment">// 当x的祖父结点不为k的时候 旋转</span><br><span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-comment">// y的左儿子为x 并且z的左儿子为y 也就是直线型 转动y（1^1=0） 折线型转动x</span><br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-comment">// 再转一次（双旋</span><br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br>    <span class="hljs-comment">// k为0的时候 让x为根</span><br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><span class="hljs-comment">// 查找v并让v为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 找前驱 先找到v 然后如果根的值小于v，直接返回x，因为比根大，不可能有前驱了（前驱是比）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br><span class="hljs-comment">// 根节点的左子树的最大结点就是前驱</span><br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>]) x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 找后继 同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br><br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 删除 并不是真的结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找前驱和后继</span><br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v);<br><span class="hljs-type">int</span> suc = <span class="hljs-built_in">get_suc</span>(v);<br><span class="hljs-comment">// 转动前驱到根，转动后继为前驱的儿子，就是逻辑上的删除了该结点（此时待删除结点为后继的左儿子）</span><br><span class="hljs-built_in">splay</span>(pre, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(suc, pre);<br>    <span class="hljs-comment">// 后继的左儿子设为del（即待删除的点）</span><br><span class="hljs-type">int</span> del = tree[suc].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[del].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">// 如果待删点不止一个，只删除一个并把他放回到根结点</span><br>tree[del].cnt--, <span class="hljs-built_in">splay</span>(del, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 后继的左儿子为0 即删除了待删除结点</span><br>tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">splay</span>(suc, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">return</span> tree[tree[root].s[<span class="hljs-number">0</span>]].siz;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[y].siz + tree[x].cnt &lt; k)<br>&#123;<br>k -= tree[y].siz + tree[x].cnt;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[y].siz &gt;= k)x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> tree[x].v;<br>&#125;<br><span class="hljs-comment">// 插入结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; tree[x].v != v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br>    <span class="hljs-comment">// 转动新插入的结点为根</span><br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意先插入哨兵</span><br><span class="hljs-built_in">insert</span>(-INF), <span class="hljs-built_in">insert</span>(INF);<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; p &gt;&gt; val;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>)<span class="hljs-built_in">insert</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">2</span>)<span class="hljs-built_in">del</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">3</span>)cout &lt;&lt; <span class="hljs-built_in">get_rank</span>(val) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">4</span>)cout &lt;&lt; <span class="hljs-built_in">get_val</span>(val + <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">5</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_pre</span>(val)].v &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">6</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_suc</span>(val)].v &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91rotate.png" alt="rotate"></p><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91splay.png" alt="splay"></p><h2 id="flag-写个python版的！"><a href="#flag-写个python版的！" class="headerlink" title="flag 写个python版的！"></a><del>flag</del> 写个python版的！</h2><h2 id="例题-营业额统计"><a href="#例题-营业额统计" class="headerlink" title="例题  营业额统计"></a>例题  <a href="https://www.luogu.com.cn/problem/P2234">营业额统计</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>, root;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>, N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> v, s[<span class="hljs-number">2</span>], cnt, siz, p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>v = v1, p = p1;<br>cnt = siz = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;tree[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = (tree[y].s[<span class="hljs-number">1</span>] == x);<br><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-keyword">if</span> (z != k)<br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; v != tree[x].v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>])x = tree[x].s[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span> (tree[root].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v), suc = <span class="hljs-built_in">get_suc</span>(v);<br><br><span class="hljs-type">int</span> a = tree[pre].v, b = tree[suc].v;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - v) &lt; <span class="hljs-built_in">fabs</span>(b - v) ? <span class="hljs-built_in">fabs</span>(a - v) : <span class="hljs-built_in">fabs</span>(b - v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">insert</span>(INF), <span class="hljs-built_in">insert</span>(-INF);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; x;<br><span class="hljs-built_in">insert</span>(x);<br><span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>ret += <span class="hljs-built_in">search</span>(x);<br><span class="hljs-keyword">else</span> ret += x;<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h2><h3 id="几个需要注意的地方"><a href="#几个需要注意的地方" class="headerlink" title="几个需要注意的地方"></a>几个需要注意的地方</h3><ul><li>Node的siz和cnt需要设置为0 而不是1  在申请结点之后设置为1</li><li>idx需要自增（C++转python的时候 由于++idx并不是放在单独的一句，写的时候容易漏掉</li><li>idx自增之后x &#x3D; idx即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.s = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-comment"># son</span><br>        self.p = <span class="hljs-number">0</span> <span class="hljs-comment"># parent</span><br>        self.v = key <span class="hljs-comment"># val</span><br>        self.cnt = <span class="hljs-number">0</span><br>        self.siz = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SplayTree</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.N = <span class="hljs-number">100010</span><br>        self.INF = <span class="hljs-number">0x7fffffff</span><br>        self.tree = [Node(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N)]<br>        self.root = <span class="hljs-number">0</span><br>        self.idx = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 更新树的大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pushup</span>(<span class="hljs-params">self, x</span>):<br>        self.tree[x].siz = self.tree[self.tree[x].s[<span class="hljs-number">0</span>]].siz + self.tree[self.tree[x].s[<span class="hljs-number">1</span>]].siz + self.tree[x].cnt<br><br>    <span class="hljs-string">&quot;&quot;&quot;旋转操作 </span><br><span class="hljs-string">    首先得到x的父节点y和y的父节点z，用k来表示左旋和右旋（如果x在y的左子树右旋，x在y的右子树左旋）</span><br><span class="hljs-string">    以右旋为例 k为0</span><br><span class="hljs-string">    首先让y的左子树放上x的右子树 同时x的右子树的父亲设置为y</span><br><span class="hljs-string">    然后让x的右子树放上y 同时y的父亲设为x</span><br><span class="hljs-string">    最后让z的右子树放上x 同时x的父亲设为z</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    更新x y结点树的大小</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, x</span>):<br>        y = self.tree[x].p<br>        z = self.tree[y].p<br>        k = self.tree[y].s[<span class="hljs-number">1</span>] == x<br><br>        self.tree[y].s[k] = self.tree[x].s[k ^ <span class="hljs-number">1</span>]<br>        self.tree[self.tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y<br><br>        self.tree[x].s[k ^ <span class="hljs-number">1</span>] = y<br>        self.tree[y].p = x<br><br>        self.tree[z].s[self.tree[z].s[<span class="hljs-number">1</span>] == y] = x<br>        self.tree[x].p = z<br><br>        self.pushup(y)<br>        self.pushup(x)<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    splay 使x为k的儿子 有三种情况 </span><br><span class="hljs-string">    k是根 做单旋  </span><br><span class="hljs-string">    k不是根 直线型 做双旋 </span><br><span class="hljs-string">    k不是根 折线形 做双旋</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    先不断向上找x的父节点 当不为k时继续循环：取出父节点y和祖先结点z 如果z不是x的祖先就旋转 </span><br><span class="hljs-string">    当为直线型的时候（用^判断）转x  折线形转y   最后还要再转一下x 双旋（y是根的时候只会转一次x）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    如果k为0 表示k为根节点 要设置x为根</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">splay</span>(<span class="hljs-params">self, x, k</span>):<br>        <span class="hljs-keyword">while</span> self.tree[x].p != k:<br>            y = self.tree[x].p<br>            z = self.tree[y].p<br>            <span class="hljs-keyword">if</span> z != k:<br>                <span class="hljs-keyword">if</span> (self.tree[y].s[<span class="hljs-number">0</span>] == x) ^ (self.tree[z].s[<span class="hljs-number">0</span>] == y):<br>                    self.rotate(x)<br>                <span class="hljs-keyword">else</span>:<br>                    self.rotate(y)<br>            self.rotate(x)<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            self.root = x<br><br>    <span class="hljs-comment"># 树的查找 找到之后要把x设为根（splay）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> self.tree[x].s[v &gt; self.tree[x].v] <span class="hljs-keyword">and</span> v != self.tree[x].v:<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        self.splay(x, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    找前驱 由于find是找到v且当v不存在时找到的是最接近v的值并将其设置为根</span><br><span class="hljs-string">    当该结点小于v的时候直接返回 否则返回他的左子树的最右边的值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pre</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &lt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">1</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_suc</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &gt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">0</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    删除结点，并非真的删除，而是让他访问不到</span><br><span class="hljs-string">    先取出v的前驱和后继结点 并splay</span><br><span class="hljs-string">    设删除结点为del_node 如果出现次数大于1 就减一并splay del_node 否则splay 后继结点</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, v</span>):<br>        pre = self.get_pre(v)<br>        suc = self.get_suc(v)<br>        self.splay(pre, <span class="hljs-number">0</span>)<br>        self.splay(suc, pre)<br>        del_node = self.tree[suc].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> self.tree[del_node].cnt &gt; <span class="hljs-number">1</span>:<br>            self.tree[del_node].cnt -= <span class="hljs-number">1</span><br>            self.splay(del_node, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            self.splay(suc, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># v的排位即v为根的时候v的左子树大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rank</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        <span class="hljs-keyword">return</span> self.tree[self.tree[self.root].s[<span class="hljs-number">0</span>]].siz<br><br>    <span class="hljs-comment"># k位的值 不断找到x的左子树 如果左子树的siz加x的cnt大于k 就往左子树走 否则就让k减去他们俩的和并往右子树走</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_val</span>(<span class="hljs-params">self, k</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            y = self.tree[x].s[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> self.tree[y].siz + self.tree[x].cnt &lt; k:<br>                k -= self.tree[y].siz + self.tree[x].cnt<br>                x = self.tree[x].s[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.tree[y].siz &gt;= k:<br>                    x = self.tree[x].s[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>        self.splay(x,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.tree[x].v<br><br>    <span class="hljs-comment"># 插入操作 先取出根节点 父节点为0 不断向下递归找到x的插入位置  找到之后 如果该结点已经存在 就让cnt+1 否则创建新节点（idx+1 p的儿子为x 初始化x</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> x <span class="hljs-keyword">and</span> self.tree[x].v != v:<br>            p = x<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        <span class="hljs-keyword">if</span> x:<br>            self.tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 注意 这里的idx要先++</span><br>            self.idx += <span class="hljs-number">1</span><br>            x = self.idx<br>            self.tree[p].s[v &gt; self.tree[p].v] = x<br>            self.tree[x].p = p<br>            self.tree[x].v = v<br>            self.tree[x].cnt = <span class="hljs-number">1</span><br>            self.tree[x].siz = <span class="hljs-number">1</span><br>        self.splay(x, <span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st = SplayTree()<br>    st.insert(-st.INF)<br>    st.insert(st.INF)<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        p, val = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:<br>            st.insert(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">2</span>:<br>            st.delete(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">print</span>(st.get_rank(val))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">print</span>(st.get_val(val + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_pre(val)].v)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_suc(val)].v)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二叉树</title>
    <link href="/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><a href="https://www.luogu.com.cn/problem/P5076">二叉搜索树</a></h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> cont = <span class="hljs-number">0</span>; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span><br>&#123;<br><span class="hljs-type">int</span> ls, rs, val, cnt, siz;<br>&#125;tree[<span class="hljs-number">1000010</span>];<br><br><span class="hljs-type">int</span> n,q,val;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz++;<span class="hljs-comment">// 首先，插入的这个结点的siz++</span><br><span class="hljs-comment">// 如果已经有这个结点，就cnt++，因为搜索树中不能有重复结点</span><br><span class="hljs-keyword">if</span> (val == tree[x].val)<br>&#123;<br>tree[x].cnt++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (val &lt; tree[x].val)<br>&#123;<br>        <span class="hljs-comment">// 到最左边</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">// 开辟新结点并赋值</span><br>cont++;<br>tree[cont].val = val;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[x].ls = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].ls, val);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>tree[x].rs = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].rs, val);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 找前驱</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryfr</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果小于当前结点</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt;= val)<br>&#123;<br>        <span class="hljs-comment">// 找到最左边了，直接返回ans</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//不然就继续找</span><br><span class="hljs-built_in">queryfr</span>(tree[x].ls, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &gt; val ? ans : tree[x].val;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">queryfr</span>(tree[x].rs, val, tree[x].val);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// 找后继</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryne</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (tree[x].val &lt;= val)<br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].rs, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &lt; ans ? tree[x].val : ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].ls, val, tree[x].val);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 找val的排位</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 没找到就返回0，当找到最后还没有找到的时候，就会走到ls或rs==0，赋值给x，就会从这里退出</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 找到了就返回，当前这个结点的左子树的长度</span><br><span class="hljs-keyword">if</span> (tree[x].val == val)<br><span class="hljs-keyword">return</span> tree[tree[x].ls].siz;<br>    <span class="hljs-comment">// 如果小于当前结点的值，往左</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].ls, val);<br>    <span class="hljs-comment">// 往右的时候要先减掉左子树和自身的值</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].rs, val) + tree[tree[x].ls].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 找排位为rk的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertrk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> rk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// rk索引越界</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> INF;<br><span class="hljs-comment">// 左子树大于rk，说明在左子树里面找</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz &gt;= rk)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].ls, rk);<br>    <span class="hljs-comment">// 左子树+cnt大于rk，说明就是当前的val</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz + tree[x].cnt &gt;= rk)<br><span class="hljs-keyword">return</span> tree[x].val;<br>    <span class="hljs-comment">// 否则在右子树，要先减掉左子树和cnt</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].rs, rk - tree[tree[x].ls].siz - tree[x].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; q &gt;&gt; val;<br><span class="hljs-keyword">switch</span> (q)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertval</span>(<span class="hljs-number">1</span>, val) + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertrk</span>(<span class="hljs-number">1</span>, val) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">queryfr</span>(<span class="hljs-number">1</span>, val, -INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout &lt;&lt; <span class="hljs-built_in">queryne</span>(<span class="hljs-number">1</span>, val, INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-comment">//特判根节点</span><br><span class="hljs-keyword">if</span> (cont == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, val);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="这个小伙居然还用python写了一遍"><a href="#这个小伙居然还用python写了一遍" class="headerlink" title="这个小伙居然还用python写了一遍"></a><del>这个小伙居然还用python写了一遍</del></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x7fffffff</span><br>cont = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,val=<span class="hljs-number">0</span>,siz=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ls=<span class="hljs-number">0</span>,rs=<span class="hljs-number">0</span></span>):<br>        self.val = val<br>        self.siz = siz<br>        self.cnt = cnt<br>        self.ls = ls<br>        self.rs = rs<br><br><br><span class="hljs-comment"># 神奇的方法</span><br>tree = [Node() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,v</span>):<br>    <span class="hljs-keyword">global</span> cont,tree<br>    tree[x].siz += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> tree[x].val == v:<br>        tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> tree[x].val &gt; v:<br>        <span class="hljs-keyword">if</span> tree[x].ls != <span class="hljs-number">0</span>:<br>            add(tree[x].ls,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].ls = cont<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs != <span class="hljs-number">0</span>:<br>            add(tree[x].rs,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].rs = cont<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryfr</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &gt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].ls,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &lt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].rs,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x],val,ans)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryne</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &lt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].rs,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &gt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-comment"># 这里有点多余</span><br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls, val,ans)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryrk</span>(<span class="hljs-params">x,rk</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> INF<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz &gt;= rk:<br>        <span class="hljs-keyword">return</span> queryrk(tree[x].ls,rk)<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz + tree[x].cnt &gt;= rk:<br>        <span class="hljs-keyword">return</span> tree[x].val<br>    <span class="hljs-keyword">return</span> queryrk(tree[x].rs,rk - tree[tree[x].ls].siz-tree[x].cnt)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryval</span>(<span class="hljs-params">x,val</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> val == tree[x].val:<br>        <span class="hljs-keyword">return</span> tree[tree[x].ls].siz<br>    <span class="hljs-keyword">if</span> val &lt; tree[x].val:<br>        <span class="hljs-keyword">return</span> queryval(tree[x].ls,val)<br>    <span class="hljs-keyword">return</span> queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt<br><br><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    q,v = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    <span class="hljs-keyword">if</span> q == <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">if</span> cont == <span class="hljs-number">0</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span><br>            tree[cont].val = v<br>        <span class="hljs-keyword">else</span>:<br>            add(<span class="hljs-number">1</span>,v)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(queryval(<span class="hljs-number">1</span>,v)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(queryrk(<span class="hljs-number">1</span>,v))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(queryfr(<span class="hljs-number">1</span>,v,-INF))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(queryne(<span class="hljs-number">1</span>,v,INF))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex学习</title>
    <link href="/2023/08/02/latex%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/latex%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li><p>首先\documentclass[UTF8]{ctexart}</p><p>….(宏包)</p><p>\begin{document}</p><p>……</p><p>\end{document}</p></li><li><p>行内要用$$括起来 行间要用$$$$括起来</p></li><li><p>公式对齐 不同的环境语法不同 eqnarray是&amp;&#x3D;&amp;；align是&amp;&#x3D;</p></li><li><p>分段函数  cases环境  使用&amp; 对齐  \\换行</p></li><li><p>矩阵 array begin后面加{ccc}表示格式  需要$$$$和自己加括号</p></li><li><p>要表示带省略号的矩阵 用pmatrix环境</p></li><li><p>表格 数字表格即矩阵加|，带汉字的要使用tabular环境。表格的横线为\hline</p></li><li><p>插图 \includegraphics[scale&#x3D;<em>] [width&#x3D;</em>][height&#x3D;*]{.png}</p><p>或使用\figure环境</p><p>\begin{figure}[H]</p><p> \centering</p><p> % Requires \usepackage{graphicx}</p><p> \includegraphics[width&#x3D;12pt]{.png}\</p><p> \caption{图1}</p><p>\end{figure}</p></li></ul><h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><ul><li>\textbf{}加粗</li><li>\textit{}斜体</li><li>underline 下划线</li></ul><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125; //正文<br><br><span class="hljs-keyword">\part</span>&#123;A&#125; // 该部分标题为A 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\chapter</span>&#123;B&#125; //该章节标题为B 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\section</span>&#123;C&#125; //该章节标题为C 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\subsection</span>&#123;D&#125; //创建子章节<br><br><span class="hljs-keyword">\subsubsection</span> //.<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125; //引入宏包<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;figure&#125;<br><span class="hljs-keyword">\centering</span> // 居中<br><span class="hljs-keyword">\includegraphics</span>[width=0.5<span class="hljs-keyword">\textwidth</span>]&#123;head&#125;<br><span class="hljs-keyword">\caption</span>&#123;...&#125; //图片标题<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>//无序列表环境为itemize<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\item</span> 列表项1<br><span class="hljs-keyword">\item</span> 列表项2<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>// 行内公式<br>AAAAA <span class="hljs-built_in">$</span>E = mc<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span><br>// 行间公式<br>// 使用equation环境<br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br>// 或者用<span class="hljs-keyword">\[</span> 和 <span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\[</span><br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="表-格"><a href="#表-格" class="headerlink" title="表 格"></a>表 格</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;table&#125;// 需要标题和居中的时候要把表格放在table环境中<br><br><span class="hljs-keyword">\center</span><br><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c c c&#125;  // c | c c代表表格共三列 每列内容都居中对齐 用l表示左对齐 r右 添加竖线代表竖边框 水平边框通过<span class="hljs-keyword">\hline</span>添加 每格之间用<span class="hljs-built_in">&amp;</span>隔开 每行之间用<span class="hljs-keyword">\\</span>隔开<br>// 把c改成p&#123;2cm&#125;自定义列宽<br><span class="hljs-keyword">\hline</span><br>单元格1 <span class="hljs-built_in">&amp;</span> 单元格2 <span class="hljs-built_in">&amp;</span> 单元格3 <span class="hljs-keyword">\\</span>      <br><span class="hljs-keyword">\hline</span> //双横线<br><span class="hljs-keyword">\hline</span><br>单元格4 <span class="hljs-built_in">&amp;</span> 单元格5 <span class="hljs-built_in">&amp;</span> 单元格6 <span class="hljs-keyword">\\</span><br>单元格7 <span class="hljs-built_in">&amp;</span> 单元格8 <span class="hljs-built_in">&amp;</span> 单元格9 <br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><br><span class="hljs-keyword">\caption</span>&#123;title&#125;<br><br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab学习</title>
    <link href="/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>部分表</li></ul><table><thead><tr><th><strong>help</strong></th><th>帮助查询</th></tr></thead><tbody><tr><td><strong>clc</strong></td><td>删除命令窗口的内容（已使用过的命令）</td></tr><tr><td><strong>clear</strong></td><td>删除内存中的变量（数据）</td></tr><tr><td><strong>clf</strong></td><td>删除图形窗口的内容</td></tr><tr><td><strong>who</strong></td><td>列出在MATLAB工作空间中已有的变量</td></tr><tr><td><strong>whos</strong></td><td>列出驻留变量的同时,还给出维数及性质</td></tr><tr><td><strong>home</strong></td><td>光标移到命令窗口的左上角</td></tr><tr><td><strong>↑</strong></td><td>调出刚才使用过的命令</td></tr><tr><td><strong>quit</strong></td><td>退出MATLAB</td></tr></tbody></table><table><thead><tr><th>r</th><th>红色</th><th>-</th><th>实线</th></tr></thead><tbody><tr><td>g</td><td>绿色</td><td>–</td><td>虚线</td></tr><tr><td>b</td><td>蓝色</td><td>:</td><td>点线</td></tr><tr><td>y</td><td>黄色</td><td>-.</td><td>点划线</td></tr><tr><td>m</td><td>洋红色</td><td>o</td><td>圆圈</td></tr><tr><td>c</td><td>青色</td><td>x</td><td>叉号</td></tr><tr><td>w</td><td>白色</td><td>+</td><td>加号</td></tr><tr><td>k</td><td>黑色</td><td>s</td><td>正方形</td></tr><tr><td>*</td><td>星号</td><td>d</td><td>菱形</td></tr><tr><td>v</td><td>向下三角</td><td>^</td><td>向上三角</td></tr><tr><td>.</td><td>点号</td><td>h</td><td>六角形</td></tr></tbody></table><ul><li><p>首先注意和数字运算的时候运算符要加点</p></li><li><p>axis([])设置坐标轴范围</p></li><li><p>grid on 显示网格线 title显示标题 xlabel标记x轴 legend添加图例</p></li></ul><h2 id="plot-x-y-’color-style-marker’-绘制图像"><a href="#plot-x-y-’color-style-marker’-绘制图像" class="headerlink" title="plot(x,y,’color-style-marker’)绘制图像"></a>plot(x,y,’color-style-marker’)绘制图像</h2><ul><li><p>选点：x &#x3D; linspace(0,1,100)  也可以使用x &#x3D; a : step : b</p><p>y1 &#x3D; linspace(0,1,100) 选择对应的点 plot(x,y,’r’) 需要保证是同维的</p><p>也可以使用解析式的方式，先确定x的范围，然后用x表示y即可，但是要注意表示的各个符号是否加点。</p><p>例：y &#x3D; -0,0234 * x + 1.2551 * x .^(2&#x2F;3)   y &#x3D; sin(x) </p></li><li><p>三维图像 plot3 用来绘制一组三维曲线  需要保证是同维的   </p><p> mesh 用来绘制三维曲面的网格线图 先选点 然后 [X,Y] &#x3D; meshgrid(x,y) Z &#x3D;  X.^2+Y.^2 最后mesh(X,Y,Z)\</p></li><li><p>如果想要画圆圈和连线那就是plot(x,a,’o’,x,a)  ‘bo’是蓝色圆圈</p><p> 前一个xa画圆圈（散点）后一个xa画直线</p></li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><p>solve 解线性方程组 使用前要定义变量 syms a b x …</p><p>S &#x3D; solve(方程，变量（默认x)  </p><p>[a,b] &#x3D; solve(90* a + 90^(2&#x2F;3)<em>b&#x3D;&#x3D;23.1,180</em>a+180^(2&#x2F;3)*b &#x3D;&#x3D; 35.8)</p></li></ul><h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><ul><li><p>for i &#x3D; n1:(step):n2</p><p>commands;</p><p>end</p></li><li><p>while …</p></li></ul><p>  commands;</p><p>  end</p><ul><li><p>if…</p><p>elseif…</p><p>else…</p><p>end</p></li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>function [x,y,z] &#x3D; f1(a,b)</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>csape(x,y,’compelete’,[-1,0])</p><p>complete代表通过给定数据点的完全样条函数 </p><p>[-1,0]表示一阶导数的边界</p>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表题解</title>
    <link href="/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><del>超，格式怎么这样了，下次再改</del></p><h1 id="妖梦拼木棒"><a href="#妖梦拼木棒" class="headerlink" title="妖梦拼木棒"></a><a href="https://www.luogu.com.cn/problem/P3799">妖梦拼木棒</a></h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>上道题中，妖梦斩了一地的木棒，现在她想要将木棒拼起来。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？</p><p>答案对 $10^9+7$ 取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$。</p><p>第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数代表答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $n \le 5 \times 10^3$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。</li></ul><p>一开始想错了，导致后面也被带偏。必须要两只一样长的木棒，剩下两个只需要和跟另外两个一样长就行了。并不需要相等长度，（想错，导致之后改错）其实也并不需要一开始的两只相等长度，比如7 7 2 +5这样。然后就是简单的组合数学</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">5001</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>nums[x]++;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">2</span>)<br>&#123;<br>a = nums[i] * (nums[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> == i &amp;&amp; nums[j] &gt;= <span class="hljs-number">2</span>)cnt += a * (nums[j] * (nums[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod) % mod;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> != i &amp;&amp; nums[j] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i - j] &gt;= <span class="hljs-number">1</span>)cnt += a * ((nums[j] * nums[i - j]) % mod) % mod;<br>&#125;<br>cnt %= mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; cnt % mod &lt;&lt; endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="kkksc03考前临时抱佛脚"><a href="#kkksc03考前临时抱佛脚" class="headerlink" title="kkksc03考前临时抱佛脚"></a><a href="https://www.luogu.com.cn/problem/P2392">kkksc03考前临时抱佛脚</a></h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">20<br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><p>本来是贪心+模拟。。但是有几个过不了，大概是情况没考虑全。btw别人想的都是把题目分成尽量平均的两部分啊。（模拟不是下意识就出来了吗，窝好菜</p><p>用dp求尽量平均的两部分，即01背包问题，分到左边和分到右边，状态表示为二维，集合为到j的时候的体积，状态计算为给左大脑和给右大脑，此处视左大脑为背包1，右大脑为0，放到让左边为1&#x2F;2总体积。每道题的时间既是价值，也是体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2000</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>)]<br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>            f[j][k] = f[j - <span class="hljs-number">1</span>][k]<br>            <span class="hljs-keyword">if</span> k &gt;= nums[j]:<br>                f[j][k] = <span class="hljs-built_in">max</span>(f[j][k],f[j - <span class="hljs-number">1</span>][k - nums[j]] + nums[j])<br>            t = <span class="hljs-built_in">max</span>(t,f[j][k])<br><br>    ans += <span class="hljs-built_in">max</span>(t, m-t)<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p>一维优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span>, nums[j]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[k] = <span class="hljs-built_in">max</span>(f[k],f[k - nums[j]] + nums[j])<br><br><br>    ans += m - f[m//<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>        f[i] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="COCI2008-2009-2-PERKET"><a href="#COCI2008-2009-2-PERKET" class="headerlink" title="[COCI2008-2009#2] PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">[COCI2008-2009#2] PERKET</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。</p><p>众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。</p><p>另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示可供选用的食材种类数。</p><p>接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示可能的总酸度和总苦度的最小绝对差。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>本题满分 $70$ 分。</li><li>题目译自 <a href="https://hsin.hr/coci/archive/2008_2009/">COCI2008-2009</a> <a href="https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf">CONTEST #2</a> PERKET，译者 @<a href="https://www.luogu.com.cn/user/115711">mnesia</a>。</li></ul><p>简单dfs 选或不选###的思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>minn = <span class="hljs-number">0x7fffffff</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u,sor,bit</span>):<br>    <span class="hljs-keyword">global</span> minn<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">if</span> sor == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> bit == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            minn = <span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">abs</span>(sor - bit))<br>            <span class="hljs-keyword">return</span><br><br>    dfs(u + <span class="hljs-number">1</span>,sor,bit)<br>    dfs(u + <span class="hljs-number">1</span>,sor * nums[u][<span class="hljs-number">0</span>], bit + nums[u][<span class="hljs-number">1</span>])<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>   nums[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><br>dfs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(minn)<br></code></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [NOIP2016 普及组 海港]([P2058 NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [NOIP2016 普及组 海港]([P2058 <a href="https://www.luogu.com.cn/problem/P2058">NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T3</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。</p><p>小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。</p><p>小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $&#x3D;86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。</p><p>形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400&lt;t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。</p><p>接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。</p><p>保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。</p><p>保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。</p><p>其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">86401 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">86402 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>3<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>【样例解释 1】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；</p><p>第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 &#x3D; 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；</p><p>第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1&#x3D;7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。</p><p>【样例解释 2】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。</p><p>第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2&#x3D;6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。</p><p>第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2&#x3D;4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。</p><p>第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1&#x3D;5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。</p><p>【数据范围】</p><ul><li>对于 $10%$ 的测试点，$n&#x3D;1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。</li><li>对于 $20%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。</li><li>对于 $40%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。</li><li>对于 $70%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。</li><li>对于 $100%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是python的语法 ship.num = lis[2:]把2和后面的全都赋到num里面，然后就是python的语法，双端队列deque的使用方法，支持[]访问，直接用shiparr[Ship()]*100000，会导致错误，应该是类似于地址出错（所有的数组里面都是同一个值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    time = <span class="hljs-number">0</span><br>    num = []<br>    numpass = <span class="hljs-number">0</span><br><br><br>q = deque()<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>peo = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000000</span><br>lis = []<br>shiparr = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>    ship = Ship()<br>    ship.time = lis[<span class="hljs-number">0</span>]<br>    ship.numpass = lis[<span class="hljs-number">1</span>]<br>    ship.num = lis[<span class="hljs-number">2</span>:]<br>    shiparr.append(ship)<br><br><br>country = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    ship = shiparr[j]<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> ship.time - q[<span class="hljs-number">0</span>].time &lt; <span class="hljs-number">86400</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q[<span class="hljs-number">0</span>].num:<br>            peo[x] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>                country -= <span class="hljs-number">1</span><br>        q.popleft()<br>        i += <span class="hljs-number">1</span><br>    q.append(ship)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ship.num:<br>        <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>            country += <span class="hljs-number">1</span><br>        peo[x] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(country)<br><br></code></pre></td></tr></table></figure><h1 id="括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [括号序列](P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [括号序列](<a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p><ol><li>空串是「平衡括号序列」</li><li>若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」</li><li>若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。</li></ol><p>例如，下面的字符串都是平衡括号序列：</p><p><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></p><p>而以下几个则不是：</p><p><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></p><p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：</p><ol><li>从左到右扫描整个字符串。</li><li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li></ol><p>配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 $s$。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([()<br></code></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">([)</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $s$ 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 主要是题目，2.的意思是从遇到第一个右括号开始向左寻找第一个未匹配的左括号（其实根本不需要栈）。只需要在找到的地方做个标记表示已匹配即可。最后，输出的时候未匹配的就直接输出同类的完整括号，匹配的就正常输出。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt;stleft;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">char</span> ch;<br>string str;<br>cin &gt;&gt; str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>ch = str[j];<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> || str[i] == <span class="hljs-string">&#x27;)&#x27;</span>))cout &lt;&lt; <span class="hljs-string">&quot;()&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;[&#x27;</span>||str[i] == <span class="hljs-string">&#x27;]&#x27;</span>)) cout &lt;&lt; <span class="hljs-string">&quot;[]&quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; str[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Our Game!</title>
    <link href="/2023/07/27/Our-Game/"/>
    <url>/2023/07/27/Our-Game/</url>
    
    <content type="html"><![CDATA[<h1 id="我们的游戏做完啦！"><a href="#我们的游戏做完啦！" class="headerlink" title="我们的游戏做完啦！"></a>我们的游戏做完啦！</h1><p>&emsp;好激动，四周的时间过的好快，好像昨天还在讨论游戏的原型设计。现在居然已经完成了所有的工作。感谢tllwtg和wegret的付出，<del>我们三个真强</del>（哈哈哈）。<br>希望zlgg和xyjj不要嫌我菜。</p><p><a href="https://github.com/tLLWtG/Capoo-Survival/releases">这里是我们的游戏</a>，点点star（可怜）</p><p>没错 就是开放世界冒险游戏（没有虚假宣传。。。开放、世界、冒险都有）</p><p>做游戏的过程还是很开心的（可能是给我的活太少了），感觉自己没做什么，还好通过我精密的计算，最后障碍物终于没有重叠了，不然就没脸见人了。<br>好怀念教室只剩下我们在讨论和实现，在群里商量分工，一件件地完成TODO。本来是很讨厌组队的，<br>但是这种组队的感觉真的好棒！跟某些课程全部都是摆子的组队感觉完全不一样哇）</p><p>第一次上去汇报手都在发抖捏，但是后面感觉还行，对！根本就没人会听，啊，你说我吗？我也不听别人讲😀（wow，居然能插入表情嘛）。一开始做ppt只会白底黑字，<br>后面加了模板，是好看一点wo。</p><p>啊!台风了，最后一次汇报没有了，本来还想拍个照片然后一起去恰个饭的，不知道下次还有没有机会，呜呜。</p><p>贴一些图片（才不是太久没写说说，写不出来东西了呢</p><p>靠 截图审美好差</p><p>部分代码截图和游戏使用图片</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog1-16907768245555.png" alt="部分代码截图和游戏使用图片"></p><p>汇报ppt</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog2-16907767706092.png" alt="汇报ppt"></p><p>还没写完，但是不想写了，嘿嘿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法</title>
    <link href="/2023/07/23/python%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/23/python%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python语法注意事项"><a href="#python语法注意事项" class="headerlink" title="python语法注意事项"></a>python语法注意事项</h1><p><del>啊，受不了了，写了几个题不是运错就是编错，还有一堆奇奇怪怪的报错，痛苦.jpg。</del><br>已经遇见未来不短的时间内会不断报错并且看不懂然后写在这里了，希望这篇可以早日停更。</p><ul><li><p>n &#x3D; int(input())</p></li><li><p>控制不住if后面加()，哭，剁手</p></li><li><p>xmuoj不支持类型注解，呜呜</p></li><li><p>没有while(n–)的操作了，用while会忘记–，死循环了，好蠢</p></li><li><p>range的范围</p></li><li><p>读入二维列表 (老是忘记lis的append，想半天)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lis = <span class="hljs-selector-attr">[]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    d = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(int,<span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>()))<br>    lis<span class="hljs-selector-class">.append</span>()<br></code></pre></td></tr></table></figure></li><li><p>浮点数确定精度输出 print(“%.1f” % n) 注意是双引号并且没有逗号</p></li><li><p>dx &#x3D; [1,0,-1,0] <del>这里是今晚最佳</del> 加了个list怎么找也找不出来，list dx[]-&gt;笑死</p></li><li><p>全排列 选哪个？ 标记选过的不再选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">sol,num,on_path</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sol) == <span class="hljs-built_in">len</span>(num):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(sol[i], <span class="hljs-string">&quot;&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> on_path[i] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                on_path[i] = <span class="hljs-number">1</span><br>                permute(sol+[num[i]],num,on_path)<br>                on_path[i] = <span class="hljs-number">0</span><br>                <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>sol = []<br>num = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)]<br>on_path = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>permute(sol,num,onpath]<br></code></pre></td></tr></table></figure></li><li><p>字典的使用方法  记得一定要先判断是否存在 <del>呜呜，明明之前才记过，写的时候又忘记了，泰蠢辣</del></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">st</span> = input()<br><br>d = dict()<br>for <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">st</span>:<br>    if <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> d:<br>        d[<span class="hljs-number">ch</span>] += <span class="hljs-number">1</span><br><span class="hljs-symbol">    else:</span><br>        d[<span class="hljs-number">ch</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>上面的题是用来求只出现一次的字符的 难过 在c++知道用count 在python就变蠢力</p></li><li><p>python线性筛 芜湖~</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">N</span> = <span class="hljs-number">100010</span><br><span class="hljs-attribute">st</span> =<span class="hljs-meta"> [False for _ in range(N)]</span><br><span class="hljs-attribute">prime</span> =<span class="hljs-meta"> [0 for _ in range(N)]</span><br><br><span class="hljs-attribute">def</span> get_prime(n):<br>    <span class="hljs-attribute">cnt</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">if</span> not st[i]:<br>            <span class="hljs-attribute">prime</span>[cnt] = i<br>            <span class="hljs-attribute">cnt</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> prime[j] &lt; n // i:<br>        <span class="hljs-attribute">st</span>[prime[j] * i] = True<br>        <span class="hljs-attribute">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">break</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>range是左开右闭</p></li><li><p>我超 在函数里面用全局变量的时候要加global </p></li><li><p>python归并</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = int(input(n))<br><span class="hljs-attribute">nums</span> = list(map(int,input()))<br><span class="hljs-attribute">temp</span> =<span class="hljs-meta"> [0 for _ in range(n)]</span><br><br><span class="hljs-attribute">merge_sort</span>(l, r):<br>    <span class="hljs-attribute">if</span> l &gt;= r:<br>        <span class="hljs-attribute">return</span> <br>    <span class="hljs-attribute">mid</span> = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-attribute">merge_sort</span>(l, mid)<br>    <span class="hljs-attribute">merge_sort</span>(mid + <span class="hljs-number">1</span>, r)<br>    <span class="hljs-attribute">i</span>, j, k = l, mid + <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-attribute">if</span> nums[i] &lt;= nums[j]:<br>            <span class="hljs-attribute">temp</span>[k] = nums[i]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">temp</span>[k] = nums[j]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid:<br>        <span class="hljs-attribute">temp</span>[k] = nums[i]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> j &lt;= r:<br>        <span class="hljs-attribute">temp</span>[k] = nums[j]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(l, r + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">nums</span>[i] = temp[j]<br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>        <br>        <br><span class="hljs-attribute">merge_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>)# n-<span class="hljs-number">1</span>!!<br></code></pre></td></tr></table></figure></li><li><p>python手动增加递归的层数<br>import sys<br>sys.setrecursionlimit(5000)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训题目整理</title>
    <link href="/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
    <url>/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.10">熄灯问题</a></h1><p>枚举&#x2F;二进制优化</p><p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。</p><p>在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。</p><p>请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。</p><ul><li>输入<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p><ul><li>输出<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p><ul><li>输入样例</li></ul><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0</p><ul><li>输出样例</li></ul><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>注意：PUZZLE行结尾没有空格，数字行最后有一个空格。   </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/* 每次碰一个开关就会使他上下左右（还有自己！）的灯都改变状态，灯只有开关两种状态，那么要使灯全部关掉，</span><br><span class="hljs-comment">其实每个灯最多只需要按一次。</span><br><span class="hljs-comment">  如何枚举？从第二排开始，只关注当前行和上一行的状态，用当前行把上一行的灯都关掉，而不考虑其他变</span><br><span class="hljs-comment">化，这样到最后一行，如果恰好全部熄灭，就是结果。能够影响结果的，就是第一行的状态，枚举第一行。</span><br><span class="hljs-comment">  第一行的状态怎么表示？由于只有开关（1/0）两种状态，可以用二进制数来表示，之后再按顺序输入到矩阵中</span><br><span class="hljs-comment">*/</span><br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>bool <span class="hljs-symbol">ButtomStatu</span>(const int m, int ori[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>], int res[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])<br>&#123;<br>//枚举第一行的所有按键情况 利用二进制数来枚举 由于有<span class="hljs-number">6</span>列 情况为<span class="hljs-number">2</span>^<span class="hljs-number">6</span>种 得到第一行的按键情况<br>int temp = m;<br><br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>res[<span class="hljs-number">0</span>][i] = temp <span class="hljs-comment">% 2;</span><br>temp /= <span class="hljs-number">2</span>;<br>&#125;<br> <br>//把上面的情况按一遍 记得按自己所在的位置<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>if (res[<span class="hljs-number">0</span>][i])<br>&#123;<br>ori[<span class="hljs-number">0</span>][i]= (ori[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[<span class="hljs-number">1</span>][i] = (ori[<span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>&#125;<br>&#125;<br><br>//从第一行下面的每一行枚举 （核心是 第一行决定了下面每一行的情况 所以只需要枚举第一行<br>for (int i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>if (ori[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">0</span>)<br>&#123;<br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">5</span>)ori[i + <span class="hljs-number">1</span>][j] = (ori[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[i][j + <span class="hljs-number">1</span>] = (ori[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i][j - <span class="hljs-number">1</span>] = (ori[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[i][j]= (ori[i][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>res[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>//如果灯全部关完 则为true<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>if (ori[i][j] != <span class="hljs-number">0</span>)return false;<br><br>return true;<br>&#125;<br><br><br>int main()<br>&#123;<br>int n;<br>cin &gt;&gt; n;<br>int orilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int resultlight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int constorilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>for(int k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br>for (int row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">5</span>; row++)<br>&#123;<br>for (int col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">6</span>; col++)<br>&#123;<br>cin &gt;&gt; constorilight[row][col];<br>&#125;<br>&#125;<br>//枚举<span class="hljs-number">64</span>种情况<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>&#123;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>orilight[i][j] = constorilight[i][j];<br>resultlight[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>//如果得到结果就输出<br>if (<span class="hljs-symbol">ButtomStatu</span>(i, orilight, resultlight))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;PUZZLE #&quot;</span> &lt;&lt; k &lt;&lt; endl;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>cout &lt;&lt; resultlight[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.5">假币问题</a></h1><p>枚举</p><p>林克有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但林克不知道假币比真币轻还是重。</p><p>于是他向他朋友约珥借了一架天平，用这架天平称了这些币三次。</p><p>如果用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。</p><p>经过精心的设计，聪明的林克根据这三次称量结果找出假币，并且能够确定假币是轻是重。</p><p>如果给你林克的称量数据，你也可以找出假币并且确定假币是轻是重吗？（林克提供的称量数据保证一定能找出假币）。</p><ul><li>输入</li></ul><p>第一行有一个数字n，表示有n组测试用例。</p><p>对于每组测试用例：</p><p>输入有三行，每行表示一次称量的结果。林克事先将银币标号为A-L。</p><p>每次称量的结果用三个以空格隔开的字符串表示：</p><p>天平左边放置的硬币  天平右边放置的硬币  平衡状态。</p><p>其中平衡状态用’’up’’, ‘’down’’, 或 ‘’even’’表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p><ul><li>输出</li></ul><p>输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)</p><ul><li>输入样例 1</li></ul><p>1<br>ABCD EFGH even<br>ABCI EFJK up<br>ABIJ EFGH even  </p><ul><li>输出样例 1</li></ul><p>K is the counterfeit coin and it is light. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 枚举十二枚硬币和轻重共24种状态，先设假币为轻，那么一定在上升的一边，依次枚举十二枚硬币是否在</span><br><span class="hljs-comment">上升的一边，如果不是，说明为真币或者假币不为轻，那么返回false。否则遍历三次称重，最后返回true，说明</span><br><span class="hljs-comment">这个就是假币并且为轻。</span><br><span class="hljs-comment">优化：不需要分别写轻，重的函数，只需要传一个参数表示状态，当判断重时把左右交换，就与判断轻的代码一样</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>vector&lt;string&gt;<span class="hljs-built_in">lef</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">rig</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">zt</span>(<span class="hljs-number">3</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> iCoin,<span class="hljs-type">bool</span> is_light)</span></span><br><span class="hljs-function"></span>&#123;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>string l = lef[i];<br>string r = rig[i];<br>string z = zt[i];<br><span class="hljs-keyword">if</span> (!is_light)<br><span class="hljs-built_in">swap</span>(l, r);<br><span class="hljs-keyword">switch</span> (zt[i][<span class="hljs-number">0</span>])<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)!=string::npos||r.<span class="hljs-built_in">find</span>(iCoin)!=string::npos)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//说明在平衡的地方找到了  肯定是真币</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//现在枚举的是轻的 那么假币一定在上升的一方 </span><br><span class="hljs-comment">//右边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//左边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> cmp[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cin &gt;&gt; lef[i]&gt;&gt;rig[i]&gt;&gt; zt[i];<br>&#125;<br><br><span class="hljs-comment">//枚举十二枚硬币</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> iCoin = <span class="hljs-string">&#x27;A&#x27;</span>; iCoin &lt;= <span class="hljs-string">&#x27;L&#x27;</span>; iCoin++) <br>&#123;<br><span class="hljs-comment">//枚举假币为轻的情况</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">true</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is light. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">false</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is heavy. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>lef.<span class="hljs-built_in">clear</span>(), rig.<span class="hljs-built_in">clear</span>(), zt.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拨钟问题"><a href="#拨钟问题" class="headerlink" title="拨钟问题"></a><a href="http://www.xmuoj.com/problem/GW102">拨钟问题</a></h1><p>子集型回溯</p><p>有9个时钟，排成一个3*3的矩阵。</p><p>(图 1)<del>明显显示不出来嘛！</del>  </p><p>现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。</p><p>移动    影响的时钟</p><p> 1         ABDE<br> 2         ABC<br> 3         BCEF<br> 4         ADG<br> 5         BDEFH<br> 6         CFI<br> 7         DEGH<br> 8         GHI<br> 9         EFHI         </p><ul><li>输入</li></ul><p>9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0&#x3D;12点、1&#x3D;3点、2&#x3D;6点、3&#x3D;9点。</p><ul><li>输出</li></ul><p>输出一个最短的时钟指针移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。 相邻两个整数之间用单个空格隔开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*子集型回溯：进入dfs之后首先判断退出条件。之后是选或不选，对于1~9每个拨钟的方法，都可以选择拨或者</span><br><span class="hljs-comment">不拨！！然后是每个数字循环三次（最多只需要拨三次）。</span><br><span class="hljs-comment">判断，k&gt;9的时候判断是否符合，符合判断最短，之前应记录每一步。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;inf = &#123; <span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;ABDE&quot;</span> ,<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-string">&quot;BCEF&quot;</span>,<span class="hljs-string">&quot;ADG&quot;</span>,<span class="hljs-string">&quot;BDEFH&quot;</span>,<span class="hljs-string">&quot;CFI&quot;</span>,<span class="hljs-string">&quot;DEGH&quot;</span>,<span class="hljs-string">&quot;GHI&quot;</span>,<span class="hljs-string">&quot;EFHI&quot;</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ori</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">movevec</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">showvec</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> si = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mi = <span class="hljs-number">50</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;ori)</span><span class="hljs-comment">//检查是否符合条件（全为0</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (ori[i] != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><span class="hljs-comment">//移动的距离</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inf[k].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] = (ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">9</span>)<span class="hljs-comment">//相当于循环9次  即枚举9种拨钟方法</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ori) &amp;&amp; si &lt; mi)<span class="hljs-comment">//由于需要最少的次数所以用mi记录（当全为0时）最少次数</span><br>&#123;<br>mi = si;<br>showvec = movevec;<span class="hljs-comment">//记录最少次数的走法 由于是按顺序枚举 所以一定是从小到大的</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br> <span class="hljs-comment">//子集型回溯  可以一个都不选</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<span class="hljs-comment">//先进去9次  这样才可以回溯 只拨第9个不行 从这里退出 拨第8个和第9个 由于move（K） 则可以枚举到1次8 1次9 2次9 3次9 ） 2次8 1次9 2次9 3次9 ）3次8 1次9 2次9 3次9。。。依次类推可以枚举到全部的情况</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<span class="hljs-comment">//每一种方法拨三次</span><br>&#123;<br>movevec[si++] = k;<span class="hljs-comment">//记录拨钟方法和次数</span><br><span class="hljs-built_in">move</span>(k);<span class="hljs-comment">//拨钟</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br>si -= <span class="hljs-number">3</span>;<br><span class="hljs-built_in">move</span>(k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>cin &gt;&gt; ori[i];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;mi ; i++)<br>&#123;<br>cout &lt;&lt; showvec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2的幂次方表示"><a href="#2的幂次方表示" class="headerlink" title="2的幂次方表示"></a><a href="http://www.xmuoj.com/problem/GW104">2的幂次方表示</a></h1><p>递归  <del>呜呜 递归真的好抽象 难过 tllwtg和wegret怎么都说自然就会了</del></p><p><del>题目居然是图片 那就点链接了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 当n=1的时候怎么办？n=2的时候怎么办？n=其他数的时候怎么办？再把次方也递归一下（1次方要特判！！）</span><br><span class="hljs-comment">然后减去这个数，剩下的数再拆分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 1不可划分 直接输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2(0)&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-comment">// 2不可划分</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 其他数 可划分 </span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a * <span class="hljs-number">2</span> &lt;= n)<br>&#123;<br>a *= <span class="hljs-number">2</span>;<br>k++;<br>&#125;<br><span class="hljs-comment">// 分解次方</span><br><span class="hljs-comment">// 这个地方要特判  因为只剩一个2的时候就直接输出了 而不是把k=1再拿去递归</span><br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-built_in">mf</span>(k);<br>cout &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> x = n - a;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;+&quot;</span>;<br><span class="hljs-built_in">mf</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">mf</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直接用python写算了"><a href="#直接用python写算了" class="headerlink" title="直接用python写算了"></a>直接用python写算了</h2><h1 id="算24"><a href="#算24" class="headerlink" title="算24"></a><a href="http://www.xmuoj.com/problem/NQ079">算24</a></h1><p>回溯<br>熟悉了递归和深度优先搜索，小华知道现在是让小鲁综合运用所学知识的时候了，他让小鲁调整一道经典题：算24.</p><p>给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。</p><p>这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。</p><p>比如，对于5，5，5，1，我们知道5 * (5 – 1 &#x2F; 5) &#x3D; 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。</p><p>注意：输入数字的次序可以改变。</p><ul><li><p>输入<br>输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。</p></li><li><p>输出<br>对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;回溯，首先寻找结束条件，当等于24时退出递归，记得用绝对值和浮点数判断。</span><br><span class="hljs-string">然后基本思路时把每种组合的加减乘除都算一遍，如何储存状态？使用一个列表，每次选出两个数，进行四则</span><br><span class="hljs-string">运算，然后把剩余的没算的数也加进shengyu数组里面，递归运算。记得要回溯pop，还要排除b == 0的情况（被除数）。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">lis</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lis) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> math.fabs(lis[<span class="hljs-number">0</span>] - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">1e-6</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br><br>            <span class="hljs-keyword">if</span> i == j:<br>                <span class="hljs-keyword">continue</span><br><br>            a = lis[i]<br>            b = lis[j]<br>            shengyu = []<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>                <span class="hljs-keyword">if</span> k != i <span class="hljs-keyword">and</span> k != j:<br>                    shengyu.append(lis[k])<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            sum1 = a + b<br>            sub = a - b<br>            mul = a * b<br>            div = a / b<br>            left = [sum1, sub, mul, div]<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> left:<br>                shengyu.append(x)<br>                <span class="hljs-keyword">if</span> cal(shengyu):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                shengyu.pop()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">if</span> lis.count(<span class="hljs-number">0</span>) == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> cal(lis):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;YES&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="求排列的逆序数"><a href="#求排列的逆序数" class="headerlink" title="求排列的逆序数"></a><a href="http://www.xmuoj.com/problem/GW108">求排列的逆序数</a></h1><p>分治 递归</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-string">&quot;&quot;</span>&quot;<br>首先分治的思路分别来求逆序数，只在左半边的，只在右半边的和跨两边的。利用归并排序的模板，当左边<br>的数大于右边的时候，就是逆序数，由于归并排序已经排好了数，所以逆序数的个数为 mid - i + 1，<br>（mid右边的比i小）<br><span class="hljs-string">&quot;&quot;</span>&quot;<br><span class="hljs-keyword">n</span> = int(<span class="hljs-keyword">input</span>())<br>temp = [0 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">n</span>)]<br><span class="hljs-keyword">lis</span> = <span class="hljs-keyword">list</span>(map(int, <span class="hljs-keyword">input</span>().<span class="hljs-keyword">split</span>()))<br><span class="hljs-keyword">ret</span> = 0<br><br>def <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, r):<br>    <span class="hljs-keyword">global</span> <span class="hljs-keyword">ret</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">l</span> &gt;= r:<br>        <span class="hljs-keyword">return</span><br>    mid = (<span class="hljs-keyword">l</span> + r) &gt;&gt; 1<br>    <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, mid)<br>    <span class="hljs-keyword">merge</span>(mid + 1, r)<br>    i, j, k = <span class="hljs-keyword">l</span>, mid + 1, 0<br>    <span class="hljs-keyword">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">lis</span>[i] &lt;= <span class="hljs-keyword">lis</span>[j]:<br>            temp[k] = <span class="hljs-keyword">lis</span>[i]<br>            i += 1<br>            k += 1<br>        <span class="hljs-keyword">else</span>:<br>            temp[k] = <span class="hljs-keyword">lis</span>[j]<br>            j += 1<br>            k += 1<br>            <span class="hljs-keyword">ret</span> += mid - i + 1<br>    <span class="hljs-keyword">while</span> i &lt;= mid:<br>        temp[k] = <span class="hljs-keyword">lis</span>[i]<br>        i += 1<br>        k += 1<br>    <span class="hljs-keyword">while</span> j &lt;= r:<br>        temp[k] = <span class="hljs-keyword">lis</span>[j]<br>        j += 1<br>        k += 1<br><br>    j = 0<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">l</span>, r + 1):<br>        <span class="hljs-keyword">lis</span>[i] = temp[j]<br>        j += 1<br><br><span class="hljs-keyword">merge</span>(0, <span class="hljs-keyword">n</span> - 1)<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ret</span>)<br></code></pre></td></tr></table></figure><h1 id="海拉鲁城堡问题"><a href="#海拉鲁城堡问题" class="headerlink" title="海拉鲁城堡问题"></a><a href="http://www.xmuoj.com/problem/GW090">海拉鲁城堡问题</a></h1><p>深搜 位运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;因为需要找到所有房间中最大的，而一次搜索只能找一个房间的面积，可以遍历寻找未搜索过的房间。</span><br><span class="hljs-string">深搜和广搜选哪个，一看是找面积最大的本来想用广搜但是判断条件写出来可能会比深搜麻烦很多，所以还是用深搜。</span><br><span class="hljs-string">每次搜索之前，位运算判断该位是否可以走</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> sys<br>sys.setrecursionlimit(<span class="hljs-number">5000</span>)<br>N = <span class="hljs-number">100</span><br>row = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>col = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>lis = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>color = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>maxArea = <span class="hljs-number">0</span><br>maxRoom = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask3</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask4</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">8</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> maxArea, maxRoom<br>    <span class="hljs-keyword">if</span> color[a][b] != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    maxArea += <span class="hljs-number">1</span><br>    color[a][b] = maxRoom<br>    <span class="hljs-keyword">if</span> mask1(lis[a][b]):<br>        dfs(a, b - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask2(lis[a][b]):<br>        dfs(a - <span class="hljs-number">1</span>, b)<br>    <span class="hljs-keyword">if</span> mask3(lis[a][b]):<br>        dfs(a, b + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask4(lis[a][b]):<br>        dfs(a + <span class="hljs-number">1</span>, b)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>        lis[i][j+<span class="hljs-number">1</span>] = a[j]<br><br>retArea = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> color[i][j] == <span class="hljs-number">0</span>:<br>            maxArea = <span class="hljs-number">0</span><br>            maxRoom += <span class="hljs-number">1</span><br>            dfs(i, j)<br>            retArea = <span class="hljs-built_in">max</span>(retArea, maxArea)<br><br><span class="hljs-built_in">print</span>(maxRoom)<br><span class="hljs-built_in">print</span>(retArea)<br></code></pre></td></tr></table></figure><h1 id="英杰们的蛋糕塔"><a href="#英杰们的蛋糕塔" class="headerlink" title="英杰们的蛋糕塔"></a><a href="http://www.xmuoj.com/problem/GW092">英杰们的蛋糕塔</a></h1><p>深搜 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-comment">//宏定义简化</span><br>#define <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span> (r*r)<br>#define sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> (<span class="hljs-number">2</span>*r*h)<br>#define <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> ((r)*(r)*(h))<br>#define <span class="hljs-constructor">V2surArea(<span class="hljs-params">r</span>,<span class="hljs-params">v</span>)</span> (<span class="hljs-number">2</span>*v/(r))<br>#define INF <span class="hljs-number">0x7fffffff</span> <br><span class="hljs-built_in">int</span> N, V, minsurArea = INF;<br><span class="hljs-built_in">int</span> sumMinS<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>, sumMinV<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>;<br><br><span class="hljs-comment">// 搜索的主体是 枚举每一层的R H 寻找体积符合时 最小的表面积</span><br>void dfs(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> nr,<span class="hljs-built_in">int</span> nh,<span class="hljs-built_in">int</span> lv,<span class="hljs-built_in">int</span> cs)<br>&#123;<br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (lv<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>cs &lt; minsurArea)minsurArea = cs;<br>return;<br>&#125;<br><span class="hljs-comment">// 剪枝操作 1.当前剩余的体积小于上面累加起来最小的体积 说明已经不符合 </span><br><span class="hljs-comment">// 2.当前表面积加上上面的最小表面积 大于minsurArea 不符合</span><br><span class="hljs-comment">// 3.启发式剪枝 提前看到下一步的结果 当nr没到最后一层 并且 上一层的表面积加上当前累加的面积已经大于minsurArea 不符合</span><br><span class="hljs-keyword">if</span> (lv &lt; sumMinV<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>)return;<br><span class="hljs-keyword">if</span> (cs + sumMinS<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> &gt;= minsurArea)return;<br><span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">V2surArea(<span class="hljs-params">nr</span> - 1, <span class="hljs-params">lv</span>)</span> + cs &gt;= minsurArea)return;<br><br><span class="hljs-comment">//从最大层 （r最大） 到最小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = nr - <span class="hljs-number">1</span>; r &gt;= u; r--)<br>&#123;<br><span class="hljs-comment">// 当到达最高层的时候 让这一层的面积等于 底面积（后面是加上表面积 是每个都有的操作 </span><br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span>N)cs = <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>;<br><span class="hljs-comment">// 预处理出最大高度的最小值 （如果把当前剩余的体积 全部做成一层 除以当前的表面积 就是最大高度</span><br><span class="hljs-built_in">int</span> H_max = (<span class="hljs-number">1.0</span><span class="hljs-operator"> * </span>lv<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (H_max &gt; nh - <span class="hljs-number">1</span>)H_max = nh - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 枚举h</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = H_max; h &gt;= u; h--)<br>&#123;<br><span class="hljs-built_in">int</span> s = sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br><span class="hljs-built_in">int</span> v = <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br>dfs(u - <span class="hljs-number">1</span>, r, h, lv - v, cs + s);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>cin &gt;&gt; V &gt;&gt; N;<br><br><span class="hljs-comment">//预处理出 累加到每一层的最小的面积和体积 用于后面的剪枝</span><br>sumMinS<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>&#123;<br>sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + sur<span class="hljs-constructor">Area(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + <span class="hljs-constructor">Volume(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>&#125;<br><span class="hljs-comment">//预处理出 最下面一层的 R H的上界 减少计算</span><br><span class="hljs-built_in">int</span> maxH = (V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(N)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> maxR = sqrt(double((V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>) + <span class="hljs-number">1</span>));<br><br>dfs(N, maxR, maxH, V, <span class="hljs-number">0</span>);<span class="hljs-comment">//从最大的蛋糕往上搜索</span><br><span class="hljs-keyword">if</span> (minsurArea<span class="hljs-operator"> == </span>INF)<br>cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; minsurArea &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="击杀黄金蛋糕人马"><a href="#击杀黄金蛋糕人马" class="headerlink" title="击杀黄金蛋糕人马"></a><a href="http://www.xmuoj.com/problem/NQ090">击杀黄金蛋糕人马</a></h1><p>记忆化搜索 动态规划   </p><p>在海拉鲁大陆冒险，没有绝佳的剑法+想象力是不可能存活下来的。<br>这不，林克遇到了一个特别巨大的敌人——黄金蛋糕人马（莱尼尔的变种）<br>这黄金蛋糕人马长相非常特别，没有脚没有手没有嘴巴没有头，整个身材就是一个大矩形（喂喂，这不就是黄金莱尼尔吗？）<br>它的长和宽分别是整数w、h。<br>林克举起大师之剑，挥向黄金蛋糕人马，要将其切成m块矩形小块打包走，分给自己的朋友（每块都必须是矩形、且长和宽均为整数）。<br>大师之剑无比锐利，每一斩带出的剑气能将黄金蛋糕人马劈成两半（形成两个小矩形蛋糕）<br>经过m-1斩，黄金蛋糕人马居然被劈成m块小蛋糕（喂喂，你的想象力也太丰富了，明明切不开好吗？）<br>请计算：最后得到的m块小蛋糕中，最大的那块蛋糕的面积下限。<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 4，则下面的斩击可使得其中最大蛋糕块的面积最小。(十字斩)<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 3，则下面的斩击可使得其中最大蛋糕块的面积最小:.(二连斩)</p><ul><li>输入</li></ul><p>共有多行，每行表示一个测试案例。<br>每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh.<br>当 w &#x3D; h &#x3D; m &#x3D; 0 时不需要处理，表示输入结束。</p><ul><li>输出</li></ul><p>每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 记忆化搜索 储存已经搜过的值 下次需要时直接返回 储存的一般为搜索的值 dfs返回值一般定义为int（不为void）</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 原来的方法主要是分成左右两边的时候不好表示 </span><br><span class="hljs-comment">* 该方法dfs传入的是当前的方块的长和宽 分为左右两边（分治）枚举左右边切的位置 和左右边分别切的刀数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w, h, m;<br><span class="hljs-type">int</span> maxCake[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>][<span class="hljs-number">500</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当m为0的时候返回当前的面积</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> w * h;<br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-keyword">if</span> (maxCake[w][h][m])<span class="hljs-keyword">return</span> maxCake[w][h][m];<br><br><span class="hljs-type">int</span> a, b, ans = inf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; w; j++) <br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(j, h, i);<span class="hljs-comment">// 切m 刀的蛋糕是由切i刀和m - i - 1刀组成的   w - i 最后会反转 可以变量所有情况</span><br>b = <span class="hljs-built_in">dfs</span>(w - j, h, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<span class="hljs-comment">// 得到最大的蛋糕 取最小</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; h; j++)<br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(w, j, i);<br>b = <span class="hljs-built_in">dfs</span>(w, h - j, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br>&#125;<br>maxCake[w][h][m] = ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; h &gt;&gt; m)<br>&#123;<br><span class="hljs-keyword">if</span> (w == h &amp;&amp; h == m &amp;&amp; m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">dfs</span>(w, h, m - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">memset</span>(maxCake, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> maxCake);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滚石柱"><a href="#滚石柱" class="headerlink" title="滚石柱"></a><a href="http://www.xmuoj.com/problem/XMU023">滚石柱</a></h1><p>广搜 结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs arduino">广搜加上结构体表示物体的状态，主要难点就在于状态的表示。用结构体表示物体的状态，更新状<br>态时，用三维数组，增加的一维用来表示<span class="hljs-number">0</span>立着横着竖着<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> d[N][N][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> row, col;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State start, State end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; row &gt;&gt; col, row || col)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>cin &gt;&gt; g[i];<br><br>State start = &#123; <span class="hljs-number">-1</span> &#125;, end;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(start, end);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python速成笔记</title>
    <link href="/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python速成的一些学习笔记"><a href="#python速成的一些学习笔记" class="headerlink" title="python速成的一些学习笔记"></a>python速成的一些学习笔记</h1><p>什么？！你说python速成？-&gt;[<a href="https://oi.wiki/lang/python/">Python 速成 - OI Wiki</a>]</p><ul><li><p>pow函数可以实现快速幂</p></li><li><p>对Unicode的字符使用函数ord可以将其转换成对应的Unicode编码 逆向转换使用chr</p></li><li><p>字符串居然也可以用加和乘的运算 但是好像不能用减？ </p></li><li><p>字符串和列表都有方便的子串&#x2F;元素检测 in 如 a in str</p></li><li><p>字符串与列表的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">70</span>))            <br>lis = [<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num]           <br><span class="hljs-built_in">print</span>(lis)                  <br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(lis)                    <br><span class="hljs-built_in">print</span>(s)            <br></code></pre></td></tr></table></figure></li><li><p>二维[数组]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">via = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]                    <br><span class="hljs-built_in">print</span>(via)              <br>via[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>               <br><span class="hljs-built_in">print</span>(via)              <br></code></pre></td></tr></table></figure></li><li><p>使用NumPy建立多维数组和访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np      <br><br><span class="hljs-comment">#容量为3 未初始化       </span><br>lis = np.empty(<span class="hljs-number">3</span>)       <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#3*3 初始化为0      </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)     <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#整数数组       </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>, dtype=<span class="hljs-built_in">int</span>)      <br><span class="hljs-built_in">print</span>(lis.shape)        <br><span class="hljs-comment">#获取数组最大值         </span><br>np.<span class="hljs-built_in">max</span>(lis)     <br><span class="hljs-comment">#展平       </span><br>lis.flatten()       <br><span class="hljs-comment">#对每行排序 返回排序结果</span><br>np.sort(lis, axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#行方向原地排序</span><br>lis.sort(axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#浮点数输出</span><br>pi = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.4f&quot;</span> % pi)<br><span class="hljs-string">&quot;%.4f - %8f = %d&quot;</span> % (pi, <span class="hljs-number">0.1416</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">#输入</span><br>s = <span class="hljs-built_in">input</span>()<br>a = s.split()<br><span class="hljs-built_in">print</span>(a)<br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]<br><span class="hljs-comment">#或者</span><br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment">#固定输入</span><br>u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典</span><br>dic = &#123;&#125;<br>dic = &#123;<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>&#125;<br>dic1 = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">69</span>)&#125;<br><span class="hljs-comment"># 翻转</span><br>dic1 = &#123;dic1[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1&#125;<br><span class="hljs-built_in">print</span>(dic1)<br><span class="hljs-comment"># 要先判断才能打印</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">in</span> dic1:<br>    <span class="hljs-built_in">print</span>(dic1[<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-keyword">else</span>:<br>    dic1[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">98</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="更新！学了两个月之后再看一遍"><a href="#更新！学了两个月之后再看一遍" class="headerlink" title="更新！学了两个月之后再看一遍"></a>更新！学了两个月之后再看一遍</h1><ul><li><p>format() 输出浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br>formatted_pi = <span class="hljs-string">&quot;圆周率的近似值是 &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi)<br><span class="hljs-built_in">print</span>(formatted_pi)<br>:<span class="hljs-number">.2</span>f 是一个格式规范，它指定了要显示小数点后两位的浮点数<br><br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">20</span><br>result = <span class="hljs-string">&quot;x 的值是 &#123;&#125;，y 的值是 &#123;&#125;，它们的和是 &#123;&#125;。&quot;</span>.<span class="hljs-built_in">format</span>(x, y, x + y)<br><span class="hljs-built_in">print</span>(result)<br><br>name = <span class="hljs-string">&quot;Alice&quot;</span><br>age = <span class="hljs-number">30</span><br>message = <span class="hljs-string">f&quot;我的名字是 <span class="hljs-subst">&#123;name&#125;</span>，年龄是 <span class="hljs-subst">&#123;age&#125;</span>。&quot;</span><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><br><span class="hljs-comment"># 二维数组</span><br>mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>N = <span class="hljs-number">4</span>; mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>mat  <span class="hljs-comment"># 先按行读入二维数组</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*mat))   <br><span class="hljs-comment"># *将 mat 解包得到里层的多个列表</span><br><span class="hljs-comment"># zip() 将多个列表中对应元素聚合成元组，得到一个迭代器</span><br><span class="hljs-comment">## 内置函数 zip() 可以将多个等长序列中的对应元素拼接在「元组」内，得到新序列</span><br><span class="hljs-comment"># map(list, iterable) 将序列中的元素（这里为元组）转成列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u, v, w)  <span class="hljs-comment"># 直接将 map() 得到的迭代器拆包，分别赋值给 u, v, w</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dict</span><br>dic = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)&#125;<br>dic = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)], <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))<br><span class="hljs-comment"># 键值对逆转</span><br>dic = &#123;dic[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic&#125;<br>dic = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()&#125;  <span class="hljs-comment"># 和上行作用相同，dic.items() 以元组存放单个键值对</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dic.items(), key=<span class="hljs-keyword">lambda</span> x:-x[<span class="hljs-number">1</span>])&#125;  <span class="hljs-comment"># 字典按值逆排序，用到了 lambda 表达式</span><br></code></pre></td></tr></table></figure></li><li><p>装饰器</p><p>lru_cache转记忆化</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2023/07/22/My-first-blog/"/>
    <url>/2023/07/22/My-first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>做这个网站真的做了好久，教程确实很详细了，但是还是有些地方默认读者已经会了（我现在确实会了）。感谢tllwtg的帮助，没有tllwtg，就没有这个网站，呜呜。<br>tllwtg告诉我教程之后还帮我调了两次（&#x2F;跪谢）。</p><p>之后自己做的过程中也好多次感觉根本搞不出来，不想搞了。但是但是，这个好有意思，最后还是做出来了。tllwtg还跟我说做两三天是很正常的，我真的哭死。做完还是很开心的。<br>我也学到了好多东西，自己去看教程，搜资料，虽然会花很多时间，但是效果确实好欸，比如之前觉得很难的git的操作，，，一直不愿意去学（卧室蓝苟）最后也被迫学会了，<br>除了做网站本身，还学到好多其他的东西。效果比tllwtg直接帮我打出来好很多。（如果我那天不是删了重新做，而是让tllwtg帮我弄一下，我现在估计还是什么都不会&#x2F;难过）。</p><p>好！不当蓝苟从现在开始。（QQ机器人？好难，下次再说吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/22/hello-world/"/>
    <url>/2023/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
