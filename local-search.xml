<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>knowledge-distillation</title>
    <link href="/2024/06/27/knowledge-distillation/"/>
    <url>/2024/06/27/knowledge-distillation/</url>
    
    <content type="html"><![CDATA[<p><del>偷懒失败，还是写一下</del></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>知识蒸馏就是把一个大的模型当作教师模型，然后把他的知识教给较小的模型（学生模型）。</p><img src="../images/$%7Bfiilename%7D/image-20240627105847582.png" alt="image-20240627105847582" style="zoom:50%;" /><p>大的模型较臃肿，真正落地的中断算力有限，比如手表等，通过知识蒸馏把大模型变为小模型，再把小模型部署到终端。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="soft-target"><a href="#soft-target" class="headerlink" title="soft target"></a>soft target</h2><p>学生网络有两种标签，一种是<strong>教师网络的输出</strong>（Soft-target），一种是<strong>真实的标签</strong>（Hart-target）。</p><p>soft target就是常用的概率标签，比如</p><p><img src="/../images/$%7Bfiilename%7D/image-20240627111036662.png" alt="image-20240627111036662"></p><p>hard target 预测为马1 驴0 汽车0</p><p>soft target 预测为马0.7 驴0.25 汽车0.05</p><p>传统的神经网络的训练方法是定义一个损失函数，目标是使预测值尽可能接近于真实值，使用原始数据集标注的one-shot标签（也就是Hard-Target）。损失函数就是使神经网络的损失值的和尽可能小，这种训练过程是对ground truth(真实值)求极大似然.。</p><p>但是知识蒸馏中使用的是Teacher模型softmax层输出的类别概率作为Soft-Target。因为Soft-target中包含了Teacher模型训练和推理的大量信息，比如某些负标签概率远大于其他负标签，说明该样本与该负标签之间有一定的相似性。因此知识蒸馏中每个样本带给Student模型的信息大于传统的训练方式。</p><p>如在MNIST数据集中做手写体数字识别任务，假设某个输入的“2”更加形似”3”，softmax的输出值中”3”对应的概率会比其他负标签类别高；而另一个”2”更加形似”7”，则这个样本分配给”7”对应的概率会比其他负标签类别高。这两个”2”对应的Hard-target的值是相同的，但是它们的Soft-target却是不同的，由此我们可见Soft-target蕴含着比Hard-target更多的信息。</p><img src="../images/$%7Bfiilename%7D/640.webp" alt="图片" style="zoom:50%;" /><p>在使用 Soft-target 训练时，Student模型可以很快学习到 Teacher模型的推理过程；而传统的 Hard-target 的训练方式，所有的负标签都会被平等对待。因此，Soft-target 给 Student模型带来的信息量要大于 Hard-target，并且Soft-target分布的熵相对高时，其Soft-target蕴含的知识就更丰富。同时，使用 Soft-target 训练时，梯度的方差会更小，训练时可以使用更大的学习率，所需要的样本也更少。这也解释了为什么通过蒸馏的方法训练出的Student模型相比使用完全相同的模型结构和训练数据只使用Hard-target的训练方法得到的模型，拥有更好的泛化能力。</p><h2 id="蒸馏温度"><a href="#蒸馏温度" class="headerlink" title="蒸馏温度"></a>蒸馏温度</h2><h3 id="Logits"><a href="#Logits" class="headerlink" title="Logits"></a>Logits</h3><p>比如图片分类，Logits就是最后输出的（softmax之前的）信息。softmax之后得到概率分布。</p><p>通过蒸馏来调整输出的概率分布，因为当softmax输出的概率分布较小的时候，负标签的值都很接近0，对损失函数的贡献小到可以忽略，因此要通过<strong>蒸馏温度</strong>来调整softmax的输出。</p><p>​$$q_i&#x3D;\frac{exp(z_i&#x2F;T)}{\sum_{j}exp(z_j&#x2F;T)}$$</p><p>T越高，softmax的输出就越趋于平滑，分布的熵就越大，负标签携带的信息也会被放大，模型训练就会更加关注负标签。</p><p>加入T还有哪些作用：</p><ol><li><strong>抑制过拟合：</strong> 高蒸馏温度下的软目标概率分布更平滑，相比硬目标更容忍学生模型的小误差。这有助于防止学生模型在训练过程中对教师模型的一些噪声或细微差异过度拟合，提高了模型的泛化能力。</li><li><strong>降低标签噪声的影响：</strong> 在训练数据中存在标签噪声或不确定性时，平滑的软目标可以减少这些噪声的影响。学生模型更倾向于关注教师模型输出的分布，而不是过于依赖单一的硬目标。</li><li><strong>提高模型鲁棒性：</strong> 平滑的软目标有助于提高模型的鲁棒性，使其对输入数据的小变化更加稳定。这对于在实际应用中面对不同环境和数据分布时的模型性能至关重要。</li></ol><h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p>知识蒸馏训练的具体方法如下图所示，主要包括以下几个步骤：</p><ol><li>训练好Teacher模型；</li><li>利用高温$T_{high}$ 产生 Soft-target；</li><li>使用${Soft-target,T_{high}}$ 和${Hard-target,T_{high}}$ 同时训练 Student模型；</li><li>设置温度T&#x3D;1，Student模型线上做inference。</li></ol><img src="../images/$%7Bfiilename%7D/640-17194607142405.webp" alt="图片" style="zoom:50%;" /><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>学生网络既要在蒸馏温度等于T时与教师网络的结果相接近。 也要保证不使用蒸馏温度时的结果与真实结果相接近。</p><p>蒸馏损失（distill loss）：把教师网络用蒸馏温度T输出的结果与学生网络蒸馏温度为T的输出结果做损失，这个损失越小越好。$L_{soft}&#x3D;-\sum^{N}_{i}p_i^Tlog(q_i^T)$</p><p>其中$p_i^T&#x3D;\frac{exp(v_i&#x2F;T)}{\sum_k^Nexp(v_k&#x2F;T)}$</p><p>$q_i^T&#x3D;\frac{exp(z_i&#x2F;T)}{\sum_k^Nexp(z_k&#x2F;T)}$</p><p>其实就是蒸馏温度T下教师和学生的损失。</p><p>学生损失（Student loss）：学生网络蒸馏温度为1的预测结果和真实的标签做loss。</p><p>$L_{hard&#x3D;-\sum_i^Nc_ilog(q_i^1)}$</p><p>注意理解$L_{soft}和L_{hard}$的关系：log前面是标签  里面是蒸馏温度T的softmax。</p><p>最后将二者加权求和$L&#x3D;\alpha L_{soft}+\beta L_{hard}$</p><p>当$L_{hard}$权重较小的时候往往能取得较好的效果。</p><h2 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h2><p>训练好后把X输入到学生网络进行推理。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDQ1NjAzNg==&mid=2247527921&idx=2&sn=1894bde4de9ecdbb2b31fa2a64cc6551&chksm=fb3ac8facc4d41ec0ab8e9d0d865163524ad741ae9dc8b0e57c269e54894abbce0e0bcd37a3d&scene=27">深度学习中的知识蒸馏技术 (qq.com)</a></p><p><a href="https://blog.csdn.net/qq_42864343/article/details/134693835">全网最细图解知识蒸馏(涉及知识点：知识蒸馏实现代码，知识蒸馏训练过程，推理过程，蒸馏温度，蒸馏损失函数)-CSDN博客</a></p><p><em>扩展一下轻量化网络的四个方向</em></p><img src="../images/$%7Bfiilename%7D/308a7daaa10e42c6a2c6a2778eaddca7.png" alt="在这里插入图片描述" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deep learning</tag>
      
      <tag>Attention</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coding-knowledge_distillation</title>
    <link href="/2024/06/27/coding-knowledge-distillation/"/>
    <url>/2024/06/27/coding-knowledge-distillation/</url>
    
    <content type="html"><![CDATA[<h2 id="fairseq的命令行参数"><a href="#fairseq的命令行参数" class="headerlink" title="fairseq的命令行参数"></a><a href="https://fairseq.readthedocs.io/en/latest/command_line_tools.html">fairseq的命令行参数</a></h2><p>本次实验基于fairseq，目的是熟悉fairseq的命令行参数、实现损失函数</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p>Q: fairseq中，inference时默认是使用test数据集，如何改成train数据集：</p><ul><li>方法一</li></ul><p>直接修改命令行参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fairseq-generate data-bin --gen-subset train --path model.pt<br></code></pre></td></tr></table></figure><p>参考</p><p><img src="/../images/$%7Bfiilename%7D/image-20240627151341390.png" alt="image-20240627151341390"></p><ul><li>方法二</li></ul><p>修改源码</p><p>fairseq的inference一般是在fairseq&#x2F;fairseq_cli&#x2F;generate.py中</p><p>从入口函数__main__开始找 到cli_main</p><p>cli_main中主要是定义命令行参数和调用main，传入参数args。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cli_main</span>():<br>    parser = options.get_generation_parser()<br>    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> replace this workaround with refactoring of `AudioPretraining`</span><br>    parser.add_argument(<br>        <span class="hljs-string">&quot;--arch&quot;</span>,<br>        <span class="hljs-string">&quot;-a&quot;</span>,<br>        metavar=<span class="hljs-string">&quot;ARCH&quot;</span>,<br>        default=<span class="hljs-string">&quot;wav2vec2&quot;</span>,<br>        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Model architecture. For constructing tasks that rely on &quot;</span><br>        <span class="hljs-string">&quot;model args (e.g. `AudioPretraining`)&quot;</span>,<br>    )<br>    args = options.parse_args_and_arch(parser)<br>    main(args)<br></code></pre></td></tr></table></figure><p>将传入main的参数args转为DictConfig对象，这意味着在命令行参数解析和转换过程中，<strong>所有命令行选项都会映射到cfg这个配置对象上</strong>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">cfg: DictConfig</span>):<br></code></pre></td></tr></table></figure><p>所以说虽然main中cfg的某些参数在cli_main中没有定义，但是可以在通过命令行参数进行推理的时候，进行添加，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python generate.py --gen-subset train<br></code></pre></td></tr></table></figure><p>这样就可以定义。</p><p>具体修改在106行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># loading the dataset should happen after the checkpoint has been loaded so we can give it the saved task config</span><br><span class="hljs-comment"># 在这里加上</span><br>cfg.dataset.gen_subset = <span class="hljs-string">&#x27;train&#x27;</span><br>task.load_dataset(cfg.dataset.gen_subset, task_cfg=saved_cfg.task)<br></code></pre></td></tr></table></figure><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><p>Q: fairseq中，inference生成的结果还包含其它信息，不能直接添加到原数据集中，如何处理为仅含源句&#x2F;目标句</p><ul><li>方法一</li></ul><p>可以在推理之后再用python文件操作处理</p><ul><li>方法二</li></ul><p>通过观察同文件中255行之后的代码可以发现，其中控制了输出的格式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cfg.common_eval.quiet:<br>    <span class="hljs-keyword">if</span> src_dict <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;S-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, src_str), file=output_file)<br>    <span class="hljs-keyword">if</span> has_target:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;T-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, target_str), file=output_file)<br><br><span class="hljs-comment"># Process top predictions</span><br><span class="hljs-keyword">for</span> j, hypo <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(hypos[i][: cfg.generation.nbest]):<br>    hypo_tokens, hypo_str, alignment = utils.post_process_prediction(<br>        hypo_tokens=hypo[<span class="hljs-string">&quot;tokens&quot;</span>].<span class="hljs-built_in">int</span>().cpu(),<br>        src_str=src_str,<br>        alignment=hypo[<span class="hljs-string">&quot;alignment&quot;</span>],<br>        align_dict=align_dict,<br>        tgt_dict=tgt_dict,<br>        remove_bpe=cfg.common_eval.post_process,<br>        extra_symbols_to_ignore=get_symbols_to_strip_from_output(generator),<br>    )<br>    detok_hypo_str = decode_fn(hypo_str)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cfg.common_eval.quiet:<br>        score = hypo[<span class="hljs-string">&quot;score&quot;</span>] / math.log(<span class="hljs-number">2</span>)  <span class="hljs-comment"># convert to base 2</span><br>        <span class="hljs-comment"># original hypothesis (after tokenization and BPE)</span><br>        <span class="hljs-built_in">print</span>(<br>            <span class="hljs-string">&quot;H-&#123;&#125;\t&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, score, hypo_str),<br>            file=output_file,<br>        )<br>        <span class="hljs-comment"># detokenized hypothesis</span><br>        <span class="hljs-built_in">print</span>(<br>            <span class="hljs-string">&quot;D-&#123;&#125;\t&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, score, detok_hypo_str),<br>            file=output_file,<br>        )<br>        <span class="hljs-built_in">print</span>(<br>            <span class="hljs-string">&quot;P-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                sample_id,<br>                <span class="hljs-string">&quot; &quot;</span>.join(<br>                    <span class="hljs-built_in">map</span>(<br>                        <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&quot;&#123;:.4f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x),<br>                        <span class="hljs-comment"># convert from base e to base 2</span><br>                        hypo[<span class="hljs-string">&quot;positional_scores&quot;</span>]<br>                        .div_(math.log(<span class="hljs-number">2</span>))<br>                        .tolist(),<br>                    )<br>                ),<br>            ),<br>            file=output_file,<br>        )<br><br>        <span class="hljs-keyword">if</span> cfg.generation.print_alignment == <span class="hljs-string">&quot;hard&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">&quot;A-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                    sample_id,<br>                    <span class="hljs-string">&quot; &quot;</span>.join(<br>                        [<br>                            <span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(src_idx, tgt_idx)<br>                            <span class="hljs-keyword">for</span> src_idx, tgt_idx <span class="hljs-keyword">in</span> alignment<br>                        ]<br>                    ),<br>                ),<br>                file=output_file,<br>            )<br>        <span class="hljs-keyword">if</span> cfg.generation.print_alignment == <span class="hljs-string">&quot;soft&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">&quot;A-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                    sample_id,<br>                    <span class="hljs-string">&quot; &quot;</span>.join(<br>                        [<span class="hljs-string">&quot;,&quot;</span>.join(src_probs) <span class="hljs-keyword">for</span> src_probs <span class="hljs-keyword">in</span> alignment]<br>                    ),<br>                ),<br>                file=output_file,<br>            )<br><br>        <span class="hljs-keyword">if</span> cfg.generation.print_step:<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">&quot;I-&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, hypo[<span class="hljs-string">&quot;steps&quot;</span>]),<br>                file=output_file,<br>            )<br><br>        <span class="hljs-keyword">if</span> cfg.generation.retain_iter_history:<br>            <span class="hljs-keyword">for</span> step, h <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(hypo[<span class="hljs-string">&quot;history&quot;</span>]):<br>                _, h_str, _ = utils.post_process_prediction(<br>                    hypo_tokens=h[<span class="hljs-string">&quot;tokens&quot;</span>].<span class="hljs-built_in">int</span>().cpu(),<br>                    src_str=src_str,<br>                    alignment=<span class="hljs-literal">None</span>,<br>                    align_dict=<span class="hljs-literal">None</span>,<br>                    tgt_dict=tgt_dict,<br>                    remove_bpe=<span class="hljs-literal">None</span>,<br>                )<br>                <span class="hljs-built_in">print</span>(<br>                    <span class="hljs-string">&quot;E-&#123;&#125;_&#123;&#125;\t&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sample_id, step, h_str),<br>                    file=output_file,<br>                )<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">S</span>-<span class="hljs-number">0</span>源句。<br><span class="hljs-attribute">T</span>-<span class="hljs-number">0</span>目标句。<br><span class="hljs-attribute">H</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>.<span class="hljs-number">123456789</span>生成的句子。<br><span class="hljs-attribute">D</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>.<span class="hljs-number">123456789</span>生成的句子。<br><span class="hljs-attribute">P</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>.<span class="hljs-number">1234</span> -<span class="hljs-number">0</span>.<span class="hljs-number">2345</span> -<span class="hljs-number">0</span>.<span class="hljs-number">3456</span>  得分<br><span class="hljs-attribute">A</span>-<span class="hljs-number">0</span><span class="hljs-number">0</span>-<span class="hljs-number">0</span> <span class="hljs-number">1</span>-<span class="hljs-number">1</span> <span class="hljs-number">2</span>-<span class="hljs-number">2</span>  对齐信息<br></code></pre></td></tr></table></figure><p>因此可以通过修改命令行参数或者直接修改源码，控制输出为原句&#x2F;目标句。(S T)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fairseq-generate --quiet False<br></code></pre></td></tr></table></figure><img src="../images/$%7Bfiilename%7D/image-20240627172002354.png" alt="image-20240627172002354" style="zoom:50%;" /><img src="../images/$%7Bfiilename%7D/image-20240627172054620.png" alt="image-20240627172054620" style="zoom:50%;" /><p>但是观察代码发现，当输出S T的时候，设置命令行参数为quiet，这会导致H D P A 也同时被输出；–print-alignment不论设置soft还是hard 都会输出额外的信息；而其他的一些参数如 –retain_iter_history –print_step等 默认值就为不输出 所以无需设置。</p><p>因此直接修改命令行参数可能无法达到预期效果，需要修改代码。</p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p>使用的是第一次代码训练中的transformer的训练结果。</p><ul><li>获取soft-target</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fairseq-generate data-bin/iwslt14.tokenized.de-en --path checkpoints/checkpoint_best.pt --batch-size 128 --beam 5 --remove-bpe --gen-subset train --source-lang de --target-lang en --results-path distillation_output<br></code></pre></td></tr></table></figure><ul><li>训练学生模型</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fairseq-train data-bin/iwslt14.tokenized.de-en --<span class="hljs-built_in">arch</span> transformer_iwslt_de_en --share-decoder-input-output-embed --optimizer adam --adam-betas <span class="hljs-string">&quot;(0.9,0.98)&quot;</span> --clip-norm 0.0 --lr 5e-4 --lr-scheduler inverse_sqrt --warmup-updates 4000 --dropout 0.3 --weight-decay 0.0001 --criterion label_smoothed_cross_entropy --label-smoothing 0.1 --max-tokens 4096 --source-lang de --target-lang en  --save-dir checkpoints/student<br></code></pre></td></tr></table></figure><ul><li>测试 生成翻译</li></ul><p>这里batch-size128太大了，gpu报错现存不足，改成64即可。改的太小也不行，会出现未定义错误，可能最小就是64。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fairseq-generate data-bin/iwslt14.tokenized.de-en --path checkpoints/student/checkpoint_best.pt --batch-size 64 --beam 5 --remove-bpe --gen-subset <span class="hljs-built_in">test</span> --source-lang de --target-lang en --results-path test_output<br></code></pre></td></tr></table></figure><p>训练完成后数据保存在test_output中。格式如下（没有按照上一问修改，确实有很多东西）。有用的就是生成句子和参考句子。用他们计算BLEU值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">S</span>-<span class="hljs-number">260</span>ein laser ist da anders .<br><span class="hljs-attribute">T</span>-<span class="hljs-number">260</span>now a laser is different .<br><span class="hljs-attribute">H</span>-<span class="hljs-number">260</span>-<span class="hljs-number">3</span>.<span class="hljs-number">3165059089660645</span>. . . .<br><span class="hljs-attribute">D</span>-<span class="hljs-number">260</span>-<span class="hljs-number">3</span>.<span class="hljs-number">3165059089660645</span>. . . .<br><span class="hljs-attribute">P</span>-<span class="hljs-number">260</span>-<span class="hljs-number">4</span>.<span class="hljs-number">3481</span> -<span class="hljs-number">2</span>.<span class="hljs-number">7208</span> -<span class="hljs-number">2</span>.<span class="hljs-number">7019</span> -<span class="hljs-number">2</span>.<span class="hljs-number">6929</span> -<span class="hljs-number">4</span>.<span class="hljs-number">1188</span><br></code></pre></td></tr></table></figure><p>本地训练有点困难，训练的epoch不多，训练数据也只截取了一部分，可能不太准确。但是有提高一点点。</p><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>Q: KL散度是非常重要的函数，请学习其概念并说明其定义</p><p>公式:</p><p>$D_{KL}(P||Q)&#x3D;\sum_{x\in X}P(x)log\frac{p(x)}{Q(x)}$</p><p>KL散度是用来衡量两个概率分布之间差异的一种度量方法。就是计算p，q之间的相对熵。按信息论的说法就是，某一个事件在系统q中的信息量和系统p中的信息量的差值，对这个差值求期望（平均）。</p><p>$D_{KL}(P||Q)&#x3D;\sum_{i&#x3D;1}^{m}p_i(f_Q(q_i)-f_P(p_i))$</p><p>由这个公式可以推导出最上面的KL散度的公式，这个公式意义可能好理解一些，就是事件$q_i$在P、Q两个概率分布中的差异。</p><p>衡量分布Q生成的数据相对于分布P生成的数据的额外信息量，也就是使用Q做近似分布时失去的信息。</p><p>可以用作<strong>损失函数</strong>或者<strong>相似性函数</strong>。</p><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>–arch是Fairseq的一个命令行参数，用于指定训练模型时使用的模型架构。使用方法如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--arch transformer_iwslt_de_en</span><br></code></pre></td></tr></table></figure><p>在Fairseq的代码中，模型架构通常使用@register_model_architecture来注册，模型用@register_model来注册。</p><p>在训练时，通过–arch来获取所需的教师模型。比如本次使用transformer进行训练，就用如上的代码获取transformer模型。</p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>调参是训练过程中的重要环节，但是有时候需要保持某些参数不变，这时候就要冻结模型参数。一般来说冻结模型参数是为了保存已有的特征提取能力，防止因为数据改变倒是模型性能下降。</p><p>可以用下列代码冻结全部参数。也可以设置条件冻结部分参数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>        param.requires_grad = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>获取教师模型的概率分布</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_teacher_probs</span>(<span class="hljs-params">teacher_model, input_data</span>):<br>    <span class="hljs-keyword">with</span> torch.no_grad():  <br>        logits = teacher_model(input_data)   <br>        probs = F.softmax(logits, dim=-<span class="hljs-number">1</span>)  <br>    <span class="hljs-keyword">return</span> probs<br></code></pre></td></tr></table></figure><p>KL散度</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">distillation_loss</span>(<span class="hljs-params">student_logits, teacher_probs, temperature=<span class="hljs-number">1.0</span></span>):<br>    log_student_probs = F.log_softmax(student_logits / temperature, dim=-<span class="hljs-number">1</span>)<br>    teacher_probs = F.softmax(teacher_probs / temperature, dim=-<span class="hljs-number">1</span>)<br>    loss = F.kl_div(log_student_probs, teacher_probs, reduction=<span class="hljs-string">&#x27;batchmean&#x27;</span>) * (temperature ** <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> loss<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deep learning</tag>
      
      <tag>coding</tag>
      
      <tag>Knowledge_Distillation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coding-Transformer</title>
    <link href="/2024/06/25/coding-Transformer/"/>
    <url>/2024/06/25/coding-Transformer/</url>
    
    <content type="html"><![CDATA[<p><del>不想打公式 直接截图了（苦鲁西</del></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>目录：&#x2F;fairseq&#x2F;models&#x2F;transformer&#x2F;</p><h3 id="transformer-legacy-py"><a href="#transformer-legacy-py" class="headerlink" title="transformer_legacy.py"></a>transformer_legacy.py</h3><p>226行注册了transformer_model_architecture，可以自定义配置。</p><p>同文件22行注册了transformer。继承TransformerModelBase。</p><p>77行init，先从Config中读取配置，再从基类初始化，最后初始化参数args</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, args, encoder, decoder</span>):<br>        cfg = TransformerConfig.from_namespace(args)<br>        <span class="hljs-built_in">super</span>().__init__(cfg, encoder, decoder)<br>        self.args = args<br></code></pre></td></tr></table></figure><p>92行build_model主要是根据参数配置：</p><p>encoder decoder层的数量；</p><p>source和target的最大编码长度；</p><p>检查和设置共享嵌入</p><p>之后的方法都直接调用基类。</p><h3 id="Transformer-config-py"><a href="#Transformer-config-py" class="headerlink" title="Transformer_config.py"></a>Transformer_config.py</h3><p>一些参数配置</p><h3 id="Transformer-base-py"><a href="#Transformer-base-py" class="headerlink" title="Transformer_base.py"></a>Transformer_base.py</h3><p>forward中为整体的流程：调用encoder和decoder最后输出decoder_out</p><h3 id="transformer-encoder-py"><a href="#transformer-encoder-py" class="headerlink" title="transformer_encoder.py"></a>transformer_encoder.py</h3><p>init中需要初始化一系列参数 比如embed_positions，layernorm_embedding等</p><p>build_encoder_layer建立encoder层发现要跳转道Transformer Encoder Layer Base</p><p>forward_embedding进行一系列嵌入（包括位置嵌入）</p><p>max_position为设置的最大输入长度</p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>在&#x2F;fairseq&#x2F;modules&#x2F;transformer_layer.py</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>首先设置注意力掩码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> attn_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            attn_mask = attn_mask.masked_fill(<br>                attn_mask.to(torch.<span class="hljs-built_in">bool</span>), -<span class="hljs-number">1e8</span> <span class="hljs-keyword">if</span> x.dtype == torch.float32 <span class="hljs-keyword">else</span> -<span class="hljs-number">1e4</span><br>            )<br><span class="hljs-comment"># 保存残差</span><br>residual = x<br></code></pre></td></tr></table></figure><p>然后是自注意力层</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> self.normalize_before:<br>            x = self.self_attn_layer_norm(x)<br>        x, _ = self.self_attn(<br>            query=x,<br>            key=x,<br>            value=x,<br>            key_padding_mask=encoder_padding_mask,<br>            need_weights=<span class="hljs-literal">False</span>,<br>            attn_mask=attn_mask,<br>        )<br></code></pre></td></tr></table></figure><p>dropout正则化 防止过拟合</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">x = self.dropout_module(x)<br></code></pre></td></tr></table></figure><p>Add &amp; Norm层</p><p>Add层参考残差网络 防止退化</p><p>Norm层归一化</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 残差连接 将原来的残差与新的x相加</span><br>x = self.residual_connection(x, residual)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.normalize_before:<br>    x = self.self_attn_layer_norm(x)<br><span class="hljs-comment"># 保存残差</span><br>residual = x<br><span class="hljs-comment"># 归一化</span><br><span class="hljs-keyword">if</span> self.normalize_before:<br>    x = self.final_layer_norm(x)<br></code></pre></td></tr></table></figure><p>激活函数和全连接层</p><p>再做一次Add &amp; Norm层</p><p>并返回结果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py">x = self.activation_fn(self.fc1(x))<br>x = self.activation_dropout_module(x)<br><span class="hljs-comment"># 全连接</span><br>x = self.fc2(x)<br><span class="hljs-comment"># 保存全连接层输出</span><br>fc_result = x<br><span class="hljs-comment"># 再做一次Add &amp; Norm</span><br>x = self.dropout_module(x)<br>x = self.residual_connection(x, residual)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.normalize_before:<br>    x = self.final_layer_norm(x)<br><br>        <span class="hljs-keyword">if</span> self.return_fc <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> torch.jit.is_scripting():<br>            <span class="hljs-keyword">return</span> x, fc_result<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>用到的一些函数如下：</p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_fc2</span>(<span class="hljs-params">self, input_dim, output_dim, q_noise, qn_block_size</span>):<br>    <span class="hljs-keyword">return</span> quant_noise(<br>        nn.Linear(input_dim, output_dim), p=q_noise, block_size=qn_block_size<br>    )<br></code></pre></td></tr></table></figure><h3 id="自注意力层"><a href="#自注意力层" class="headerlink" title="自注意力层"></a>自注意力层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_self_attention</span>(<span class="hljs-params">self, embed_dim, cfg</span>):<br>    <span class="hljs-keyword">return</span> MultiheadAttention(<br>        embed_dim,<br>        cfg.encoder.attention_heads,<br>        dropout=cfg.attention_dropout,<br>        self_attention=<span class="hljs-literal">True</span>,<br>        q_noise=self.quant_noise,<br>        qn_block_size=self.quant_noise_block_size,<br>        xformers_att_config=cfg.encoder.xformers_att_config,<br>    )<br></code></pre></td></tr></table></figure><h3 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">residual_connection</span>(<span class="hljs-params">self, x, residual</span>):<br>    <span class="hljs-keyword">return</span> residual + x<br></code></pre></td></tr></table></figure><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><h3 id="forward-1"><a href="#forward-1" class="headerlink" title="forward"></a>forward</h3><p>先设置自注意力的状态和输入缓冲</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> prev_self_attn_state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    prev_key, prev_value = prev_self_attn_state[:<span class="hljs-number">2</span>]<br>    saved_state: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Optional</span>[Tensor]] = &#123;<br>        <span class="hljs-string">&quot;prev_key&quot;</span>: prev_key,<br>        <span class="hljs-string">&quot;prev_value&quot;</span>: prev_value,<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prev_self_attn_state) &gt;= <span class="hljs-number">3</span>:<br>        saved_state[<span class="hljs-string">&quot;prev_key_padding_mask&quot;</span>] = prev_self_attn_state[<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">assert</span> incremental_state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>    self.self_attn._set_input_buffer(incremental_state, saved_state)<br>_self_attn_input_buffer = self.self_attn._get_input_buffer(incremental_state)<br></code></pre></td></tr></table></figure><p>设置掩码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> self.cross_self_attention <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> (<br>    incremental_state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">and</span> _self_attn_input_buffer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;prev_key&quot;</span> <span class="hljs-keyword">in</span> _self_attn_input_buffer<br>):<br>    <span class="hljs-keyword">if</span> self_attn_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">assert</span> encoder_out <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        self_attn_mask = torch.cat(<br>            (x.new_zeros(x.size(<span class="hljs-number">0</span>), encoder_out.size(<span class="hljs-number">0</span>)), self_attn_mask), dim=<span class="hljs-number">1</span><br>        )<br>    <span class="hljs-keyword">if</span> self_attn_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> encoder_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">assert</span> encoder_out <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>            encoder_padding_mask = self_attn_padding_mask.new_zeros(<br>                encoder_out.size(<span class="hljs-number">1</span>), encoder_out.size(<span class="hljs-number">0</span>)<br>            )<br>        self_attn_padding_mask = torch.cat(<br>            (encoder_padding_mask, self_attn_padding_mask), dim=<span class="hljs-number">1</span><br>        )<br>    <span class="hljs-keyword">assert</span> encoder_out <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>    y = torch.cat((encoder_out, x), dim=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">else</span>:<br>    y = x<br><br></code></pre></td></tr></table></figure><p>自注意力</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">x, attn = self.self_attn(<br>    query=x,<br>    key=y,<br>    value=y,<br>    key_padding_mask=self_attn_padding_mask,<br>    incremental_state=incremental_state,<br>    need_weights=<span class="hljs-literal">False</span>,<br>    attn_mask=self_attn_mask,<br>)<br></code></pre></td></tr></table></figure><p>Add &amp; Norm</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">x = self.dropout_module(x)<br>x = self.residual_connection(x, residual)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.normalize_before:<br>    x = self.self_attn_layer_norm(x)<br></code></pre></td></tr></table></figure><p>Encoder_attn层 也是多头自注意力但是输入是前一层的输出和Encoder的输出结合</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> self.encoder_attn <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> encoder_out <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    residual = x<br>    <span class="hljs-keyword">if</span> self.normalize_before:<br>        x = self.encoder_attn_layer_norm(x)<br>    <span class="hljs-keyword">if</span> prev_attn_state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        prev_key, prev_value = prev_attn_state[:<span class="hljs-number">2</span>]<br>        saved_state: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Optional</span>[Tensor]] = &#123;<br>            <span class="hljs-string">&quot;prev_key&quot;</span>: prev_key,<br>            <span class="hljs-string">&quot;prev_value&quot;</span>: prev_value,<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prev_attn_state) &gt;= <span class="hljs-number">3</span>:<br>            saved_state[<span class="hljs-string">&quot;prev_key_padding_mask&quot;</span>] = prev_attn_state[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">assert</span> incremental_state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br>        self.encoder_attn._set_input_buffer(incremental_state, saved_state)<br><br>    x, attn = self.encoder_attn(<br>        query=x,<br>        key=encoder_out,<br>        value=encoder_out,<br>        key_padding_mask=encoder_padding_mask,<br>        incremental_state=incremental_state,<br>        static_kv=<span class="hljs-literal">True</span>,<br>        need_weights=need_attn <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> self.training <span class="hljs-keyword">and</span> self.need_attn),<br>        need_head_weights=need_head_weights,<br>    )<br></code></pre></td></tr></table></figure><p>最后Add&amp;Norm激活全连接归一化返回结果</p><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><p>在module的Multi-Head Attention中 <del>太长了看不懂 先鸽了</del></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="BPE"><a href="#BPE" class="headerlink" title="BPE"></a>BPE</h2><p>BPE（Byte Pair Encoding）是字节对编码，在固定大小的 词表中实现可变长度的子词。将词分成单个字符，然后依次用另一个字符替换频率最高的一对字符，直到循环次数结束。</p><p>算法流程：</p><ol><li><p>准备语料库  确定期望的subword词表大小等参数</p></li><li><p>在每个单词末尾添加后缀</w> 统计词频 如“l o w</w>”:5</p></li><li><p>将所有<strong>单词拆分成单个字符</strong> 用所有单个字符建立最初的词典 并统计单个字符的频率</p></li><li><p>挑出频次最高的符号对 比如t h组成th 将新字符加入词表 然后merge 将所有的t h变为th（有点类似哈夫曼树）</p></li></ol><p>重复 上述操作 直到词表中单词数达到设定量或下一个最高频数为1 达到设定量后其余词汇直接丢弃</p><p>BPE可以有效地平衡词典大小和编码步骤数。</p><p>参考<a href="https://blog.csdn.net/a1097304791/article/details/122068153">BPE 算法原理及使用指南【深入浅出】-CSDN博客</a></p><h2 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionalEncoding</span>(nn.Module):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, d_model, dropout, max_len=<span class="hljs-number">5000</span></span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:param d_model: pe编码维度，一般与word embedding相同，方便相加</span><br><span class="hljs-string">:param dropout: dorp out</span><br><span class="hljs-string">:param max_len: 语料库中最长句子的长度，即word embedding中的L</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">super</span>(PositionalEncoding, self).__init__()<br><span class="hljs-comment"># 定义drop out</span><br>self.dropout = nn.Dropout(p=dropout)<br><span class="hljs-comment"># 计算pe编码</span><br>pe = torch.zeros(max_len, d_model) <span class="hljs-comment"># 建立空表，每行代表一个词的位置，每列代</span><br>表一个编码位<br>position = torch.arange(<span class="hljs-number">0</span>, max_len).unsqueeze(<span class="hljs-number">1</span>) <span class="hljs-comment"># 建个arrange表示词的</span><br>位置以便公式计算，size=(max_len,<span class="hljs-number">1</span>)<br>div_term = torch.exp(torch.arange(<span class="hljs-number">0</span>, d_model, <span class="hljs-number">2</span>) * <span class="hljs-comment"># 计算公式中</span><br><span class="hljs-number">10000</span>**（2i/d_model)<br>-(math.log(<span class="hljs-number">10000.0</span>) / d_model))<br>pe[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(position * div_term) <span class="hljs-comment"># 计算偶数维度的pe值</span><br>pe[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(position * div_term) <span class="hljs-comment"># 计算奇数维度的pe值</span><br>pe = pe.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-comment"># size=(1, L, d_model)，为了后续与word_embedding</span><br>相加,意为batch维度下的操作相同<br>self.register_buffer(<span class="hljs-string">&#x27;pe&#x27;</span>, pe) <span class="hljs-comment"># pe值是不参加训练的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br><span class="hljs-comment"># 输入的最终编码 = word_embedding + positional_embedding</span><br>x = x + Variable(self.pe[:, :x.size(<span class="hljs-number">1</span>)],requires_grad=<span class="hljs-literal">False</span>) <span class="hljs-comment">#size =</span><br>[batch, L, d_model]<br><span class="hljs-keyword">return</span> self.dropout(x) <span class="hljs-comment"># size = [batch, L, d_model]</span><br></code></pre></td></tr></table></figure><h2 id="Cross-attention和Self-attention的区别"><a href="#Cross-attention和Self-attention的区别" class="headerlink" title="Cross-attention和Self-attention的区别"></a>Cross-attention和Self-attention的区别</h2><p>Cross-attention也就是代码中的encoder-decoder-attention</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> self.self_attention:<br>    q = self.q_proj(query)<br>    k = self.k_proj(query)<br>    v = self.v_proj(query)<br><span class="hljs-keyword">elif</span> self.encoder_decoder_attention:<br>    <span class="hljs-comment"># encoder-decoder attention</span><br>    q = self.q_proj(query)<br>    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">assert</span> value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>        k = v = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> self.beam_size &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> bsz == key.size(<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># key is [T, bsz*beam_size, C], reduce to [T, bsz, C]</span><br>            key = key.view(key.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>, self.beam_size, key.size(<span class="hljs-number">2</span>))[<br>                :, :, <span class="hljs-number">0</span>, :<br>            ]<br>            <span class="hljs-keyword">if</span> key_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                key_padding_mask = key_padding_mask.view(<br>                    -<span class="hljs-number">1</span>, self.beam_size, key_padding_mask.size(<span class="hljs-number">1</span>)<br>                )[:, <span class="hljs-number">0</span>, :]<br>        k = self.k_proj(key)<br>        v = self.v_proj(key)<br><br></code></pre></td></tr></table></figure><p>交叉注意力用于decoder中使其当前状态和encoder的output交互。decoder作为Q encoder_output为K、V</p><h2 id="BLEU指标"><a href="#BLEU指标" class="headerlink" title="BLEU指标"></a>BLEU指标</h2><h3 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h3><p>BLEU指标采用N-gram的匹配机制，就是比较译文和参考译文之间n组词之间相似的一个占比。</p><img src="../images/$%7Bfiilename%7D/626346-20171016222256849-1802531988.png" alt="img" style="zoom:;" /><p>译文分为4个3-gram词组 有2个命中参考译文 则该译文的3-gram匹配度为2&#x2F;4</p><h3 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h3><p>机器译文：the the the the </p><p>人工译文：The cat is standing on the ground</p><p>1-gram的匹配度为1但是the在参考译文只出现了2次，如果匹配度直接用1很显然是不合理的。</p><p>$Count_{clip}&#x3D;min(Count,Max_Ref_Count)$前者为译文中出现的次数，后者为参考译文中的最大次数，取最小值限制上文的情况（即最多不超过参考译文中该单词的频率）</p><p>计算每个N-gram的公式如下：</p><p>人工译文$s_j$</p><p>机器译文$c_i$</p><p>$h_k(c_i)$表示第k个词组在翻译译文$c_i$出现的次数</p><p>$h_k(s_{i,j})$表示第k个词组在标准答案$s_{i,j}$出现的次数$</p><p><img src="/../images/$%7Bfiilename%7D/image-20240626192902992.png" alt="image-20240626192902992"></p><h3 id="惩罚因子"><a href="#惩罚因子" class="headerlink" title="惩罚因子"></a>惩罚因子</h3><p>N-gram的匹配度可能会随着句子长度变短而变好，因此会存在一个问题，一个翻译引擎只翻译出部分句子且比较准确，那么匹配度依然很高。因此要引入长度惩罚因子</p><img src="../images/$%7Bfiilename%7D/image-20240626194522680.png" alt="image-20240626194522680" style="zoom: 50%;" /><p>$l_c$代表机器译文的长度</p><p>$l_s$代表参考译文的有效长度</p><p>当机器译文较长的时候不惩罚</p><p>最终公式</p><img src="../images/$%7Bfiilename%7D/image-20240626194923426.png" alt="image-20240626194923426" style="zoom:50%;" /><p>BLEU采用均匀加权 $W_n&#x3D;1&#x2F;N$</p><p>N最大为4 即最多4-gram</p><p>参考ca<a href="https://blog.csdn.net/qq_30232405/article/details/104219396">BLEU算法（例子和公式解释）-CSDN博客</a></p><h2 id="beam"><a href="#beam" class="headerlink" title="beam"></a>beam</h2><p>Beam Search</p><p>Greedy Search问题在于在每一步它只选择得分最高的top 1单词，假设被它忽略的top 2单词带来的后面一系列单词使得整个序列的得分反而更高，则Greedy Search就不会得到最合理的解码结果。<br>Beam Search集束搜索是Greedy Search的改进版，它拓展了Greedy Search在每一步的搜索空间，每一步保留当前最优的K个候选，一定程度上缓解了Greedy Search的问题，令K为Beam Size代表束宽，Beam Size是一个超参数，它决定搜索空间的大小，<strong>越大搜索结果越接近最优，但是搜索的复杂度也越高</strong>，当Beam Size等于1的时候，Beam Search退化为Greedy Search。</p><p>Beam Search单条候选序列停止条件细分有两种情况，分别是</p><ul><li>候选序列解码到停止</li><li>早停，候选序列得分已经低于已解码完的当前最优序列</li></ul><p><img src="/../images/$%7Bfiilename%7D/image-20240626195444349.png" alt="image-20240626195444349"></p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ol><li>首先配置环境、下载fairseq</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">conda create -n &#123;YOUR_ENV_NAME&#125; python=<span class="hljs-number">3</span>.<span class="hljs-number">9</span><br>conda activate &#123;YOUR_ENV_NAME&#125;<br>git clone https://github.com/pytorch/fairseq<br><span class="hljs-built_in">cd</span> fairseq<br>pip install --editable ./<br></code></pre></td></tr></table></figure><ol start="2"><li>下载数据并预处理 注意bash命令需要在git bash中找到对应的目录运行，遇到了下载失败的问题，<a href="###bash%E5%91%BD%E4%BB%A4%E7%9A%84%E9%97%AE%E9%A2%98">解决方案</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Download and prepare the data</span><br><span class="hljs-built_in">cd</span> examples/translation/<br>bash prepare-iwslt14.sh<br><span class="hljs-built_in">cd</span> ../..<br></code></pre></td></tr></table></figure><ol start="3"><li>数据下载完成后 使用如下命令进行数据处理，要将$TEXT替换为TEXT的值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">TEXT=examples/translation/iwslt14.tokenized.de-en<br>fairseq-preprocess --source-lang de --target-lang en --trainpref examples/translation/iwslt14.tokenized.de-en/train2k --validpref examples/translation/iwslt14.tokenized.de-en/valid --testpref examples/translation/iwslt14.tokenized.de-en/test --destdir data-bin/iwslt14.tokenized.de-en --workers 20<br></code></pre></td></tr></table></figure><ol start="4"><li>为了节省时间，只抽取两千数据训练。然后运行下列命令进行训练</li></ol><p>注意用set命令设置CUDA</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> CUDA_VISIBLE_DEVICES=<span class="hljs-number">0</span> <br>fairseq-train data-bin/iwslt14.tokenized.de-en --arch transformer_iwslt_de_en --share-decoder-input-output-embed --optimizer adam --adam-betas &quot;(<span class="hljs-number">0</span>.<span class="hljs-number">9</span>, <span class="hljs-number">0</span>.<span class="hljs-number">98</span>)&quot; --clip-norm <span class="hljs-number">0</span>.<span class="hljs-number">0</span> --lr <span class="hljs-number">5</span>e-<span class="hljs-number">4</span> --lr-scheduler inverse_sqrt --warmup-updates <span class="hljs-number">4000</span> --dropout <span class="hljs-number">0</span>.<span class="hljs-number">3</span> --weight-decay <span class="hljs-number">0</span>.<span class="hljs-number">0001</span> --max-tokens <span class="hljs-number">4096</span> --eval-bleu --eval-bleu-args &quot;&#123;\&quot;beam\&quot;: <span class="hljs-number">5</span>, \&quot;max_len_a\&quot;: <span class="hljs-number">1</span>.<span class="hljs-number">2</span>, \&quot;max_len_b\&quot;: <span class="hljs-number">10</span>&#125;&quot; --eval-bleu-detok moses --eval-bleu-remove-bpe --eval-bleu-<span class="hljs-built_in">print</span>-samples --best-checkpoint-metric bleu --maximize-best-checkpoint-metric<br></code></pre></td></tr></table></figure><p>遇到了Cython组件出错的问题，<a href="###Cython%E9%97%AE%E9%A2%98">解决方案</a></p><ol start="5"><li>进行推理</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">fairseq-generate data-bin/iwslt14.tokenized.de-en --<span class="hljs-built_in">path</span> checkpoints/checkpoint_best.pt --batch-size <span class="hljs-number">128</span> --beam <span class="hljs-number">5</span> --remove-bpe<br></code></pre></td></tr></table></figure><p>遇到了Mask类型未定义问题，<a href="###Mask%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98">解决方案</a></p><ol start="6"><li>得到结果</li></ol><p>BLEU4为得分</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h3 id="bash命令的问题"><a href="#bash命令的问题" class="headerlink" title="bash命令的问题"></a>bash命令的问题</h3><p>wget无法使用，通过下文下载：<a href="https://blog.csdn.net/aidijava/article/details/127114543">【Git】解决Git Bash无法使用tree、zip、wget等命令_git bash zip-CSDN博客</a></p><p>修改prepare-iwslt14.sh，运行后可以正常下载数据。</p><p> 6-10 13-17有添加 46有修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><br><span class="hljs-comment">#!/usr/bin/env bash</span><br><span class="hljs-comment"># Adapted from https://github.com/facebookresearch/MIXER/blob/master/prepareData.sh</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Cloning Moses github repository (for tokenization scripts)...&#x27;</span><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">&quot;mosesdecoder&quot;</span> ]; <span class="hljs-keyword">then</span><br>  git <span class="hljs-built_in">clone</span> https://github.com/moses-smt/mosesdecoder.git<br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Moses directory already exists. Skipping clone.&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Cloning Subword NMT repository (for BPE pre-processing)...&#x27;</span><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">&quot;subword-nmt&quot;</span> ]; <span class="hljs-keyword">then</span><br>  git <span class="hljs-built_in">clone</span> https://github.com/rsennrich/subword-nmt.git<br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Subword NMT directory already exists. Skipping clone.&quot;</span><br><span class="hljs-keyword">fi</span><br><br>SCRIPTS=mosesdecoder/scripts<br>TOKENIZER=<span class="hljs-variable">$SCRIPTS</span>/tokenizer/tokenizer.perl<br>LC=<span class="hljs-variable">$SCRIPTS</span>/tokenizer/lowercase.perl<br>CLEAN=<span class="hljs-variable">$SCRIPTS</span>/training/clean-corpus-n.perl<br>BPEROOT=subword-nmt/subword_nmt<br>BPE_TOKENS=10000<br><br>URL=<span class="hljs-string">&quot;http://dl.fbaipublicfiles.com/fairseq/data/iwslt14/de-en.tgz&quot;</span><br>GZ=de-en.tgz<br><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$SCRIPTS</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Please set SCRIPTS variable correctly to point to Moses scripts.&quot;</span><br>    <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br><br>src=de<br>tgt=en<br>lang=de-en<br>prep=iwslt14.tokenized.de-en<br>tmp=<span class="hljs-variable">$prep</span>/tmp<br>orig=orig<br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$orig</span> <span class="hljs-variable">$tmp</span> <span class="hljs-variable">$prep</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Downloading data from <span class="hljs-variable">$&#123;URL&#125;</span>...&quot;</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$orig</span><br>wget <span class="hljs-string">&quot;<span class="hljs-variable">$URL</span>&quot;</span> -O <span class="hljs-variable">$GZ</span><br></code></pre></td></tr></table></figure><h3 id="Cython问题"><a href="#Cython问题" class="headerlink" title="Cython问题"></a>Cython问题</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 无法调用numpy<br><span class="hljs-function">ImportError: <span class="hljs-title">numpy.core.multiarray</span> <span class="hljs-title">failed</span> <span class="hljs-title">to</span> <span class="hljs-title">import</span> (<span class="hljs-title">auto</span>-<span class="hljs-title">generated</span> <span class="hljs-title">because</span> <span class="hljs-title">you</span> <span class="hljs-title">didn</span>&#x27;<span class="hljs-title">t</span> <span class="hljs-title">call</span> &#x27;<span class="hljs-title">numpy.import_array</span>()&#x27; <span class="hljs-title">after</span> <span class="hljs-title">cimporting</span> <span class="hljs-title">numpy</span>; <span class="hljs-title">use</span> &#x27;&lt;<span class="hljs-title">void</span>&gt;<span class="hljs-title">numpy._import_array</span>&#x27; <span class="hljs-title">to</span> <span class="hljs-title">disable</span> <span class="hljs-title">if</span> <span class="hljs-title">you</span> <span class="hljs-title">are</span> <span class="hljs-title">certain</span> <span class="hljs-title">you</span> <span class="hljs-title">don</span>&#x27;<span class="hljs-title">t</span> <span class="hljs-title">need</span> <span class="hljs-title">it</span>).</span><br><span class="hljs-function"># <span class="hljs-title">cython</span>组件出错</span><br><span class="hljs-function"><span class="hljs-title">ImportError</span>: <span class="hljs-title">Please</span> <span class="hljs-title">build</span> <span class="hljs-title">Cython</span> <span class="hljs-title">components</span> <span class="hljs-title">with</span>: <span class="hljs-title">python</span> <span class="hljs-title">setup.py</span> <span class="hljs-title">build_ext</span> --<span class="hljs-title">inplace</span></span><br></code></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pip install <span class="hljs-comment">--upgrade cython</span><br>cd <span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/fairseq<br>python setup.py build_ext <span class="hljs-comment">--inplace</span><br></code></pre></td></tr></table></figure><p>同时在\fairseq\fairseq\data\data_utils_fast.pyx中添加手动引用np</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">cimport numpy <span class="hljs-keyword">as</span> np<br>np.import_array()<br></code></pre></td></tr></table></figure><h3 id="Mask类型定义问题"><a href="#Mask类型定义问题" class="headerlink" title="Mask类型定义问题"></a>Mask类型定义问题</h3><p>关键报错如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">File</span> <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\a</span>naconda3<span class="hljs-char escape_">\e</span>nvs<span class="hljs-char escape_">\t</span>ransformer\lib\site-packages<span class="hljs-char escape_">\f</span>airseq\modules<span class="hljs-char escape_">\t</span>ransformer_layer.py&quot;</span>, <span class="hljs-variable">line</span> <span class="hljs-number">319</span>, <span class="hljs-keyword">in</span> forward<br>    <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-variable">torch</span>.<span class="hljs-variable">_transformer_encoder_layer_fwd</span>(<br><span class="hljs-title class_">RuntimeError</span>: <span class="hljs-title class_">Mask</span> <span class="hljs-title class_">Type</span> <span class="hljs-variable">should</span> <span class="hljs-variable">be</span> <span class="hljs-variable">defined</span><br></code></pre></td></tr></table></figure><p>解决方法</p><p>找到\anaconda3\envs\transformer\lib\site-packages\fairseq\modules\transformer_layer.py</p><p>在forward中加入</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">self.can_use_fastpath=<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>有点作弊的方法，如果有其他方法不建议使用这个。但是在google colab上可以正常运行，本地可能是环境的问题。</p><p>然后又遇到了输出的类型不对的问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AssertionError</span>: expecting key_padding_mask shape of (<span class="hljs-number">5</span>, <span class="hljs-number">128</span>), but got torch.Size([<span class="hljs-number">128</span>, <span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>解决方法 在self.can_use_fastpath&#x3D;False之后 会转到else中运行，在else中加入</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> encoder_padding_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> encoder_padding_mask.shape != (x.size(<span class="hljs-number">1</span>), x.size(<span class="hljs-number">0</span>)):<br>            encoder_padding_mask = encoder_padding_mask.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deep learning</tag>
      
      <tag>Attention</tag>
      
      <tag>Transformer</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer</title>
    <link href="/2024/06/24/Transformer/"/>
    <url>/2024/06/24/Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><h3 id="心理学基础"><a href="#心理学基础" class="headerlink" title="心理学基础"></a>心理学基础</h3><p>动物在复杂环境下关注值得注意的带你</p><p>人类能够根据随意线索和不随意线索选择注意点</p><h2 id="注意力机制的发展"><a href="#注意力机制的发展" class="headerlink" title="注意力机制的发展"></a>注意力机制的发展</h2><p>首先是从传统的RNN模型得来的Encoder-Decoder（两个RNN）模型，是包含时序的（$s_0$-&gt;$s_1$…）但是由于前面的所有输入$X_i$，无论多长都只能压缩成统一长度的编码c，导致翻译的精度下降。</p><img src="../images/$%7Bfiilename%7D/image-20240625161804200.png" alt="image-20240625161804200" style="zoom:50%;" /><p>而Attention机制通过在不同时间输入不同的c来解决这个问题，而$\alpha$就是输入的权重。以$c_1$的视角来看，$\alpha_{11}\  \alpha_{12}\  \alpha_{13}$就是$c_1$对于输入$X_i$的编码$S_i$的注意力。</p><p>引入Attention之后打破了每一时刻只能用单一的编码c的限制，模型可以动态地看到全局的信息将注意力集中到对当前的任务（比如翻译）最重要的编码$s_i$上。</p><img src="../images/$%7Bfiilename%7D/image-20240625162306039.png" alt="image-20240625162306039" style="zoom:50%;" /><p>既然Attention机制已经对全部的输入进行打分，那RNN的时序就没什么用了，于是将时序去掉，就得到了Self-Attention。</p><img src="../images/$%7Bfiilename%7D/image-20240625163328593.png" alt="image-20240625163328593" style="zoom:50%;" /><img src="../images/$%7Bfiilename%7D/27976b34f7695aabe3fbcbe245b47cbe.png" alt="img" style="zoom:50%;" /><img src="../images/$%7Bfiilename%7D/image-20240625172021697.png" alt="image-20240625172021697" style="zoom:50%;" /><p>上面是attention的公式 </p><ol><li>通过softmax求出权重</li><li>求hidden state加权和</li></ol><h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>transformer的网络结构 由6个encoder和decoder堆叠而成</p><img src="../images/$%7Bfiilename%7D/image-20240625172442378.png" alt="image-20240625172442378" style="zoom:50%;" /><p>先放大其中一层的Encoder-Decoder</p><img src="../images/$%7Bfiilename%7D/image-20240625185817650.png" alt="image-20240625185817650" style="zoom:50%;" /><p>Encoder中有两个层-注意力层和前馈层</p><h2 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h2><p>首先看注意力层，下图是Self-Attention的结构：</p><img src="../images/$%7Bfiilename%7D/image-20240625190016359.png" alt="image-20240625190016359" style="zoom:50%;" /><p>$$Attention(Q,K,V)&#x3D;softmax(\frac{QK^T}{\sqrt{d_k}})V$$</p><p>Query-查询，$Q&#x3D;W^QX$</p><p>Key-索引，$K&#x3D;W^KX$</p><p>V-内容，$V&#x3D;W^VX$</p><p>都是由输入X通过线性变换得到的矩阵，其中$W^Q,W^K,W^V$都是可学习的矩阵。</p><p>为了更好地理解这三个参数，引用<a href="%E3%80%90%E5%9C%A8%E7%BA%BF%E6%BF%80%E6%83%85%E8%AE%B2%E8%A7%A3transformer&Attention%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%91https://www.bilibili.com/video/BV1y44y1e7FW?vd_source=1abb260791c1703ab2112e23e9c6fdd6">狗中赤兔的讲解</a>（PS：视频太好看了 使我的attention旋转）：</p><p>有一个海王，他有N个备胎，他想要从备胎中找出最符合自己期望的，分配注意力。Q表示期望，但是海外选备胎的同时，备胎也会看他的条件，用K来表示他的条件。被匹配到的备胎就是V。每个人都有自己的一套QKV，当海王开始选择自己的备胎时，备胎的K和海王的Q相似度更高的说明这个备胎更符合海王的择偶标准</p><p>$softmax(QK^T)$这个矩阵运算是在算每个行向量的相关性，softmax求得权重矩阵。</p><p>根据权重矩阵就可以得到这个海王所需要关注的备胎。也有理想型是自己的情况，这个海王最需要关心的是自己。</p><p>最后除以$\sqrt{d_k}$保持梯度稳定防止梯度消失。</p><p>结果如下：</p><p><img src="/../images/$%7Bfiilename%7D/image-20240625231753685.png" alt="image-20240625231753685"></p><p>最后再与V相乘（也就是加权）就是完整的自注意力的原理。</p><img src="../images/$%7Bfiilename%7D/image-20240625231942225.png" alt="image-20240625231942225" style="zoom:50%;" /><p><img src="/../images/$%7Bfiilename%7D/image-20240625232849469.png" alt="image-20240625232849469"></p><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><p>每个注意力头使用不同的线性变换，这意味着它们可以从输入序列的不同子空间中学习不同的特征关联。这样一来，模型可以通过多个注意力头同时关注输入序列的不同方面，例如语法结构、语义角色、主题转移等。</p><p>通过多个注意力头，模型可以学习到更丰富的上下文信息，每个头可能关注输入的不同特征，这些特征综合起来可以更全面地理解和处理输入序列。</p><p>从不同角度捕捉数据的多样性，增强了模型对复杂序列任务的理解和泛化能力。</p><p><img src="/../images/$%7Bfiilename%7D/image-20240625233208205.png" alt="image-20240625233208205"></p><p>在进行Multi-Head Attention计算之后，计算的结果需要进行 Add&amp;Norm操作。</p><img src="../images/$%7Bfiilename%7D/image-20240625233814260.png" alt="image-20240625233814260" style="zoom:50%;" /><p>Add就是将当前层的计算结果和输入X相加（原理借鉴了残差网络，目的是防止退化）</p><p>Norm是layer normalization，对向量进行标准化加速收敛。</p><p>接下来放入将结果输入Feed Forward这个两层的全连接层进行特征提取，Encoder的任务就完成了。</p><h2 id="Masked"><a href="#Masked" class="headerlink" title="Masked"></a>Masked</h2><p>Decoder中第一层的注意力中多了Masked</p><p><img src="/../images/$%7Bfiilename%7D/image-20240625234357816.png" alt="image-20240625234357816"></p><p>Mask的作用：1.对于长度超出期望的序列只保留期望长度的内容，未达到期望长度的填充0，填充的位置无意义，不希望分配注意力，因此给填充的位置加上负无穷。在计算注意力的时候会用到softmax函数，加上过负无穷的位置会被softmax处理为0，这个操作叫padding mask。</p><p>2.在翻译的时候需要按顺序翻译，先翻译前i个再翻译第i+1个，要阻止模型注意到还不该翻译的词，也就是每个单词之能注意到自己和自己之前的单词。</p><h2 id="Encoder-Decoder-Attention"><a href="#Encoder-Decoder-Attention" class="headerlink" title="Encoder-Decoder Attention"></a>Encoder-Decoder Attention</h2><p>Decoder中的第二个Multi-Head Attention并不是Self-Attention，因为他的QKV矩阵不是通过输入X得到的，K、V来自Encoder的输出Q来自Decoder第一层的输出。</p><h2 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h2><p>由于翻译的时候词序是很重要的，比如狗咬我和我咬狗，虽然单词一样但是顺序不同，意思也不同，而transformer没有采用RNN，难道就不能捕获序列信息了吗？</p><p>可以在Encoder外对进行Position Embedding，在将输入的文字编码成词向量的时候结合上单词的位置信息，就可以学习词序信息了。</p><img src="../images/$%7Bfiilename%7D/image-20240626132655843.png" alt="image-20240626132655843" style="zoom:50%;" /><p>PE是如何计算出来的呢？</p><p>$$PE_{(pos,2i)}&#x3D;sin(pos&#x2F;10000^{2i&#x2F;d_{model}})$$</p><p>$$PE_{(pos,2i+1)}&#x3D;cos(pos&#x2F;10000^{2i&#x2F;d_{model}})$$</p><p>$d_{model}&#x2F;h&#x3D;d_k&#x3D;d_v$</p><p>$i\in[0,\frac{d_{model}}{2}-1]$</p><p>PE的计算结果是一个行数与序列数相等，列数与模型维度相等的矩阵–这样刚好每次取出一行来与$x_i$相加。</p><p>使用sin为偶数维度编码 cos为奇数维度编码</p><p>使用三角函数的公式</p><img src="../images/$%7Bfiilename%7D/image-20240626134022126.png" alt="image-20240626134022126" style="zoom:50%;" /><p>可以得到</p><p><img src="/../images/$%7Bfiilename%7D/image-20240626134107054.png" alt="image-20240626134107054"></p><p>这样pos+k位置的位置向量，可以表示为pos位置和k位置的位置向量的2i与2i+1的线性组合。这就意味着位置向量中蕴含了相对位置信息。</p><p><begin>我 是 狗<end></p><p>pos&#x3D;0     1   2   3    4</p><h2 id="OutPut"><a href="#OutPut" class="headerlink" title="OutPut"></a>OutPut</h2><p>做一次线性变换再通过词典输出概率最大的单词即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/149490072">Attention 机制超详细讲解(附代码) - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/magicyangjay111/article/details/132634186">解码注意力Attention机制：从技术解析到PyTorch实战_attention代码pytorch-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_42475060/article/details/121101749">【超详细】【原理篇&amp;实战篇】一文读懂Transformer-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42533357/article/details/136888781">【NLP】多头注意力（Multi-Head Attention）的概念解析_多头注意力层-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/347678607">(26 封私信 &#x2F; 81 条消息) 如何理解Transformer论文中的positional encoding，和三角函数有什么关系？ - 知乎 (zhihu.com)</a></p><p>【Transformer使我快乐（上下）】<a href="https://www.bilibili.com/video/BV1E44y1Y7B4?vd_source=1abb260791c1703ab2112e23e9c6fdd6">https://www.bilibili.com/video/BV1E44y1Y7B4?vd_source=1abb260791c1703ab2112e23e9c6fdd6</a></p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deep learning</tag>
      
      <tag>Attention</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Meta-Learning</title>
    <link href="/2024/06/24/Meta-learning/"/>
    <url>/2024/06/24/Meta-learning/</url>
    
    <content type="html"><![CDATA[<p>先看一下Meta-Learning和Machine-Learning的区别</p><p><img src="/../images/$%7Bfiilename%7D/v2-23b952fb974edeffa4e28d0065440227_1440w.webp" alt="img"></p><p>主要区别就是Meta-Learning是为了让机器学会学习，也就是通过一系列任务的训练，获取一组更好的模型初始化参数（让模型学会初始化），使其能够在小规模数据上迅速收敛并完成Fine-Tune。而传统的机器学习就是寻找当前任务的参数。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>元学习中要准备许多任务进行学习，每个任务都有自己的训练集和测试集。</p><p>以下为一个任务的示例：</p><p><em>假如要进行N-ways K-shot的图像分类任务，也就是做N个分类，每个分类下面有K张图片的任务。</em></p><p>我们需要构建很多个这样的任务，并且将其分为训练任务(Train Task)和测试任务(Test Task)。每个任务里面都有自己的训练数据(Support Set)，测试数据(Query Set)。</p><p>用多个训练任务训练之后，在测试任务上测试性能</p><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><ul><li>MAML的执行与model pretraining &amp; transfer learning的区别？</li></ul><p><img src="/../images/$%7Bfiilename%7D/v2-94e03adc2c481edf670f04da68d94e13_1440w.webp" alt="img"></p><p>Meta-Learning的L来源于训练任务上网络参数更新过一次之后的$\hat{\theta}^m$。基于这个$\hat{\theta}^m$使用Query Set计算该任务的loss–$l^m(\hat{\theta}^m)$并计算$l^m(\hat{\theta}^m)$对$\hat{\theta}^m$的梯度。</p><p>而model-pretraining的L来源于同一个model的参数（只有一个）使用训练数据计算loss和梯度对model进行更新，如果有多个训练任务，他的所有梯度都会直接更新到model的参数上。</p><p>直观上理解就是model-pretraining最小化当前任务上的loss，希望找到一个在许多任务上表现较好的初始化参数。而Meta-Learning最小化每一个子任务训练一步之后，第二次计算出的loss，用第二步的梯度来更新meta网络。这表明Meta希望得到参数更新的潜力（希望得到能够快速收敛的初始化参数）我们不在意$\phi$在当前Task上的表现，在意模型在$\phi$上训练出来的表现如何。</p><ul><li><p>为何在meta网络赋值给具体训练任务（如任务m）后，要先更训练任务的参数，再计算梯度，更新meta网络</p></li><li><p>在更新训练任务的网络时，只走了一步，然后更新meta网络。为什么是一步，可以是多步吗？</p></li></ul><p>只更新一次，速度比较快，因为Meta-Learning中子任务很多，更新多次训练时间较久</p><p>初始化参数应用到具体任务中时 可以funetuning多次</p><p>few-shot learning的训练数据往往较少</p><h2 id="Fine-tune"><a href="#Fine-tune" class="headerlink" title="Fine-tune"></a>Fine-tune</h2><p>初始化直接利用训练好的初始化参数</p><p>只需要抽取目标task（一个）进行学习，不用形成batch。利用目标task的support set 训练</p><p>用query set进行测试</p><p>fine-tune没有二次梯度更新 直接使用第一次梯度计算的结果更新参数。</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deep learning</tag>
      
      <tag>Meta-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNN</title>
    <link href="/2024/06/22/GNN/"/>
    <url>/2024/06/22/GNN/</url>
    
    <content type="html"><![CDATA[<h1 id="GNN"><a href="#GNN" class="headerlink" title="GNN"></a>GNN</h1><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>图可以标识事物之间的相关关系，图在场景分析问题推理、推荐系统、风控 甚至无人汽车等多方面都有很大作用。</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>点：是特征，由特征向量表示</p><p>边：表示点之间的关系，也有特征。所有的边类型相同</p><p>图：全局的图，是向量</p><p>输入时要输入点的特征和邻接矩阵，邻接矩阵表示关系。 </p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>传统神经网络输入的规模固定（比如CNN输入图像一般都是256或512），在实际应用时，分子结构、或交通道路等点和边个数不同，难以使用传统的神经网络（resize强行改成相同效果可能不好）</p><p>GNN优势就是处理不规则数据</p><p>实际输入的邻接矩阵一般不是N*N的，而是2*N，即source-&gt;target </p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>在对点进行更新的时候，不仅要考虑自身的信息，还要考虑邻接的信息。</p><img src="../images/$%7Bfiilename%7D/image-20240622093307428.png" alt="image-20240622093307428" style="zoom: 50%;" /><p>如上图，在更新6的时候要考虑1，3，4的信息。以1为例，1要给6多少信息取决于可学习的权重参数w1和1本身的特征x1</p><p><strong>聚合</strong>：每个点提供的特征是由可学习的参数经过特征映射得到的结果：$$\bar{a_i}&#x3D;G({W_j \cdot x_j:j \in N_i})$$</p><p>最后将信息进行汇总：</p><p>$$h_i&#x3D;\sigma(W_1 \cdot h_i+\sum_{j \in N_i} \mathbf{W}_2 \cdot h_j)$$</p><p>前面表示自己的特征 后面表示邻居的特征，类似于加权。</p><p>邻接与当前点的关系有很多可选的方式：</p><img src="../images/$%7Bfiilename%7D/image-20240622094432513.png" alt="image-20240622094432513" style="zoom:50%;" /><p>输入矩阵不变，只更新点的特征。虽然每个点相邻的点不变，但是在不断更新中，可以得到与其他未连接点的关系，感受野不断变大。</p><p>输出的特征可用于分类、回归等。</p><h1 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h1><p>GCN与CNN差别较大：输入方面</p><p><img src="/../images/$%7Bfiilename%7D/image-20240622105736738.png" alt="image-20240622105736738"></p><h2 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h2><p>不需要全部都有标签，少量标签也可以训练，计算损失只用有标签的。适合半监督任务</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>GCN</tag>
      
      <tag>deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2024/03/20/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2024/03/20/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>结点由两个集合组成 两个集合内部没有边的图</p><p>也就是 存在一种方案 将结点划分成满足以上两个性质的集合</p><p>就是集合中的点都染成黑白 可以发现二分图中每条边都链接一个白点一个黑点</p><p>二分图不存在长为奇数的环（每条边都从一个集合走到另一个集合 偶数次才能回到同一个集合）</p><p>判断二分图：遍历：发现奇环就不是 否则是</p><h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p><a href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>匈牙利算法（ntr算法哈哈</p><p>就是每次先配对 然后下一个人来配对的时候 遍历她所有可以访问的点 如果没被访问过并且没有配对 就配对 如果有配对了 就看看上一个人能不能让出来 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n, m, e;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> vis[N], match[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, ne;<br>&#125; edge[N];<br><span class="hljs-type">int</span> head[N], idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[++idx] = &#123;b, head[a]&#125;;<br>    head[a] = idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = edge[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = edge[i].v;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">dfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i))<br>            ans++;<br>    &#125;<br>    cout &lt;&lt; ans;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xmuoj-AI2024春《算法设计与分析》第三次上机"><a href="#xmuoj-AI2024春《算法设计与分析》第三次上机" class="headerlink" title="xmuoj | AI2024春《算法设计与分析》第三次上机"></a><a href="https://www.xmuoj.com/contest/221/problem/6">xmuoj | AI2024春《算法设计与分析》第三次上机</a></h2><p>棋盘覆盖问题  可以当作二分图来写：</p><p>这样思考 每个块都把他当作是两个点合在一起 假设中间是一个白点 （2，2）那么（1，2）（2，1）（3，2）（2，3）都是黑点 然后建边 这样就类似与上面的二分图了  对白点或者黑点进行二分图查找就可以找到最大匹配（一个匹配就相当于是放了一块木板）</p><p>难点在于想到用二分图的做法来做这个题 还有怎样去建边 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-comment">//N开太大会超时</span><br><span class="hljs-type">int</span> b[N][N], vis[N * N], match[N * N];<span class="hljs-comment">// N*N才能过 不然数组太小</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N * N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 匈牙利算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">bfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n, t;<br>    cin &gt;&gt; n &gt;&gt; t;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        b[x][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!b[i][j])<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<br>                &#123;<br>                    <span class="hljs-type">int</span> x = dx[k] + i, y = dy[k] + j;<br>                    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= n &amp;&amp; !b[x][y])<br>                    &#123;<br>                        <span class="hljs-comment">// 建边</span><br>                        e[i * n + j].<span class="hljs-built_in">push_back</span>(x * n + y);<br>                        e[x * n + y].<span class="hljs-built_in">push_back</span>(i * n + j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((i ^ j) &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 枚举奇数结点</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-comment">//清空</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bfs</span>(i * n + j))<br>                ans++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Bipartite graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树&amp;树状数组</title>
    <link href="/2024/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>树状数组板子  注意在主函数中使用的时候 假设数组为n 需要写为BiTree(n + 1) 因为树状数组范围是1~n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="307-区域和检索-数组可修改-力扣（LeetCode）"><a href="#307-区域和检索-数组可修改-力扣（LeetCode）" class="headerlink" title="307. 区域和检索 - 数组可修改 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></h2><p>树状数组模板题 求不断修改数组的情况下的区间和 </p><p>主要是add函数 for循环结束条件是i &lt; tree.size()</p><p>然后修改了数组元素 要把数组变为val 然后tree里面的值也相应地要修改  修改了<strong>delta</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i ; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums):<span class="hljs-built_in">nums</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">tree</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-built_in">add</span>(i, nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> delta = val - nums[index];<br>        nums[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>; i &lt; tree.<span class="hljs-built_in">size</span>(); i += <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += delta;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(right + <span class="hljs-number">1</span>) - <span class="hljs-built_in">pre</span>(left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3072-将元素分配到两个数组中-II-力扣（LeetCode）"><a href="#3072-将元素分配到两个数组中-II-力扣（LeetCode）" class="headerlink" title="3072. 将元素分配到两个数组中 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></h2><p>离散化+树状数组</p><p>由于数的范围在1e9 太大了 数组开不下 所以要用离散化 为什么可以离散化  因为他只是为了比大小 那把数去重排序后映射到1~n的区间就行了  由于树状数组从1开始 建议映射也从1开始</p><p>用unordered_map把每个数映射</p><p>树状数组的部分 首先把板子打上</p><p>树状数组 存什么呢？ 别的题树状数组（如上题）可能是存前缀和 但是这个题目不一样 他主要是看前面有几个数比他大 我们又已经把数映射了 所以每次add的时候就加1表示index这个地方多了一个数 那么算出来的前缀和就是到1~n这个地方共有几个数 那就是比他小的数的个数  再用size减一下就得到比他大的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">resultArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">tmp</span>(nums);<br>        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>        tmp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()), tmp.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> m = tmp.<span class="hljs-built_in">size</span>(), n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)mp[tmp[i]] = i + <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt;a&#123;nums[<span class="hljs-number">0</span>]&#125;,b&#123;nums[<span class="hljs-number">1</span>]&#125;;<br>        <span class="hljs-function">BiTree <span class="hljs-title">t1</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>        t1.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">0</span>]], <span class="hljs-number">1</span>);<br>        t2.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-type">int</span> v = mp[nums[i]];<br>            <span class="hljs-type">int</span> gc1 = a.<span class="hljs-built_in">size</span>() - t1.<span class="hljs-built_in">pre</span>(v);<br>            <span class="hljs-type">int</span> gc2 = b.<span class="hljs-built_in">size</span>() - t2.<span class="hljs-built_in">pre</span>(v);<br><br>            <span class="hljs-keyword">if</span> (gc1 &gt; gc2 || (gc2 == gc1 &amp;&amp; a.<span class="hljs-built_in">size</span>() &lt;= b.<span class="hljs-built_in">size</span>()))<br>            &#123;<br>                a.<span class="hljs-built_in">push_back</span>(x);<br>                t1.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                b.<span class="hljs-built_in">push_back</span>(x);<br>                t2.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br>        a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1265-数星星-AcWing题库"><a href="#1265-数星星-AcWing题库" class="headerlink" title="1265. 数星星 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星 - AcWing题库</a></h2><p>主要是要理解树状数组的含义  update函数到底在加什么</p><p>像这种计数的题目 而不是求数组区间和  一般就是update(i, 1)表示在i处多了一个什么什么东西</p><p>然后还有这个题的细节 求ans[t.pre(x)]++要先求 因为如果先update的话 x这个地方就多了1（他自己）但是题目要求自己不算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp;(-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span> (<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>             sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">BiTree <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">32001</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        x ++;<br>        ans[t.<span class="hljs-built_in">pre</span>(x)]++;<br>        t.<span class="hljs-built_in">upd</span>(x, <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout&lt;&lt;ans[i]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>下面几道都是板子题 分别代表线段树处理不同的查询</p><h2 id="1270-数列区间最大值-AcWing题库（add-and-max）"><a href="#1270-数列区间最大值-AcWing题库（add-and-max）" class="headerlink" title="1270. 数列区间最大值 - AcWing题库（add and max）"></a><a href="https://www.acwing.com/problem/content/submission/code_detail/32357296/">1270. 数列区间最大值 - AcWing题库</a>（add and max）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll nums[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>];<br>ll n, m;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p * <span class="hljs-number">2</span>] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <br>        tree[p] = nums[l];<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bulid</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">bulid</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = <span class="hljs-built_in">max</span>(tree[p * <span class="hljs-number">2</span>], tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p=<span class="hljs-number">1</span>, ll cl=<span class="hljs-number">1</span>, ll cr=n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tree[p];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ll mid = cl + cr &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid), <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">bulid</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(a, b)&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add-and-sum"><a href="#add-and-sum" class="headerlink" title="add and sum"></a>add and sum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100010</span>;<br>ll nums[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>], n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(ll l=<span class="hljs-number">1</span>, ll r=n, ll p=<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        tree[p] = nums[l];<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bulid</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">bulid</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br>        <span class="hljs-keyword">if</span> (cr &gt; cl)<br>            mark[p] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">update</span>(l, r, d, p, cl, mid);<br>        <span class="hljs-built_in">update</span>(l, r, d, p, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p=<span class="hljs-number">1</span>, ll cl=<span class="hljs-number">1</span>, ll cr=n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tree[p];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2024/02/21/%E9%80%92%E5%BD%92/"/>
    <url>/2024/02/21/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="92-递归实现指数型枚举-AcWing题库"><a href="#92-递归实现指数型枚举-AcWing题库" class="headerlink" title="92. 递归实现指数型枚举 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/94/">92. 递归实现指数型枚举 - AcWing题库</a></h1><p><img src="/../images/$%7Bfiilename%7D/image-20240221101137855.png" alt="image-20240221101137855"></p><p>每个位置 选或不选  不选的话就直接dfs(u + 1)过去 选的话 就标记一下vis</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 边界 枚举到最后一个</span><br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[i])<br>                cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!vis[u])<br>    &#123;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>); <span class="hljs-comment">// 当前位置选</span><br>        vis[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<span class="hljs-comment">// 当前位置不选</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)a[i] = i;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="94-递归实现排列型枚举-AcWing题库"><a href="#94-递归实现排列型枚举-AcWing题库" class="headerlink" title="94. 递归实现排列型枚举 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/96/">94. 递归实现排列型枚举 - AcWing题库</a></h1><p><img src="/../images/$%7Bfiilename%7D/image-20240221112328817.png" alt="image-20240221112328817"></p><p>每个位置都需要填东西  关键是填什么 </p><p>那就是 每个位置选一个填 选过的就标记 下次从没标记的里面选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> used[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cout&lt;&lt;nums[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!used[i])<br>        &#123;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            nums[u] = i;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// </span><br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lqb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯&amp;分支限界(剪枝)</title>
    <link href="/2024/02/06/%E5%9B%9E%E6%BA%AF&amp;%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C(%E5%89%AA%E6%9E%9D)/"/>
    <url>/2024/02/06/%E5%9B%9E%E6%BA%AF&amp;%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C(%E5%89%AA%E6%9E%9D)/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="子集型（选或不选）"><a href="#子集型（选或不选）" class="headerlink" title="子集型（选或不选）"></a>子集型（选或不选）</h2><h3 id="6-买瓜-蓝桥云课-lanqiao-cn"><a href="#6-买瓜-蓝桥云课-lanqiao-cn" class="headerlink" title="6.买瓜 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3505/learning/?subject_code=1&group_code=5&match_num=14&match_flow=1&origin=cup">6.买瓜 - 蓝桥云课 (lanqiao.cn)</a></h3><p>DFS+剪枝 主要有几种情况 不需要继续进行搜索</p><p>当sum &gt; m的时候 必定不相等 当cnt &gt; mcnt的时候 不会是最小</p><p>比较难想的是 对所有的瓜进行排序 当买到第i个的时候 如果后面所有瓜加起来都不能到m 那也是必定不相等的 这个就相当于往后多看了一步 就不用去走了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">100</span>), <span class="hljs-built_in">suf</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> mcnt = <span class="hljs-number">2e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> sum, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= m)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (sum == m)<br>    &#123;<br>        mcnt = <span class="hljs-built_in">min</span>(cnt, mcnt);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == n || sum &gt; m || suf[i] + sum &lt; m)<br>    &#123;<br>      <span class="hljs-comment">//  cout&lt;&lt;sum&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i], cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum, cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i] / <span class="hljs-number">2</span>, cnt + <span class="hljs-number">1</span>);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 请在此输入您的代码</span><br>    <br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)cin&gt;&gt;nums[i];<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)suf[i] = suf[i + <span class="hljs-number">1</span>] + nums[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    mcnt == <span class="hljs-number">2e9</span> ? cout&lt;&lt; <span class="hljs-number">-1</span> : cout&lt;&lt;mcnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列型（选哪个）"><a href="#排列型（选哪个）" class="headerlink" title="排列型（选哪个）"></a>排列型（选哪个）</h2>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lqb</title>
    <link href="/2024/02/06/lqb/"/>
    <url>/2024/02/06/lqb/</url>
    
    <content type="html"><![CDATA[<h1 id="1-平方差-蓝桥云课-lanqiao-cn"><a href="#1-平方差-蓝桥云课-lanqiao-cn" class="headerlink" title="1.平方差 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3213/learning/?subject_code=1&group_code=5&match_num=14&match_flow=1&origin=cup">1.平方差 - 蓝桥云课 (lanqiao.cn)</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] != B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size())</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++) <br>            C[i + j] += A[i] * B[j];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t += C[i];<br>        C[i] = t % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<br>    string aa, bb, a, b;<br><br>    cin&gt;&gt;aa&gt;&gt;bb;<br><br>    <span class="hljs-keyword">if</span>(aa[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; aa.<span class="hljs-built_in">size</span>(); i++) a += aa[i];<br>    <span class="hljs-keyword">else</span> a = aa;<br>    <span class="hljs-keyword">if</span>(bb[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; bb.<span class="hljs-built_in">size</span>(); i++) b += bb[i];<br>    <span class="hljs-keyword">else</span> b = bb;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    A = <span class="hljs-built_in">mul</span>(A, A);<br>    B = <span class="hljs-built_in">mul</span>(B, B);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B)) C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>;<br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cout&lt;&lt;C[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1210-连号区间数-AcWing题库"><a href="#1210-连号区间数-AcWing题库" class="headerlink" title="1210. 连号区间数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1212/">1210. 连号区间数 - AcWing题库</a></h1><p>有点偏技巧 关键要找到规律 怎么样求出一个区间是否连号   只要一个区间的最大值和最小值的差 等于 区间的长度就是连号的区间   比如3 2 4    4 - 2 &#x3D; 2 区间长度（下标分别为0 1 2 ）为2 - 0 &#x3D; 2   </p><p>因为当排好序之后 连号数列为minn x1 x2… maxn 则 maxn - minn &#x3D; 区间长度</p><p>找到规律之后直接枚举 左右区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> maxn = nums[<span class="hljs-number">0</span>], minn = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; l++)<br>    &#123;<br>        maxn = minn = nums[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; n; r++)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, nums[r]);<br>            minn = <span class="hljs-built_in">min</span>(minn, nums[r]);<br>            <span class="hljs-keyword">if</span> (maxn - minn == r - l)cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反悔贪心</title>
    <link href="/2024/02/06/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/"/>
    <url>/2024/02/06/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>反悔贪心 就是 贪心 + 优先队列 </p><p>重点是找到 把什么放进优先队列中</p><h1 id="LCP-30-魔塔游戏-力扣（LeetCode）"><a href="#LCP-30-魔塔游戏-力扣（LeetCode）" class="headerlink" title="LCP 30. 魔塔游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/p0NxJO/description/">LCP 30. 魔塔游戏 - 力扣（LeetCode）</a></h1><p>每次都把扣的血直接扣掉 加的血直接加上 扣的血加入优先队列中（因为最好我只用移动扣血量最大的 移动一个就可以少移几个血量小的）</p><p>直到扣的血超过当前血量的时候 <strong>反悔</strong> 此时把 扣血最多的移动到最后（不用真的移动）然后把血加上 继续向后</p><p>本题放入优先队列的就是 扣血量 因为一个扣血大的可以抵很多个扣血少的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">magicTower</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll hp = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: nums)<br>        &#123;<br>            hp += x;<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(-x);<br>            <span class="hljs-keyword">if</span> (hp &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                cnt ++;<br>                hp += q.<span class="hljs-built_in">top</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h1 id="630-课程表-III-力扣（LeetCode）"><a href="#630-课程表-III-力扣（LeetCode）" class="headerlink" title="630. 课程表 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iii/description/">630. 课程表 III - 力扣（LeetCode）</a></h1><p>课程有两个衡量标准 第一是 持续时间  第二是结束时间 </p><p>结束时间早的应该先上  所以对结束时间进行排序 </p><p>而持续时间应该放入优先队列  因为 一个持续时间长的可以抵很多持续时间短的 所以尽量要上时间短的课  </p><p>当当前时间大于这节课的结束时间的时候 就可以考虑要不要<strong>反悔</strong> 去掉之前上的时间最长的课 改为上这节课（如果这节课的时长较短）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scheduleCourse</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; courses)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(courses.<span class="hljs-built_in">begin</span>(), courses.<span class="hljs-built_in">end</span>(), [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;a, vector&lt;<span class="hljs-type">int</span>&gt;b)<br>        &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;);<br><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: courses)<br>        &#123;<br>            <span class="hljs-type">int</span> dur = x[<span class="hljs-number">0</span>], last = x[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (now + dur &lt;= last)<br>            &#123;<br>                now += dur;<br>                q.<span class="hljs-built_in">push</span>(dur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; dur &lt; q.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                now -= q.<span class="hljs-built_in">top</span>() - dur;<br>                q.<span class="hljs-built_in">pop</span>();<br>                q.<span class="hljs-built_in">push</span>(dur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1642-可以到达的最远建筑-力扣（LeetCode）"><a href="#1642-可以到达的最远建筑-力扣（LeetCode）" class="headerlink" title="1642. 可以到达的最远建筑 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/furthest-building-you-can-reach/description/">1642. 可以到达的最远建筑 - 力扣（LeetCode）</a></h1><p>这题放入优先队列的是高度差 因为高度差高的地方用梯子可以省下很多砖头</p><p>梯子相当于是一次性无限量砖块 那么就要把梯子放在差距最高的几个地方 维护长为[梯子的数量]的优先队列 表示这几个要用梯子  后面一旦遇到比top大的高度差 就pop出来 换上这个 然后pop出来的就要用砖头 砖头不够的时候就退出 表示最后只能到这里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights, <span class="hljs-type">int</span> bricks, <span class="hljs-type">int</span> ladders)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>        <br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-type">int</span> sumH = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> deltaH = heights[i] - heights[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (deltaH &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(deltaH);<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &gt; ladders)<br>                &#123;<br>                    sumH += q.<span class="hljs-built_in">top</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sumH &gt; bricks)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2024/02/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/02/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z_function</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>      z[i] = z[i - l];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      z[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) l = i, r = i + z[i] - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>石子游戏</title>
    <link href="/2024/02/03/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/02/03/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><p>石子游戏（每次只能选择 前端或者后端的那一堆）的主要思想是 计算当前局面先手的人选择的那一堆 和 他留给另一个人的局面 从中选出最优解</p><p>f[i] [j]考虑区间 [l, r]之间双方都做最优选择  先手后手的最大分差是多少</p><h1 id="877-石子游戏-力扣（LeetCode）"><a href="#877-石子游戏-力扣（LeetCode）" class="headerlink" title="877. 石子游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏 - 力扣（LeetCode）</a></h1><p>dfs(i, j) 双指针表示当前可以取的前端和后端 然后每次取的时候 的好处为  <strong>当前先手取得的值减去留给对手的局面所能获得的值</strong>  </p><p>取i和取j两种选择 选较大的</p><p>注意当i&#x3D;&#x3D;j的时候为退出条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            dfs(i, j) 表示到当前局面先手的人 与另一个的差值</span><br><span class="hljs-comment">            当i==j的时候不用选 直接返回</span><br><span class="hljs-comment">            否则选择</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// int n = piles.size();</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;memo(n, vector&lt;int&gt;(n, -1));</span><br>        <span class="hljs-comment">// function&lt;int(int, int)&gt;dfs=[&amp;](int i, int j)-&gt;int</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     if (i == j)</span><br>        <span class="hljs-comment">//         return piles[i];</span><br>        <span class="hljs-comment">//     if (memo[i][j] != -1)</span><br>        <span class="hljs-comment">//         return memo[i][j];</span><br>            <br>        <span class="hljs-comment">//     memo[i][j] = max(piles[i] - dfs(i + 1, j), piles[j] - dfs(i, j - 1));</span><br>        <span class="hljs-comment">//     return memo[i][j];</span><br>        <span class="hljs-comment">// &#125;;</span><br>        <span class="hljs-comment">// return dfs(0, n - 1);</span><br><br>        <span class="hljs-type">int</span> n = piles.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            dp[i][i] = piles[i];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(piles[i] - dp[i + <span class="hljs-number">1</span>][j], piles[j] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1690-石子游戏-VII-力扣（LeetCode）"><a href="#1690-石子游戏-VII-力扣（LeetCode）" class="headerlink" title="1690. 石子游戏 VII - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/stone-game-vii/?envType=daily-question&envId=2024-02-03">1690. 石子游戏 VII - 力扣（LeetCode）</a></h1><p>这个和上一个有不同的地方 这个题每次是把剩余的全部加起来 所以dfs的时候要先计算出sum （注意每次加之前要先减去当前取的值）相当于dfs多出来一个变量sum</p><p>而动态规划写法不能这样  就只能先计算出<strong>区间和</strong> 每次加上区间和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoneGameVII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">/* dfs(i, j) 表示当前局面先手得分和后手的差距</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// int sum = 0;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     sum += nums[i];</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;memo(n, vector&lt;int&gt;(n, -1));</span><br>        <span class="hljs-comment">// function&lt;int(int, int, int)&gt;dfs=[&amp;](int i, int j, int now)-&gt;int</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     if(i == j)</span><br>        <span class="hljs-comment">//         return 0;</span><br>        <span class="hljs-comment">//     if (memo[i][j] != -1)</span><br>        <span class="hljs-comment">//         return memo[i][j];</span><br>            <br>        <span class="hljs-comment">//     memo[i][j] = max(now - nums[i] - dfs(i + 1, j, now - nums[i]), now - nums[j] - dfs(i, j - 1, now - nums[j]));</span><br>        <span class="hljs-comment">//     return memo[i][j];</span><br>        <span class="hljs-comment">// &#125;;</span><br>        <span class="hljs-comment">// return dfs(0, n - 1, sum);</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">sum</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 记录i到j的区间和  和前面的题目不一样的地方 区间和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == j)sum[i][j] = nums[i];<br>                <span class="hljs-keyword">else</span> sum[i][j] = sum[i][j - <span class="hljs-number">1</span>] + nums[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(sum[i + <span class="hljs-number">1</span>][j] - dp[i + <span class="hljs-number">1</span>][j], sum[i][j - <span class="hljs-number">1</span>] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2024/02/03/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/02/03/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="2055-蜡烛之间的盘子-力扣（LeetCode）"><a href="#2055-蜡烛之间的盘子-力扣（LeetCode）" class="headerlink" title="2055. 蜡烛之间的盘子 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/plates-between-candles/">2055. 蜡烛之间的盘子 - 力扣（LeetCode）</a></h1><p>其实只需要计算 每次查询的最前面的蜡烛和最后面的蜡烛 中间的盘子的数量 盘子的数量可以用前缀和来处理 （因为要频繁地查询 不能每次都数一遍 要直接用前缀和来求）</p><p>蜡烛的位置可以用二分查找来计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">platesBetweenCandles</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">qzh</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(q.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt;lz;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;|&#x27;</span>)lz.<span class="hljs-built_in">push_back</span>(i);<br>            qzh[i + <span class="hljs-number">1</span>] = qzh[i] + (s[i] == <span class="hljs-string">&#x27;*&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lz.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = q[i][<span class="hljs-number">0</span>], b = q[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = <span class="hljs-number">-1</span>, d = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = lz.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (mid &gt;= a) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(lz[r] &gt;= a)c = lz[r];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>            l = <span class="hljs-number">0</span>, r = lz.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (lz[mid] &lt;= b) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lz[r] &lt;= b) d = lz[r];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (c &lt;= d) ans[i] = qzh[d + <span class="hljs-number">1</span>] - qzh[c];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1236-递增三元组-AcWing题库"><a href="#1236-递增三元组-AcWing题库" class="headerlink" title="1236. 递增三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></h1><p>除了二分也可以用前缀和  比如b中的5  可以求出a中所有比5小的数 这时候就可以用哈希表＋前缀和 哈希表记录1 2 3 4 出现的次数 然后加起来 就可以得到比5小的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], b[N], c[N], cnt1[N], cnt2[N], qzh1[N], qzh2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>        cnt1[++a[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;b[i];<br>        b[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;c[i];<br>        cnt2[++c[i]]++;<br>    &#125;<br>    qzh1[<span class="hljs-number">0</span>] = cnt1[<span class="hljs-number">0</span>];<br>    qzh2[<span class="hljs-number">0</span>] = cnt2[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        qzh1[i] = qzh1[i - <span class="hljs-number">1</span>] + cnt1[i];<br>        qzh2[i] = qzh2[i - <span class="hljs-number">1</span>] + cnt2[i];<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> k = b[i];<br>        ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(qzh2[N - <span class="hljs-number">1</span>] - qzh2[k]) * qzh1[k - <span class="hljs-number">1</span>];<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2024/01/22/%E8%B4%AA%E5%BF%83/"/>
    <url>/2024/01/22/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1953-你可以工作的最大周数-力扣（LeetCode）"><a href="#1953-你可以工作的最大周数-力扣（LeetCode）" class="headerlink" title="1953. 你可以工作的最大周数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/description/">1953. 你可以工作的最大周数 - 力扣（LeetCode）</a></h2><p>假设按顺序排列 C1，C2… Cn</p><p>那么Cn &gt;&#x3D; Cn - 1 则Cn - 1 必定可以插在Cn的空里面 那Cn - 2就一定可以插在Cn - 1的空里（也可以插在别的数的空里） 所以前面的数是一定可以插入的</p><p>关键就在最后一个数 如果前面所有数都去插他的空 还不够的话 那后面的就不能用了</p><p>所以分两种情况 前n - 1个数的sum &gt; 最大数Cn则所有数都可以插入 答案为sum + Cn</p><p>否则 只有sum * 2 + 1个数可以（拿Cn去插 sum的空）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">numberOfWeeks</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; milestones)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> m = *<span class="hljs-built_in">max_element</span>(milestones.<span class="hljs-built_in">begin</span>(), milestones.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> rest = <span class="hljs-built_in">accumulate</span>(milestones.<span class="hljs-built_in">begin</span>(), milestones.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) - m;<br>        <span class="hljs-keyword">if</span> (m &gt; rest + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> rest * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> rest + m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="104-货仓选址-AcWing题库"><a href="#104-货仓选址-AcWing题库" class="headerlink" title="104. 货仓选址 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/106/">104. 货仓选址 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>尽量选在中间位置 比如1  2   6 9</p><p>选择在2 6 中间   距离和为 2x - 3 + 15 - 2x &#x3D; 12</p><p>选在6 9中间为 9 - x - 9 + 3x 并且x &gt; 6  sum  &gt; 12</p><p>所以在中间是最好的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        left += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> + n % <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        right += nums[i];<br>    &#125;<br>    cout&lt;&lt;right - left&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0填充-蓝桥云课-lanqiao-cn"><a href="#0填充-蓝桥云课-lanqiao-cn" class="headerlink" title="0填充 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3519/learning/">0填充 - 蓝桥云课 (lanqiao.cn)</a></h2><ul><li>3&#x2F;6</li></ul><p>贪心的策略 从0到n 一旦遇到了两两凑成一对的 就直接计入结果并且跳过i + 1</p><p>如果遇到？ 大概有这几种情况 0??1   0?可以 ?1 可以</p><p>??11    ??可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>  string s;<br>  cin&gt;&gt;s;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>] || s[i] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>)<br>      &#123;<br>          ans++;<br>          i++;<br>      &#125;<br>  &#125;<br>  cout&lt;&lt;ans;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-糖果传递-AcWing题库"><a href="#122-糖果传递-AcWing题库" class="headerlink" title="122. 糖果传递 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/124/">122. 糖果传递 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>[环形]均分纸牌问题</p><img src="../images/$%7Bfiilename%7D/image-20240302163447063.png" alt="image-20240302163447063" style="zoom:67%;" /><p>推公式：先设每个人要给左边的$x_i$个 从右边拿到$x_{i + 1}$个 （只需要给旁边的 因为就算跨着给 结果也是一样的 直接设只给旁边的好算） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], temp[N], c[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    ll sum = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>        sum += a[i];<br>    &#125;<br>    ll ave = sum / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        temp[i] = ave - a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>] = temp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        c[i] = c[i - <span class="hljs-number">1</span>] + temp[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(c, c + n);<br>    <span class="hljs-type">int</span> xn = c[n / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        ret += <span class="hljs-built_in">abs</span>(c[i] - xn);<br>    &#125;<br>    cout&lt;&lt;ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="112-雷达设备-AcWing题库"><a href="#112-雷达设备-AcWing题库" class="headerlink" title="112. 雷达设备 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/114/">112. 雷达设备 - AcWing题库</a></h2><ul><li>3&#x2F;11</li></ul><p>本来想这样贪心：先按x从小到大 相同x的y从大到小排序 不断选取最右边的值 但是有些情况不符合 <img src="../images/$%7Bfiilename%7D/image-20240302195003434.png" alt="image-20240302195003434" style="zoom:25%;" /></p><p>所以要先求出每个岛的探测区间 然后再按区间合并的方法来做</p><p>按右端点排序 排完序后如果一个区间的左端点小于last区间的右端点 那么就说明他们可以共用一个雷达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> r first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> l second</span><br>PII seg[<span class="hljs-number">100010</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> INF = <span class="hljs-number">1e10</span>, eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, d;<br>    cin &gt;&gt; n &gt;&gt; d;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span> (y &gt; d)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">sqrt</span>(d * d - y * y);<br>        seg[i] = &#123;x + len, x - len&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(seg, seg + n);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> last = -INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (seg[i].l &gt; last + eps)<br>        &#123;<br>            res++;<br>            last = seg[i].r;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1235-付账问题-AcWing题库"><a href="#1235-付账问题-AcWing题库" class="headerlink" title="1235. 付账问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1237/">1235. 付账问题 - AcWing题库</a></h2><p>求出平均值 当小于平均值的 时候  直接allin 当大于平均值的时候只需要给出平均值就行</p><p>关键在于不断地更新当前的平均值 </p><p>一开始想的贪心是 先把小于的全部给了 大于的把平均值给了 然后算差的钱的平均值 再从大的里面减 然后不够了再去… 这样要两层循环 是$O(n^2)$的 不行</p><p>可以对每一个数都更新一下当前的平均值 小于的全部给  但是由于小于平均值 这里要更新一下当前的平均值 因为这人给的不够 后面要多给   由于<strong>排序</strong>了 如果有人够了 就直接给平均值的钱就行 因为后面的必然够</p><p>注意同时计算sum</p><p>注意这题爆double了（哭   要用long double<img src="../images/$%7Bfiilename%7D/image-20240302205938546.png" alt="image-20240302205938546" style="zoom:25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">500010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> ave = s * <span class="hljs-number">1.0</span> / n ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> cur_ave = ave;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= cur_ave)<br>        &#123;<br>            s -= nums[i];<br>            sum += (ave - nums[i]) * (ave - nums[i]);<br>            cur_ave = s  * <span class="hljs-number">1.0</span> / (n - i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            sum += (cur_ave - ave) * (cur_ave - ave);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4llf&quot;</span>,<span class="hljs-built_in">sqrt</span>(sum / n));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1239-乘积最大-AcWing题库"><a href="#1239-乘积最大-AcWing题库" class="headerlink" title="1239. 乘积最大 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1241/">1239. 乘积最大 - AcWing题库</a></h2><ul><li>3&#x2F;7</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">k是奇数则 如果全是负数 结果为负</span><br><span class="hljs-comment">否则先选一个正数（最大的） 变为k是偶数的情况</span><br><span class="hljs-comment">k是偶数则答案必然是正的 看负数的个数 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span> , mod = <span class="hljs-number">1000000009</span> ;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n , k ;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br>    <span class="hljs-built_in">sort</span>(a,a + n);<br><br>    LL res = <span class="hljs-number">1</span> ; <span class="hljs-comment">//乘积初始化</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span> ;<span class="hljs-comment">//双指针初始化</span><br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span> ; <span class="hljs-comment">// 符号初始化</span><br><br>    <span class="hljs-comment">//由于4种情况除了 k 是奇数且 k &lt; n 的时候需要特判一下处理一下符号 ,其他的时候都可以转化为双指针做法</span><br>    <span class="hljs-comment">//k 是奇数是先选出最大的数, k-- 就是偶数,两边再同时取对,转化成相同的双指针做法</span><br>    <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> )<br>    &#123;<br>        res =  a[r]; <span class="hljs-comment">// 取出最大的一个数</span><br>        r -- ; <span class="hljs-comment">//右指针移动</span><br>        k -- ; <span class="hljs-comment">//个数减1</span><br><br>        <span class="hljs-keyword">if</span>(res &lt; <span class="hljs-number">0</span>) sign = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果最大值都是负数,就证明全是负数,那么符号要发生改变</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(k) <span class="hljs-comment">// 双指针做法</span><br>    &#123;<br>        LL x = (LL)a[l] * a[l + <span class="hljs-number">1</span>] , y = (LL)a[r] * a[r - <span class="hljs-number">1</span>];<span class="hljs-comment">//两边同时取对</span><br>        <span class="hljs-comment">//选择更大的一对,和归并排序思路相近</span><br>        <span class="hljs-keyword">if</span>(x * sign &gt; y * sign)<br>        &#123;<br>            res = x % mod * res % mod; <span class="hljs-comment">// 需要注意的是 :不可以写成(x * res) % mod ,也不可以写成是 res % mod * x % mod</span><br>                                       <span class="hljs-comment">// 因为x最大是 10^10，如果不先取模的话，和res相乘的结果最大是 10^19,会暴long long。            </span><br>            l += <span class="hljs-number">2</span>; <span class="hljs-comment">// 指针移动                                 </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            res = y % mod * res % mod; <br>            r -= <span class="hljs-number">2</span>; <br>        &#125;<br>        k -= <span class="hljs-number">2</span>; <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1247-后缀表达式-AcWing题库"><a href="#1247-后缀表达式-AcWing题库" class="headerlink" title="1247. 后缀表达式 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1249/">1247. 后缀表达式 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>一开始没读懂题意   后缀表达式关键在于他转换成中缀表达式 是可以随意添加括号的  所以说 根据负负得正的原则 我们可以将负数转化成正数 比如 -1 -2 -3   1 2 3   可以是1 +2+3-(-1-2-3)</p><p>贪心：先选最大的数作为基数 如果没有减号那就是全部相加 如果有一个减号 那就把所有负数变成正的  如果没有负的就要减去最小的正数   所以一开始直接减去最小的那个数 然后把1~n+m-1的数全部按绝对值加起来就可以</p><p>如果有多个减号  通过加括号 可以变成跟一个减号一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">300010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m + <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n + m + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = nums[n + m];<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        res -= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1248-灵能传输-AcWing题库"><a href="#1248-灵能传输-AcWing题库" class="headerlink" title="1248. 灵能传输 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1250/">1248. 灵能传输 - AcWing题库</a></h2><ul><li>3&#x2F;4</li></ul><p>太困难了 最后还是没看懂题解 但是学到了：</p><p>每次中间的给两边的能量 求最小的最大值  每次传输完能量后前缀和会由 s[i - 1] s[i] s[i + 1]变成s[i] s[i - 1] s[i + 1] 这就说明了所有的前缀和都可以任意排序 当顺序排序的时候差值最小 最大值就最小</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2024/01/18/%E4%BA%8C%E5%88%86/"/>
    <url>/2024/01/18/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="0求阶乘-蓝桥云课-lanqiao-cn"><a href="#0求阶乘-蓝桥云课-lanqiao-cn" class="headerlink" title="0求阶乘 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2145/learning/">0求阶乘 - 蓝桥云课 (lanqiao.cn)</a></h1><p>只有5 * 2 才能&#x3D;10 才可能出现0  由于2 必定比5多  只需要求5 的个数</p><p>二分法求到mid的时候前面有多少5 不断除以5就可以算出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll x;<br><span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (mid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret += mid / <span class="hljs-number">5</span>;<br>        mid /= <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin&gt;&gt;x;<br>    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">6e18</span>;<br>    ll res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        ll s = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (s &lt; x)<br>            l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(r) == x)<br>    cout&lt;&lt;r;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1236-递增三元组-AcWing题库"><a href="#1236-递增三元组-AcWing题库" class="headerlink" title="1236. 递增三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></h1><p>找这个三元组 主要是看中间一行 比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>就看B的5能和A结合几个 能和C结合几个</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">4</span> <br><span class="hljs-attribute">5</span> <br>  <span class="hljs-attribute">6</span> <span class="hljs-number">7</span>  <br></code></pre></td></tr></table></figure><p>结果为2 * 2 &#x3D; 4  </p><p>所以只需要对B的每一个数在A   C两个数组内进行二分 求出比他小的第一个数 和比他大的第一个数即可</p><p>然后注意一些下标的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums[i], nums[i] + n);<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> key = nums[<span class="hljs-number">1</span>][i];<br>        <span class="hljs-type">int</span> pos1 = <span class="hljs-built_in">lower_bound</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">0</span>] + n, key) - nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 在A中找到第一个小于key的数</span><br>        <span class="hljs-type">int</span> pos2 = <span class="hljs-built_in">upper_bound</span>(nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">2</span>] + n, key) - nums[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在C中找到第一个大于key的数</span><br>        <br>        res += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(n - pos2 + <span class="hljs-number">1</span>) * pos1;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位DP</title>
    <link href="/2024/01/17/%E6%95%B0%E4%BD%8DDP/"/>
    <url>/2024/01/17/%E6%95%B0%E4%BD%8DDP/</url>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">以第一题为例比如n = <span class="hljs-number">1234</span> 要找<span class="hljs-number">1</span>~<span class="hljs-number">1234</span>的数<br>数位DP是 一位一位地去填 看能不能填上这个数<br>比如<span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> 第一位填<span class="hljs-number">1</span> 那么第二位就只能填 <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> 中的数 （否则就会超出<span class="hljs-number">1234</span>）<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> 第二位填<span class="hljs-number">1</span> 那么第三位 第四位都可以随意地填<span class="hljs-number">0</span>~<span class="hljs-number">9</span>的任何值 因为不论怎么填都不会超过<span class="hljs-number">1234</span> <br></code></pre></td></tr></table></figure><h1 id="数位DP模板"><a href="#数位DP模板" class="headerlink" title="数位DP模板"></a>数位DP模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">bool</span> isLimit, <span class="hljs-type">bool</span> isNum) -&gt; <span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h2><p>i代表现在走到第几位数</p><p>mask 根据题目而定 也可能没有 也可能是cnt等 主要用于记录题目的条件 比如第一题 用cnt 记录1的个数 第二题是用mask记录是否有重复的数字</p><p>isLimit 看是否有受到限制 这涉及到<a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">数位DP的思想</a>：</p><p>则isLimit就是判断这一位能填写的上下界（主要是上界up）如果不受限制 那就是9 受限制就是 n在这一位的值s[i]</p><p>isNum 主要是用来判断前导0的情况 如果前面有0 就不是一个数了 如果题目不含前导0则不需要</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先把n转换为字符串 然后求出长度m 初始化记忆化数组</p><p>写function函数</p><p>退出条件 一般是i &#x3D;&#x3D; m 返回 什么？</p><p>记忆化 一般是！isLimit &amp;&amp; dp[i] [cnt&#x2F;mask] !&#x3D; 0&#x2F;-1 &amp;&amp; isNum 直接return</p><p>res &#x3D; 0 用于记录答案</p><p>求出最大最小值 up 和 low</p><p>循环for d in range(low, up) 在循环内递归</p><p>if (d &#x3D;&#x3D; 1 &#x2F;&#x2F; mask&gt;&gt;d&amp;1 &#x3D;&#x3D; 0) 选择的这个d 如果满足题目条件</p><p>​就递归 res +&#x3D; f(i + 1, ???, isLimit &amp;&amp; d &#x3D;&#x3D; up, ???) 注意更新状态 </p><p>最后 还需要写入记忆化 if(!isLimit &amp;&amp; isNum)dp[i] [cnt&#x2F; mask] &#x3D; res</p><p>return res</p><p>注意初始条件</p><h1 id="233-数字-1-的个数-力扣（LeetCode）"><a href="#233-数字-1-的个数-力扣（LeetCode）" class="headerlink" title="233. 数字 1 的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-digit-one/solutions/1750339/by-endlesscheng-h9ua/">233. 数字 1 的个数 - 力扣（LeetCode）</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">to_string</span>(n);<br>    <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), dp[m][m];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> cnt, <span class="hljs-type">bool</span> isLimit) -&gt; <span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == m)<br>                <span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[i][cnt] &gt;= <span class="hljs-number">0</span>) <br>                <span class="hljs-keyword">return</span> dp[i][cnt];<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br>            <span class="hljs-type">int</span> up = isLimit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= up; d++)<br>            &#123;<br>                res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, cnt + (d == <span class="hljs-number">1</span>), isLimit &amp;&amp; d == up);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit) dp[i][cnt] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 一开始需要限制</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="2376-统计特殊整数-力扣（LeetCode）"><a href="#2376-统计特殊整数-力扣（LeetCode）" class="headerlink" title="2376. 统计特殊整数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-special-integers/description/">2376. 统计特殊整数 - 力扣（LeetCode）</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>     string s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), dp[m][<span class="hljs-number">1</span>&lt;&lt;m];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">int</span> isLimit, <span class="hljs-type">int</span> isNum) -&gt; <span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == m)<br>                <span class="hljs-keyword">return</span> isNum;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> dp[i][mask];<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!isNum)<br>                res = <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            <span class="hljs-type">int</span> up = isLimit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">9</span>;<br>            <span class="hljs-type">int</span> low = isNum ? <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = low; d &lt;= up; d++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> ((mask&gt;&gt;d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>                    res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask | (<span class="hljs-number">1</span>&lt;&lt;d), isLimit &amp;&amp; up == d, <span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum)<br>                dp[i][mask] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3007-价值和小于等于-K-的最大数字-力扣（LeetCode）"><a href="#3007-价值和小于等于-K-的最大数字-力扣（LeetCode）" class="headerlink" title="3007. 价值和小于等于 K 的最大数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/">3007. 价值和小于等于 K 的最大数字 - 力扣（LeetCode）</a></h1><p>二分+数位DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ll <span class="hljs-title">CntDigitOne</span><span class="hljs-params">(ll n, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">64</span> - __builtin_clzll(n);<br>        ll dp[m][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><br>        function&lt;ll(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> isLimit) -&gt; ll<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[i][cnt] &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> dp[i][cnt];<br>            ll res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> up = isLimit? n&gt;&gt;i &amp; <span class="hljs-number">1</span>: <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= up; d++)<br>            &#123;<br>                res += <span class="hljs-built_in">f</span>(i - <span class="hljs-number">1</span>, cnt + (d == <span class="hljs-number">1</span> &amp;&amp; ((i + <span class="hljs-number">1</span>) % x == <span class="hljs-number">0</span>)), isLimit &amp;&amp; up == d);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit)dp[i][cnt] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(m - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findMaximumNumber</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll left = <span class="hljs-number">1</span>, right = (k + <span class="hljs-number">1</span>) &lt;&lt; x;<br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            ll mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            ll s = <span class="hljs-built_in">CntDigitOne</span>(mid, x);<br>            <span class="hljs-keyword">if</span> (s &lt;= k)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                res = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贡献法</title>
    <link href="/2023/11/27/%E8%B4%A1%E7%8C%AE%E6%B3%95/"/>
    <url>/2023/11/27/%E8%B4%A1%E7%8C%AE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="828-统计子串中的唯一字符-力扣（LeetCode）"><a href="#828-统计子串中的唯一字符-力扣（LeetCode）" class="headerlink" title="828. 统计子串中的唯一字符 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/?envType=daily-question&envId=2023-11-26">828. 统计子串中的唯一字符 - 力扣（LeetCode）</a></h1><p>贡献法  一个字符 能贡献1 代表他在这个子数组里 是唯一的 那就求这样的子数组有多少个 那就在前后找 他上一个和下一个相同元素 这中间的所有数的子数组个数 就是贡献度</p><p>预处理这个字符的前后的相同的字符的位置 然后再用乘法原理算出来相同子数组的个数  注意这里的子数组是类子串而不是类子序列</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniqueLetterString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        res = <span class="hljs-number">0</span><br>        m = &#123;&#125;<br>        l = [<span class="hljs-number">0</span>] * n<br>        r = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            x = s[i]<br>            l[i] = m.get(x, -<span class="hljs-number">1</span>)<br>            m[x] = i<br>        m.clear()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            x = s[i]<br>            r[i] = m.get(x, n)<br>            m[x] = i<br>        <br>        res = <span class="hljs-built_in">sum</span>((i - a) * (b - i) <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(l, r)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="907-子数组的最小值之和-力扣（LeetCode）"><a href="#907-子数组的最小值之和-力扣（LeetCode）" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h1><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="2477-到达首都的最少油耗-力扣（LeetCode）"><a href="#2477-到达首都的最少油耗-力扣（LeetCode）" class="headerlink" title="2477. 到达首都的最少油耗 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">2477. 到达首都的最少油耗 - 力扣（LeetCode）</a></h1><p>计算每条边的贡献 到首都的人数是固定的 每个人要走的边也是固定的 因此可以用贡献法直接计算出每条边会有多少人经过 然后再把这个贡献 &#x2F;&#x2F; 车载数 就可以得到这条边上要消耗的油量 然后把所有边加起来就行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumFuelCost</span>(<span class="hljs-params">self, roads: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], seats: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    g = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> roads:<br>        g[a].append(b)<br>        g[b].append(a)<br>    <br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 令dfs返回这条路的人数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, fa</span>):<br>        <span class="hljs-comment"># 每条路至少有端点这一个人走</span><br>        ret = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>            <span class="hljs-keyword">if</span> y != fa:<br>                <span class="hljs-keyword">nonlocal</span> ans<br>                t = dfs(y, x)<br>                ans += (t - <span class="hljs-number">1</span>) // seats + <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 现在ret 就是这个点到终点的人数 （注意一个点可通向多个点 有多个终点 这些终点是不算在这个ret里的 而是算在fa的ret里）</span><br>            ret += t<br>        <span class="hljs-keyword">return</span> ret<br>dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> ans<br>                <br></code></pre></td></tr></table></figure><h1 id="979-在二叉树中分配硬币-力扣（LeetCode）"><a href="#979-在二叉树中分配硬币-力扣（LeetCode）" class="headerlink" title="979. 在二叉树中分配硬币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/">979. 在二叉树中分配硬币 - 力扣（LeetCode）</a></h1><p>类似于贡献法 算出棵子树的硬币总数 和结点数 就可以算出 有多少硬币要移出这棵子树  然后就可以算出 有多少硬币要移出这个子树的边<img src="/../images/$%7Bfiilename%7D/image-20231206230837411.png" alt="image-20231206230837411"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCoins</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 返回硬币数和结点数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root:TreeNode</span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            l_c, l_n = dfs(root.left)<br>            r_c, r_n = dfs(root.right)<br>          coin = l_c + r_c + root.val<br>            node = l_n + r_n + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">nonlocal</span> ans<br>            ans += <span class="hljs-built_in">abs</span>(coin - node)<br>            <span class="hljs-keyword">return</span> (coin, node)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/11/27/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2023/11/27/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="907-子数组的最小值之和-力扣（LeetCode）"><a href="#907-子数组的最小值之和-力扣（LeetCode）" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h2><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="2454-下一个更大元素-IV-力扣（LeetCode）"><a href="#2454-下一个更大元素-IV-力扣（LeetCode）" class="headerlink" title="2454. 下一个更大元素 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-iv/description/">2454. 下一个更大元素 IV - 力扣（LeetCode）</a></h2><p>要找到下下个更大的元素   其实就是用单调栈  一个单调栈用于找下一个更大的元素  两个单调栈就可以找下下个更大的元素</p><p>st1存放 (暂时没找到比他大的)元素   st2存放(已经有一个比他大)的元素</p><p>每次先判断当前元素x 是否大于st2中的元素 如果是  就直接更新ans</p><p>然后判断有多少个st1中的数可以被更新到st2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">secondGreaterElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        st1 = []<br>        st2 = []<br>        ans = [-<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">while</span> st2 <span class="hljs-keyword">and</span> nums[st2[-<span class="hljs-number">1</span>]] &lt; x:<br>                ans[st2.pop()] = x<br>            j = <span class="hljs-built_in">len</span>(st1) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[st1[j]] &lt; x:<br>                j -= <span class="hljs-number">1</span><br>            st2 += st1[j + <span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">del</span> st1[j + <span class="hljs-number">1</span>:]<br>            st1.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="1673-找出最具竞争力的子序列-力扣（LeetCode）"><a href="#1673-找出最具竞争力的子序列-力扣（LeetCode）" class="headerlink" title="1673. 找出最具竞争力的子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/">1673. 找出最具竞争力的子序列 - 力扣（LeetCode）</a></h2><p>主要是没看出来是用单调栈的题目 </p><p>一般来说需要从小到大（比如每日温度那个题）就是用单调栈</p><p>这个题目就满足 为了取最小的数 需要小数放前面 大数放后面 而且要按照数组中出现的顺序 所以可以考虑用单调栈</p><p>特别的是 这个题还有数量要求 必须是k个数字</p><p><strong>那就设置last &#x3D; n - k 表示pop的次数</strong> 在单调栈循环内 如果pop超过了last次 后面就不再pop了 否则数量不够k个  在单调栈循环结束后 如果last大于0 表示超过了k个数 需要再pop掉last次 由于小的数字放越前面越好 所以pop肯定是越早越好 所以就是遇到可以pop的就pop 后面的次数不够了就直接push进来</p><p>然后注意这题单调栈里面放的是数 不是下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mostCompetitive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> last = n - k;<br>        vector&lt;<span class="hljs-type">int</span>&gt;st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; last &gt; <span class="hljs-number">0</span> &amp;&amp; st.<span class="hljs-built_in">back</span>() &gt; nums[i])<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                last--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(last--)<br>            st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> st;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2302-统计得分小于-K-的子数组数目-力扣（LeetCode）"><a href="#2302-统计得分小于-K-的子数组数目-力扣（LeetCode）" class="headerlink" title="2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）</a></h2><p>这题首先是个数学问题  当出现连续的子数组的时候 每次答案增加的数量是 <strong>r - l + 1</strong> 知道这个之后就好想到滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0L</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++)<br>        &#123;<br>            sum += nums[r];<br>            <span class="hljs-keyword">while</span> (sum * (r - l + <span class="hljs-number">1</span>) &gt;= k) <span class="hljs-comment">// zhu&#x27;yi&#x27;shi</span><br>            &#123;<br>                sum -= nums[l++];<br>            &#125;<br>            ans += r - l + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2023/11/25/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2023/11/25/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="P4779-【模板】单源最短路径（标准版）-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4779-【模板】单源最短路径（标准版）-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>板子题 注意几个点 </p><p>1.dis数组的初始化   dis[s] &#x3D; 0</p><p>2.整体的思路 最小堆的创建  尤其注意cmp函数 里面是<strong>大于</strong>不是小于</p><p>3.vis数组 在哪里更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;edge[N];<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> head[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].w = w;<br>edge[idx].to = to;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br><span class="hljs-type">int</span> dist, id;<br><span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dist, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">dist</span>(dist), <span class="hljs-built_in">id</span>(id) &#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.dist &gt; b.dist;<br>&#125;<br>&#125;;<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt; q;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dis[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(<span class="hljs-number">0</span>, s));<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (vis[p])<br><span class="hljs-keyword">continue</span>;<br>vis[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to, w = edge[e].w;<br><br>dis[to] = <span class="hljs-built_in">min</span>(dis[to], dis[p] + w);<br><span class="hljs-keyword">if</span> (!vis[to])<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(dis[to], to));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m, s;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)dis[i] = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-built_in">dijkstra</span>(s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P3385-【模板】负环-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3385-【模板】负环-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3385 【模板】负环 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3385">P3385 【模板】负环 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>spfa板子 用spfa判负环</p><p>注意</p><p>1.一定一定一定非常注意 spfa函数的初始化 q.push 、dis  inq  inqc有没有初始化  </p><p>2.每次如何更新inq inqc dis q </p><p>3.判负环 就是看inqc有没有&gt;&#x3D;n （同一个点的松弛次数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;;<br>edges edge[N];<br><span class="hljs-type">int</span> idx, head[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].to = to;<br>edge[idx].w = w;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> inq[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(s);<br>inq[s] = <span class="hljs-number">1</span>;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> inqc[N] = &#123; <span class="hljs-number">0</span> &#125;;<br>inqc[s] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>inq[p] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to;<br><span class="hljs-keyword">if</span> (dist[to] &gt; dist[p] + edge[e].w)<br>&#123;<br>dist[to] = dist[p] + edge[e].w;<br><span class="hljs-keyword">if</span> (!inq[to])<br>&#123;<br>inqc[to]++;<br><span class="hljs-keyword">if</span> (inqc[to] &gt;= n)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>inq[to] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T = <span class="hljs-number">0</span>;<br>cin &gt;&gt; T;<br><span class="hljs-keyword">while</span> (T--)<br>&#123;<br><br>cin &gt;&gt; n &gt;&gt; m;<br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>edge[i].to = <span class="hljs-number">0</span>;<br>edge[i].next = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br><span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span>)<span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P5960-【模板】差分约束-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5960-【模板】差分约束-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5960 【模板】差分约束 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>差分约束<br>$$<br>\begin{cases} x_{c_1}-x_{c’<em>1}\leq y_1 \x</em>{c_2}-x_{c’<em>2} \leq y_2 \ \cdots\ x</em>{c_m} - x_{c’_m}\leq y_m\end{cases}<br>$$</p><p>类似于三角不等式 跟最短路的优化形式相近 考虑用最短路</p><p>变形 $x_{c1}\leq x_{c1}’ + y_1$ 即可以求最短路 </p><p>添加一个超级源点 0 求出0 到每个点的最短路 </p><p>如果不存在负环 就是有解 有负环则无解 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> v, w, next;<br>&#125;edge[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> head[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].v = v;<br>edge[idx].w = w;<br>edge[idx].next = head[u];<br>head[u] = idx;<br>&#125;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">5005</span>], tot[<span class="hljs-number">5005</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><br>vis[s] = <span class="hljs-number">1</span>;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(s);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[p] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].v, w = edge[e].w;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + w)<br>&#123;<br>dis[to] = dis[p] + w;<br><span class="hljs-keyword">if</span> (!vis[to])<br>&#123;<br><br>vis[to] = <span class="hljs-number">1</span>;<br>tot[to]++;<br><span class="hljs-keyword">if</span> (tot[to] == n + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b, c;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><span class="hljs-built_in">add</span>(a, b, c);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>))cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P1993-小-K-的农场-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1993-小-K-的农场-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1993 小 K 的农场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1993">P1993 小 K 的农场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>差分约束变形</p><p>超级源点要初始化 连接0 到所有的点 权值为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> m, n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> w, v, next;<br>&#125;edge[N];<br><br><span class="hljs-type">int</span> head[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].v = v;<br>edge[idx].w = w;<br>edge[idx].next = head[u];<br>head[u] = idx;<br>&#125;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5005</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">5005</span>], tot[<span class="hljs-number">5005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>vis[s] = <span class="hljs-literal">true</span>;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(s);<br>tot[s]++;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[p] = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].v, w = edge[e].w;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + w)<br>&#123;<br>dis[to] = dis[p] + w;<br><span class="hljs-keyword">if</span> (!vis[to])<br>&#123;<br>vis[to] = <span class="hljs-literal">true</span>;<br>tot[to]++;<br><span class="hljs-keyword">if</span> (tot[to] == n + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> c, u, v, w;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, -w);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">2</span>) <br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">3</span>)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v;<br><span class="hljs-built_in">add</span>(u, v, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">add</span>(v, u, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 超级源点0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>))cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B3611-【模板】传递闭包-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#B3611-【模板】传递闭包-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="B3611 【模板】传递闭包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/B3611">B3611 【模板】传递闭包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>传递闭包  就和离散的传递闭包一个意思 如果存在a-&gt;b b-&gt;c 那就必须有a-&gt;c 就这样加上   注意这个题要用邻接矩阵存储</p><p>用Floyd算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> g[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br>cin &gt;&gt; g[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[k][j] &amp;&amp; g[i][k])g[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br>cout &lt;&lt; g[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1144-最短路计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1144-最短路计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1144">P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>无权图 可以用BFS  先到达的必定是最短的  用deg记录这个点dfs的层数  如果这个点的层数比上一个相邻结点多1 说明找到了一条最短路 更新条数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><span class="hljs-type">int</span> deg[N], cnt[N], vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>cnt[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>deg[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : g[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[e])<br>&#123;<br>vis[e] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(e);<br>deg[e] = deg[p] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (deg[e] == deg[p] + <span class="hljs-number">1</span>)<br>cnt[e] = (cnt[e] + cnt[p]) % <span class="hljs-number">100003</span>;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; cnt[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><br><span class="hljs-built_in">bfs</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1462-通往奥格瑞玛的道路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1462-通往奥格瑞玛的道路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1462 通往奥格瑞玛的道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1462">P1462 通往奥格瑞玛的道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>神奇的二分+最短路</p><p>一开始题目看不懂  求可以到达的情况下 他所经过的所有城市中 收费最多的一次 收取的费用的最小值是多少</p><p>就是要最小化 （经过城市收费的最大值）</p><p>最大（小）化 最小（大）值 就用二分</p><p>二分钱数   check就找可以通过并且通过的钱数小于mid 的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, b;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;edge[N];<br><span class="hljs-type">int</span> idx, head[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].w = w;<br>edge[idx].to = to;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br><span class="hljs-type">int</span> id, dis;<br><span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dis, <span class="hljs-type">int</span> id) :<span class="hljs-built_in">dis</span>(dis), <span class="hljs-built_in">id</span>(id) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.dis &gt; b.dis;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt;q;<br>q.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;);<br>dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (f[<span class="hljs-number">1</span>] &gt; mid)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (vis[p])<span class="hljs-keyword">continue</span>;<br>vis[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to;<br><span class="hljs-keyword">if</span> (f[to] &gt; mid)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + edge[e].w)<br>&#123;<br>dis[to] = dis[p] + edge[e].w;<br>q.<span class="hljs-built_in">push</span>(&#123; dis[to], to &#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (dis[n] &gt; b)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; b;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; f[i];<br>r = <span class="hljs-built_in">max</span>(f[i], r);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br><span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dij</span>(INT_MAX))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;AFK&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dij</span>(mid))<br>&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; l &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P6464-传智杯-2-决赛-传送门-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P6464-传智杯-2-决赛-传送门-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P6464 传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P6464 <a href="https://www.luogu.com.cn/problem/P6464">传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>思考优化策略  从$O(n^5)$优化到$O(n^4)$</p><p>最初的想法应该是 每两个点为0都单独($O(n^2)$)再跑一遍Floyd($O(n^3)$)</p><p>但是其实不需要   而是只需要更新{加入传送门之后 距离改变了 }会影响到的那几条边   假设与l—b加上传送门  只用更新 需要中介l的点和需要中介b 的点即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> g[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>f[u][v] = f[v][u] = w;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k][j]);<br>g[i][j] = f[i][j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; l++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt; l; b++)<br>&#123;<br><br>g[l][b] = g[b][l] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 关键优化步骤</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][l] + g[l][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][b] + g[b][j]);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>&#123;<br>ret += g[i][j];<br>&#125;<br>&#125;<br>ans = <span class="hljs-built_in">min</span>(ans, ret);<br><span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-built_in">sizeof</span>(f));<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P2419-USACO08JAN-Cow-Contest-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2419-USACO08JAN-Cow-Contest-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2419 USACO08JAN] Cow Contest S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2419 <a href="https://www.luogu.com.cn/problem/P2419">USACO08JAN] Cow Contest S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>关键在于 能够确定排名的牛  是怎么看的</p><p>能确定排名 就是直到有几只牛比他高 有几只牛比他低 用有向图表示 弧尾表示赢的牛 弧头表示输的牛 </p><p>那么入度就是输给几头牛的数  出度就是赢了几头牛 当入度+出度&#x3D;n-1的时候  代表他已经确定和其他n - 1头牛的关系了 说明可以排名</p><p>入度和出度 可以用bfs 正反图+dfs（因为间接赢也是赢）来求</p><p>也可以用floyd再计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 胜利者指向失败者</span><br><span class="hljs-comment">* 入度是被多少牛打败</span><br><span class="hljs-comment">* 出度是打败了多少牛</span><br><span class="hljs-comment">* 能确定排名就是 入度 + 出度 = n - 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N], rg[N];<br><span class="hljs-type">int</span> win[N], lose[N];<br><span class="hljs-type">int</span> win_c, lose_c;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_win</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : g[i])<br><span class="hljs-keyword">if</span> (!win[y])<br>&#123;<br>win[y] = <span class="hljs-number">1</span>;<br>win_c++;<br><span class="hljs-built_in">dfs_win</span>(y);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_lose</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : rg[i])<br><span class="hljs-keyword">if</span> (!lose[y])<br>&#123;<br>lose[y] = <span class="hljs-number">1</span>;<br>lose_c++;<br><span class="hljs-built_in">dfs_lose</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>rg[v].<span class="hljs-built_in">push_back</span>(u);<br><br>&#125;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>win_c = lose_c = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(win, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(win));<br><span class="hljs-built_in">memset</span>(lose, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(lose));<br><span class="hljs-built_in">dfs_win</span>(i);<br><span class="hljs-built_in">dfs_lose</span>(i);<br><span class="hljs-comment">//cout &lt;&lt; win_c &lt;&lt; lose_c &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (win_c + lose_c == n - <span class="hljs-number">1</span>)ret++;<br>&#125;<br>cout &lt;&lt; ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1073-NOIP2009-提高组-最优贸易-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1073-NOIP2009-提高组-最优贸易-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1073 NOIP2009 提高组] 最优贸易 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1073 <a href="https://www.luogu.com.cn/problem/P1073">NOIP2009 提高组] 最优贸易 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>由于边权为1 考虑BFS  </p><p>权值在点上  可以预处理出一个中转点i i满足通路 1~i  i ~ n （即首先需要能够到达n才行）</p><p>然后再1<del>i上找一个点买入  i</del>n找一个点卖出 则可以用<strong>两次bfs</strong>求出1<del>i的每个点的最小值 i</del>n的每个点的最大值 （求i<del>n可以存反图 求n</del>i的点 然后求与1~i 的交集）</p><p>最后遍历1~n 即令每个点都为中转点 求出哪个点作为中转时最大</p><p>注意 1 和n 作为中转也可以  要给1和n赋初值 当<strong>重复</strong>经过的时候也必须算上 就是说BFS的vis即使已经为1 maxn和minn也要进行比较赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> mon[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;G[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;rg[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> maxn[N], minn[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[v])<br>&#123;<br>q.<span class="hljs-built_in">push</span>(v);<br>vis[v] = <span class="hljs-number">1</span>;<br><br>&#125;<br>minn[v] = <span class="hljs-built_in">min</span>(minn[p], mon[v]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : rg[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[v])<br>&#123;<br>q.<span class="hljs-built_in">push</span>(v);<br>vis[v] = <span class="hljs-number">1</span>;<br><br>&#125;<br>maxn[v] = <span class="hljs-built_in">max</span>(maxn[p], mon[v]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">memset</span>(maxn, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(maxn));<br><span class="hljs-built_in">memset</span>(minn, <span class="hljs-number">10</span>, <span class="hljs-built_in">sizeof</span>(minn));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; mon[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, t;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;<br>rg[v].<span class="hljs-built_in">push_back</span>(u);<br>G[u].<span class="hljs-built_in">push_back</span>(v);<br><br><span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">1</span>)<br>&#123;<br>G[v].<span class="hljs-built_in">push_back</span>(u);<br>rg[u].<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br>&#125;<br>minn[<span class="hljs-number">1</span>] = maxn[<span class="hljs-number">1</span>] = mon[<span class="hljs-number">1</span>];<br>maxn[n] = minn[n] = mon[n];<br><span class="hljs-built_in">bfs1</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">bfs2</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; minn[i] &lt;&lt; &quot; &quot; &lt;&lt; maxn[i] &lt;&lt; endl;</span><br>ret = <span class="hljs-built_in">max</span>(ret, maxn[i] - minn[i]);<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2023/11/16/Trie%E6%A0%91/"/>
    <url>/2023/11/16/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="2935-找出强数对的最大异或值-II-力扣（LeetCode）"><a href="#2935-找出强数对的最大异或值-II-力扣（LeetCode）" class="headerlink" title="2935. 找出强数对的最大异或值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/submissions/482713400/">2935. 找出强数对的最大异或值 II - 力扣（LeetCode）</a></h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>():<br>    __slots__ = <span class="hljs-string">&#x27;children&#x27;</span>, <span class="hljs-string">&#x27;cnt&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.children = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]<br>        self.cnt = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>():<br>    HIGH_BIT = <span class="hljs-number">19</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = Node()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cur.children[bit] = Node()<br>            cur = cur.children[bit]<br>            cur.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            cur = cur.children[(val &gt;&gt; i) &amp; <span class="hljs-number">1</span>]<br>            cur.cnt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_xor</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cur = self.root<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit ^ <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> cur.children[bit ^ <span class="hljs-number">1</span>].cnt:<br>                ans |= <span class="hljs-number">1</span> &lt;&lt; i<br>                bit ^= <span class="hljs-number">1</span><br>            cur = cur.children[bit]<br>        <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumStrongPairXor</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        root = Trie()        <br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ret = left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> nums:<br>            root.insert(y)<br>            <span class="hljs-keyword">while</span> nums[left] * <span class="hljs-number">2</span> &lt; y:<br>                root.remove(nums[left])<br>                left += <span class="hljs-number">1</span><br>            ret = <span class="hljs-built_in">max</span>(ret, root.max_xor(y))            <br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/10/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/10/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="斐波那契型"><a href="#斐波那契型" class="headerlink" title="斐波那契型"></a>斐波那契型</h1><h2 id="一般是直观的状态转移-选或不选的问题"><a href="#一般是直观的状态转移-选或不选的问题" class="headerlink" title="一般是直观的状态转移  选或不选的问题"></a>一般是直观的状态转移  选或不选的问题</h2><p>dp[i] 表示前i个最多能有多少钱   每个选还是不选？因为选了这个 就不能选下一个 由此得出状态转移方程 dp[i] &#x3D; max(dp[i - 2] + cost[i], dp[i - 1])  选了这个 就需要加上这个的值（并且不能选i - 1） 不选这个 就直接从i - 1转移</p><p>初始化 视情况而定 一般初始化 dp[0] 、dp[1] 等 前几个元素</p><h3 id="198-打家劫舍-力扣（LeetCode）"><a href="#198-打家劫舍-力扣（LeetCode）" class="headerlink" title="198. 打家劫舍 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=dynamic-programming">198. 打家劫舍 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i])<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="740-删除并获得点数-力扣（LeetCode）-https-leetcode-cn-problems-delete-and-earn-envType-study-plan-v2-envId-dynamic-programming"><a href="#740-删除并获得点数-力扣（LeetCode）-https-leetcode-cn-problems-delete-and-earn-envType-study-plan-v2-envId-dynamic-programming" class="headerlink" title="740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&amp;envId=dynamic-programming)"></a>740. 删除并获得点数 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&envId=dynamic-programming">https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&amp;envId=dynamic-programming</a>)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAndEarn</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">max</span>(nums)<br>        cost = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            cost[x] += x<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>     <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + cost[i], dp[i - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h1 id="矩阵型"><a href="#矩阵型" class="headerlink" title="矩阵型"></a>矩阵型</h1><h2 id="一般是类似于走迷宫-用二维的-dp-i-j"><a href="#一般是类似于走迷宫-用二维的-dp-i-j" class="headerlink" title="一般是类似于走迷宫 用二维的 dp[i] [j]"></a>一般是类似于走迷宫 用二维的 dp[i] [j]</h2><p>i，j表示坐标   状态从上一坐标 转移而来  一般是相邻的位置 比如i - 1 j - 1 等</p><p>注意 这类问题 一般需要判断该位置是否已经走过？  比如求最大值可以设初值为0 判断为0即未访问 求最小值设为inf等</p><p>得到状态转移方程为  dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]) + cost[]</p><p>初始化一般是用于转移的前几个数</p><p>由于数组的原因 下标经常从1开始 到n+1结束 相应的cost数组的下标也需要改变</p><h3 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths/?envType=study-plan-v2&envId=dynamic-programming">62. 不同路径 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">0</span>:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h3 id="64-最小路径和-力扣（LeetCode）"><a href="#64-最小路径和-力扣（LeetCode）" class="headerlink" title="64. 最小路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&envId=dynamic-programming">64. 最小路径和 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">10</span> ** <span class="hljs-number">9</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h3 id="221-最大正方形-力扣（LeetCode）"><a href="#221-最大正方形-力扣（LeetCode）" class="headerlink" title="221. 最大正方形 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=dynamic-programming">221. 最大正方形 - 力扣（LeetCode）</a></h3><p>这题同样是矩阵型 </p><p>dp[i] [j] 表示以i j 为右下角的最大正方形的 边长 每次看他的上、左和上左 三个格子的最大边长  + 1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">len</span>(matrix)<br>        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                ret = <span class="hljs-built_in">max</span>(ret, dp[i][j])<br>        <span class="hljs-keyword">return</span> ret ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2304-网格中的最小路径代价-力扣（LeetCode）"><a href="#2304-网格中的最小路径代价-力扣（LeetCode）" class="headerlink" title="2304. 网格中的最小路径代价 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">2304. 网格中的最小路径代价 - 力扣（LeetCode）</a></h2><p>想到 从第一行开始取数 然后向下转移 </p><p>比如g[0] [0] 就可以到 g[1] [0]….g[1] [m - 1]这样</p><p>于是用dfs(i, j) 来表示状态  在第i行第j列的最小值 </p><p>然后就要考虑怎么递增 从i j 递增到下一行的第k个 那么下一行第k个的值 就是dfs(i + 1, k) + moveCost[grid[i] [j]] [k] </p><p>然后考虑退出条件  不断向下 那肯定就是到第n - 1行结束 </p><p>结束的时候要返回什么？ 这和存的东西 有关  dfs（i, j）表示i j 的最小值 然后往下转移 最后一行不再往下转移 最小值就是它本身</p><p>然后通过这个转移的过程 可以发现 i j处的最小值  其实是i j 加上 从i j往下 的所有的（也就是  我们最后会把所有的都加到第0行 返回第0行的最小值）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], moveCost: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> grid[i][j]<br>           ret = inf<br>            <span class="hljs-comment"># 注意 这里算的是 i j 的最小值 那就是i j 往下转移到下一行每一个 求最小</span><br>            <span class="hljs-keyword">for</span> k, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moveCost):<br>                res = <span class="hljs-built_in">min</span>(res, dfs(i + <span class="hljs-number">1</span>, k) + c)<br>            <span class="hljs-keyword">return</span> res + grid[i][j] <span class="hljs-comment"># 记得加上grid</span><br>        <span class="hljs-comment"># 由dfs函数 就可以计算出 i j的最小值 -》算出0 j 的最小值 所以 还需要遍历0~m-1找第0行的最小值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(<span class="hljs-number">0</span>, j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m))<br></code></pre></td></tr></table></figure><p>然后翻译成递推</p><ul><li>dfs改dp</li><li>递归改循环</li><li>递归边界改为dp初始值</li><li>递归入口即为答案</li></ul><p>dfs(i, j) -&gt; dp[i] [j]  几个参数 就是几维</p><p>dp[-1] &#x3D; grid[-1] 递归的边界 最后一行 就是初始值 因为我们算i j 的时候 其实是必须先算出来 i + 1 k 的值 然后再往上转移的</p><p>所以i要从下往上遍历  最后dp[0]  的最小值就是答案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], moveCost: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[inf] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[-<span class="hljs-number">1</span>] = grid[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">for</span> k, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moveCost):<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i + <span class="hljs-number">1</span>][k] + c, dp[i][j])<br>             dp[i][j] += grid[i][j]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h2 id="1212-地宫取宝-AcWing题库"><a href="#1212-地宫取宝-AcWing题库" class="headerlink" title="1212. 地宫取宝 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝 - AcWing题库</a></h2><p>这个题目与上一个题有点像 都是矩阵型 状态转移方程也是由左(j  - 1)上(i - 1)转移到[i, j]</p><p>四维DP      状态表示 dp[i] [j] [cnt] [d] 表示i到j中 拿到cnt个物品且最大价值为d的情况</p><p>状态计算 有选或不选两种 （只有当拿的东西不多于k并且价值大于当前最大价值才可以拿）</p><p>不选就直接转移   dp[i] [j] [c] [d] &#x3D; (dp[i] [j] [c] [d] + dp[i - 1] [j] [c] [d]) % mod;</p><p>选的话 需要从c - 1转移过来 并且要加上所有价值小于d的情况</p><p>最后需要加上所有的最大价值的情况 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>, mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, M = <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> nums[N][N], dp[N][N][M][M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;row&gt;&gt;col&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>            nums[i][j]++;<br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= k; c++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; M; d++)<br>                &#123;<br>                    <span class="hljs-comment">// 不选</span><br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c][d]) % mod;<br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c][d]) % mod;<br>                    <span class="hljs-comment">// 选</span><br>                    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d == nums[i][j])<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; d; s++)<br>                        &#123;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c - <span class="hljs-number">1</span>][s]) % mod;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c - <span class="hljs-number">1</span>][s]) % mod;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; M; i++)<br>    &#123;<br>        res = (res + dp[row][col][k][i])%mod;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单字符串型"><a href="#单字符串型" class="headerlink" title="单字符串型"></a>单字符串型</h1><p>在单个字符串上进行操作  一般状态表示也是两个变量 i， j 然后取出一个区间   j 一般表示端点 s[i:j]或s[j: i]</p><p>初始化 一般需要初始化大量的字符串  比如 回文串 需要初始化每个s[i:i] 为1 </p><h3 id="5-最长回文子串-力扣（LeetCode）"><a href="#5-最长回文子串-力扣（LeetCode）" class="headerlink" title="5. 最长回文子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/?envType=study-plan-v2&envId=dynamic-programming">5. 最长回文子串 - 力扣（LeetCode）</a></h3><p>dp[i] [j] 表示i到j是否为回文串   状态转移为  看12…..21 比如 1 &#x3D;&#x3D; 1 那就看前面 一段2…..2是不是回文 </p><p>如果1 !&#x3D; 1 那就直接false</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> s<br>       begin = <span class="hljs-number">0</span><br>     max_len = <span class="hljs-number">1</span><br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 枚举长度L</span><br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                j = i + L - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> j &gt;= n:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> s[i] != s[j]:<br>                    dp[i][j] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<span class="hljs-comment"># s[i] = s[j]  那就看前一段是不是回文 </span><br>                    <span class="hljs-keyword">if</span> L &lt; <span class="hljs-number">3</span>:<br>                        dp[i][j] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> j - i + <span class="hljs-number">1</span> &gt; max_len:<br>                    max_len = j - i + <span class="hljs-number">1</span><br>                    begin = i<br>        <span class="hljs-keyword">return</span> s[begin:begin + max_len]<br>                <br></code></pre></td></tr></table></figure><h3 id="139-单词拆分-力扣（LeetCode）"><a href="#139-单词拆分-力扣（LeetCode）" class="headerlink" title="139. 单词拆分 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=dynamic-programming">139. 单词拆分 - 力扣（LeetCode）</a></h3><p>跟前一题很像 用dp[i]表示 前i个能不能被word拼接  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> dp[i] == <span class="hljs-literal">True</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> dp[j] == <span class="hljs-literal">False</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 当前i个是False 并且前j个事True的时候  就要从j转移到i </span><br>                <span class="hljs-keyword">if</span> s[j:i] <span class="hljs-keyword">in</span> wordDict:<br>                    s[i] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">break</span><br>         <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>                   <br></code></pre></td></tr></table></figure><h3 id="516-最长回文子序列-力扣（LeetCode）"><a href="#516-最长回文子序列-力扣（LeetCode）" class="headerlink" title="516. 最长回文子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">516. 最长回文子序列 - 力扣（LeetCode）</a></h3><p>子序列问题 不连续 一般就要用i 和 j </p><p>dp[i] [j] 表示i 到j 最长是多少</p><p>当s[i] &#x3D;&#x3D; s[j]的时候 dp[i] [j] 就可以从dp[i + 1] [j - 1]更新来</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindromeSubseq</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            ret = <span class="hljs-built_in">max</span>(ret, dp[i][j])<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="双字符串型"><a href="#双字符串型" class="headerlink" title="双字符串型"></a>双字符串型</h1><p>双字符串的题一般要用dp[i] [j] 一个用来表示第一个字符串的 第i个 一个用来表示第2个字符串的前j个</p><h3 id="72-编辑距离-力扣（LeetCode）"><a href="#72-编辑距离-力扣（LeetCode）" class="headerlink" title="72. 编辑距离 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&envId=dynamic-programming">72. 编辑距离 - 力扣（LeetCode）</a></h3><p>dp[i] [j] 表示第一个到i 第二个到j 相同的最小编辑次数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;def dfs(i, j):</span><br><span class="hljs-string">            if i &lt; 0:</span><br><span class="hljs-string">                return j + 1</span><br><span class="hljs-string">           if j &lt; 0:</span><br><span class="hljs-string">                return i + 1</span><br><span class="hljs-string">           if word1[i] == word2[j]:</span><br><span class="hljs-string">                return dfs(i - 1, j - 1)</span><br><span class="hljs-string">            return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># dfs 转 dp</span><br>        n, m = <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> word1[i] == word2[j]:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][j + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n][m]<br>        <br></code></pre></td></tr></table></figure><h3 id="115-不同的子序列-力扣（LeetCode）"><a href="#115-不同的子序列-力扣（LeetCode）" class="headerlink" title="115. 不同的子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distinct-subsequences/description/?envType=study-plan-v2&envId=dynamic-programming">115. 不同的子序列 - 力扣（LeetCode）</a></h3><p>这题与上一题不同 在于 上一题是修改s使其与 t相等  所以 不相等的时候只需要修改 就可以相等  然后位移指针</p><p>但是这个题 是求t在x中出现的次数 也就是说t 必须全部匹配  所以t的指针j 只有在匹配的时候才能位移</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numDistinct</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;def dfs(i, j):</span><br><span class="hljs-string">            if i &lt; 0:</span><br><span class="hljs-string">                return 0</span><br><span class="hljs-string">            if j &lt; 0:</span><br><span class="hljs-string">                return 1 # 表示已经匹配</span><br><span class="hljs-string">           if s[i] == t[j]:</span><br><span class="hljs-string">                return dfs(i - 1, j - 1) + dfs(i - 1, j)  # 选或不选两种情况</span><br><span class="hljs-string">            return dfs(i - 1, j)</span><br><span class="hljs-string">       &quot;&quot;&quot;</span><br>        n, m = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s[i] == t[j]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[n][m]<br>                <br></code></pre></td></tr></table></figure><h3 id="712-两个字符串的最小ASCII删除和-力扣（LeetCode）"><a href="#712-两个字符串的最小ASCII删除和-力扣（LeetCode）" class="headerlink" title="712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/?envType=study-plan-v2&envId=dynamic-programming">712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）</a></h3><p>由于直接求最小不好求  可以选择 先求出两个字符串的ascll总和  然后求<strong>最长子序列</strong> 最后再减去最长子序列的ascll * 2 就是删除的最小和</p><p>dp[i] [j] 表示最长子序列的ascll和  （即 到s1[i] s2[j]的ascll和）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumDeleteSum</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        s = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(s1[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>        s += <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(s2[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-built_in">ord</span>(s1[i])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> s - dp[n][m] * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="673-最长递增子序列的个数-力扣（LeetCode）"><a href="#673-最长递增子序列的个数-力扣（LeetCode）" class="headerlink" title="673. 最长递增子序列的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/?envType=study-plan-v2&envId=dynamic-programming">673. 最长递增子序列的个数 - 力扣（LeetCode）</a></h3><p>先是找最长的递增子序列 用maxn记录最长的长度 dp[i] 记录到i的最长子序列长度 （最长递增子序列） </p><p>由于本题求得是个数 需要增加cnt[i] 表示 到i 的最长递增子序列的个数 </p><p>对于每个i  遍历0 ~ i的每个j 如果nums[i] &gt; nums[j] 说明i 可以接在j后面形成递增子序列 </p><p>如果dp[i] &lt; dp[j] + 1那么说明到i的最长递增子序列的长度需要更新  那么到i 的最长子序列的数量 可以直接更新(到j的数量 直接转移到 到i的数量 )</p><p>如果dp[i] &#x3D;&#x3D; dp[j] + 1 那么说明到i这个地方 他的最长递增子序列（并非整个数组最长而是0~i最长）的数量+&#x3D; 到j的数量</p><p>最后把到每个i 的等于maxn的数量加起来</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNumberOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        cnt = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        maxn = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i] = <span class="hljs-number">1</span><br>            cnt[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    <span class="hljs-keyword">if</span> dp[i] &lt; dp[j] + <span class="hljs-number">1</span>:<br>                        dp[i] = dp[j] + <span class="hljs-number">1</span><br>                        cnt[i] = cnt[j]<br>                    <span class="hljs-keyword">elif</span> dp[i] == dp[j] + <span class="hljs-number">1</span>:<br>                        cnt[i] += cnt[j]<br>            maxn = <span class="hljs-built_in">max</span>(maxn, dp[i])<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> dp[i] == maxn:<br>                ret += cnt[i]<br>        <span class="hljs-keyword">return</span> ret<br>                        <br></code></pre></td></tr></table></figure><h2 id="646-最长数对链-力扣（LeetCode）"><a href="#646-最长数对链-力扣（LeetCode）" class="headerlink" title="646. 最长数对链 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/description/?envType=study-plan-v2&envId=dynamic-programming">646. 最长数对链 - 力扣（LeetCode）</a></h2><p>模板题 最长上升子序列</p><p>状态表示dp[i] 表示到i 到j 的最长链 </p><p>状态转移 i + 1的l如果大于i的r</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLongestChain</span>(<span class="hljs-params">self, pairs: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(pairs)<br>        pairs.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> pairs[j][<span class="hljs-number">1</span>] &lt; pairs[i][<span class="hljs-number">0</span>]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i])<br>                <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h1 id="公共子序列型"><a href="#公共子序列型" class="headerlink" title="公共子序列型"></a>公共子序列型</h1><p>一般需要二维 i用来表示到text1   j表示到text2 的时候最长公共子序列为多长</p><p>更新状态一般是当text1[i - 1] &#x3D;&#x3D; text2[i - 1]的时候就是dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1 意思是到i j 公共子序列长度增加</p><p>否则就是选出dp[i - 1] [j] 和dp[i] [j - 1] 中较大的</p><h2 id="1143-最长公共子序列-力扣（LeetCode）"><a href="#1143-最长公共子序列-力扣（LeetCode）" class="headerlink" title="1143. 最长公共子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">1143. 最长公共子序列 - 力扣（LeetCode）</a></h2><p>dp[i] [j] </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h1 id="0数组切分-蓝桥云课-lanqiao-cn"><a href="#0数组切分-蓝桥云课-lanqiao-cn" class="headerlink" title="0数组切分 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2148/learning/">0数组切分 - 蓝桥云课 (lanqiao.cn)</a></h1><p>类似最长子串的问题 判断条件变为 连续数字</p><p>判断连续的数字 就用i - j &#x3D;&#x3D; max - min 从i到j中的最大值与最小值的差等于i - j的话 那么这个范围内的数字就是连续的</p><p>dp[i] 表示前i个数共有多少种表示方法</p><p>二重循环从i到0 倒着找 如果找到了一个范围j~i使得里面的数字连续的话  (原来前i个数 共有dp[i] 种表示方法  前j - 1个数共有dp[j - 1]种)  那么现在dp[i] &#x3D; dp[i] + dp[j - 1] 因为前j - 1的方案数 现在j ~i也可以了 就可以接上 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>], dp[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> ma = a[i], mi = a[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i - j == ma - mi)<br>            &#123;<br>                dp[i] = (dp[i] + dp[j - <span class="hljs-number">1</span>]) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n];<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1035-不相交的线-力扣（LeetCode）"><a href="#1035-不相交的线-力扣（LeetCode）" class="headerlink" title="1035. 不相交的线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/uncrossed-lines/description/?envType=study-plan-v2&envId=dynamic-programming">1035. 不相交的线 - 力扣（LeetCode）</a></h2><p>最长公共子序列  同时要满足线不能相交（也就是要有序 ）其实跟最长公共子序列一样</p><h2 id="1312-让字符串成为回文串的最少插入次数-力扣（LeetCode）"><a href="#1312-让字符串成为回文串的最少插入次数-力扣（LeetCode）" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/?envType=study-plan-v2&envId=dynamic-programming">1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）</a></h2><p>也是最长公共子序列 只不过不是两个字符串  而是一个字符串 从前往后 一个字符串从后往前 来比较</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minInsertions</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j  - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> n - dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="树上DP"><a href="#树上DP" class="headerlink" title="树上DP"></a>树上DP</h1><h2 id="96-不同的二叉搜索树-力扣（LeetCode）"><a href="#96-不同的二叉搜索树-力扣（LeetCode）" class="headerlink" title="96. 不同的二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/?envType=study-plan-v2&envId=dynamic-programming">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></h2><p>求二叉搜索树的种数  就是G[0] &#x3D; 1 G[1] &#x3D; 1 G[2] &#x3D; 2</p><p><img src="/../images/$%7Bfiilename%7D/image-20231125183323873.png" alt="image-20231125183323873"></p><p>卡特兰数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numTrees</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        g[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>           <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>):<br>                g[i] += g[j - <span class="hljs-number">1</span>] * g[i - j]<br>        <span class="hljs-keyword">return</span> g[n]<br></code></pre></td></tr></table></figure><h2 id="95-不同的二叉搜索树-II-力扣（LeetCode）"><a href="#95-不同的二叉搜索树-II-力扣（LeetCode）" class="headerlink" title="95. 不同的二叉搜索树 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/?envType=study-plan-v2&envId=dynamic-programming">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></h2><p>搜索 首先想要递归什么？递归start和end 就是每棵树包含start到end的元素</p><p>递归出口条件 就是当start &lt; end 的时候 说明没有元素 return None</p><p>然后思考如何去递归  既然是递归start和end中间的元素  那么就可以想到  左子树是start到i  右子树是i+1到end  然后再去把这两个树加上根节点拼起来  存入答案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateTrees</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[TreeNode]]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">start, end</span>):<br>            <span class="hljs-keyword">if</span> start &gt; end:<br>                <span class="hljs-keyword">return</span> [<span class="hljs-literal">None</span>, ]<br>            alltrees = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end + <span class="hljs-number">1</span>):<br>                leftTree = generate(start, i)<br>                rightTree = generate(i + <span class="hljs-number">1</span>, end)<br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> leftTree:<br>                <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rightTree:<br>                    curTree = TreeNode(i)<br>                    curTree.left = l<br>                    curTree.right = r<br>                   allTree.append(curTree)<br>            <span class="hljs-keyword">return</span> allTrees<br>        <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> n <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure><h2 id="337-打家劫舍-III-力扣（LeetCode）"><a href="#337-打家劫舍-III-力扣（LeetCode）" class="headerlink" title="337. 打家劫舍 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iii/description/?envType=study-plan-v2&envId=dynamic-programming">337. 打家劫舍 III - 力扣（LeetCode）</a></h2><p>首先思考怎么表示状态 偷或不偷  返回值表示 左边偷的钱 和右边偷的钱  如果左边或右边偷了  那么根就不能偷 否则偷根 </p><p>递归出口 当root is None的时候 就返回0，0 表示</p><p>然后是每个  当dfs(root.left) 表示偷左不偷右  right同理</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>            l_rob, r_not_rob = dfs(root.left)<br>            l_not_rob, r_rob = dfs(root.right)<br>            rob = root.val + l_not_rob + r_not_rob<br>            <span class="hljs-comment"># not_rob = l_rob + r_rob不偷根 也不一定必须偷左右  而是可以偷左右</span><br>            not_rob = <span class="hljs-built_in">max</span>(l_rob, l_not_rob) + <span class="hljs-built_in">max</span>(r_rob, r_not_rob)<br>            <span class="hljs-keyword">return</span> rob, not_rob<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(root))<br></code></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和-力扣（LeetCode）"><a href="#124-二叉树中的最大路径和-力扣（LeetCode）" class="headerlink" title="124. 二叉树中的最大路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=dynamic-programming">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></h2><p>首先思考递归表示 root</p><p>然后是递归出口 当root is None的时候 返回0</p><p>然后是算出左边的结点 右边的结点  再加上中间的  求最大值</p><p>返回最大值   注意最后的返回值要和0比较 因为有负数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = -inf<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <br>            l_val = dfs(root.left)<br>            r_val = dfs(root.right)<br>            <span class="hljs-keyword">nonlocal</span> ans <br>            ans = <span class="hljs-built_in">max</span>(l_val + r_val + root.val, ans)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l_val, r_val) + root.val, <span class="hljs-number">0</span>)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="1155-掷骰子等于目标和的方法数-力扣（LeetCode）"><a href="#1155-掷骰子等于目标和的方法数-力扣（LeetCode）" class="headerlink" title="1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）</a></h2><p>分组背包 总和为n 每个骰子只能有一个点数 选哪个的问题</p><p>并且不是分组背包求最大值的问题  而是分组背包求固定和的问题  用的转移方程是  j - ds</p><p>第三重循环枚举点数 即 从dp[i - 1] 转移到dp[i] 的情况  有dp[i - 1] [j - 1] + 1；dp[i -  1] [j - 2] + 2 ……dp[i - 1] [j - k] + k </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRollsToTarget</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><span class="hljs-comment"># 注意数组的范围 由于可能遍历计算的最大值是超过target的 所以这里不能开target</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">max</span>(target + <span class="hljs-number">1</span>, n * k + <span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-comment"># 注意初始化 j = 0 的时候不可能 即种数为0 大于k的时候也为0 因为一个骰子最多是k（大于target不用算了 所以为0）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(target, k) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 算到n * k因为n * k 可能小于target 这时候为0</span><br>        maxn = n * k<br>        <span class="hljs-comment"># 前两个循环 是枚举dp[i][j] 前i个骰子 和为j有几种情况</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, maxn + <span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 第三个循环 状态转移 枚举第n - 1个骰子的点数 转移到i</span><br>                ds = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span>  j - ds &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ds &lt;= k:<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - ds]<br>                    dp[i][j] %= mod<br>                    ds += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> dp[n][target]<br></code></pre></td></tr></table></figure><h1 id="组合型背包"><a href="#组合型背包" class="headerlink" title="组合型背包"></a>组合型背包</h1><h2 id="518-零钱兑换-II-力扣（LeetCode）"><a href="#518-零钱兑换-II-力扣（LeetCode）" class="headerlink" title="518. 零钱兑换 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></h2><p>这个题目与上题有区别 一个是求排列数 一个是求组合数 </p><p>也就是说 上一题会把1 2 和2 1当成两种情况 但是这一题 视为同一种情况 如果按上面的写法 最后结果会偏大</p><p>本质原因是子问题的改变   我们需要加上对硬币的限制 1 2 和 2 1 是同种情况 因此可以枚举硬币而不是枚举总和  从小到大枚举硬币 就不会出现2 1这种情况</p><p>现在子问题变为 到第k个硬币 合成金额i的组合数</p><p>状态转移为dp[k] [i] &#x3D; dp[k - 1] [i] + dp[k] [i - coins[k]]  (i &gt; coins[k])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; coins.<span class="hljs-built_in">size</span>(); k++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= coins[k - <span class="hljs-number">1</span>])<br>            dp[k][i] = dp[k][i - coins[k - <span class="hljs-number">1</span>]] + dp[k - <span class="hljs-number">1</span>][i];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp[k][i] = dp[k - <span class="hljs-number">1</span>][i];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时就算交换两个for循环的顺序也不会影响结果 因为交换后子数组的状态转移方程不变 得到的结果也不变</p><p>如果要降成一维的数组 重新定义子问题为 必须选择第k个硬币的时候 凑成金额i的方案数  不能交换for循环的顺序 因为交换完之后 子问题的意义就是 对于金额i 有几种选择硬币的方案数（理解两个子问题的差别 一个是可重复一个不行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// dp[i] 表示必须选择第i个硬币时能凑成的金额的组合数</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                dp[i] += dp[i - x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            cout&lt;&lt;dp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="排列型背包"><a href="#排列型背包" class="headerlink" title="排列型背包"></a>排列型背包</h1><h2 id="322-零钱兑换-力扣（LeetCode）"><a href="#322-零钱兑换-力扣（LeetCode）" class="headerlink" title="322. 零钱兑换 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change/description/?envType=daily-question&envId=2024-03-24">322. 零钱兑换 - 力扣（LeetCode）</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//dp[i] 表示到i为止的最小硬币数</span><br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:coins)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= amount)<br>            dp[x] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i - x] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">1e9</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="279-完全平方数-力扣（LeetCode）"><a href="#279-完全平方数-力扣（LeetCode）" class="headerlink" title="279. 完全平方数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=dynamic-programming">279. 完全平方数 - 力扣（LeetCode）</a></h2><p>背包问题 i 表示到i要多少数 </p><p>当i  &gt; j ^2 的时候i 就可以更新   找到最少的次数  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> num ** <span class="hljs-number">2</span> &gt; n:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> num ** <span class="hljs-number">2</span> == n:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            minn = inf<br>            j = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j ** <span class="hljs-number">2</span> &lt;= i:<br>                minn = <span class="hljs-built_in">min</span>(minn, dp[i - j ** <span class="hljs-number">2</span>])<br>                j += <span class="hljs-number">1</span><br>            dp[i] = minn + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="518-零钱兑换-II-力扣（LeetCode）-1"><a href="#518-零钱兑换-II-力扣（LeetCode）-1" class="headerlink" title="518. 零钱兑换 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/?envType=study-plan-v2&envId=dynamic-programming">518. 零钱兑换 II - 力扣（LeetCode）</a></h2><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>k 表示前k个硬币  i 表示凑成i 元</p><p>前k个硬币凑成i元的种类为 前k - 1个凑成i 元  加上 前k个硬币凑成了i - k元  就差k了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, amount: <span class="hljs-built_in">int</span>, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(coins)<br>        dp = [[<span class="hljs-number">0</span>] * (amount + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> i &gt;= coins[k - <span class="hljs-number">1</span>]:<br>                    dp[k][i] = dp[k][i - coins[k - <span class="hljs-number">1</span>]] + dp[k - <span class="hljs-number">1</span>][i]<br></code></pre></td></tr></table></figure><h1 id="定差型"><a href="#定差型" class="headerlink" title="定差型"></a>定差型</h1><p>不是 i - 1 和i 的关系 而是 每次比较 i 和i - nums[i] 这样的 某个差值nums[i] 之间的关系</p><h2 id="1218-最长定差子序列-力扣（LeetCode）"><a href="#1218-最长定差子序列-力扣（LeetCode）" class="headerlink" title="1218. 最长定差子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/?envType=study-plan-v2&envId=dynamic-programming">1218. 最长定差子序列 - 力扣（LeetCode）</a></h2><p>每次到达dp[i] 的时候 就去 dp[i - difference] 找上一个相差difference的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], difference: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = defaultdict(<span class="hljs-built_in">int</span>)<br><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>            dp[x] = dp[x - difference] + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp.values())<br></code></pre></td></tr></table></figure><h2 id="1027-最长等差数列-力扣（LeetCode）"><a href="#1027-最长等差数列-力扣（LeetCode）" class="headerlink" title="1027. 最长等差数列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">1027. 最长等差数列 - 力扣（LeetCode）</a></h2><p>与上题相同 但是difference需要自己找</p><p>每个dp[i] 存储一个哈希表</p><p>每个哈希表存储 i - 1 ~ 0 的所有数 和nums[i] 的差值（key）和这个差值d 的出现的次数</p><p>比如9 4 7 2 10  到10 的时候 就往前找 2与10 差8 公差为8 的就是1个 再在2中找 公差为8的次数 0 ＋1&#x3D;1</p><p>7 与10 差3 公差为3 在7中找公差为3的 为1 （7 和4） 总次数为2</p><p>最后个数是次数+1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestArithSeqLength</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [&#123;&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>               d = nums[i] - nums[j]<br>                <span class="hljs-keyword">if</span> d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dp[i]:<br>                    dp[i][d] = dp[j].get(d, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>                    <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(d.values()) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dp[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h2 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/E">Problem - E - Codeforces</a></h2><p>从n向前寻找  当i + nums[i] &lt;&#x3D; n的时候  是可以形成 [长度+数组]的形式的  这时候就要检查这个地方是否需要选（可以选 也可以不选）</p><p>就要判断选这个点的代价（因为选这个可能影响其他代价更小的点）选了就是 dp[i + nums[i] + 1] 就是 这个点清除掉之后 比如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 2 3 4 5 6 7<br>3 3 4 5 2 6 1<br></code></pre></td></tr></table></figure><p>选了nums[1]的话 从1到n的代价就为 nums[5]的代价 因为1~4都被消除了</p><p>如果不选i 的话  那就是dp[i + 1] + 1(即直接删除这个点)</p><p>如果i + nums[i] &gt; n 不能形成 数组 那就需要删除 删除的话就是dp[i] &#x3D; dp[i + 1] + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(N)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br><br>    dp[n] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + i &gt; n)<br>            dp[i] = dp[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i + nums[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="100133-购买水果需要的最少金币数-力扣（LeetCode）"><a href="#100133-购买水果需要的最少金币数-力扣（LeetCode）" class="headerlink" title="100133. 购买水果需要的最少金币数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/description/">100133. 购买水果需要的最少金币数 - 力扣（LeetCode）</a></h2><p>跟上面那题有点像。。但是也不一样</p><p>找买水果的最少的钱数  首先写递归 </p><p>这个水果买或不买 怎么看 哪些水果是免费的？ 从1开始递归往后找</p><p>能够不花钱的水果就是i + 1, i + 2 …, 2 * i</p><p>那我下一个要买的水果 就是从i + 1 i + 2… 2 * i + 1 因为2 * i + 1必定是要买的  而前面i个是可以选择买的  那么下一个买的肯定就在这中间 </p><p>那么dfs（i）的意义就是 从1到后面需要花的最少的钱</p><p>那么从i开始 后面要花的最少的钱 就是 我现在买了i的钱 再加上下一个要买的 j 的最小值 （从j 到后面需要花的最少的钱）就是 i买的覆盖了i到2 * i 然后加上 dfs（j） 的最小值就是dfs(i)</p><p>然后递归出口 大于n的时候就是 0 就是不用在花钱了</p><p>细节地方是 prices 下标从1开始 我们dfs也定义从1开始 但是本质上prices是个数组 下标从0开始  所以每次加的时候 加prices[i - 1]</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> i &gt; n:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            res = <span class="hljs-built_in">min</span>(dfs(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>))<br>            <span class="hljs-keyword">return</span> res + prices[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>优化可以是 2 * i &gt; n的时候 return prices[i - 1] 因为这时候只用花一次钱就行了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * i &gt;= n:<br>                <span class="hljs-keyword">return</span> prices[i - <span class="hljs-number">1</span>]<br>            res = <span class="hljs-built_in">min</span>(dfs(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>))<br>            <span class="hljs-keyword">return</span> res + prices[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>然后翻译成递推 因为我们是从1开始到n的  那么变成递推就要改成从n 开始 因为从1 开始 递归到n 说明我实际上是从n算到1的  就是 我算前面的时候  后面是已经先算出来的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br>        f = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * i &gt;= n:<br>                f[i] = prices[i - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                f[i] = prices[i - <span class="hljs-number">1</span>] + <span class="hljs-built_in">min</span>(f[i + <span class="hljs-number">1</span>: <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1214-波动数列-AcWing题库"><a href="#1214-波动数列-AcWing题库" class="headerlink" title="1214. 波动数列 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1216/">1214. 波动数列 - AcWing题库</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, s, a, b;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">100000007</span>;<br><span class="hljs-type">int</span> f[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmod</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x % y + y) % y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            f[i][j] = ((f[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(j - a * (n - i), n)] + f[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(j + b * (n - i), n)]))%mod;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(s, n)];<br>&#125;<br></code></pre></td></tr></table></figure><p>[d]: </p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/10/11/KMP/"/>
    <url>/2023/10/11/KMP/</url>
    
    <content type="html"><![CDATA[<p>将模式串指针j的回溯 看作整个模式串向后移动来匹配主串</p><p>当i j不匹配的时候有两种做法，第一是模式串移动到当前串的后面（对应的其实是next数组移动到0的位置的时候 也就是全不匹配的时候）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>          <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>第二种 移动到下一个公共子串的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>    <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>即主串的后缀集合与模式串的前缀集合有交集的时候</p><p>j指针回溯的位置是A后缀和B前缀交集里最长的元素（这样不会遗漏）最长元素的长度就是j回溯的位置</p><p>匹配失败 但是A和B串存在一段相同的子串 j回溯的位置只与B有关（A、B相同子串的前后缀 其实就是B子串的前后缀） 因此可以先求出B放入next数组</p><p>next[i]表示B[1]~B[i]最长公共前后缀的长度</p><p>匹配步骤</p><p>i, j初始化为0</p><p>1.如果A[i + 1] &#x3D;&#x3D; B[j + 1] i++,j++</p><p>2.如果不相等 不断回溯j到next[j] 直到A[i + 1] &#x3D;&#x3D; B[j + 1]   或者j回溯到next[0] &#x3D; -1了 此时直接让i++（）意思是B移到A后面</p><p>3.j &#x3D; m 匹配成功输出位置 </p><p>构建next数组  </p><p>求B[1]~B[i]最长公共后缀长度</p><p>如果匹配 next[i] &#x3D; j + 1  (j 表示B串前缀的指针 也就是当前字符匹配之前的最长公共前后缀长度 匹配成功就+1)</p><p>匹配不成功 回溯j指针j &#x3D; next[j]直到成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(string p, <span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i] = j<br>&#125;<br>        <span class="hljs-keyword">else</span><br>           j = next[j]<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">KMP</span>(string s, string p, <span class="hljs-type">int</span> next[])<br>&#123;<br>    <span class="hljs-built_in">getnext</span>(p,next);<br>    <br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j = next[j]<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == p_len)<span class="hljs-keyword">return</span> i - j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课题组学习</title>
    <link href="/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）"><a href="#分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）" class="headerlink" title="分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></h1><h2 id="压缩表示"><a href="#压缩表示" class="headerlink" title="压缩表示"></a>压缩表示</h2><p>集合用二进制表示，从高到低第i位为1表示i在集合中。如{0,2,3}可以表示为1101，压缩成一个数字 13</p><h2 id="集合与集合"><a href="#集合与集合" class="headerlink" title="集合与集合"></a>集合与集合</h2><p>集合的交并补差</p><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><p>“&lt;&lt;”代表左移，相当于乘2 ^ i</p><p>“&gt;&gt;”代表右移， 相当于除2 ^ i</p><p>补集~s</p><p>全集 (1&lt;&lt;n) - 1</p><p>属于  (s &gt;&gt; i) &amp; 1 &#x3D; 1</p><p>不属于 (s &gt;&gt; i) &amp; 1 &#x3D; 0</p><p>添加元素 s | (1 &lt;&lt; i)</p><p>删除元素 s &amp; ~ (1 &lt;&lt; i)  (比如i &#x3D; 2 变成0100 取反变成 1011 然后和s并起来  这样才可以保证 只删除目标位而不影响其他位)</p><p>删除最小元素 s &amp; (s - 1) ((s - 1)可以使得最低位的1变为0 并且其右边的所有0变为1  然后&amp;s 使得 最低位的1以及后面的所有0全部变成0)</p><p>lowbit  &#x3D; s &amp; (-s)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">     s = <span class="hljs-number">101100</span><br>    ~s = <span class="hljs-number">010011</span><br>(~s)+<span class="hljs-number">1</span> = <span class="hljs-number">010100</span> <span class="hljs-regexp">//</span> 根据补码的定义，这就是 -s   最低 <span class="hljs-number">1</span> 左侧取反，右侧不变<br>s &amp; -s = <span class="hljs-number">000100</span> <span class="hljs-regexp">//</span> lowbit<br></code></pre></td></tr></table></figure><h3 id="部分库函数"><a href="#部分库函数" class="headerlink" title="部分库函数"></a>部分库函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">s.bit_count() <span class="hljs-comment"># 集合大小</span><br>s.bit_length() <span class="hljs-comment"># 二进制长度</span><br>(s&amp;-s).bit_length()-<span class="hljs-number">1</span> <span class="hljs-comment"># 集合中的最小元素</span><br></code></pre></td></tr></table></figure><h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-comment"># 如果i在s中</span><br>    <span class="hljs-keyword">if</span> (s &gt;&gt; i) &amp; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="枚举集合"><a href="#枚举集合" class="headerlink" title="枚举集合"></a>枚举集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 从空集枚举到全集U</span><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 设集合为s 从大到小枚举s的所有非空子集sub</span><br>sub = s<br><span class="hljs-keyword">while</span> sub:<br>    <span class="hljs-comment"># pass</span><br>    <br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s <span class="hljs-comment"># （如何证明？）</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">跳过非子集的集合！</span><br><span class="hljs-string">意思是，把10100 的最低位1变0，它的后面有两位 00， 都是0。这时候按照普通二进制，会把这两个 00 都变成 11，如果按照压缩版，就只把原来集合里有的 1 变成 1 （因为求的是子集），其余的还是 0，原有的集合是 10101，最后两位是 01，所以只保留 01。综合起来就是 10100 先变 10000，然后保留 01，变成 10001。</span><br><span class="hljs-string"></span><br><span class="hljs-string">这样做的效果是从 10100 直接跳到 10001，把中间的 10011 和10010 忽略掉了（普通减法顺序是 10100 - 10011 - 10010 - 10001），因为10011 和 10010不是有效的子集。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 所有子集</span><br><span class="hljs-keyword">while</span> sub:<br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s<br>    <span class="hljs-keyword">if</span> sub == s:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h1 id="136-只出现一次的数字-力扣（LeetCode）"><a href="#136-只出现一次的数字-力扣（LeetCode）" class="headerlink" title="136. 只出现一次的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></h1><p>一个数字出现一次 其他数字出现两次   用异或操作 因为a^0 &#x3D; a a ^ a &#x3D; 0 所以两个一样的数异或就为0 </p><p>并且a ^ b ^ c 满足交换律  </p><p>即所有的数都是相同的凑成一对 变为0   然后剩下的目标数字^0 &#x3D; 目标  输出即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            ret ^= x<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="137-只出现一次的数字-II-力扣（LeetCode）"><a href="#137-只出现一次的数字-II-力扣（LeetCode）" class="headerlink" title="137. 只出现一次的数字 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-ii/description/">137. 只出现一次的数字 II - 力扣（LeetCode）</a></h1><p>一个数字出现三次  目标数字出现三次</p><p>所以每个比特位的1的数量必定是3的倍数  不是3的倍数的 就是ans的比特位 </p><p>注意python这种对有符号整型和无符号整型不区分的语言 需要特判最高位</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = [<span class="hljs-number">0</span>] * <span class="hljs-number">33</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>                ret[i] += ((x&gt;&gt;i) &amp; <span class="hljs-number">1</span>)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>            <span class="hljs-keyword">if</span> ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">31</span>:<br>                    ans -= (<span class="hljs-number">1</span> &lt;&lt; i)<br>                <span class="hljs-keyword">else</span>:<br>                    ans |= (<span class="hljs-number">1</span> &lt;&lt; i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            &#123;<br>                ret[i] += ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>)<br>                ans += (<span class="hljs-number">1</span> &lt;&lt; i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="260-只出现一次的数字-III-力扣（LeetCode）"><a href="#260-只出现一次的数字-III-力扣（LeetCode）" class="headerlink" title="260. 只出现一次的数字 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-iii/description/">260. 只出现一次的数字 III - 力扣（LeetCode）</a></h1><p>每个元素只出现两次  有两个只出现一次的数 要找出这两个数 </p><p>由于这两个数不同  必然有一个(以上)的比特位不同  那么就求这个比特位 </p><p>然后把所有在这个比特位上 是1 的 异或到一起 （包含所有 这个比特位上是1 的两个两个的数  和 这个比特位上是1 的目标数）  把所有这个比特位上是0 的异或到一起…</p><p>注意取  lowbit   lowbit &#x3D;  a &amp; (-a)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        xorsum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            xorsum ^= x<br>        ans1 = ans2 = <span class="hljs-number">0</span><br>        lb = xorsum &amp; (-xorsum)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> lb &amp; x:<br>                ans1 ^= x<br>            <span class="hljs-keyword">else</span>:<br>                ans2 ^= x<br><br>        <span class="hljs-keyword">return</span> [ans1, ans2]<br></code></pre></td></tr></table></figure><h1 id="78-子集-力扣（LeetCode）"><a href="#78-子集-力扣（LeetCode）" class="headerlink" title="78. 子集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></h1><p>子集的形式与二进制数非常相似 可以考虑用二进制来写</p><p>1 &lt; (1 &lt;&lt; n)就是小于2的n次方</p><p>i&gt;&gt;j 就是把i这个二进制数往右移动j位</p><p>比如0001  移动0位是1  移动1位是0 移动两位是0 三位是0</p><p>就是用这种方式 代表每个位置上的数选或不选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        rets = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; (<span class="hljs-number">1</span>&lt;&lt;n):<br>            ret = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:<br>                    ret.append(nums[j])<br>            rets.append(ret)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> rets<br></code></pre></td></tr></table></figure><h1 id="421-数组中两个数的最大异或值-力扣（LeetCode）"><a href="#421-数组中两个数的最大异或值-力扣（LeetCode）" class="headerlink" title="421. 数组中两个数的最大异或值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></h1><h2 id="前缀哈希表"><a href="#前缀哈希表" class="headerlink" title="前缀哈希表"></a>前缀哈希表</h2><p>mask每次是00000-10000-11000-11100-11110-11111 每次让他第i位变成1  则其前i位都为1  后i + 1位都为0</p><p>new_ans &#x3D; ans|&#x3D;(1  &lt;&lt; i) 就是假设ans的第i位为1 其余位不变</p><p>然后对每个x 先和mask与 得到 <strong>前缀</strong> 重点  这里是得到前缀  因为mask前i位为1 后为0 则与后 x前i位不变 后i+1位为0 实现取前缀的操作</p><p>假设此时进行到了第 k个x (即nums[k]) seen里面有nums的前k - 1个数的前缀（后缀为0）如果x ^ new_ans 在seen里找到了  说明ans的这一位为1是可以的  因为：</p><p>x ^ new_ans 如果在seen里找到了   说明seen里一定有一个数 y 满足 x ^ y &#x3D;&#x3D; new_ans   （因为a ^ b &#x3D; c  &lt;&#x3D;&gt; a ^ c &#x3D; b &lt;，&#x3D;&gt; b ^ c &#x3D; a）那就说明 有两个数的异或值 可以为new_ans （也即在保留前i - 1位的情况下  第i位可以为1）   如果没有找到的话 就说明不存在两个数异或为new_ans 那ans就不变 （即该位为0不变）否则ans &#x3D; new_ans   这样 每一位都尽量取1  最后就是最大值</p><p>主要用了 用mask与 取前缀排除后缀的影响  不是只比较第i位  而是比较前i位   </p><p>设new_ans 去异或  然后在set里查找</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaximumXOR</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = mask = <span class="hljs-number">0</span><br>        high_bit = <span class="hljs-built_in">max</span>(nums).bit_length() - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            mask = <span class="hljs-number">1</span> |= (<span class="hljs-number">1</span> &lt;&lt; i) <br>            seen = <span class="hljs-built_in">set</span>()<br>           new_ans = ans |= (<span class="hljs-number">1</span> &lt;&lt; i)<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>                x &amp;= mask<br>                <span class="hljs-keyword">if</span> (x ^ new_ans) <span class="hljs-keyword">in</span> seen():<br>                    ans = new_ans<br>                    <span class="hljs-keyword">break</span><br>                seen.add(x)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>建前缀树  要尽量往相反方向走</p><p>每个数进入add函数 建树  扩展树的枝叶</p><p>每个数进入check函数 如果当前位是1 则尽量往0的枝叶走（left）如果左边走不了再走右  如果当前位是0 尽量往1走（right）</p><p>每次走到相反位   x &#x3D; x * 2 + 1 相同位 x &#x3D; x * 2 因为是从高往低位走的（从根往叶子走） </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaximumXOR</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        root = Trie()<br>        high_bit = <span class="hljs-built_in">max</span>(nums).bit_length() - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>            cut = root<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> bit == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> cur.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                        cur.left = Trie()<br>                    cur = cur.left<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> cur.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                        cur.right = Trie()<br>                    cur = cur.right<br>       <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>            cur = root<br>            x = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> bit == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> cur.right:<br>                        cur = cur.right<br>                        x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        cur = cur.left<br>                        x = x * <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> cur.left:<br>                        cur = cur.left<br>                        x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        cur = cur.right<br>                        x = x * <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> x<br>         <br>        x = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            add(nums[i - <span class="hljs-number">1</span>])<br>            x = <span class="hljs-built_in">max</span>(x, check(nums[i]))<br>        <span class="hljs-keyword">return</span> x<br>            <br></code></pre></td></tr></table></figure><h1 id="2939-最大异或乘积-力扣（LeetCode）"><a href="#2939-最大异或乘积-力扣（LeetCode）" class="headerlink" title="2939. 最大异或乘积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-xor-product/description/">2939. 最大异或乘积 - 力扣（LeetCode）</a></h1><p>aa</p><p>两个位相同的话 x的该位就直接取反</p><p>两个位不同的话 总有一位为0 一位为1 如何取</p><p>注意到a &#x3D; 12 和 b &#x3D; 5 即 1100 和 0101 x第二位为0第三位为1 那么x如果是0010 即让x异或完a变成 0100 &#x3D; 8 b变成1101 &#x3D; 13 总和为21  如果x是1010 a &#x3D; 0110 6 b &#x3D; 1111 15 总和为21   其实也很好想 每个地方放1 不管放在哪 都会被加进去 在a第0位 放1 变成a + 1 + b   在b的第0位放1 也是a + b + 1 所以a + b 总和是不变的  这也是位运算的特殊之处</p><p>基本不等式 a + b &gt; 2 sqrt(a * b)  要让a b尽量接近</p><p>如何让a b 尽量接近呢  由上分析 已经知道了 只需要考虑a 和b中 不相等的位 那这几位1是固定的 关键在于如何把1分配给a 和b 要让a b 尽量接近 如果a &gt; b 就把最高位分配给a 剩余位 分配给b （因为最高的一位大于剩下最低位的和</p><p>然后考虑分配 a b 都小于2 ^ n 直接分  a b有一个 大于等于 2 ^ n的时候  那前面的部分是不可修改的 如果a b前面的位都相同 那就跟上面一样 分配后面的  否则 a &gt; b 的话 那就把所有的1都分配给b</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumXorProduct</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> a &lt; b:<br>            a, b = b, a<br>        mask = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> <span class="hljs-comment"># 全为1的掩码</span><br>        <span class="hljs-comment"># 取出第n位及其左边的数 不被x影响</span><br>        ax = a &amp; ~mask<br>        bx = b &amp; ~mask<br>        <span class="hljs-comment"># 再来算右边的</span><br>        a &amp;= mask<br>        b &amp;= mask<br>        <br>        left = a ^ b <span class="hljs-comment"># 可分配的位 （a^b 就是a和b的不同位）</span><br>        one = mask ^ left <span class="hljs-comment"># 不用分配的位</span><br>        <span class="hljs-comment"># 把右边的 无需分配的 先加到左边</span><br>        ax |= one<br>        bx |= one<br>        <br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ax == bx:<br>            high_bit = <span class="hljs-number">1</span> &lt;&lt; (left.bit_length() - <span class="hljs-number">1</span>)<br>            ax |= high_bit <span class="hljs-comment"># 最高位给a</span><br>            left ^= high_bit <span class="hljs-comment"># 除了最高位以外的其他位</span><br>        bx |= left <span class="hljs-comment"># 给b （因为当left &gt; 0 ax == bx的时候才需要把最高位给a  但是 其他的不管什么情况都是给b）</span><br>    <span class="hljs-keyword">return</span> ax * bx % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch环境</title>
    <link href="/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="配个环境配了一天-人麻了"><a href="#配个环境配了一天-人麻了" class="headerlink" title="配个环境配了一天 人麻了"></a>配个环境配了一天 人麻了</h1><p>pytorch+cuda环境配置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">conda create -n &#123;Env Name&#125; python==<span class="hljs-number">3</span>.<span class="hljs-number">10</span><br>conda activate &#123;Env Name&#125;<br>pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br>pip install torch==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>+cu118 torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">15</span>.<span class="hljs-number">1</span>+cu118 torchaudio==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+cu118 -f https://download.pytorch.org/whl/torch_stable.html<br></code></pre></td></tr></table></figure><p>注意使用清华源要关VPN </p><p>注意对应版本<a href="https://zhuanlan.zhihu.com/p/694038606">PyTorch&#x2F;Python&#x2F;Cuda&#x2F;torchvision&#x2F;torchaudio版本对应和兼容性 - 知乎 (zhihu.com)</a></p><p>实测下来下载速度非常快5<del>15MB&#x2F;s 包大概是2</del>3GB 不超过十分钟下载好 如果不是这样大概率是网络有问题</p><p>验证</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import torch<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(torch.cuda.is_available()</span></span>)<br></code></pre></td></tr></table></figure><p>应该是True</p><h2 id="下不下来的包-居然可以直接复制粘贴文件夹吗？（😀"><a href="#下不下来的包-居然可以直接复制粘贴文件夹吗？（😀" class="headerlink" title="下不下来的包 居然可以直接复制粘贴文件夹吗？（😀"></a>下不下来的包 居然可以直接复制粘贴文件夹吗？（😀</h2><p>vscode终端出问题。。一直以为是pytorch环境错了</p><p>把终端换成（pytorch1）也就是conda的虚拟环境就可以了 而不能用PS的终端</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基环树</title>
    <link href="/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    <url>/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>一般来说就是先存反图 算入度 </p><p>然后拓扑排序 剩下的就是基环</p><p>第三步 分别对每个基环进行操作 找基环的方式为模板（如下题）</p><h1 id="2127-参加会议的最多员工数-力扣（LeetCode）"><a href="#2127-参加会议的最多员工数-力扣（LeetCode）" class="headerlink" title="2127. 参加会议的最多员工数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/">2127. 参加会议的最多员工数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumInvitations</span>(<span class="hljs-params">self, favorite: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(favorite)<br>        deg = [<span class="hljs-number">0</span>] * n<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(favorite):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br><br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = favorite[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            m_depth = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    m_depth = <span class="hljs-built_in">max</span>(m_depth, rdfs(y) + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> m_depth<br><br>        <br>        max_ring_size = sum_chine_size = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 找基环的套路</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            res = <span class="hljs-number">0</span><br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                res += <span class="hljs-number">1</span><br>                deg[x] = -<span class="hljs-number">1</span><br>                x = favorite[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">2</span>:<br>                sum_chine_size += rdfs(i) + rdfs(favorite[i])<br>            <span class="hljs-keyword">else</span>:<br>                max_ring_size = <span class="hljs-built_in">max</span>(max_ring_size, res)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_ring_size, sum_chine_size)<br></code></pre></td></tr></table></figure><h1 id="2876-有向图访问计数-力扣（LeetCode）"><a href="#2876-有向图访问计数-力扣（LeetCode）" class="headerlink" title="2876. 有向图访问计数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/description/">2876. 有向图访问计数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countVisitedNodes</span>(<span class="hljs-params">self, g: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(g)<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        deg = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(g):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br>        <br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = g[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br>        <br>        ans = [<span class="hljs-number">0</span>] * n<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x, depth</span>):<br>            ans[x] = depth<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    rdfs(y, depth + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 找基环的操作</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            ring = []<br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ring.append(x)<br>                deg[x] = -<span class="hljs-number">1</span><br>                x = g[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ring:<br>                rdfs(x, <span class="hljs-built_in">len</span>(ring))<br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="股票问题系列通解（转载翻译）-力扣（LeetCode）"><a href="#股票问题系列通解（转载翻译）-力扣（LeetCode）" class="headerlink" title="股票问题系列通解（转载翻译） - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/qiAgHn/">股票问题系列通解（转载翻译） - 力扣（LeetCode）</a></h1><p>首先，通用状态表示是dp[i] [k] [0]和dp[i] [k] [1]表示第i天时 交易k次 手上有0&#x2F;1只股票的时候的最大利润 </p><p>状态计算，dp[i] [k] [0] &#x3D; max(dp[i - 1] [k] [0], dp[i - 1] [k] [1] + price[i]])</p><p>第i天手上有0只股票的最大收益为 第i - 1天手上有0只股票 和 第i - 1天手上有1只股票并且卖掉的最大收益 </p><p>dp[i] [k] [1] &#x3D; max(dp[i - 1] [k] [1], dp[i - 1] [k - 1] [0] - price[i]])</p><p>第i天手上有1只股票的最大收益为 第i - 1天手上有1只股票 和 第i - 1天手上有0只股票并且买入的最大收益 注意 要减掉一次交易次数</p><p>当k &gt;&#x3D; n &#x2F;&#x2F; 2时 就相当于k无限 因为买入卖出算一次交易 那么最多前面一半全买入 后面一半全卖出</p><p>手续费直接减掉</p><p>冷冻期就跳过一天  加入i - 2天这个变量 买入的时候要从第i - 2天转移过来</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Ans</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合题解</title>
    <link href="/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>并查集模板</p><p>看两个数是不是在一个集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, p  = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> fa[x] == x:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    union(a, b)<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> find(a) == find(b):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Loading-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#Loading-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1536">Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>不是看两个数是不是在一个集合 而是计算一共有多少个集合</p><p>计算还需要修几条路才能把所有村子连接起来 其实就是求现在的集合数 连起来的村子当同一个村子 当fa[i] &#x3D;&#x3D; i 的时候 cnt + 1  因为每个集合有且仅有一个 fa[i] &#x3D;&#x3D; i 因此可以用来计数 最后 村子数减一就是道路数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    n = l[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    m = l[<span class="hljs-number">1</span>]<br>    fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        union(a, b)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> fa[i] == i:<br>            cnt += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(cnt - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>为每个字符串求一个hash值 直接放入列表中 排序列表 然后看相邻的两个数的值是否一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">base = <span class="hljs-number">131</span><br>prime = <span class="hljs-number">233317</span><br>mod = <span class="hljs-number">212370440130137957</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hashe</span>(<span class="hljs-params">s</span>):<br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>        ans = (ans * base + <span class="hljs-built_in">ord</span>(char)) % mod + prime<br>    <span class="hljs-keyword">return</span> ans<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    s = <span class="hljs-built_in">input</span>()<br>    a.append(hashe(s))<br><br>a.sort()<br>ans = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> a[i] != a[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P3405 USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P3405 <a href="https://www.luogu.com.cn/problem/P3405">USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求城市对数 算出每个城市的hash值（只需要看前两位） 如果AB不是同一座城市  那么A B就是一个城市对 先放入mp中存起来  而B A可以直接加到答案里（题目要求有两个城市互为对的时候才算一个 比如MIAMT FL  和 FLINT 和 MI 算一对）所以每次遇到A B都先存着  知道遇到B  A再一次取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>ans = <span class="hljs-number">0</span><br>mp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">676</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">676</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a, b = <span class="hljs-built_in">input</span>().split()<br>    A = (<span class="hljs-built_in">ord</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    B = (<span class="hljs-built_in">ord</span>(b[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(b[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> A != B:<br>        mp[A][B] += <span class="hljs-number">1</span>  <br>        ans += mp[B][A]<br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>计数 然后看mp中有没有A - k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>mp = &#123;&#125;<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> mp:<br>        mp[x] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        mp[x] = <span class="hljs-number">1</span><br><br>ans = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mp.items():<br>    <span class="hljs-keyword">if</span> key - k <span class="hljs-keyword">in</span> mp:<br>       ans += mp[key - k] * value<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1525 NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1525 <a href="https://www.luogu.com.cn/problem/P1525">NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>带权并查集   并且一共只有两个集合  判断每个集合里面要放哪些</p><p>首先定义fa数组和Enemy（空数组） 对所有囚犯的怒气值从大到小排序 把最大的分别放到不同的集合 直到出现冲突（比如有个人A 和B   前面有一个在1监狱已经放好 而且B被放到2监狱（因为1和B的仇恨更大）这个人没办法 只能被放到1 和B仇恨较小的那个监狱）由于排序了 这个值就是最大值  带权值的并查集 只要用结构体加上w就行</p><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fo,to,w</span>):<br>        self.fo = fo<br>        self.to = to<br>        self.w = w<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-keyword">if</span> fa[k] == k:<br>        <span class="hljs-keyword">return</span> k<br>    fa[k] = find(fa[k])<br>    <span class="hljs-keyword">return</span> fa[k]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>p = [node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    p[i].fo = u<br>    p[i].to = v<br>    p[i].w = w<br><br>p.sort(key=<span class="hljs-keyword">lambda</span> x: -x.w)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    <span class="hljs-comment"># 如果已经在同一监狱</span><br>    t1, t2 = find(p[i].fo), find(p[i].to)<br>    <span class="hljs-keyword">if</span> t1 == t2:<br>        <span class="hljs-built_in">print</span>(p[i].w)<br>        sys.exit()<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].fo] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].fo] = p[i].to<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].fo], p[i].to)<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].to] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].to] = p[i].fo<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].to], p[i].fo)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h1 id="P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1621">P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最终的集合数其实就是算素数的个数  因为非素数都会被合并  每次合并总集合都减去一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>a, b, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>ans = b - a + <span class="hljs-number">1</span><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>prime = [<span class="hljs-number">0</span>] * (b + <span class="hljs-number">1</span>)<br>prime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> prime[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> i &gt;= p:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> j - i &gt;= a <span class="hljs-keyword">and</span> find(j) != find(j - i):<br>                    union(j, j - i)<br>                    ans -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1892 BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1892 <a href="https://www.luogu.com.cn/problem/P1892">BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    op, a, b = <span class="hljs-built_in">input</span>().split()<br>    a = <span class="hljs-built_in">int</span>(a)<br>    b = <span class="hljs-built_in">int</span>(b)<br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;E&#x27;</span>:<br>        <span class="hljs-keyword">if</span> Enemy[a] == <span class="hljs-number">0</span>:<br>            Enemy[a] = find(b)<br>        <span class="hljs-keyword">else</span>:<br>            union(Enemy[a], b)<br>        <span class="hljs-keyword">if</span> Enemy[b] == <span class="hljs-number">0</span>:<br>            Enemy[b] = find(a)<br>        <span class="hljs-keyword">else</span>:<br>            union(a, Enemy[b])<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;F&#x27;</span>:<br>        union(a,b)<br><br>count = [<span class="hljs-number">0</span>] * <span class="hljs-number">1001</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    count[find(i)] = <span class="hljs-number">1</span><br><br>cnt= <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt += count[i]<br><br><span class="hljs-built_in">print</span>(cnt)<br></code></pre></td></tr></table></figure><h1 id="765-情侣牵手-力扣（LeetCode）"><a href="#765-情侣牵手-力扣（LeetCode）" class="headerlink" title="765. 情侣牵手 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/couples-holding-hands/description/?envType=daily-question&envId=2023-11-11">765. 情侣牵手 - 力扣（LeetCode）</a></h1><p>n对情侣要相邻 (0, 1)(2, 3)(4, 5)… 从 因此可以分组 01为第0组 23为第1组 45 为第2组… 恰好0 1 &#x2F; 2 &#x3D; 0  2 3 &#x2F; 2 &#x3D; 1  4 5 &#x2F; 2 &#x3D; 2 这样来分组   </p><p>如果两组情侣坐错了 那只需要其中两个人互换一次就可以  三组情侣坐错 只需要互换两次就可以 即k对错误的情侣 需要k - 1次交换就可以</p><p>注意 三个互相坐错 2次   若是两组 3个互相坐错就是 4次…（称为一个环）</p><p>就寻找有几个相互坐错的环  每个环 求环的大小减1就行</p><p>用并查集来写 坐错的就加到一个集合里 最后统计每个集合要交换的个数相加</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSwapsCouples</span>(<span class="hljs-params">self, row: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">if</span> x == fa[x]:<br>                <span class="hljs-keyword">return</span> x<br>           fa[x] = find(fa[x])<br>            <span class="hljs-keyword">return</span> fa[x]<br>      <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>            fa[find(x)] = find(y)<br>        <br>        <br>        n = <span class="hljs-built_in">len</span>(row)<br>        m = n // <span class="hljs-number">2</span><br>        fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, <span class="hljs-number">2</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            0 1 union(0, 0) 就是把0 合到 0 不变 下面去比的时候 0 == find(0) 就是集合0 </span><br><span class="hljs-string">            若是0 3 union(0, 1) 即 集合1 合到集合1 那么find(1) = 0下面找 1 != find(1)那就不是</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            union(row[i] // <span class="hljs-number">2</span>, row[i + <span class="hljs-number">1</span>] // <span class="hljs-number">2</span>)<br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> find(i) == i:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> m - cnt    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赛题题解</title>
    <link href="/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-C-Codeforces"><a href="#Problem-C-Codeforces" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/C">Problem - C - Codeforces</a></h1><p>先给每一圈赋一个权重dis</p><p>算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> dis[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; nums;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        nums.<span class="hljs-built_in">emplace_back</span>(s);<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res += dis[<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i, j), <span class="hljs-built_in">min</span>(<span class="hljs-number">9</span> - i, <span class="hljs-number">9</span> - j))];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/E">Problem - E - Codeforces</a></h1><p>赛时调了半天没调出来，寄，害的F也没调出来&#x2F;kk </p><p>二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mid - nums[i] &gt;= <span class="hljs-number">0</span>)<br>            res += (mid - nums[i]);<br>        <span class="hljs-keyword">if</span> (res &gt; m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(nums));<br>    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>, mid;<br><br>    <span class="hljs-keyword">while</span> (l &lt;= r)<br>    &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>        &#123;<br>            res = mid;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br><br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-G-Codeforces"><a href="#Problem-G-Codeforces" class="headerlink" title="Problem - G - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/G">Problem - G - Codeforces</a></h1><p>AB-&gt;BC BA-&gt;CB</p><p>那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 </p><p>如果有两个B连在一起的话只可能是B..BB…B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B </p><p>如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span> || s[n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;A&#x27;</span>)<br>                sum++, cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            &#123;<br>                minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>                    flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>        <span class="hljs-keyword">if</span> (flag)<br>        &#123;<br>            cout &lt;&lt; sum &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (minn != <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>                cout &lt;&lt; sum - minn &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/H">Problem - H - Codeforces</a></h1><p>寻找基环树（套路）因为这个题不仅要判断环 而且需要储存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, a, b; <span class="hljs-comment">// a is M b is V</span><br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 存无向图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        graph[u].<span class="hljs-built_in">pb</span>(v);<br>        graph[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">incircle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>    <br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (v == fa)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-comment">// 第二次经过代表有环</span><br>            &#123;<br>                ok = <span class="hljs-literal">true</span>;<br>                incircle[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记在环上</span><br>                <span class="hljs-type">int</span> x = u;<br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    incircle[x] = <span class="hljs-number">1</span>;<br>                    x = pre[x];<br>                &#125; <span class="hljs-keyword">while</span> (x != v); <span class="hljs-comment">// 标记环上的所有点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                vis[v] = <span class="hljs-number">1</span>;<br>                pre[v] = u;<br>                <span class="hljs-built_in">dfs</span>(v, u);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 如果已经在环上了</span><br>    <span class="hljs-keyword">if</span> (incircle[b]) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> goal = <span class="hljs-number">-1</span>, gdis = <span class="hljs-number">-1</span>;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-comment">// 清空vis数组</span><br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;b, <span class="hljs-number">0</span>&#125;);<br>    vis[b] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (incircle[v])<br>            &#123;<br>                goal = v;<br>                gdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">goto</span> end;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>end:;<br>    <span class="hljs-keyword">if</span> (goal == a)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> tdis = <span class="hljs-number">-1</span>;<br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;a, <span class="hljs-number">0</span>&#125;);<br>    vis[a] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (v == goal)<br>            &#123;<br>                tdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (tdis &lt;= gdis)<br>                    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="5153-删除-AcWing题库"><a href="#5153-删除-AcWing题库" class="headerlink" title="5153. 删除 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5156/">5153. 删除 - AcWing题库</a></h1><p>一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除<br>而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推<br>所以只需要枚举1 2 3 位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;8&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;8&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                cout &lt;&lt; a &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; k++)<br><br>            &#123;<br>                <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">100</span> + (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                    cout &lt;&lt; a &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1878/problem/D">Problem - D - Codeforces</a></h1><p>给出区间 然后反转 可以用差分 当这个下标被旋转奇数次的时候就需要旋转 被旋转偶数次的时候 就相当于没动 不用旋转 </p><p>每次旋转要找到唯一一个i 使得a[i] &lt;&#x3D; x &amp;&amp; b[i] &gt;&#x3D; x 然后旋转a[i] b[i] 的元素 </p><p>可以用cnt（类似差分数组）记录x出现的次数   并且不需要根据x寻找第二行所说的那个区间 而是遍历区间 找到这个区间的x</p><p>遍历区间 然后取出子串 从left到mid依次与right到mid交换 （根据sum的奇偶来判断）sum就是当前位置和对称位被交换次数之和（累计   因为是差分）然后输出子串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br><br>using namespace std;<br><br>using ll = long long;<br>using PII = pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;;<br><br><span class="hljs-comment">#define pb push_back</span><br><span class="hljs-comment">#define all(x) (x).begin(), (x).end()</span><br><span class="hljs-comment">#define fi first</span><br><span class="hljs-comment">#define se second</span><br><span class="hljs-comment">#define endl &#x27;\n&#x27;</span><br><br><span class="hljs-comment">#define debug(x)                          \</span><br>    &#123;                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; \</span><br>    &#125;<br><span class="hljs-comment">#define debugfull(x)                                                      \</span><br>    &#123;                                                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; (line &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; endl; \</span><br>    &#125;<br><br>/*-------------------------------------------*/<br><br>void solve()<br>&#123;<br>    <span class="hljs-built_in">int</span> n, k;<br>    string s;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    cin &gt;&gt; s;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; a(k), b(k);<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; cnt(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; a[i], a[i]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; b[i], b[i]--;<br>    <span class="hljs-built_in">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> x;<br>        cin &gt;&gt; x;<br>        cnt[x - <span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    &#123;<br>        string s1 = s.substr(a[i], b[i] - a[i] + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l = a[i];<br>        <span class="hljs-built_in">int</span> r = b[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = l; j &lt;= (l + r) / <span class="hljs-number">2</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">sum</span> += cnt[j] + cnt[r - j + l];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> % <span class="hljs-number">2</span>)<br>                swap(s1[j - l], s1[r - j]);<br>        &#125;<br>        cout &lt;&lt; s1;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    // clock_t st = clock(), ed;<br>    ios::sync_with_stdio(<span class="hljs-number">0</span>);<br>    cin.tie(<span class="hljs-number">0</span>);<br>    // cout &lt;&lt; setprecision(<span class="hljs-number">15</span>) &lt;&lt; fixed;<br>    <span class="hljs-built_in">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        solve();<br><br>    // ed = clock();<br>    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;<br>    // cout &lt;&lt; <span class="hljs-string">&quot;Total time: &quot;</span> &lt;&lt; endtime &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100019-将数组分割成最多数目的子数组-力扣（LeetCode）"><a href="#100019-将数组分割成最多数目的子数组-力扣（LeetCode）" class="headerlink" title="100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/description/">100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）</a></h1><p>按位与的结果只能越来越小 因此要求最小的按位与的子数组的和 就是全部与在一起的和 就是最小的 但是又特殊情况 就是 当全部的与为0时 可能中间有一部分已经为0了  这样就可以拆成很多个与为0的子数组   如果不为0  那必然整个数组的与就是最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarrays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        t = nums[<span class="hljs-number">0</span>]<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>                cnt += <span class="hljs-number">1</span><br>                t = nums[i]<br>            t&amp;=nums[i]<br>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cnt <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）"><a href="#2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）" class="headerlink" title="2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/2464559/javapython3cshen-du-you-xian-sou-suo-tan-3r78/">2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）</a></h1><p>由于题目说了 整棵树所有结点的和一定为k的倍数 那么从中取出一棵节点和为k的倍速的子树  剩下的部分的结点和一定也为k的倍数  </p><p>因此可以自底向上递归  每次找到一棵节点和为k的倍数的子树 就直接加入答案 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxKDivisibleComponents</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 建树</span><br>        self.link = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> edges:<br>            self.link[s].append(e)<br>            self.link[e].append(s)<br>        self.res = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 递归</span><br>        self.dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, values, k)<br>        <span class="hljs-keyword">return</span> self.res<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, node, parent, values, k</span>):<br>            node_sum = values[node]<br>            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.link[node]:<br>                <span class="hljs-comment"># 因为建的是无向图 要去掉父节点</span><br>                <span class="hljs-keyword">if</span> child == parent:<br>                    <span class="hljs-keyword">continue</span><br>                child_sum = dfs(child, node, values, k)<br>                <span class="hljs-keyword">if</span> child_sum % k == <span class="hljs-number">0</span>:<br>                    self.res += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    node_sum += child_sum<br>            <span class="hljs-keyword">return</span> node_sum<br></code></pre></td></tr></table></figure><h1 id="100086-有序三元组中的最大值-II-力扣（LeetCode）"><a href="#100086-有序三元组中的最大值-II-力扣（LeetCode）" class="headerlink" title="100086. 有序三元组中的最大值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">100086. 有序三元组中的最大值 II - 力扣（LeetCode）</a></h1><p>遍历j 算出j的前缀的最大值和j的后缀的最大值 因为求得是(nums[i] - nums[j]) * nums[k] 所以i k要尽量大</p><p>后缀就是从n - 1往前 求出每一个j值所对应的最大后缀  前缀同理</p><p>最后直接计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumTripletValue</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        surmax = [-<span class="hljs-number">1</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            surmax[i] = <span class="hljs-built_in">max</span>(surmax[i + <span class="hljs-number">1</span>], nums[i])<br>        premax = nums[<span class="hljs-number">0</span>]<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">max</span>(ans, (surmax[i + <span class="hljs-number">1</span>] * (premax - nums[i])))<br>            premax = <span class="hljs-built_in">max</span>(premax, nums[i])<br>        <span class="hljs-keyword">return</span> ans <br></code></pre></td></tr></table></figure><h1 id="100076-无限数组的最短子数组-力扣（LeetCode）"><a href="#100076-无限数组的最短子数组-力扣（LeetCode）" class="headerlink" title="100076. 无限数组的最短子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">100076. 无限数组的最短子数组 - 力扣（LeetCode）</a></h1><p>滑动窗口</p><p>子数组是连续的 要求最短的就是先看看 能凑成几个完整的原序列  然后再两个序列间 凑出剩余的</p><p>剩余的就用滑动窗口来算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSizeSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        total = <span class="hljs-built_in">sum</span>(nums)<br>        nums = nums + nums<br>        x = target // total<br>        target %= total<br>        s = l = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * <span class="hljs-number">2</span>):<br>            s += nums[i]<br>            <span class="hljs-keyword">while</span> s &gt; target:<br>                s -= nums[l]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s == target:<br>                ret = <span class="hljs-built_in">min</span>(ret, i - l + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ret + x * n<br>        <br></code></pre></td></tr></table></figure><h1 id="8028-执行操作使两个字符串相等-力扣（LeetCode）"><a href="#8028-执行操作使两个字符串相等-力扣（LeetCode）" class="headerlink" title="8028. 执行操作使两个字符串相等 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/">8028. 执行操作使两个字符串相等 - 力扣（LeetCode）</a></h1><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><p>首先 1的个数的奇偶不同就不能变成一样的 返回-1</p><p>用dfs计算加上@cache变为记忆化搜索</p><p>每次变都是两个一起变 操作1 第一个变的时候就记录这次变化的消耗  然后另一个就相当于可以免费变化  记录免费变化的次数</p><p>操作2 不能像操作1那样在任意位置变  而是 只要用了操作2 必定是连续的两个变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span> != s2.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>        n = <span class="hljs-built_in">len</span>(s1)<br>        <span class="hljs-comment"># 从前往后遍历 </span><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, pre_rever: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 到头了</span><br>            <span class="hljs-keyword">if</span> i == n:<br>                <span class="hljs-keyword">return</span> inf <span class="hljs-keyword">if</span> j <span class="hljs-keyword">or</span> pre_rever <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 不需要反转</span><br>            <span class="hljs-comment"># 当前不相等 但是前面有反转了 导致这两个相等</span><br>            <span class="hljs-keyword">if</span> s1[i] != s2[i] <span class="hljs-keyword">and</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <span class="hljs-comment"># 当前相等 并且前面没反转 这两个仍然相等</span><br>            <span class="hljs-keyword">if</span> s1[i] == s2[i] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <br>            <span class="hljs-comment"># 需要反转 分别用操作1 和 操作2 取最小值 记得加上反转的代价 操作1为x 操作2为1</span><br>            res = <span class="hljs-built_in">min</span>(dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>) + x, dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">True</span>) + <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment"># 操作1的免费反转（操作2的免费反转在上面）</span><br>            <span class="hljs-keyword">if</span> j:<br>                res = <span class="hljs-built_in">min</span>(res, dfs(i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, pre_rever))<br>            <br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>dp做法</p><p>把所有需要变的位置先写出来 然后每次消除  通过操作1 每次消除一个 消耗x&#x2F;2（最后必定是可以消完的因为不行的情况已经返回-1了）或者用操作2 每次消除两个 比如1，4位置需要变化 那就需要3次操作12 23 34 这样  需要消耗 p[i] - p[i - 1]</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1 == s2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = [i <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(s1, s2)) <span class="hljs-keyword">if</span> x != y]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(p)<br><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 递归出口  到-1 说明是正常退出 （操作1 的0 - 1  操作2 的1 - 2）</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 到-2说明有问题 返回inf代表这个答案不能用</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> inf<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(i - <span class="hljs-number">1</span>) + x, dfs(i - <span class="hljs-number">2</span>) + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>再翻译成递推 dfs(i) -&gt; f[i]   注意翻译的时候 i - 1和i - 2  如果是f[i - 1] 和 f[i - 2] 会导致最后 i &#x3D;&#x3D; -1 和i &#x3D;&#x3D; -2 无法表示  所以 每个下标加上2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        f = [<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>)<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        f[<span class="hljs-number">1</span>] = x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            new_f = <span class="hljs-built_in">min</span>(f[i] + x, f[i - <span class="hljs-number">1</span>] + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>           f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>]<br>            f[<span class="hljs-number">1</span>] = new_f<br>        <span class="hljs-keyword">return</span> f[m] // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>​     然后空间优化  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    f0, f1 = <span class="hljs-number">0</span>, x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            f0, f1 = f1, <span class="hljs-built_in">min</span>(f1 + x, f0 + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> f1 // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="2897-对数组执行操作使平方和最大-力扣（LeetCode）"><a href="#2897-对数组执行操作使平方和最大-力扣（LeetCode）" class="headerlink" title="2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/">2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）</a></h1><p>与 越与越小 或越或越大   而x^y + y ^ 2 &lt; (x - d)^2 + (y + d)^2  所以 要尽量做或操作 直到最大</p><p>用位运算思考 先记录所有数每个比特位上有多少个1  然后构造尽量大的数 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">max</span>(nums).bit_length()<br>        cnt = [<span class="hljs-number">0</span>] * m<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                cnt[i] += x &gt;&gt; i &amp; <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 构造出k个尽可能大的数</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            x = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> cnt[i]:<br>                    <span class="hljs-comment"># 消耗该比特位上的一个1</span><br>                    cnt[i] -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># x |= 就是直接把该位变成1 而1&lt;&lt;i就是对应位</span><br>                    x |= <span class="hljs-number">1</span> &lt;&lt; i <br>            ans += x * x<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="8026-构造乘积矩阵-力扣（LeetCode）"><a href="#8026-构造乘积矩阵-力扣（LeetCode）" class="headerlink" title="8026. 构造乘积矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/construct-product-matrix/description/">8026. 构造乘积矩阵 - 力扣（LeetCode）</a></h1><p>前后缀优化</p><p>类似的还有<a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><p>不能用乘积全部乘起来再除的方法 因为首先可能有0的情况 会导致错误 然后就是复杂度太高了</p><p>虽然说没有写循环 但是 乘积是高精度乘法 复杂度非常高所以会超时</p><p>同理  在每次计算前后缀的时候也需要取模防止数据过大超时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructProductMatrix</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        pre = suf = <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        ans = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        mod = <span class="hljs-number">12345</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans[i][j] = pre % mod<br>                pre = pre * grid[i][j] % mod<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                ans[i][j] = ans[i][j] * suf % mod<br>                suf = suf * grid[i][j] % mod<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="100101-找出满足差值条件的下标-II-力扣（LeetCode）"><a href="#100101-找出满足差值条件的下标-II-力扣（LeetCode）" class="headerlink" title="100101. 找出满足差值条件的下标 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">100101. 找出满足差值条件的下标 II - 力扣（LeetCode）</a></h1><p>这种题目 下标差 然后再找满足另一个条件的 就需要 储存前缀（或后缀）的最大值和最小值</p><p>类似于股票的第一题</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findIndices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], indexDifference: <span class="hljs-built_in">int</span>, valueDifference: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        max_idx = <span class="hljs-number">0</span><br>        min_idx = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(indexDifference, n):<br>            j = i - indexDifference<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[max_idx]:<br>                max_idx = j<br>            <span class="hljs-keyword">elif</span> nums[j] &lt; nums[min_idx]:<br>                min_idx = j<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[max_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, max_idx]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[min_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, min_idx]<br>        <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><h1 id="100077-最长相邻不相等子序列-II-力扣（LeetCode）"><a href="#100077-最长相邻不相等子序列-II-力扣（LeetCode）" class="headerlink" title="100077. 最长相邻不相等子序列 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/description/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></h1><p><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/solutions/2484023/python3zhu-ju-fen-xi-dong-tai-gui-hua-qi-gdss/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></p><h1 id="100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）"><a href="#100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）" class="headerlink" title="100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）</a></h1><p>滑动窗口 </p><p>一开始写的时候 出了好多错ww 下标什么的 while循环的条件带不带等号 还有最后更新忘记判断字典序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBeautifulSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        l = <span class="hljs-number">0</span><br>        cnt = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> cnt &gt; k:<br>                <span class="hljs-keyword">if</span> s[l] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    cnt -= <span class="hljs-number">1</span><br>                    l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; n <span class="hljs-keyword">and</span> s[l] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == k:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ans) == <span class="hljs-number">0</span>:<br>                    ans = s[l:i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> i - l + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(ans):<br>                    ans = s[l: i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">elif</span> i - l + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(ans):<br>                    <span class="hljs-keyword">if</span> s[l: i + <span class="hljs-number">1</span>] &lt; ans:<br>                        ans = s[l:i + <span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="6920-得到-K-个半回文串的最少修改次数-力扣（LeetCode）"><a href="#6920-得到-K-个半回文串的最少修改次数-力扣（LeetCode）" class="headerlink" title="6920. 得到 K 个半回文串的最少修改次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/description/">6920. 得到 K 个半回文串的最少修改次数 - 力扣（LeetCode）</a></h1><p>思路是枚举每一个串看他们是否可以分成符合要求的子串</p><p>主要分成三个部分  首先就是求   一个子字符串变成半回文串的最小修改次数 </p><p>需要先预处理出每个长度n的真因子  </p><p>然后用modify数组来存储每个子字符串的最少修改次数</p><p>最后用划分DP来求整个串需要的最少修改次数</p><p>dfs(i, j ) 表示把s[0]到s[j] 的字符串划分成i + 1 个子字符串  </p><p>i 表示还需要分割的次数   i + 1 表示切出来i + 1段</p><p> j表示 s[0] ~ s[j]为当前需要切割的部分 （右端点）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 预处理n的所有的真因子(类似于埃式筛的做法 先求出i是那几个数的真因子)</span><br>MX = <span class="hljs-number">201</span><br>divisors = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(MX)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, MX):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, MX, i):<br>        divisors[j].append(i)<br><br><span class="hljs-comment"># 先求单个字串s变成半回文串的最少修改次数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_modify</span>(<span class="hljs-params">s:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <br>    n = <span class="hljs-built_in">len</span>(s)<br>    ans = inf<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> divisors[n]:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i0 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(d):<br>            i, j = i0, n - d + i0<br>            <span class="hljs-keyword">while</span> i &lt; j:<br>                ret += s[i] != s[j]<br>                i += d<br>                j -= d<br>        ans = <span class="hljs-built_in">min</span>(ans, ret)<br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumChanges</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        划分型DP</span><br><span class="hljs-string">        dfs(i, j)</span><br><span class="hljs-string">        i 为 剩余需要分割的个数</span><br><span class="hljs-string">        那么i + 1 就是切出来的子串的个数</span><br><span class="hljs-string">        j s[0] ~ s[j] 为当前需要切割的部分</span><br><span class="hljs-string">        返回修改最少的次数</span><br><span class="hljs-string">        枚举当前这一段的左端点</span><br><span class="hljs-string">        L的最小值就是2i 因为 剩下i段要切 每段至少是2（因为1&lt;=d&lt;=len len至少是2）</span><br><span class="hljs-string">        L的最大值为j - 1</span><br><span class="hljs-string">        设modify[i][j] 为s[i] ~ s[j]最小修改次数</span><br><span class="hljs-string">        dfs(i, j) = dfs(i - 1, L - 1) + modify[i][j]</span><br><span class="hljs-string">        终点 i = 0 return modify[0][j]</span><br><span class="hljs-string">        入口dfs(k - 1, n - 1)</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-comment"># 预处理出每个子串 成为半回文串的最小修改次数</span><br>        modify = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left + <span class="hljs-number">1</span>, n):<br>                modify[left][right] = get_modify(s[left:right + <span class="hljs-number">1</span>])<br><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-comment"># i为0 的时候 即 不需要再划分了</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> modify[<span class="hljs-number">0</span>][j]<br>            ret = inf<br>            <span class="hljs-comment"># 枚举左端点 左端点从i* 2开始 最大为j - 1 右端点为j</span><br>            <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, j):<br>                ret = <span class="hljs-built_in">min</span>(ret, dfs(i - <span class="hljs-number">1</span>, L - <span class="hljs-number">1</span>) + modify[L][j])<br>            <span class="hljs-keyword">return</span> ret<br>        <span class="hljs-keyword">return</span> dfs(k - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="100097-合法分组的最少组数-力扣（LeetCode）"><a href="#100097-合法分组的最少组数-力扣（LeetCode）" class="headerlink" title="100097. 合法分组的最少组数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/">100097. 合法分组的最少组数 - 力扣（LeetCode）</a></h1><p>首先思路就错了。。其实是从大（最少出现次数）到小（1） 枚举最小分割的k  一旦满足要求就可以直接返回  而不是先从最小出现次数 计算不对之后 再去拆分每一个数。。因为只要不是k 和k + 1 就不行  k - 1 会与k + 1 冲突</p><p>为什么q &lt; r 的时候不行呢   因为 k &#x3D; 10的时候 比如30分成3个10 可以31 分成10 10 11 ；32 分成10 11 11 ；33分成11 11 11 ；但是到了34   r &#x3D; 4  q &#x3D; 3  此时不能把r均摊到q上   所以说这种分法是不行的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minGroupsForValidAssignment</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums = Counter(nums)<br>        m = <span class="hljs-built_in">min</span>(nums.values())<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            ans = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> nums.values():<br>                q, r = <span class="hljs-built_in">divmod</span>(v, i)<br>                <span class="hljs-keyword">if</span> q &lt; r:<br>                    ans = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    ans += math.ceil(v / (i + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># for else 结构  没有break运行 （也可以 if ans:）</span><br>                <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="100114-元素和最小的山形三元组-II-力扣（LeetCode）"><a href="#100114-元素和最小的山形三元组-II-力扣（LeetCode）" class="headerlink" title="100114. 元素和最小的山形三元组 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/submissions/476195772/">100114. 元素和最小的山形三元组 II - 力扣（LeetCode）</a></h1><p>求出前缀的最小值 后缀的最小值</p><p>然后遍历每个i 如果是山状的  取i  i-1的最小值  i + 1 的最小值即可 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        left_min = [<span class="hljs-number">0</span>] * n<br>        left_min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        right_min = [<span class="hljs-number">0</span>] * n<br>        right_min[-<span class="hljs-number">1</span>] = nums[-<span class="hljs-number">1</span>]<br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            left_min[i] = <span class="hljs-built_in">min</span>(left_min[i - <span class="hljs-number">1</span>], nums[i])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            right_min[i] = <span class="hljs-built_in">min</span>(right_min[i + <span class="hljs-number">1</span>], nums[i])<br>        <br>        ret = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; left_min[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i] &gt; right_min[i + <span class="hljs-number">1</span>]:<br>                ret = <span class="hljs-built_in">min</span>(ret, nums[i] + left_min[i - <span class="hljs-number">1</span>] + right_min[i + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ret == inf <span class="hljs-keyword">else</span> ret<br></code></pre></td></tr></table></figure><h1 id="容器multiset"><a href="#容器multiset" class="headerlink" title="容器multiset"></a>容器multiset</h1><p><a href="https://codeforces.com/contest/1883/problem/D">Problem - D - Codeforces</a></p><p>用multiset可以自动排序 并且存储多个重复的数</p><p>注意erase的时候 要用s.erase(s.lower_bound(x))不然会删掉所有的x</p><p>本题只需要有一个不相交就行  那也就是 最大的left 和最小的right比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br>multiset&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">char</span> c;<br>    cin &gt;&gt; c &gt;&gt; l &gt;&gt; r;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>)<br>    &#123;<br>        s1.<span class="hljs-built_in">insert</span>(l);<br>        s2.<span class="hljs-built_in">insert</span>(r);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">lower_bound</span>(l));<br>        s2.<span class="hljs-built_in">erase</span>(s2.<span class="hljs-built_in">lower_bound</span>(r));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> s = s1.<span class="hljs-built_in">end</span>(), e = s2.<span class="hljs-built_in">begin</span>();<br>    s--;<br>    <span class="hljs-keyword">if</span> (*s &gt; *e)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-C-Codeforces-1"><a href="#Problem-C-Codeforces-1" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/C">Problem - C - Codeforces</a></h1><p>模拟  每次循环比较两个位置的值 然后把小的数变成大的数（题目要求只能增大）计算出差值就是一共要走的步数  并且直接将两个位置的值都修改为较大的值（表示变换了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">v</span>(n + <span class="hljs-number">5</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(n + <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            cin &gt;&gt; v[i][j];<br>        &#125;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        ll ii = <span class="hljs-number">1</span>, jj = <span class="hljs-number">1</span>;<br>        ll tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = n; col &gt;= <span class="hljs-number">1</span>; col--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">1</span>; row &lt;= n; row++)<br>            &#123;<br>                tot += <span class="hljs-built_in">abs</span>(v[ii][jj] - v[row][col]);<br>                ans += <span class="hljs-built_in">abs</span>(v[ii][jj] - v[row][col]);<br>                v[row][col] = <span class="hljs-built_in">max</span>(v[ii][jj], v[row][col]);<br>                v[ii][jj] = <span class="hljs-built_in">max</span>(v[ii][jj], v[row][col]);<br>                jj++;<br>            &#125;<br>            ii++;<br>            jj = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!tot)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces-1"><a href="#Problem-D-Codeforces-1" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/D">Problem - D - Codeforces</a></h1><p>n个数 能不能最后变成相同的n个数  注意到 <em>x &#x2F; x 最终的乘积是不变的 所以可以算出每个数的因子  这些因子乘起来 就是总乘积  然后除了1以外  看看这些因子是否能被n整除  比如 3个5  6个8 肯定是能被分成3个一样的数的 5 * (2</em> 8) 用哈希表记录每个因数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j&lt;=x/j; j++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % j == <span class="hljs-number">0</span>)<br>            &#123;<br>                mp[j]++;<br>                x /= j;<br>            &#125;<br>        &#125;<br>        mp[x]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : mp)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x.first == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (x.second % n != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-B-Codeforces"><a href="#Problem-B-Codeforces" class="headerlink" title="Problem - B - Codeforces"></a><a href="https://codeforces.com/contest/1899/problem/B">Problem - B - Codeforces</a></h1><p>CF–记录傻逼瞬间</p><p>简单的暴力 maxnum范围开小了 从头WA到尾。。</p><p>前缀和 的范围 是远超过1e9的单个数字的范围的。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">qzh</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br>    ll minn = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>, maxn = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, nums[i]);<br>        minn = <span class="hljs-built_in">min</span>(minn, nums[i]);<br>        qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>    ll ret = maxn - minn;<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">if</span> (n % i != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j += i)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, qzh[j] - qzh[j - i]);<br>            minn = <span class="hljs-built_in">min</span>(minn, qzh[j] - qzh[j - i]);<br>        &#125;<br>        ret = <span class="hljs-built_in">max</span>(ret, maxn - minn);<br>    &#125;<br>    cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-C-Codeforces-2"><a href="#Problem-C-Codeforces-2" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1899/problem/C">Problem - C - Codeforces</a></h1><p>C也是懒得喷。。我艹 vector开在局部 还每次都开2e5赋值0的是什么傻逼 T了一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> nums[N] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    ll ret = nums[<span class="hljs-number">0</span>];<br>    ll l = <span class="hljs-number">0</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[l] &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret = nums[l];<br>        sum = nums[l];<br>    &#125;<br>    l++;<br>    <span class="hljs-keyword">while</span> (l &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(nums[l] % <span class="hljs-number">2</span>) != <span class="hljs-built_in">abs</span>(nums[l - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>))<br>        &#123;<br>            sum += nums[l];<br>            <span class="hljs-keyword">while</span> (sum &lt; <span class="hljs-number">0</span> &amp;&amp; l &lt; n)<br>            &#123;<br>                l++;<br>                sum = nums[l];<br>                ret = <span class="hljs-built_in">max</span>(ret, sum);<br>            &#125;<br>            ret = <span class="hljs-built_in">max</span>(ret, sum);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                sum = nums[l];<br>                ret = <span class="hljs-built_in">max</span>(sum, ret);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        l++;<br>    &#125;<br>    cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100138-最大化网格图中正方形空洞的面积-力扣（LeetCode）"><a href="#100138-最大化网格图中正方形空洞的面积-力扣（LeetCode）" class="headerlink" title="100138. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/">100138. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）</a></h1><p>emm 感觉这两场状态都很差，题目没看明白 浪费了很多时间。</p><p>其实求最大的正方形  不是去整个里面删除  而是在可以删除的线（vBars和hBars）里面找 最长的连续的是多少   画个图 就能看出来 (最后要加一，，也是画图)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximizeSquareHoleArea</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, hBars: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], vBars: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>):<br>            l = <span class="hljs-built_in">len</span>(a)<br>            cnt = <span class="hljs-number">1</span><br>            ret = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l):<br>                <span class="hljs-keyword">if</span> a[i] == a[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    ret = <span class="hljs-built_in">max</span>(ret, cnt)<br>                    cnt = <span class="hljs-number">1</span><br>            ret = <span class="hljs-built_in">max</span>(ret, cnt)<br>            <span class="hljs-keyword">return</span> ret<br><br>        hBars.sort()<br>        vBars.sort()<br>        x = <span class="hljs-built_in">min</span>(f(hBars), f(vBars)) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure><h1 id="100139-循环移位后的矩阵相似检查-力扣（LeetCode）"><a href="#100139-循环移位后的矩阵相似检查-力扣（LeetCode）" class="headerlink" title="100139. 循环移位后的矩阵相似检查 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/matrix-similarity-after-cyclic-shifts/description/">100139. 循环移位后的矩阵相似检查 - 力扣（LeetCode）</a></h1><p>看清题目！其实就是直接比较两列是否相等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areSimilar</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        row = <span class="hljs-built_in">len</span>(mat)<br>        col = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">if</span> k % col == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        k %= col<br>        <br>        now = [[<span class="hljs-number">0</span>] * col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br>        <span class="hljs-built_in">print</span>(mat)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>                now[j][i] = mat[j][(i + k) % col]<br>                <br>        <span class="hljs-built_in">print</span>(now, mat)<br>        <span class="hljs-keyword">if</span> now == mat:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1 id="100142-交换得到字典序最小的数组-力扣（LeetCode）"><a href="#100142-交换得到字典序最小的数组-力扣（LeetCode）" class="headerlink" title="100142. 交换得到字典序最小的数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/">100142. 交换得到字典序最小的数组 - 力扣（LeetCode）</a></h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lexicographicallySmallestArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        3 1 2 limit = 1 那么1 3 的差大于limit 是不是就不能换了呢？</span><br><span class="hljs-string">        不是 可以借助2来换 2 1 3 -&gt; 1 2 3 </span><br><span class="hljs-string">        3 5 1 7 limit = 2 可以换到1 3 5 7 </span><br><span class="hljs-string">        这说明limit限制内的所有数 都可以被换成从小到大的数</span><br><span class="hljs-string">        这被称为一个连通块（类似图论的概念）</span><br><span class="hljs-string">        再看 2 4 22 20 3 21 1 </span><br><span class="hljs-string">        这组数有两个连通块 1 2 3 4 可以按顺序 20 21 22 可以按顺序 但是 他们只能在各自的块内交换 即 1 2 20 21 3 22 4</span><br><span class="hljs-string">        用 排序+分组循环</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 注意排序不能直接排  会丢失下标</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        a = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(nums, <span class="hljs-built_in">range</span>(n)))<br>        <span class="hljs-comment"># 现在a 是带下标的 排序的nums值 如(6,1)(0,2)(4,3)(1,4)(3,20)(5,21)(2,22) 需要把他们分别放到各自的空里</span><br>        <span class="hljs-comment"># 分组循环 每次排一个连通块</span><br>        i = <span class="hljs-number">0</span><br>        ans = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            st = i<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> a[i][<span class="hljs-number">0</span>] &lt;= a[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + limit:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 出来的这个i 就是下一组的了</span><br>            <span class="hljs-comment"># 现在要把前面这几个 按下标排序 排完之后把a分别放到这些下标里（因为a是数从小到大 刚好放到下标的从小到大）</span><br>            sub = a[st:i]<br>            sub_idx = <span class="hljs-built_in">sorted</span>(i <span class="hljs-keyword">for</span> _, i <span class="hljs-keyword">in</span> sub)<br>            <span class="hljs-comment"># 排好了 放回去</span><br>            <span class="hljs-keyword">for</span> j, (x, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(sub_idx, sub):<br>                ans[j] = x<br>            <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习</title>
    <link href="/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- This is explanation--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to write<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is Heading1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is Heading2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>MAX Heading is 6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is strong<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>single tag:next paragraph<br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>single tag:divider<br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>ATTENTION:single tag:next paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> This<br>    is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>same as strong<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>This is underline<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This is italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>This is delete<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You must have find that even if you wrap in vscode, it won&#x27;t wrap in Webpage<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert some medium<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to insert a photo<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 只写宽或高会等比例变换 两个都写可能变形 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./MD5.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;加载失败（替换文本示例）&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;This is title&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 下级目录 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;in/MD5.png&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 上级目录 就用../--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play music<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;刻在我心底的名字.mp3&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play video<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;a.mp4&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert hyperlink<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/?tn=15007414_8_dg&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;study1.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>study1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><p>app.json </p><p>pages记录当前小程序所有页面的路径</p><p>window 全局定义小程序背景文字颜色</p><p>style 组件样式</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>js</tag>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Math</title>
    <link href="/2023/09/11/Math/"/>
    <url>/2023/09/11/Math/</url>
    
    <content type="html"><![CDATA[<h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">如果i是primes[j]的倍数，跳出循环是因为在线性筛的过程中，我们的目标是找到小于等于n的所有素数，并且要保证每个合数只被标记一次。因此，在内层循环中，当i是primes[j]的倍数时，我们不需要再继续考虑primes[j] * i及其之后的倍数了，因为它们已经在之前的迭代中被标记过了。</span><br><span class="hljs-string"></span><br><span class="hljs-string">举个例子来说明：</span><br><span class="hljs-string"></span><br><span class="hljs-string">假设我们正在处理i=10，而primes[j]=2，也就是说10是2的倍数。那么在这一轮迭代中，我们会标记10、20、30、40、...等等所有10的倍数为非素数。但实际上，这些数在之前已经被标记过了，因为它们分别是2、4、6、8、...等等的倍数，而这些倍数在处理2的时候已经被标记过了。所以，为了避免重复标记，当i是primes[j]的倍数时，我们可以直接跳出内层循环，不再处理这个数及其后续的倍数。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_sieve</span>(<span class="hljs-params">n</span>):<br>    is_prime = [<span class="hljs-literal">True</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 初始化一个布尔数组，标记每个数是否为素数</span><br>    primes = []  <span class="hljs-comment"># 存储素数的列表</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i]:<br>            primes.append(i)  <span class="hljs-comment"># i是素数</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(primes)):<br>            <span class="hljs-comment"># 将已知素数primes[j]与当前数i相乘，标记其倍数为非素数</span><br>            <span class="hljs-keyword">if</span> primes[j] * i &gt; n:<br>                <span class="hljs-keyword">break</span><br>            is_prime[primes[j] * i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % primes[j] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果i是primes[j]的倍数，跳出循环</span><br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> primes<br><br>n = <span class="hljs-number">30</span>  <span class="hljs-comment"># 你可以设置需要查找素数的上限</span><br>primes = linear_sieve(n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小于等于&quot;</span>, n, <span class="hljs-string">&quot;的素数：&quot;</span>, primes)<br><br></code></pre></td></tr></table></figure><h1 id="0质因数个数-蓝桥云课-lanqiao-cn"><a href="#0质因数个数-蓝桥云课-lanqiao-cn" class="headerlink" title="0质因数个数 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2155/learning/">0质因数个数 - 蓝桥云课 (lanqiao.cn)</a></h1><p>n最大为10^16   </p><p>时间复杂度要在O(sqrt(n))</p><p>主要是 中间的while循环会直接处理掉所有当前质数的合数 比如i &#x3D; 2 会一直除以2 直到不能再被2除 使得2 4 6 8 10等合数在后面都不重复计算 而质数就会被留下 比如5 7 等 不会因为除以2而消失 最后会留下来 所以不会漏算 </p><p>然后 i &lt; n &#x2F; i 有效减低了复杂度 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>)res++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)res++;<br>    cout&lt;&lt;res;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="365-水壶问题-力扣（LeetCode）"><a href="#365-水壶问题-力扣（LeetCode）" class="headerlink" title="365. 水壶问题 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/water-and-jug-problem/?envType=daily-question&envId=2024-01-28">365. 水壶问题 - 力扣（LeetCode）</a></h1><p>每次水壶只会增加或者减少x 或y的水 只要x + y &gt;&#x3D; z 找出一对a， b使得<strong>ax+by&#x3D;z</strong>就可以 那么就需要找出xy的最大公约数</p><p>贝祖定理告诉我们，ax+by&#x3D;z ax+by&#x3D;z $a<em>x+b</em>y&#x3D;z$ 有解当且仅当 z 是 x y 的最大公约数的倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canMeasureWater</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x + y &lt; z)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> z == <span class="hljs-number">0</span> || x + y == z;<br>        <span class="hljs-keyword">return</span> z % <span class="hljs-built_in">gcd</span>(x, y) == <span class="hljs-number">0</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span>: a? <span class="hljs-built_in">gcd</span>(b, a) <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1792-最大平均通过率-力扣（LeetCode）"><a href="#1792-最大平均通过率-力扣（LeetCode）" class="headerlink" title="1792. 最大平均通过率 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-average-pass-ratio/">1792. 最大平均通过率 - 力扣（LeetCode）</a></h1><p>优秀的学生要加入那个班级？ 这个就要看 这个学生加入那个班级最好（使得平均通过率增加最多）</p><p>就要算平均通过率的增量 按照增量排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxAverageRatio</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; classes, <span class="hljs-type">int</span> extraStudents)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        priority_queue&lt;tuple&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: classes)<br>        &#123;<br>            <span class="hljs-type">int</span> a = x[<span class="hljs-number">0</span>], b = x[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">double</span> zl = (<span class="hljs-type">double</span>) (a + <span class="hljs-number">1</span>) / (b + <span class="hljs-number">1</span>) - (<span class="hljs-type">double</span>) a / b;<br>            q.<span class="hljs-built_in">push</span>(&#123;zl, a, b&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (extraStudents--)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [_, a, b] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            a++, b++;<br>            <span class="hljs-type">double</span> zl = (<span class="hljs-type">double</span>)(a + <span class="hljs-number">1</span>) / (b + <span class="hljs-number">1</span>) - (<span class="hljs-type">double</span>)a / b;<span class="hljs-comment">// 如果再次加到这个班 增量的大小</span><br>            q.<span class="hljs-built_in">push</span>(&#123;zl, a, b&#125;);<br>        &#125;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [_, a, b] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ans += (<span class="hljs-type">double</span>) a / b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans / classes.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1205-买不到的数目-AcWing题库"><a href="#1205-买不到的数目-AcWing题库" class="headerlink" title="1205. 买不到的数目 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1207/">1205. 买不到的数目 - AcWing题库</a></h1><h2 id="寻找数学规律的方法"><a href="#寻找数学规律的方法" class="headerlink" title="寻找数学规律的方法"></a>寻找数学规律的方法</h2><p>可以把题目先模拟出来找规律 不用手写</p><p>找规律可以固定a不变 换b  然后再固定b不变换a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (m &gt;= p &amp;&amp; <span class="hljs-built_in">dfs</span>(m - p, p, q))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (m &gt;= q &amp;&amp; <span class="hljs-built_in">dfs</span>(m - q, p, q))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p, q;<br>    cin&gt;&gt;p &gt;&gt; q;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, p, q))res = i;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个数不能凑出的 最大数 要求 两个正整数必须互质才可能有最大不能凑出的数</p><p>即当gcd(a, b)&gt;1 的时候无解   互质的时候 两个数最大不能凑出的数为 (a - 1) * (b - 1) - 1</p><h1 id="1216-饮料换购-AcWing题库"><a href="#1216-饮料换购-AcWing题库" class="headerlink" title="1216. 饮料换购 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1218/">1216. 饮料换购 - AcWing题库</a></h1><p>当还有剩余的瓶盖或者完整的饮料的时候 就要继续循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> ys = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        ans += n;<br>        ys += n % <span class="hljs-number">3</span>;<br>        n /= <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//cout&lt;&lt; n&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;ys&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (n || ys &gt;= <span class="hljs-number">3</span>)<br>    &#123;<br>        n = ys / <span class="hljs-number">3</span>;<br>        ys = ys % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (n)<br>        &#123;<br>            ans += n;<br>            ys += n % <span class="hljs-number">3</span>;<br>            n /= <span class="hljs-number">3</span>;<br>            <span class="hljs-comment">//cout&lt;&lt; n&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;ys&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br>        &#125;<br>        <br>    &#125;<br>    <br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1224-交换瓶子-AcWing题库"><a href="#1224-交换瓶子-AcWing题库" class="headerlink" title="1224. 交换瓶子 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1226/">1224. 交换瓶子 - AcWing题库</a></h1><p>置换群</p><p>每个长k的环需要k - 1次交换 则求n中有多少个环即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> nums[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; <br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[nums[i]])<br>        &#123;<br>            cnt++;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (!vis[nums[j]])<br>            &#123;<br>                vis[nums[j]] = <span class="hljs-number">1</span>;<br>                j = nums[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;n - cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论入门题解</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P5318">P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>用vector<int>graph[N]存图 类似于defaultdict(list)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>vis[x] = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[x][i]])<br>&#123;<br><span class="hljs-built_in">dfs</span>(graph[x][i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(x);<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[a].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[a][i]])<br>&#123;<br>vis[graph[a][i]] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(graph[a][i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">emplace_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">sort</span>(graph[i].<span class="hljs-built_in">begin</span>(), graph[i].<span class="hljs-built_in">end</span>());<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>有向图求每个点能到达的编号最大的点</p><p>图论的经典做法  存反图然后从最大的点开始遍历他能到达的所有点 更新  后续如果这个点已经更新过了 就不再更新了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;fgraph[N];<br><span class="hljs-type">int</span> dis[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>dis[x] = d;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fgraph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(fgraph[x][i], d);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>fgraph[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">dfs</span>(i, i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1113">P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>经典拓扑+动态规划</p><p>把前面的杂物干完才能干后面的事  拓扑排序</p><p>并且加上了动态规划（有点类似dijkstra）   完成所有杂物的最短时间 每次循环更新 到u这个任务需要的最短时间 （即f[u] &#x3D; max(f[u], f[x] + t[u]）到u的最短 即到源点到x的最短加上到x到u的最短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">500500</span>;<br><br>vector&lt;<span class="hljs-built_in">int</span>&gt;graph[N];<br><span class="hljs-built_in">int</span> deg[N];<br><span class="hljs-built_in">int</span> f[N];<br><span class="hljs-built_in">int</span> t[N];<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; t[i];<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v &amp;&amp; v)<br>&#123;<br>graph[v].push_back(u);<br>deg[u]++;<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-built_in">int</span>&gt;q;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(i);<br>f[i] = t[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.empty())<br>&#123;<br><span class="hljs-built_in">int</span> x = q.front();<br>q.pop();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].size(); i++)<br>&#123;<br><span class="hljs-built_in">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(u);<br>&#125;<br>f[u] = <span class="hljs-built_in">max</span>(f[u], f[x] + t[u]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求食物链的数量（食物链必须到最高消费者 即不被捕食的动物 即出度为0的）</p><p>拓扑排序+动态规划 </p><p>比如a-&gt;b-&gt;c   每次更新时 nums[b] &#x3D; nums[b] + nums[a] 把到第a的食物链条数全部累加到b中  最后把出度为0的点的条数加上 即为答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">80112002</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> deg[N], out[N], nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>deg[b]++;<br>out[a]++;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>nums[i] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(u);<br>&#125;<br>nums[u] = (nums[u] + nums[x]) % mod;<br>&#125;<br><br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>)<br>&#123;<br>ans = (nums[i] + ans)%mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1807">P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最长路问题   还是动态规划  d[i] &#x3D; max(d[x]  + mp[x ] [ i ], d[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000</span>, M = <span class="hljs-number">55000</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> d[N], mp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> u, v, w;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>mp[u][v] = <span class="hljs-built_in">max</span>(mp[u][v], w);<br>&#125;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (mp[x][i] &amp;&amp; d[i] &lt; d[x] + mp[x][i])<br>&#123;<br>d[i] = d[x] + mp[x][i];<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>&#125;<br>&#125;<br><br>cout &lt;&lt; d[n] &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2853 USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2853 <a href="https://www.luogu.com.cn/problem/P2853">USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求有几个地方 是所有的奶牛都可以的到达的</p><p>那每次走过的时候次数+1  当all[x] &#x3D;&#x3D; k 的时候就代表这个点都可以到达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> a[N], vis[N], all[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>vis[x] = <span class="hljs-number">1</span>;<br>all[x] += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> y = graph[x][i];<br><span class="hljs-keyword">if</span> (vis[y] == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(a[i]);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (all[i] == k)<br>ans += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1363">P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>无线的地图 那么只要它能够回到原点 就说明可以从一个点到另一个点  就可以无限走 就符合题意</p><p>用vis储存横纵坐标和是否访问  </p><p>每次进入先判断该点（是取模过的点 ***）是否已经访问过  如果访问过 并且x， y跟之前的不一样（只要有一个不一样就行）那就说明走到了另一个地图的原点 说明可以无限</p><p>如果访问过 并且是回到了原点 那就退回</p><p>标记该点为已访问 像四个方向拓展  lx和ly用来记录是否走出  要取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m, n, sx, sy, dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;, dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;, ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">bool</span> graph[N][N] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">int</span> vis[N][N][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> ly)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; (vis[lx][ly][<span class="hljs-number">0</span>] != x || vis[lx][ly][<span class="hljs-number">1</span>] != y))<br>&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; vis[lx][ly][<span class="hljs-number">0</span>] == x &amp;&amp; vis[lx][ly][<span class="hljs-number">1</span>] == y)<span class="hljs-keyword">return</span>;<br>vis[lx][ly][<span class="hljs-number">0</span>] = x; vis[lx][ly][<span class="hljs-number">1</span>] = y; vis[lx][ly][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nx, ny;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">4</span>; w++)<br>&#123;<br>nx = (lx + dx[w] + n) % n;<br>ny = (ly + dy[w] + m) % m;<br><span class="hljs-keyword">if</span> (graph[nx][ny])<span class="hljs-built_in">dfs</span>(x + dx[w], y + dy[w], nx, ny);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(graph, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(graph));<br>ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>)graph[i][j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;S&#x27;</span>)<br>&#123;<br>sx = i, sy = j;<br>graph[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> graph[i][j] = <span class="hljs-literal">false</span>;<br>&#125; <br>&#125;<br><span class="hljs-built_in">dfs</span>(sx, sy, sx, sy);<br><span class="hljs-keyword">if</span> (ans)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="省份数量-547-省份数量-力扣（LeetCode）"><a href="#省份数量-547-省份数量-力扣（LeetCode）" class="headerlink" title="[省份数量](547. 省份数量 - 力扣（LeetCode）)"></a>[省份数量](<a href="https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory">547. 省份数量 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>cities = <span class="hljs-built_in">len</span>(isConnected)<br>        province = <span class="hljs-number">0</span><br>        vis = [<span class="hljs-number">0</span>] * cities<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[j] <span class="hljs-keyword">and</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    vis[j] = <span class="hljs-number">1</span><br>                    dfs(j)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                vis[i] = <span class="hljs-number">1</span><br>                province += <span class="hljs-number">1</span><br>                dfs(i)<br><br>        <span class="hljs-keyword">return</span> province<br>    <br>   <span class="hljs-comment"># 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 </span><br><span class="hljs-comment"># 重点在并查集的写法</span><br>uf = UnionFind()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(isConnected)):<br>            uf.add(i)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    uf.merge(i,j)<br>        <span class="hljs-keyword">return</span> uf.num_of_sets<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.father = &#123;&#125;<br>        self.num_of_sets = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self,x</span>):<br>        root = x<br>        <span class="hljs-keyword">while</span> self.father[root] != <span class="hljs-literal">None</span>:<br>            root = self.father[root]<br><span class="hljs-comment"># 让并查集更宽 减少时间复杂度</span><br>        <span class="hljs-keyword">while</span> x != root:<br>            original_father = self.father[x]<br>            self.father[x] = root<br>            x = original_father<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self,x,y</span>):<br>        root_x, root_y = self.find(x),self.find(y)<br><br>        <span class="hljs-keyword">if</span> root_x != root_y:<br>            self.father[root_x] = root_y<br>            self.num_of_sets -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.father:<br>            self.father[x] = <span class="hljs-literal">None</span><br>            self.num_of_sets += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）"><a href="#找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="[找到最终的安全状态](802. 找到最终的安全状态 - 力扣（LeetCode）)"></a>[找到最终的安全状态](<a href="https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory">802. 找到最终的安全状态 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2</span><br><span class="hljs-string">一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全</span><br><span class="hljs-string">&quot;&quot;&quot;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>n = <span class="hljs-built_in">len</span>(graph)<br>        color = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>            <span class="hljs-comment"># 访问已经搜过的结点 1为有环 2为无环</span><br>            <span class="hljs-keyword">if</span> color[x] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span><br>            <span class="hljs-comment"># 如果是0</span><br>            color[x] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-comment"># 快速退出</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> safe(y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True</span><br>            color[x] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>       <br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> safe(i)]<br>    <br>    <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的</span><br><span class="hljs-string">    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序</span><br><span class="hljs-string">    循环结束后 所有入度为0的结点都是安全的</span><br><span class="hljs-string">    意思是，原图的出度为0的结点，和指向出度为0的结点的结点</span><br><span class="hljs-string">    （由于存了反图并拓扑排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> graph]<br>        <span class="hljs-comment"># 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0</span><br>        <span class="hljs-keyword">for</span>  x, ys <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:<br>rg[y].append(x)<br>        <span class="hljs-comment"># in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）</span><br>        in_deg = [<span class="hljs-built_in">len</span>(ys) <span class="hljs-keyword">for</span> ys <span class="hljs-keyword">in</span> graph]<br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>])<br><span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rg[q.popleft()]:<br>                in_deg[x] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[x] == <span class="hljs-number">0</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i, d  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="颜色交替的最短路径"><a href="#颜色交替的最短路径" class="headerlink" title=" 颜色交替的最短路径 "></a><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory"> 颜色交替的最短路径 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestAlternatingPaths</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, redEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], blueEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> redEdges:<br>            g[x].append((y,<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> blueEdges:<br>            g[x].append((y,<span class="hljs-number">1</span>))<br>        <br><br>        dis = [-<span class="hljs-number">1</span>] * n<br>        vis = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        q = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> x, color <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">if</span> dis[x] == -<span class="hljs-number">1</span>:<br>                    dis[x] = level<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-keyword">if</span> p[<span class="hljs-number">1</span>] != color <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        vis.add(p)<br>                        q.append(p)<br>            level += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dis<br></code></pre></td></tr></table></figure><h1 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间 "></a><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/">通知所有员工所需的时间 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            g[manager[i]].append(i)<br><br>        q = collections.deque()<br>        q.append((headID, <span class="hljs-number">0</span>))<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tid, val = q.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g[tid]) == <span class="hljs-number">0</span>:<br>                res = <span class="hljs-built_in">max</span>(res, val)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> ne <span class="hljs-keyword">in</span> g[tid]:<br>                    q.append((ne, val + informTime[tid]))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="1466-重新规划路线-力扣（LeetCode）"><a href="#1466-重新规划路线-力扣（LeetCode）" class="headerlink" title="1466. 重新规划路线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory">1466. 重新规划路线 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> connections:<br>            g[a].append((b, <span class="hljs-number">1</span>))<br>            g[b].append((a, <span class="hljs-number">0</span>))<br>        <br>        q = deque([<span class="hljs-number">0</span>])<br>        vis = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">while</span> q:<br>            cur = q.popleft()<br>            <span class="hljs-comment"># 遍历所有和cur相邻的边</span><br>            <span class="hljs-keyword">for</span> end, dirction <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g[cur]):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[end]:<br>                    vis[end] = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果方向不对就反转</span><br>                    res += dirction<br>                    q.append(end)<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <br><span class="hljs-comment"># 或者 用set一次遍历  有点问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = &#123;<span class="hljs-number">0</span>&#125;<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> connection:<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> s:<br>                s.add(l)<br>            <span class="hljs-comment"># 右边不通向0 并且左边通向0 （左边通向右边） 那就让r-&gt;l r就可以到0</span><br>            <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">in</span> s:<br>                s.add(r)<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>                <br>        <br></code></pre></td></tr></table></figure><h1 id="1192-查找集群内的关键连接-力扣（LeetCode）"><a href="#1192-查找集群内的关键连接-力扣（LeetCode）" class="headerlink" title="1192. 查找集群内的关键连接 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory">1192. 查找集群内的关键连接 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环 （此时的curnode为入口结点）</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="934-最短的桥-力扣（LeetCode）"><a href="#934-最短的桥-力扣（LeetCode）" class="headerlink" title="934. 最短的桥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory">934. 最短的桥 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两座相同的岛 先找到第一个不为0的数然后dfs标记这个岛的全部，然后用bfs搜索当第一次搜到第二个岛的step即是答案，注意dfs的时候要把第一个岛全部放入q（因为每个点都可能是距离第二个岛最近的点）搜完上下左右一圈后step + 1 （不需要vis数组记录 直接把走过的设为-1即可）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBridge</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = -<span class="hljs-number">1</span><br>            q.append((x, y))<br>            <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                    dfs(nx, ny)<br><br>        n = <span class="hljs-built_in">len</span>(grid)<br>        q = deque()<br>        i, j = <span class="hljs-built_in">next</span>((i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> grid[i][j])<br>        dfs(i, j)<br>        step = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x, y = q.popleft()<br>                <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n :<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">return</span> step<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">0</span>:<br>                            grid[nx][ny] = -<span class="hljs-number">1</span><br>                            q.append((nx, ny))<br>            step += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="127-单词接龙-力扣（LeetCode）"><a href="#127-单词接龙-力扣（LeetCode）" class="headerlink" title="127. 单词接龙 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=graph-theory">127. 单词接龙 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每次枚举26个字母 一一替换单词 直到找到wordList的单词 如果是end的话就直接返回 否则step+1放入q继续bfs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> beginWord == endWord:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        word = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)]<br>        q = deque([(beginWord, <span class="hljs-number">1</span>)])<br>        <span class="hljs-keyword">while</span> q:<br>            cur, step = q.popleft()<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cur):<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> word:<br>                    <span class="hljs-keyword">if</span> x != y:<br>                        nxt = cur[:i] + y + cur[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">in</span> wordList:<br>                            <span class="hljs-keyword">if</span> nxt == endWord:<br>                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                            q.append((nxt, step + <span class="hljs-number">1</span>))<br>                            wordList.remove(nxt)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="126-单词接龙-II-力扣（LeetCode）"><a href="#126-单词接龙-II-力扣（LeetCode）" class="headerlink" title="126. 单词接龙 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个方法相当于是每次把step=1的所有数都找出来并且加进去 把所有step=2的都找出来加进去这样（&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot; and &quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;）     当q（内层）取完之后表示当前步数可以链接的下一个单词已经全部找到 可以step+1 然后把s中暂存的给q 再次循环    直到end 加入答案 （当内层q为0的时候表示所有路径都已经加进去 就直接return） 当q（外层）取完（也就是sq交换的时候s为[]）之后表示所有路径都已经走过 但是还没有遇到end 这时返回[]</span><br><span class="hljs-comment"># 首先 建图方面 建立这个单词可以变的其他单词 变化处用* 表示 用defaultdict后面可以快速访问 </span><br><span class="hljs-comment"># 然后q用来存储当前值和当前路径 s与q相同 但是s是用来存储每轮的数据 每次开始时s都为[] （保证数据 相当于temp）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLadders</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> []<br>        dic = defaultdict(<span class="hljs-built_in">list</span>)<br>        n = <span class="hljs-built_in">len</span>(beginWord)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]].append(w)<br>        <br>        q, s = [(beginWord, [beginWord])], []<br>        res = []<br>        vis = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">while</span> q:<br>                w, path = q.pop()<br>                vis.add(w)<br>                <span class="hljs-keyword">if</span> w == endWord:<br>                    res.append(path)<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]]:<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                            s.append((nxt, path + [nxt]))<br>            <span class="hljs-keyword">if</span> res:<br>                <span class="hljs-keyword">return</span> res<br>            q, s = s, q<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="542-01-矩阵-力扣（LeetCode）"><a href="#542-01-矩阵-力扣（LeetCode）" class="headerlink" title="542. 01 矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/01-matrix/description/?envType=study-plan-v2&envId=graph-theory">542. 01 矩阵 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多起点的最短路问题 可以将所有的0 看成同一个源点 然后使用bfs 因为每次扩散一轮 所有的都加一时候再扩散下一轮（队列 先进先出）每次只需要搜索四个方向 然后再原来的ret的基础上加一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n, m = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        ret = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        q = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:<br>                    ret[i][j] = <span class="hljs-number">0</span><br>                    q.append([i,j])<br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j = q.popleft()<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> ret[ni][nj] == -<span class="hljs-number">1</span>:<br>                    ret[ni][nj] = ret[i][j] + <span class="hljs-number">1</span><br>                    q.append([ni, nj])<br><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="863-二叉树中所有距离为-K-的结点-力扣（LeetCode）"><a href="#863-二叉树中所有距离为-K-的结点-力扣（LeetCode）" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/?envType=study-plan-v2&envId=graph-theory">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distanceK</span>(<span class="hljs-params">self, root: TreeNode, target: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 首先用字典node_parent存储每个结点的父节点</span><br>        node_parent = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_find_parent</span>(<span class="hljs-params">node: TreeNode</span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">if</span> node.left:<br>                node_parent[node.left] = node<br>            <span class="hljs-keyword">if</span> node.right:<br>                node_parent[node.right] = node<br>            dfs_find_parent(node.left)<br>            dfs_find_parent(node.right)<br><br><br>        dfs_find_parent(root)<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [target.val]<br>        res = []<br><br>        q = deque()<br>        vis = <span class="hljs-built_in">set</span>()<br>        q.append(target)<br>        vis.add(target)<br>        <span class="hljs-comment"># 现在依次遍历和target距离为level的结点（波纹法 一层层搜索）</span><br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> level &lt; k:<br>            level += <span class="hljs-number">1</span> <span class="hljs-comment"># 先加还是后加取决于level初值</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [node_parent[x] <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> node_parent <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, x.left, x.right]: <span class="hljs-comment"># 遍历和当前点相邻的所有结点（每次搜索一层 注意要用set判重）</span><br>                    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">and</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        <span class="hljs-keyword">if</span> level == k:<br>                            res.append(y.val)<br>                        q.append(y)<br>                        vis.add(y)<br>        <span class="hljs-keyword">return</span> res<br><br>                <br></code></pre></td></tr></table></figure><h1 id="864-获取所有钥匙的最短路径-力扣（LeetCode）"><a href="#864-获取所有钥匙的最短路径-力扣（LeetCode）" class="headerlink" title="864. 获取所有钥匙的最短路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/?envType=study-plan-v2&envId=graph-theory">864. 获取所有钥匙的最短路径 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不同之处在于 并不是一个点只能走一次 而是可以多次走 找到最短的路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathAllKeys</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dis 用于记录每个点走的距离 不同的是 现在有3个状态 多了一个钥匙数的状态 </span><br>        dis = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0x3f3f3f3f</span>)<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>:<br>                    q = deque([(i, j, <span class="hljs-number">0</span>)])<br>                    dis[(i, j, <span class="hljs-number">0</span>)] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> grid[i][j].islower():<br>                    cnt += <span class="hljs-number">1</span><br><br><br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        <br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j, cur = q.popleft()<br>            step = dis[(i,  j, cur)]<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m:<br>                    c = grid[ni][nj]<br>                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 先将cur右移c位然后&amp;1判断是否为1</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> <span class="hljs-keyword">and</span> (cur &gt;&gt; (<span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    ncur = cur<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:<br>                        <span class="hljs-comment"># 标记为已有</span><br>                        ncur |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-keyword">if</span> ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 如果曾经走到过这里 并且步数更少的话 更新 （如果没有走到过的话 那就是0x3f3f3f3f 必定更新）</span><br>                    <span class="hljs-keyword">if</span> step + <span class="hljs-number">1</span> &lt; dis[(ni, nj, ncur)]:<br>                        dis[(ni, nj, ncur)] = step + <span class="hljs-number">1</span><br>                        q.append((ni, nj, ncur))<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="1334-阈值距离内邻居最少的城市-力扣（LeetCode）"><a href="#1334-阈值距离内邻居最少的城市-力扣（LeetCode）" class="headerlink" title="1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></h1><p>题目要求一个城市在距离小于distanceThreshold下能够到达的城市</p><p>可以直接求 对每个城市进行搜索 也可以直接用Floyd 算法求出每两个城市之间的距离 再找距离小于dis的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheCity</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], distanceThreshold: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        graph = [[inf] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b, w <span class="hljs-keyword">in</span> edges:<br>            graph[a][b] = graph[b][a] = w<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])<br>        <br>        ans = min_cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> j != i <span class="hljs-keyword">and</span> graph[i][j] &lt;= distanceThreshold:<br>                    cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt &lt;= min_cnt:<br>                min_cnt = cnt<br>                ans = i<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="2646-最小化旅行的价格总和-力扣（LeetCode）"><a href="#2646-最小化旅行的价格总和-力扣（LeetCode）" class="headerlink" title="2646. 最小化旅行的价格总和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/">2646. 最小化旅行的价格总和 - 力扣（LeetCode）</a></h1><p>树形DP  要算所有的路径  的总和可以先暴力DFS算出所有的路径的<strong>贡献</strong>：也就是比如0-1-2中求(0,2)(1,2) 那么1-2 算了两次 这样求出所有边走的次数cnt[x]</p><p>遍历(start, end) 求cnt</p><p>然后知道每个边的 次数之后再用树形DP（打家劫舍3）求出最小值   每个点减或不减</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotalPrice</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], price: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], trips: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            g[a].append(b)<br>            g[b].append(a)<br>        cnt = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> trips:<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>                <span class="hljs-keyword">if</span> x == end:<br>                    cnt[x] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-comment"># dfs(y) 是为了说明这是可以到end的路(到end之后再往回更新cnt)</span><br>                    <span class="hljs-keyword">if</span> y != fa <span class="hljs-keyword">and</span> dfs(y):<br>                        cnt[x] += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dfs(start, -<span class="hljs-number">1</span>)<br>        <br>       <span class="hljs-comment"># 现在就得到了走的边的次数 再加上已知点的权值 用树形DP求</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            now_not_halve = price[x] * cnt[x]<br>            now_halve = price[x] * cnt[x] // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                <span class="hljs-keyword">if</span> y != fa:<br>                    kid_not_halve, kid_halve = dfs(y, x)<br>                    now_not_halve += <span class="hljs-built_in">min</span>(kid_not_halve, kid_halve)<br>                    now_halve += kid_not_halve<br>            <span class="hljs-keyword">return</span> now_not_halve, now_halve<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))<br>        <br>                        <br></code></pre></td></tr></table></figure><h1 id="1631-最小体力消耗路径-力扣（LeetCode）"><a href="#1631-最小体力消耗路径-力扣（LeetCode）" class="headerlink" title="1631. 最小体力消耗路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径 - 力扣（LeetCode）</a></h1><p>看起来像DP但是其实是图论的题  为什么呢  因为dp只能向一个方向更新 比如只能一直向下 选择 [i + 1] [j - 1] 、[i + 1] [j] 、[i + 1] [j + 1] 这三种 但是这个题明显就是有4个方向 类似BFS</p><h2 id="方法一、-二分-BFS"><a href="#方法一、-二分-BFS" class="headerlink" title="方法一、 二分+BFS"></a>方法一、 二分+BFS</h2><p>二分可能的最大差异值 用bfs计算 如果最大差异大于x则…</p><p>注意这里维护的是最大差异  每次当更新的时候如果差异值小于x才更新 最终如果能到达右下角说明这个x可以</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">10</span>**<span class="hljs-number">6</span>+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">mid</span>):<br>            dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>            dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>            q = deque()<br>            q.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            minn = maxn = heights[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>            vis = [[<span class="hljs-literal">False</span>] * m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> q:<br>                x, y = q.popleft()<br><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                    nx = x + dx[i]<br>                    ny = y + dy[i]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> vis[nx][ny] <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]) &lt;= mid:<br>                        vis[nx][ny] = <span class="hljs-number">1</span><br>                        q.append((nx, ny))<br><br>            <span class="hljs-keyword">return</span> vis[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="方法二、并查集"><a href="#方法二、并查集" class="headerlink" title="方法二、并查集"></a>方法二、并查集</h2><p>其实是Kruskal算法  对所有边排序之后 不断添加边 同时维护最大差异值 直到左上角和右下角联通 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">if</span> fa[x] == x:<br>                <span class="hljs-keyword">return</span> x<br>            fa[x] = find(fa[x])<br>            <span class="hljs-keyword">return</span> fa[x]<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>            fa[find(x)] = find(y)<br><br>        edgelen = []<br>        fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                pos = i * m + j<br>                <span class="hljs-keyword">if</span> i &lt; n - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i + <span class="hljs-number">1</span>][j] - heights[i][j]), pos, pos + m])<br>                <span class="hljs-keyword">if</span> j &lt; m - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i][j + <span class="hljs-number">1</span>] - heights[i][j]), pos, pos + <span class="hljs-number">1</span>])<br>        <br>        edgelen.sort()<br>        <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edgelen:<br>            union(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">if</span> find(<span class="hljs-number">0</span>) == find(m * n - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> e[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="方法三、最短路"><a href="#方法三、最短路" class="headerlink" title="方法三、最短路"></a>方法三、最短路</h2><p>Dijikstra算法  只不过本来维护最短距离  现在维护最大差异 本来是存边  现在不需要存边 直接用BFS</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        q = [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]<br>        dis = [inf] * (m * n)<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        vis = <span class="hljs-built_in">set</span>()<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> q:<br>            d, x, y = heapq.heappop(q)<br>            pos = x * m + y<br>            <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> vis:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> (x, y) == (n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">break</span><br>            vis.add(pos)<br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = dx[i] + x<br>                ny = dy[i] + y<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny])) &lt;= dis[nx * m + ny]:<br>                    dis[nx * m + ny] = <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]))<br>                    heapq.heappush(q, (dis[nx * m + ny], nx, ny))<br>        <span class="hljs-keyword">return</span> dis[m * n - <span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><h1 id="1345-跳跃游戏-IV-力扣（LeetCode）"><a href="#1345-跳跃游戏-IV-力扣（LeetCode）" class="headerlink" title="1345. 跳跃游戏 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game-iv/">1345. 跳跃游戏 IV - 力扣（LeetCode）</a></h1><p>BFS 但是要分情况 主要是存图要用map存 map[arr[i]].push_back(i);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            mp[arr[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dist</span>(n, inf);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(), step = dist[x];<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; n &amp;&amp; dist[x + <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x + <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dist[x - <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x - <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : mp[arr[x]])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dist[y] == inf)<br>                &#123;<br>                    dist[y] = step + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125;<br>            &#125;<br>            mp[arr[x]].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1207-大臣的旅费-AcWing题库"><a href="#1207-大臣的旅费-AcWing题库" class="headerlink" title="1207. 大臣的旅费 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1209/">1207. 大臣的旅费 - AcWing题库</a></h1><p>求树的直径问题</p><p>要求相距最远的两个城市 也就是求树的直径 </p><p>先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径</p><p>用dis记录任意点到i点的最远距离</p><p>dfs中需要添加father 防止回头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ;<br><span class="hljs-type">int</span> w[N] , e[N] , ne[N] , h[N] , idx ;<br><span class="hljs-type">int</span> maxu , maxd ;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b , <span class="hljs-type">int</span> c )</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> fa , <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    dis[u] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i != <span class="hljs-number">-1</span> ; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j != fa)<br>            <span class="hljs-built_in">dfs</span>(j,u,d + w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a , b , c ;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxd * <span class="hljs-number">10</span> + (maxd + <span class="hljs-number">1ll</span>) * maxd / <span class="hljs-number">2</span> &lt;&lt; endl ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一题题解</title>
    <link href="/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5166-对称山脉-AcWing题库"><a href="#5166-对称山脉-AcWing题库" class="headerlink" title="5166. 对称山脉 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5169/">5166. 对称山脉 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])</span><br><span class="hljs-comment"># 用ans记录每个长度j下的最小值</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>s = [[<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5010</span>)]<br>ans = [<span class="hljs-number">0x3f3f3f3f</span>] * <span class="hljs-number">5010</span><br>h = [<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    h[i+<span class="hljs-number">1</span>] =  nums[i]   <br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n-j+<span class="hljs-number">2</span>):<br>        s[i][i + j - <span class="hljs-number">1</span>] = s[i + <span class="hljs-number">1</span>][i + j - <span class="hljs-number">2</span>] + <span class="hljs-built_in">abs</span>(h[i] - h[i + j - <span class="hljs-number">1</span>])<br>        ans[j] = <span class="hljs-built_in">min</span>(ans[j], s[i][i + j - <span class="hljs-number">1</span>])<br><br>ans[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[j],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="5180-正方形泳池-AcWing题库"><a href="#5180-正方形泳池-AcWing题库" class="headerlink" title="5180. 正方形泳池 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5183/">5180. 正方形泳池 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>tree = []<br>tree.append([-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 占位</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,t + <span class="hljs-number">1</span>):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    tree.append([a, b])<br><br>tree.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>tree.append([<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>])<br>tree.append([n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>tree.append([n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>])<br>t += <span class="hljs-number">4</span> <span class="hljs-comment"># 四个顶点插入树 树的个数要加上</span><br><br>ans = -<span class="hljs-number">1</span><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]) <span class="hljs-comment">#  对x排序</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]</span><br><span class="hljs-string">不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）</span><br><span class="hljs-string">更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    d, u = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> x - a - <span class="hljs-number">1</span> &gt; u - d - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, x - a - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> y &gt;= b:<br>            u = <span class="hljs-built_in">min</span>(u, y)<br>        <span class="hljs-keyword">if</span> y &lt;= b:<br>            d = <span class="hljs-built_in">max</span>(d, y)<br><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    l, r = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> y - b - <span class="hljs-number">1</span> &gt; r - l - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, y - b - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x &gt;= a:<br>            r = <span class="hljs-built_in">min</span>(r, x)<br>        <span class="hljs-keyword">if</span> x &lt;= a:<br>            l = <span class="hljs-built_in">max</span>(l, x)<br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="1654-到家的最少跳跃次数-力扣（LeetCode）"><a href="#1654-到家的最少跳跃次数-力扣（LeetCode）" class="headerlink" title="1654. 到家的最少跳跃次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BFS 搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumJumps</span>(<span class="hljs-params">self, forbidden: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q,vis = deque([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]), <span class="hljs-built_in">set</span>([<span class="hljs-number">0</span>])<br>        lower, upper = <span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(forbidden) + a, x) + b<br>        forbiddenSet = <span class="hljs-built_in">set</span>(forbidden)<br>        <span class="hljs-keyword">while</span> q:<br>            position, direction, step = q.popleft()<br>            <span class="hljs-keyword">if</span> x == position:<br>                <span class="hljs-keyword">return</span> step<br>            nextposition = position + a<br>            nextdirection = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                vis.add(nextposition * nextdirection)<br>                q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 不能两次退后</span><br>            <span class="hljs-keyword">if</span> direction == <span class="hljs-number">1</span>:<br>                nextposition = position - b<br>                nextdirection = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                    vis.add(nextposition * nextdirection)<br>                    q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="823-带因子的二叉树-力扣（LeetCode）"><a href="#823-带因子的二叉树-力扣（LeetCode）" class="headerlink" title="823. 带因子的二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-trees-with-factors/">823. 带因子的二叉树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = <span class="hljs-built_in">set</span>(arr)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">val</span>):<br>            ans = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> s:<br>                    ans += dfs(x) * dfs(val // x)<br>            <span class="hljs-keyword">return</span> ans<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(dfs(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>    <br><span class="hljs-comment"># 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        idx = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr)&#125;<br>        f = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                val = arr[i]<br>                x = arr[j]<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> idx:<br>                    f[i] += f[j] * f[idx[val // x]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(f) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br><br></code></pre></td></tr></table></figure><h1 id="1761-一个图中连通三元组的最小度数-力扣（LeetCode）"><a href="#1761-一个图中连通三元组的最小度数-力扣（LeetCode）" class="headerlink" title="1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/">1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次</span><br><span class="hljs-comment"># 用邻接矩阵来储存 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minTrioDegree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        degree = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> edges:<br>            x, y = x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span><br>            g[x][y] = g[y][x] = <span class="hljs-number">1</span><br>            degree[x] += <span class="hljs-number">1</span><br>            degree[y] += <span class="hljs-number">1</span><br>        <br>        ans = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                <span class="hljs-keyword">if</span> g[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, n):<br>                        <span class="hljs-keyword">if</span> g[i][k] == g[j][k] == <span class="hljs-number">1</span>:<br>                            ans = <span class="hljs-built_in">min</span>(ans, degree[i] + degree[j] + degree[k] - <span class="hljs-number">6</span>)<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ans == inf <span class="hljs-keyword">else</span> ans<br><br></code></pre></td></tr></table></figure><h1 id="5183-好三元组-AcWing题库"><a href="#5183-好三元组-AcWing题库" class="headerlink" title="5183. 好三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5186/">5183. 好三元组 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。</span><br><span class="hljs-string">所有情况为n * (n - 1) * (n - 2) // 6</span><br><span class="hljs-string">当三个数在同一点上时 不合规</span><br><span class="hljs-string">两个点在同一点上 不合规</span><br><span class="hljs-string">三个点在同一个半圆内时 不合规</span><br><span class="hljs-string">同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规</span><br><span class="hljs-string">所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1</span><br><span class="hljs-string">最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>N = <span class="hljs-number">2000100</span><br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>p = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>cnt = [<span class="hljs-number">0</span>] * N<br>s = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt[p[i - <span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    cnt[p[i - <span class="hljs-number">1</span>] + c] += <span class="hljs-number">1</span><br><br>res = n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br><br>s[<span class="hljs-number">0</span>] = cnt[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * c):<br>    s[i] = s[i - <span class="hljs-number">1</span>] + cnt[i]<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c):<br>    <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">continue</span><br>    t = cnt[i]<br>    d = s[i + c // <span class="hljs-number">2</span>] - s[i]<br>    <br>    <span class="hljs-comment"># 其实不需要判断也行</span><br>    <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">3</span>:<br>            res -= t * (t - <span class="hljs-number">1</span>) * (t - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br>        res -= t * (t - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * d<br>    res -= t * d * (d - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c // <span class="hljs-number">2</span>):<br>        u, v = cnt[i], cnt[i + c // <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">2</span>:<br>            res += u * (u - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * v<br>        <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">2</span>:<br>            res += v * (v - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * u<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="5145-同色环-AcWing题库"><a href="#5145-同色环-AcWing题库" class="headerlink" title="5145. 同色环 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5148/">5145. 同色环 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> nums[N][N];<br><span class="hljs-type">bool</span> vis[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> ox, <span class="hljs-type">int</span> oy)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx = x + dx[i];<br>        <span class="hljs-type">int</span> ny = y + dy[i];<br><br>        <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m<br>            <span class="hljs-comment">// 这一句的意思是 不能退回</span><br>            &amp;&amp; !(nx == ox &amp;&amp; ny == oy)<br>            <span class="hljs-comment">// 颜色相同</span><br>            &amp;&amp; nums[nx][ny] == nums[x][y])<br>        &#123;<br>            <span class="hljs-comment">// 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况</span><br>            <span class="hljs-keyword">if</span> (vis[nx][ny] || <span class="hljs-built_in">dfs</span>(nx, ny, x, y))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            cin &gt;&gt; nums[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i][j])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1921-消灭怪物的最大数量-力扣（LeetCode）"><a href="#1921-消灭怪物的最大数量-力扣（LeetCode）" class="headerlink" title="1921. 消灭怪物的最大数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03">1921. 消灭怪物的最大数量 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eliminateMaximum</span>(<span class="hljs-params">self, dist: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(dist)<br>        <span class="hljs-comment"># 上取整</span><br>        arrivetime = [math.ceil(dist[i] / speed[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>        arrivetime.sort()<br>        <span class="hljs-keyword">for</span> attacktime, arrivetime <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arrivetime):<br>            <span class="hljs-keyword">if</span> attacktime &gt;= arrivetime:<br>                <span class="hljs-keyword">return</span> attacktime<br>        <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure><h1 id="统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛"><a href="#统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛" class="headerlink" title="统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛"></a><a href="https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/">统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Counter 返回字典 每个元素是键 出现次数为值</span><br><span class="hljs-comment"># dfs</span><br><span class="hljs-comment"># 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        mx = -<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        keys = <span class="hljs-built_in">list</span>(c.keys())<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, count, add, mul</span>):<br>            <span class="hljs-keyword">nonlocal</span> mx, ans<br>            <span class="hljs-keyword">if</span> count == k:<br>                <span class="hljs-keyword">if</span> add &gt; mx:<br>                    mx = add<br>                    ans = mul<br>                <span class="hljs-keyword">elif</span> add == mx:<br>                    ans += mul<br>                ans %= Mod<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> i + k - count &gt; <span class="hljs-built_in">len</span>(keys):<br>                <span class="hljs-keyword">return</span><br>            dfs(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, add + c[keys[i]], mul * c[keys[i]] % Mod)<br>            dfs(i + <span class="hljs-number">1</span>, count, add, mul)<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-comment"># 数学</span><br><span class="hljs-comment"># 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> comb<br>            Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>            values = <span class="hljs-built_in">sorted</span>(c.values(), reverse=<span class="hljs-literal">True</span>)<br>            ans = <span class="hljs-number">1</span><br>            c = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                <span class="hljs-keyword">if</span> values[i] &gt; values[k - <span class="hljs-number">1</span>]:<br>                    ans *= values[i]<br>                    ans %= Mod<br>                <span class="hljs-keyword">elif</span> values[i] == values[k - <span class="hljs-number">1</span>]:<br>                    c += <span class="hljs-number">1</span><br>                    ans *= values[i]<br>                    ans %= Mod<br>            <span class="hljs-keyword">return</span> ans * comb(values.count(values[k - <span class="hljs-number">1</span>]),c) % Mod<br><br></code></pre></td></tr></table></figure><h1 id="2605-从两个数字数组里生成最小数字-力扣（LeetCode）"><a href="#2605-从两个数字数组里生成最小数字-力扣（LeetCode）" class="headerlink" title="2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/">2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是看一下这个写法 s = set(nums1) &amp; set(nums2) 直接取出1 2 中的相同的数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minNumber</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        a = <span class="hljs-built_in">min</span>(nums1)<br>        b = <span class="hljs-built_in">min</span>(nums2)<br>        <span class="hljs-keyword">if</span> a &gt; b:<br>            a, b = b, a<br>        ret = a * <span class="hljs-number">10</span> + b<br><br>        s = <span class="hljs-built_in">set</span>(nums1) &amp; <span class="hljs-built_in">set</span>(nums2)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> ret <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(s)<br></code></pre></td></tr></table></figure><h1 id="5198-整理书籍-AcWing题库"><a href="#5198-整理书籍-AcWing题库" class="headerlink" title="5198. 整理书籍 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5201/">5198. 整理书籍 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算有几个L几个M 然后算有几个L不在前面 有几个M不在中间 然后至多需要交换这么多次 才能换好 但是当错位的L和M互换时 两次就只需要一次了 所以说取min(l,m)(这就是LM相互错位的个数)减掉就行</span><br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())<br>n = <span class="hljs-built_in">len</span>(nums)<br>cl, cm, cs = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        cl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        cm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;S&#x27;</span>:<br>        cs += <span class="hljs-number">1</span><br><br><br>wl, wm, lm, ml = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;L&#x27;</span>:<br>        wl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        lm += <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl, cl + cm):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;M&#x27;</span>:<br>        wm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        ml += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(wl + wm - <span class="hljs-built_in">min</span>(lm, ml))<br><br></code></pre></td></tr></table></figure><h1 id="2594-修车的最少时间-力扣（LeetCode）"><a href="#2594-修车的最少时间-力扣（LeetCode）" class="headerlink" title="2594. 修车的最少时间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/">2594. 修车的最少时间 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分最长的时间 计算这个时间每个人可以修的车的数量 和 cars比较 （并不需要实际地去算 应该给每个人安排多少车 而是求最大修车数 看能不能修完）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repairCars</span>(<span class="hljs-params">self, ranks: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], cars: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        right = cars * cars * <span class="hljs-built_in">min</span>(ranks)<br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(isqrt(mid // r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> ranks) &gt;= cars:<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><h1 id="Problem-F-Codeforces"><a href="#Problem-F-Codeforces" class="headerlink" title="Problem - F - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/F">Problem - F - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求一个数，他的约数的个数（同一个约数可能出现很多次）最多，遍历1~n，ans[j] += len(cs[i])。因为i的所有倍数上的点，都满足条件。所以把每个ans[j] 都加上i的个数。遍历到n的时候，就把所有的数都加上了</span><br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <br>    cs = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>        cs[x].append(i)<br>    ans = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    m = <span class="hljs-built_in">len</span>(cs)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        j = i<br>        <span class="hljs-keyword">while</span> j &lt;= n:<br>            ans[j] += <span class="hljs-built_in">len</span>(cs[i])<br>            j += i<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(ans))<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="210-课程表-II-力扣（LeetCode）"><a href="#210-课程表-II-力扣（LeetCode）" class="headerlink" title="210. 课程表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-ii/?envType=daily-question&envId=2023-09-10">210. 课程表 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拓扑排序(注意拓扑排序 是看是不是所有的都进入过q 或者说 最后是不是所有入度都为0) 首先建图 同时增加入度 然后把入度为0的都加入q 不断循环 每次pop的同时 numCourse-1 记录进入q的个数 如果全部进了代表没有环 那么就可以返回 而上课顺序 恰好是从q pop的顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        how = []<br>        <span class="hljs-keyword">while</span> q:<br>            pre = q.popleft()<br>            numCourses -= <span class="hljs-number">1</span><br>            how.append(pre)<br>            <span class="hljs-keyword">for</span> cur <span class="hljs-keyword">in</span> graph[pre]:<br>                in_deg[cur] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[cur] == <span class="hljs-number">0</span>:<br>                    q.append(cur)<br>        <br>        <span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> how<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="630-课程表-III-力扣（LeetCode）"><a href="#630-课程表-III-力扣（LeetCode）" class="headerlink" title="630. 课程表 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iii/?envType=daily-question&envId=2023-09-11">630. 课程表 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 贪心＋优先队列 （反悔贪心） 很容易想到要先对结束时间排序 结束时间越晚 就越晚做，因为开始晚的先做如果做得完，可能前面的做不完了，开始晚的先做如果做不完，那前面的肯定做不完了。开始晚的后做，不管做不做得完，前一个肯定是不受影响的。</span><br><span class="hljs-comment"># 接着是按顺序取课 用sum记录当前总时间 h为优先队列（注意 heap默认是小根堆  为了使其成为大根堆 每次存入和取出使用相反数），如果sum+dur &lt;= end 说明是可以都上的 那就加上 并且放入h  如果&gt;end 不能都上 那么就判断当前的dur和之前已经存在的时间最长的课哪个时间更长 如果原来的课比当前课时间长 就要和当前的课进行替换（总数不变 sum变小） 使得sum最小 那么就更有可能多上几节课 如果当前的时间长 那这节课肯定选不了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scheduleCourse</span>(<span class="hljs-params">self, courses: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        courses.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>        n = <span class="hljs-built_in">len</span>(courses)<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        h = []<br>        <span class="hljs-keyword">for</span> dur, end <span class="hljs-keyword">in</span> courses:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> + dur &lt;= end:<br>                <span class="hljs-built_in">sum</span> += dur<br>                heappush(h, -dur)<br>            <span class="hljs-keyword">elif</span> h <span class="hljs-keyword">and</span> -h[<span class="hljs-number">0</span>] &gt; dur:<br>                <span class="hljs-built_in">sum</span> -= -h[<span class="hljs-number">0</span>] - dur<br>                heappop(h)<br>                heappush(h, -dur)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br></code></pre></td></tr></table></figure><h1 id="1462-课程表-IV-力扣（LeetCode）"><a href="#1462-课程表-IV-力扣（LeetCode）" class="headerlink" title="1462. 课程表 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkIfPrerequisite</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">bool</span>]:<br>        <span class="hljs-comment"># 拓扑排序的思路仍然是先建图 存储入度 循环找点  不同的是 （有向图） 这次0-1-2-3 不仅0-1连通 0-3也连通 要反映这样的一种关系 需要建立一个二维数组表示他们的连通关系  每次pop取出一个点 这个点是x连向的所有点 即列表graph[x] 遍历里面的每个元素 （入度减一等操作） 遍历每一个numCourse的点 如果他跟x有连接 或者跟y有连接就为True （h-y or h-x-y）</span><br>        <span class="hljs-comment"># Toposort</span><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        ret = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                in_deg[y] -= <span class="hljs-number">1</span><br>                ret[x][y] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    ret[h][y] = ret[h][y] <span class="hljs-keyword">or</span> ret[h][x]<br>                <span class="hljs-keyword">if</span> in_deg[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br>        <span class="hljs-keyword">return</span> [ret[a][b] <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> queries]<br>    <br>    <br>        <span class="hljs-comment"># Floyd的思路 边权为True 建好图之后直接循环</span><br>        <span class="hljs-comment"># Floyd</span><br>        graph = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre][cur] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    graph[i][j] = (graph[i][k] <span class="hljs-keyword">and</span> graph[k][j]) <span class="hljs-keyword">or</span> graph[i][j]<br><br>        <span class="hljs-keyword">return</span> [graph[i][j] <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces（新二分板子）"><a href="#Problem-E-Codeforces（新二分板子）" class="headerlink" title="Problem - E - Codeforces（新二分板子）"></a><a href="https://codeforces.com/contest/1850/problem/E">Problem - E - Codeforces</a>（新二分板子）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 来自tllwtg的算法模板</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">更好记录答案 也更有逻辑</span><br><span class="hljs-string">if check():</span><br><span class="hljs-string">res = mid</span><br><span class="hljs-string">l = mid + 1</span><br><span class="hljs-string">else:</span><br><span class="hljs-string">r = mid - 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">return res</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>    l, r, res = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>, -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> l &lt;= r:<br>        mid = (l + r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-built_in">sum</span>([(nums[i] + <span class="hljs-number">2</span> * mid ) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]):<br>            res = mid <br>            l = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid - <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/D">Problem - D - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求去掉几个可以使连续的最大 就是求最大然后用n减去</span><br><span class="hljs-comment"># 用diff记录差值 但其实可以优化 毕竟排序之后 差值只需要和前一个比较即可</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    diff = [<span class="hljs-number">0</span>] * n<br>    diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># print(diff)</span><br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">if</span> diff[i] &lt;= k:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br>    <br><span class="hljs-comment"># 优化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    <br>    <br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    pre = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<span class="hljs-comment"># 0不看 因为cnt初始值为1 从1开始</span><br>        <span class="hljs-keyword">if</span> nums[i] - pre &gt; m:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            cnt += <span class="hljs-number">1</span><br>    pre = nums[i]<br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br>    <br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="5151-程序调用-AcWing题库"><a href="#5151-程序调用-AcWing题库" class="headerlink" title="5151. 程序调用 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5154/">5151. 程序调用 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 通过索引找值 再通过值找索引  并且实现交换 主要是两个数组 一个是原数组 一个是pos数组 注意每次交换的时候两个数组都要交换 知道值a pos[a]即为索引 那a的前一个数就是pos[a] - 1 然后交换</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m, k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; s[i];<br>f[s[i]] = i;<br>w[i] = (i - <span class="hljs-number">1</span>) / k + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>ret += w[f[x]];<br><br><span class="hljs-keyword">if</span> (f[x] == <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br><br><span class="hljs-built_in">swap</span>(s[f[x]], s[f[x] - <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">swap</span>(f[s[f[x]]], f[s[f[x] - <span class="hljs-number">1</span>]]);<br>&#125;<br>cout &lt;&lt; ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="213-打家劫舍-II-力扣（LeetCode）"><a href="#213-打家劫舍-II-力扣（LeetCode）" class="headerlink" title="213. 打家劫舍 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打家劫舍1是一个动态规划问题 用f[k]来表示 前k间房子最多能偷多少钱 当k=n的时候就是答案 状态转移方程为f[i] = max(f[i -  1], f[i - 2] + nums[i]) 选i-1或者选i-2 + nums[i]  最后 如下的写法是优化空间复杂度的写法 因为每次仅需要前两个数和当前这个数 所以可以交替使用</span><br><span class="hljs-comment"># 打家劫舍2在1的基础上把首尾相连成环 这就导致首尾选不选的问题 这样的环的问题其实可以先排除掉环的影响再来做 即分为两类 首部选或不选（必定可且仅可分为两类）选首部的时候 尾部不能选（第二个也不能选） 那就是[2:-1] 不选首部的时候 就是[1:]然后看看哪个更大（有点类似之前实训课做过的枚举）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob1</span>(<span class="hljs-params">self, nums:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>)-&gt;<span class="hljs-built_in">int</span>:<br>        f0 = f1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            f0, f1 = f1, <span class="hljs-built_in">max</span>(f0 + x, f1)<br>        <br>        <span class="hljs-keyword">return</span> f1<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>] + self.rob1(nums[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]), self.rob1(nums[<span class="hljs-number">1</span>:]))<br>        <br></code></pre></td></tr></table></figure><h1 id="337-打家劫舍-III-力扣（LeetCode）"><a href="#337-打家劫舍-III-力扣（LeetCode）" class="headerlink" title="337. 打家劫舍 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iii/discussion/">337. 打家劫舍 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 树形DP 还是一样分析 根节点选或者不选（注意根节点不选 下一个结点也不一定要选）求出 左子树不选根的最大值和左子树选根的最大值 和 右子树不选根的最大值和右子树选根的最大值 如果选根 那么总共的最大值就是根+左不选根+右不选根 如果不选根 那就是左子树最大（选根和不选根 的最大）和右子树最大 相加</span><br><span class="hljs-comment"># 注意先想好dfs是做什么的  从root开始 返回选root的最大值 和不选root的最大值</span><br><br><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>           l_rob, l_not_rob = dfs(root.left)<br>            r_rob, r_not_rob = dfs(root.right)<br>            rob = root.val + l_not_rob + r_not_rob<br>            not_rob = <span class="hljs-built_in">max</span>(l_rob, l_not_rob) + <span class="hljs-built_in">max</span>(r_rob, r_not_rob)<br>            <span class="hljs-keyword">return</span> rob, not_rob<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(root))<br></code></pre></td></tr></table></figure><h1 id="2560-打家劫舍-IV-力扣（LeetCode）"><a href="#2560-打家劫舍-IV-力扣（LeetCode）" class="headerlink" title="2560. 打家劫舍 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iv/solutions/2093952/er-fen-da-an-dp-by-endlesscheng-m558/">2560. 打家劫舍 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分答案 最小化能够抢到的最大值 类似的表述就是二分答案的套路</span><br><span class="hljs-comment"># 二分偷取的钱数（得到最小值）  当偷盗的房子数满足k的时候 就可以成为一个答案  本解还有贪心 只要遇到可偷的就立即偷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        minn = <span class="hljs-built_in">min</span>(nums)<br>        maxn = <span class="hljs-built_in">max</span>(nums)<br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> minn &lt;= maxn:<br>            mid = (maxn + minn) // <span class="hljs-number">2</span><br>            cnt = <span class="hljs-number">0</span><br>            vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis <span class="hljs-keyword">and</span> num &lt;= mid:<br>                    cnt += <span class="hljs-number">1</span><br>                    vis = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> cnt &lt; k:<br>                <br>                minn = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res = mid<br>                maxn = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>    <br><span class="hljs-comment"># 也可以用二分+动态规划 状态表示为从0~i可偷的房间数为f[i] 状态计算为f[i] = max(f[i - 1], f[i - 1] + 1) </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">mx: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            f0 = f1 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &lt;= mx:<br>                   f0, f1 = f1, <span class="hljs-built_in">max</span>(f1, f0 + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                    f0 = f1<br>           <span class="hljs-keyword">return</span>  f1<br>       <span class="hljs-keyword">return</span> bisect_left(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(nums)), k, key=solve)<br></code></pre></td></tr></table></figure><h1 id="2603-收集树中金币-力扣（LeetCode）"><a href="#2603-收集树中金币-力扣（LeetCode）" class="headerlink" title="2603. 收集树中金币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collectTheCoins</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(coins)<br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        deg = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">len</span>, graph))<br>        q = deque()<br>        res = n - <span class="hljs-number">1</span> <span class="hljs-comment"># 总边数</span><br>        <span class="hljs-comment"># 先把没有金币的叶子节点存入数组（相当于拓扑排序的放入入度为0的点</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">0</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 删除所有没有金币的叶子节点</span><br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            res -= <span class="hljs-number">1</span> <span class="hljs-comment"># 每次循环都会删掉一条边</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> coins[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br><br>        <span class="hljs-comment"># 删除最下面两层结点（叶子结点和叶子节点的父节点）（此时的叶子节点是含金币的因为不含的已经删除）</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">1</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 这一层的所有含金币的叶子都被删除了 那么这些线就不用走了 删除的总数就是len(q)      </span><br>        res -= <span class="hljs-built_in">len</span>(q)<br><br>        <span class="hljs-comment"># 接下来删除叶子节点的父节点（叶子在上面已经删除）</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q:<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span>:<br>                    res -= <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, res * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="1993-树上的操作-力扣（LeetCode）"><a href="#1993-树上的操作-力扣（LeetCode）" class="headerlink" title="1993. 树上的操作 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/operations-on-tree/?envType=daily-question&envId=2023-09-23">1993. 树上的操作 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockingTree</span>:<br><span class="hljs-comment"># 初始化需要有父节点和每个父节点的子节点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        n = <span class="hljs-built_in">len</span>(parent)<br>        self.parent = parent<br>        self.lockNodeUser = [-<span class="hljs-number">1</span>] * n<br>        self.children = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <br>        <span class="hljs-keyword">for</span> node, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(parent):<br>            <span class="hljs-keyword">if</span> p != -<span class="hljs-number">1</span>:<br>                self.children[p].append(node)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == -<span class="hljs-number">1</span>:<br>            self.lockNodeUser[num] = user<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == user:<br>            self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 难点主要是更新 如果该结点没有上锁 并且祖先没有上锁 并且孩子有上锁（同时解锁所有孩子） </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] == -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.haslockedansester(num) <span class="hljs-keyword">and</span> self.checkandlockdescendant(num)<br>        <span class="hljs-keyword">if</span> res:<br>            self.lockNodeUser[num] = user<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-comment"># 由父节点不断向上 直到根节点 如果有上锁的 就直接返回 否则就继续向上</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">haslockedansester</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.parent[num]<br>        <span class="hljs-keyword">while</span> num != -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.lockNodeUser[num] != -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                num = self.parent[num]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 如果找到了一个上锁的子节 就直接解锁  因为只要有上锁 就表示满足要求 需要解锁 而如果都没有上锁 那解锁操作也不会影响原来的结点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkandlockdescendant</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] != -<span class="hljs-number">1</span><br>        self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.children[num]:<br>            res |= self.checkandlockdescendant(child)<br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-comment"># Your LockingTree object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LockingTree(parent)</span><br><span class="hljs-comment"># param_1 = obj.lock(num,user)</span><br><span class="hljs-comment"># param_2 = obj.unlock(num,user)</span><br><span class="hljs-comment"># param_3 = obj.upgrade(num,user)</span><br></code></pre></td></tr></table></figure><h1 id="146-LRU-缓存-力扣（LeetCode）"><a href="#146-LRU-缓存-力扣（LeetCode）" class="headerlink" title="146. LRU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=daily-question&envId=2023-09-24">146. LRU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>, value=<span class="hljs-number">0</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        self.prev = <span class="hljs-literal">None</span><br>        self.key = key<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br>    <span class="hljs-comment"># 因为需要O(1) 的存取 所以使用双向链表加字典</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.head = Node()<br>        self.head.prev = self.head<br>        self.head.<span class="hljs-built_in">next</span> = self.head<br>        self.<span class="hljs-built_in">map</span> = <span class="hljs-built_in">dict</span>()<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 插入 如果已经在的话就修改 如果不在的话首先 在map中记录 如何插入链表头 如果大于capacity的话 就删除链表尾(因为一开始把每次访问的都放在头部了（LRU的特性）所以删除的时候就可以直接删除尾部)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span><br>        <br>        self.<span class="hljs-built_in">map</span>[key] = node = Node(key, value)<br>        self.push_front(node)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.<span class="hljs-built_in">map</span>) &gt; self.capacity:<br>            back_node = self.head.prev<br>            <span class="hljs-keyword">del</span> self.<span class="hljs-built_in">map</span>[back_node.key]<br>            self.remove(back_node)<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev = self.head<br>        x.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        self.head.<span class="hljs-built_in">next</span>.prev = x<br>        self.head.<span class="hljs-built_in">next</span> = x<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-comment"># 查找 如果key不在map的话 return None 否则把他放到链表头</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[Node]:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">map</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.<span class="hljs-built_in">map</span>[key]<br>        self.remove(node)<br>        self.push_front(node)<br>        <span class="hljs-keyword">return</span> node<br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="460-LFU-缓存-力扣（LeetCode）"><a href="#460-LFU-缓存-力扣（LeetCode）" class="headerlink" title="460. LFU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lfu-cache/?envType=daily-question&envId=2023-09-25">460. LFU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-comment"># 结点的定义 双向链表的结点加上字典的key和访问次数cnt</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>,value=<span class="hljs-number">0</span>,<span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>,prev=<span class="hljs-literal">None</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        self.prev = prev<br>        self.cnt = <span class="hljs-number">1</span><br>        self.key = key<br><br><span class="hljs-comment"># 需要建一个次数表 把访问次数相同的放在一起 用字典实现 key为访问次数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.key_to_node = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_node</span>()-&gt;Node:<br>            head = Node()<br>            head.<span class="hljs-built_in">next</span> = head<br>            head.prev = head<br>            <span class="hljs-keyword">return</span> head<br>        self.freq_to_head = defaultdict(new_node)<br>    <br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 当这本书已经存在的时候 修改值 否则要放入（访问一次）中（注意先判断是否已满）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-comment"># 如果已满就拿出访问min_freq次的最下面的书（最不常用）</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.key_to_node) == self.capacity:<br>            phead = self.freq_to_head[self.min_freq]<br>            back_node = phead.prev <span class="hljs-comment"># 最不常用的</span><br>            <span class="hljs-keyword">del</span> self.key_to_node[back_node.key]  <span class="hljs-comment"># 从字典删除</span><br>            self.remove(back_node) <span class="hljs-comment"># 从链表中删除</span><br>            <span class="hljs-comment"># 如果删除的是头结点 那就直接把整个链表删除了</span><br>            <span class="hljs-keyword">if</span> phead.prev == phead:<br>                <span class="hljs-keyword">del</span> self.freq_to_head[self.min_freq]<br>        <span class="hljs-comment"># 插入这本书</span><br>        self.key_to_node[key] = node = Node(key, value)<br>        <span class="hljs-comment"># 放到最上面</span><br>        self.push_front(self.freq_to_head[<span class="hljs-number">1</span>],node)<br>        <span class="hljs-comment"># 刚插入的访问次数必定为1</span><br>        self.min_freq = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, head:Node, x:Node</span>):<br>        x.prev = head<br>        x.<span class="hljs-built_in">next</span> = head.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x<br>        x.prev.<span class="hljs-built_in">next</span> = x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x:Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.key_to_node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.key_to_node[key]<span class="hljs-comment"># 找到这本书</span><br>        self.remove(node)<span class="hljs-comment"># 去掉</span><br>        phead = self.freq_to_head[node.cnt]<br>        <span class="hljs-comment"># 如果这本书原来所在的链表只有他一个 那就删除链表</span><br>        <span class="hljs-keyword">if</span> phead.prev == phead:<br>            <span class="hljs-keyword">del</span> self.freq_to_head[node.cnt]<br>            <span class="hljs-comment"># 如果这本书恰好是访问一次的链表 那么删除之后就没有访问一次的了 至少也是访问两次的</span><br>            <span class="hljs-keyword">if</span> self.min_freq == node.cnt:<br>                self.min_freq += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 这本书访问次数加1</span><br>        node.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 插到最上面</span><br>        self.push_front(self.freq_to_head[node.cnt], node)<br>        <span class="hljs-keyword">return</span> node<br>        <br><br><span class="hljs-comment"># Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LFUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="587-安装栅栏-力扣（LeetCode）"><a href="#587-安装栅栏-力扣（LeetCode）" class="headerlink" title="587. 安装栅栏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/erect-the-fence/description/">587. 安装栅栏 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outerTrees</span>(<span class="hljs-params">self, trees: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-comment"># 求扫过的面积 如果&lt;0 说明需要更新</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">cross</span>(<span class="hljs-params">p: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], q: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], r: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">return</span> (q[<span class="hljs-number">0</span>] - p[<span class="hljs-number">0</span>]) * (r[<span class="hljs-number">1</span>] - q[<span class="hljs-number">1</span>]) - (q[<span class="hljs-number">1</span>] - p[<span class="hljs-number">1</span>]) * (r[<span class="hljs-number">0</span>] - q[<span class="hljs-number">0</span>])<br>        <br>        n = <span class="hljs-built_in">len</span>(trees)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> trees<br><br>        trees.sort()<br><br>        hull = [<span class="hljs-number">0</span>]<br>        used = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-comment"># 求凸包下半部分</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                used[hull.pop()] = <span class="hljs-literal">False</span><br>            used[i] = <span class="hljs-literal">True</span><br>            hull.append(i)<br>        <span class="hljs-comment"># 求凸包的上半部分</span><br>        m = <span class="hljs-built_in">len</span>(hull)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[i]:<br>                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; m <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                    used[hull.pop()] = <span class="hljs-literal">False</span><br>                used[i] = <span class="hljs-literal">True</span><br>                hull.append(i)<br>        <span class="hljs-comment"># hull[0] 是起点 同时参加上半部分的检测 所以要删掉</span><br>        hull.pop()<br>        <span class="hljs-keyword">return</span> [trees[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hull]<br></code></pre></td></tr></table></figure><h1 id="2251-花期内花的数目-力扣（LeetCode）"><a href="#2251-花期内花的数目-力扣（LeetCode）" class="headerlink" title="2251. 花期内花的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solutions/1445000/chai-fen-pythonjavacgo-by-endlesscheng-wz35/?envType=daily-question&envId=2023-09-28">2251. 花期内花的数目 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 差分前缀和 不需要每次把每个区间全部加上 这样复杂度过高 而是只需要在区间开头处+1 在区间结尾处-1 然后排序保证访问的时候是遍历的顺序 计算前缀和  如第一个人第二分钟来 那就算出第二分钟有几朵花 就是第二分钟的前缀和 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        diff = Counter()<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> flowers:<br>            diff[s] += <span class="hljs-number">1</span><br>            diff[e + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br><br>        time = <span class="hljs-built_in">sorted</span>(diff.keys())<br>        s = j = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> p, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(people, <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(people)))):<br>            <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(time) <span class="hljs-keyword">and</span> time[j] &lt;= p:<br>                s += diff[time[j]]<br>                j += <span class="hljs-number">1</span><br>            people[i] = s<br><br>        <span class="hljs-keyword">return</span> people<br>    <br><span class="hljs-comment"># 或者更简单的 直接计算第i分钟的花的数量  用第i分钟开花的数量减去第j分钟开花的数量 对开花时间和结束时间排序获得start和end数组 通过二分寻找开花数和凋谢数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        start = <span class="hljs-built_in">sorted</span>(s <span class="hljs-keyword">for</span> s, _ <span class="hljs-keyword">in</span> flowers)<br>        end = <span class="hljs-built_in">sorted</span>(e <span class="hljs-keyword">for</span> _, e <span class="hljs-keyword">in</span> flowers)<br>        <span class="hljs-keyword">return</span> [bisect_right(start, p) - bisect_left(end, p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> people]<br>    <br></code></pre></td></tr></table></figure><h1 id="2731-移动机器人-力扣（LeetCode）"><a href="#2731-移动机器人-力扣（LeetCode）" class="headerlink" title="2731. 移动机器人 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/movement-of-robots/">2731. 移动机器人 - 力扣（LeetCode）</a></h1><p>发现 最后只需要计算机器人的间隔 左右相碰之后转向 其实也就可以视为两个之间互换了 之间的 距离不会受到影响 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">比如<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span>R <span class="hljs-selector-tag">b</span> <span class="hljs-number">2</span>L <span class="hljs-number">3s</span> <br><span class="hljs-number">1s</span> 时在<span class="hljs-number">1</span> 处相碰   转向 <span class="hljs-selector-tag">a</span>向左 <span class="hljs-selector-tag">b</span>向右<br>然后<span class="hljs-number">3s</span>后  <span class="hljs-selector-tag">a</span>在-<span class="hljs-number">1</span> <span class="hljs-selector-tag">b</span>在<span class="hljs-number">3</span><br>其实也就相当于  <span class="hljs-selector-tag">a</span>直接走<span class="hljs-number">3s</span>到<span class="hljs-number">3</span>  <span class="hljs-selector-tag">b</span>直接走<span class="hljs-number">3s</span>到-<span class="hljs-number">1</span>  距离不变  机器人间不需要区分<br></code></pre></td></tr></table></figure><p>然后计算距离  两两之间的差可以O(n)计算！！但是注意 必须有序</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1 3 4 8 9 之间的差为<br>3<span class="hljs-string">-1</span> + 4<span class="hljs-string">-1</span> + 8<span class="hljs-string">-1</span> + 9<span class="hljs-string">-1</span><br>      4<span class="hljs-string">-3</span> + 8<span class="hljs-string">-3</span> + 9<span class="hljs-string">-3</span> <br>            8<span class="hljs-string">-4</span> + 9<span class="hljs-string">-4</span><br>                  9<span class="hljs-string">-8</span><br>因此每次算一个即可  ans + i * nums[i] 表示排i的数共被加了几次 3 1次 4 两次 8 三次 9 四次<br>再减去s  s表示每次减去的数  第一次减1  第二次减4（1 + 3） 第三次减8 （1 + 3 + 4） 第四次减16（1 + 3 + 4 + 8）<br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumDistance</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], s: <span class="hljs-built_in">str</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            f = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            nums[i] += f * d<br>        nums.sort()<br><br>        ans = <span class="hljs-number">0</span><br>        s = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ans += i * nums[i] - s<br>            s += nums[i]<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="2512-奖励最顶尖的-K-名学生-力扣（LeetCode）"><a href="#2512-奖励最顶尖的-K-名学生-力扣（LeetCode）" class="headerlink" title="2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reward-top-k-students/?envType=daily-question&envId=2023-10-11">2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）</a></h1><p>不需要用结构体也可以 用zip来直接sort</p><p>用split分割单词</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topStudents</span>(<span class="hljs-params">self, positive_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], negative_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], report: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], student_id: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        score = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> positive_feedback:<br>            score[w] = <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> negative_feedback:<br>            score[w] = -<span class="hljs-number">1</span><br>        a = <span class="hljs-built_in">sorted</span>((-<span class="hljs-built_in">sum</span>(score[w] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> r.split()), i) <span class="hljs-keyword">for</span> r, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(report, student_id))<br><br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> _, i <span class="hljs-keyword">in</span> a[:k]]<br></code></pre></td></tr></table></figure><h1 id="1488-避免洪水泛滥-力扣（LeetCode）"><a href="#1488-避免洪水泛滥-力扣（LeetCode）" class="headerlink" title="1488. 避免洪水泛滥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/avoid-flood-in-the-city/">1488. 避免洪水泛滥 - 力扣（LeetCode）</a></h1><p>不是每次晴天就去寻找抽哪个  而是到了后面 发现他要发洪水之后 就去前面找他下雨之后的第一个晴天 把他的水抽干 如果没找到 就直接返回空数组</p><p>注意用bisect_left寻找该湖泊下雨后第一个晴天</p><p>用pop删除这个晴天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avoidFlood</span>(<span class="hljs-params">self, rains: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(rains)<br>        ans = [<span class="hljs-number">1</span>] * n<br>        sun_day = SortedList()<br>        full = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> rains[i] == <span class="hljs-number">0</span>:<br>                sun_day.add(i)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> rains[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> full:<br>                    full[rains[i]] = i<br>                <span class="hljs-keyword">else</span>:<br>                    j = sun_day.bisect_left(full[rains[i]])<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-built_in">len</span>(sun_day):<br>                        <span class="hljs-keyword">return</span> []<br>                    ans[sun_day.pop(j)] = rains[i]<br>                    full[rains[i]] = i<br>                ans[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="1726-同积元组-力扣（LeetCode）"><a href="#1726-同积元组-力扣（LeetCode）" class="headerlink" title="1726. 同积元组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组 - 力扣（LeetCode）</a></h1><p>不需要三重循环来找 a * b &#x2F;&#x2F; c 在字典里面的</p><p>而是计数  记录下同一个积的两个数 的组合有多少种  然后用a * (a - 1)  计算种数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mp = defaultdict(<span class="hljs-built_in">int</span>)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                mp[nums[i] * nums[j]] += <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(mp)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> mp.values():<br>            ans += x * (x - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="2316-统计无向图中无法互相到达点对数-力扣（LeetCode）"><a href="#2316-统计无向图中无法互相到达点对数-力扣（LeetCode）" class="headerlink" title="2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/">2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）</a></h1><p>主要是最后计算乘法超时了 乘法不需要再额外循环来计算 可以直接在 BFS循环里面算出前缀和  然后相乘  求得两两相乘的和</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countPairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">i</span>):<br>            q.append(i)<br>            s = <span class="hljs-number">1</span><br>            vis[i] = <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">while</span> q:<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[y]:<br>                        vis[y] = <span class="hljs-number">1</span><br>                        s += <span class="hljs-number">1</span><br>                        q.append(y)<br>            <span class="hljs-keyword">return</span> s<br>            <br>                    <br><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> (a, b) <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        vis = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        total = ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                size = bfs(i)<br>                ret += size * total<br>                total += size<br>        <span class="hljs-keyword">return</span> ret<br><br>        <br></code></pre></td></tr></table></figure><h1 id="1402-做菜顺序-力扣（LeetCode）"><a href="#1402-做菜顺序-力扣（LeetCode）" class="headerlink" title="1402. 做菜顺序 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reducing-dishes/description/">1402. 做菜顺序 - 力扣（LeetCode）</a></h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>每次有选和不选这道菜两种  用dp[i] [j] 表示前i道菜种选了j道菜  达到的最大值</p><p>当i &#x3D;&#x3D; j的时候必须选第i道菜</p><p>其他时候 就比较不选这道菜 dp[i - 1] [j]  和选这道菜dp[i -1 ] [j -1 ] + sa[i - 1] * j   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> dp[<span class="hljs-number">550</span>][<span class="hljs-number">550</span>];<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>public:<br>    <span class="hljs-built_in">int</span> maxSatisfaction(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; satisfaction) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">550</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">550</span>; j++)<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> n = satisfaction.size();<br>        sort(satisfaction.begin(), satisfaction.end());<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = satisfaction[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(i==j) <br>                        dp[i][j]= dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j);<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[n][i]);<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><em>s</em>1+2<em>s</em>0&gt;<em>s</em>0即<em>s</em>1+<em>s</em>0&gt;0</p><p><em>s</em>2+2<em>s</em>1+3<em>s</em>0&gt;<em>s</em>1+2<em>s</em>0即<em>s</em>2+<em>s</em>1+<em>s</em>0&gt;0</p><p>因此只需要反向遍历  找到前面加起来大于0的部分 的和就是最大的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">sa.sort(key=<span class="hljs-keyword">lambda</span> x:-x)<br>        s = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> sa:<br>            <span class="hljs-keyword">if</span> s + c &gt; <span class="hljs-number">0</span>:<br>                s += c<br>                ret += s<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="力扣（LeetCode）官网-全球极客挚爱的技术成长平台"><a href="#力扣（LeetCode）官网-全球极客挚爱的技术成长平台" class="headerlink" title="力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台"></a><a href="https://leetcode.cn/problems/h-index/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></h1><p>至少有h篇论文有h引的次数 </p><p>排序之后 二分下标mid   有 citation[mid] 引的文章有n - mid篇  只要引用次数大于文章数  比如8引的文章有两篇 （此时h &#x3D; 2）说明要往前找 有没有更多文章      如果3引的文章有5篇（此时h &#x3D; 3）说明要往后找有没有更大的引用数 </p><p>最后二分得到的答案是最多引的最多文章数的   下标  比如 0 2 8 8 8 8 mid &#x3D; 2</p><p>所以返回答案应该是n – mid</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hIndex</span>(<span class="hljs-params">self, citations: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        citations.sort()<br>        n = <span class="hljs-built_in">len</span>(citations)<br>        l, r = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> citations[-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">mid</span>):<br>            <span class="hljs-keyword">if</span> citations[mid] &gt;= n - mid:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l &lt;= r:<br>            mid = (l + r) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> check(mid):<br>                l = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <br>                r = mid - <span class="hljs-number">1</span><br>                ret = mid<br>        <span class="hljs-keyword">return</span> n - ret<br></code></pre></td></tr></table></figure><h1 id="2003-每棵子树内缺失的最小基因值-力扣（LeetCode）"><a href="#2003-每棵子树内缺失的最小基因值-力扣（LeetCode）" class="headerlink" title="2003. 每棵子树内缺失的最小基因值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/">2003. 每棵子树内缺失的最小基因值 - 力扣（LeetCode）</a></h1><p>只要nums中没有1  那么直接返回1   所有的最小缺失值都是1</p><p>那么同理 只要一棵子树中没有1 那么这颗子树上的所有点的缺失值都是1</p><p>于是用一次dfs找出1 的位置 找到1 之后 从根到1 的这条链上 所有点的缺失值要重新计算  而其他链上的缺失值全部为1</p><p>计算根到 1 的这条链的缺失值  应该自底向上来找 由于缺失值是单调不减的 可以维护一个缺失值now 一旦now已经访问过 那就直接让now++ 直到最小的未访问的值</p><p>到底之后开始向上寻找 注意 链上的每个结点都有自己的子树 缺失值要在整棵子树上寻找 于是到达一个结点 要先访问所有的非链上的所有结点 把所有值做标记  最终把最小缺失值赋值给i</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestMissingValueSubtree</span>(<span class="hljs-params">self, parents: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            g[parents[i]].append(i)<br>        visit = [<span class="hljs-literal">False</span>] * <span class="hljs-number">100010</span><br>        has1 = [<span class="hljs-literal">False</span>] * <span class="hljs-number">100010</span><br>        ans = [<span class="hljs-number">0</span>] * n<br>        now = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs1</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">1</span>:<br>                has1[i] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                has1[i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> g[i]:<br>                dfs1(f)<br>                has1[i] |= has1[f]<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[i]:<br>                ans[i] = <span class="hljs-number">1</span><br><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs3</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                dfs3(j)<br>            visit[nums[i]] = <span class="hljs-literal">True</span><br>                <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs2</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">nonlocal</span> now<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[i]:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                <span class="hljs-keyword">if</span> has1[j]:<br>                    dfs2(j)<br>            <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[j]:<br>                    dfs3(j)<br>            visit[nums[i]] = <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">while</span> visit[now]:<br>                now += <span class="hljs-number">1</span><br>            ans[i] = now<br>        <br>        dfs1(<span class="hljs-number">0</span>)<br>        dfs2(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）"><a href="#117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a></h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>关键在于 s &#x3D; len(q) 直接取出当前层的结点数  然后通过for循环来遍历</p><h2 id="层序-链表"><a href="#层序-链表" class="headerlink" title="层序+链表"></a>层序+链表</h2><p>遍历当前层的时候 连接下一层的结点 </p><p>设置哨兵结点 遍历完当前层之后从哨兵结点开始下一层遍历</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.left = left</span><br><span class="hljs-string">        self.right = right</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-string">&quot;&quot;&quot;q = deque([root])</span><br><span class="hljs-string">        while q:</span><br><span class="hljs-string">            s = len(q)</span><br><span class="hljs-string">            pre = None</span><br><span class="hljs-string">            for i in range(s):</span><br><span class="hljs-string">                x = q.popleft()</span><br><span class="hljs-string">                if pre:</span><br><span class="hljs-string">                    pre.next = x</span><br><span class="hljs-string">                pre = x</span><br><span class="hljs-string">                if x.left:</span><br><span class="hljs-string">                    q.append(x.left)</span><br><span class="hljs-string">                if x.right:</span><br><span class="hljs-string">                    q.append(x.right)</span><br><span class="hljs-string">                </span><br><span class="hljs-string">        return root&quot;&quot;&quot;</span><br>        cur = root<br>        <span class="hljs-keyword">while</span> cur:<br>            dummy = Node()<br>            pre = dummy<br>            <span class="hljs-keyword">while</span> cur:<br>                <span class="hljs-keyword">if</span> cur.left:<br>                    pre.<span class="hljs-built_in">next</span> = cur.left<br>                    pre = pre.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">if</span> cur.right:<br>                    pre.<span class="hljs-built_in">next</span> = cur.right<br>                    pre = pre.<span class="hljs-built_in">next</span><br>                cur = cur.<span class="hljs-built_in">next</span><br>            cur = dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> root<br>        <br></code></pre></td></tr></table></figure><h1 id="318-最大单词长度乘积-力扣（LeetCode）"><a href="#318-最大单词长度乘积-力扣（LeetCode）" class="headerlink" title="318. 最大单词长度乘积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/description/">318. 最大单词长度乘积 - 力扣（LeetCode）</a></h1><h2 id="哈希-位运算"><a href="#哈希-位运算" class="headerlink" title="哈希-&gt;位运算"></a>哈希-&gt;位运算</h2><p>一开始想到用哈希表存储 每个单词中 每个字母是否出现 即用列表存储哈希表 但是这样时间复杂度太高 每次查重的时候都需要遍历前i个单词的每个字母</p><p>可以用位运算优化 26个单词对应26个bit位 每次查重只需要 做<strong>与运算</strong>就可以判断是否有重复的单词 </p><p>（前面单词的长度 为len(word[j]) 因为是for j in range(i)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        sc = []<br>        maxret = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            mask = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> words[i]:<br>                mask |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>            sc.append(mask)<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> mask &amp; sc[j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(words[j]) * <span class="hljs-built_in">len</span>(words[i]) &gt; maxret:<br>                    maxret = <span class="hljs-built_in">len</span>(words[j]) * <span class="hljs-built_in">len</span>(words[i])<br>        <span class="hljs-keyword">return</span> maxret<br></code></pre></td></tr></table></figure><h2 id="位运算-哈希"><a href="#位运算-哈希" class="headerlink" title="位运算+哈希"></a>位运算+哈希</h2><p>哈希表不止能放1 然后判断是否出现啊  可以放每个单词的长度</p><p>如果两个单词相同的话 就是对应的位运算值相同 也就是mask相同  那么只需要取最大的长度就可以了 即保证哈希表中存放的都是这个单词最大的长度 可以减少重复的循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mp = <span class="hljs-built_in">dict</span>()<br>        maxret = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            mask = <span class="hljs-number">0</span><br>            l = <span class="hljs-built_in">len</span>(words[i])<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> words[i]:<br>                mask |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>            <span class="hljs-keyword">if</span> mask <span class="hljs-keyword">in</span> mp <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(words[i]) &gt; mp[mask]:<br>                mp[mask] = l<br>            <span class="hljs-keyword">elif</span> mask <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> mp:<br>                mp[mask] = l<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> m, v <span class="hljs-keyword">in</span> mp.items():<br>                <span class="hljs-keyword">if</span> mask &amp; m == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> v * l &gt; maxret:<br>                    maxret = v * l<br>        <span class="hljs-keyword">return</span> maxret<br></code></pre></td></tr></table></figure><h1 id="2258-逃离火灾-力扣（LeetCode）"><a href="#2258-逃离火灾-力扣（LeetCode）" class="headerlink" title="2258. 逃离火灾 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/escape-the-spreading-fire/?envType=daily-question&envId=2023-11-09">2258. 逃离火灾 - 力扣（LeetCode）</a></h1><p>其实类似于脑筋急转弯 最后分类完只需要看 人是不是比火先到达安全屋即可</p><ul><li>人能到安全屋</li><li><ul><li>火不能到安全屋10**9</li><li>火能到安全屋</li><li><ul><li>火比人先到 -1</li><li><ul><li>火能不能在中途烧到人？ 不可能 因为火如果在中途烧到人 那么火就可以沿着 人的这条路走到安全屋 那么火一定是比人先到的</li></ul></li><li>火比人后到 t</li></ul></li></ul></li><li>人不能到安全屋 -1</li></ul><p>最后再看  火如果烧到了安全屋的上和左两格  那就把路封死了 即人和火同时到这两格 是不行的 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">q: <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]</span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            d = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> q:<br>                d[i][j] = <span class="hljs-number">0</span><br>            ti = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> q:<br>                t = q<br>                q = []<br>                <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> t:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                        ni, nj = i + dx[k], j+ dy[k]<br>                        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[ni][nj] &lt; <span class="hljs-number">0</span>:<br>                            d[ni][nj] = ti<br>                            q.append((ni, nj))<br>                ti += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> [d[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>], d[-<span class="hljs-number">1</span>][-<span class="hljs-number">2</span>], d[-<span class="hljs-number">2</span>][-<span class="hljs-number">1</span>]]<br>        <br>        man, m1, m2 = bfs([(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)])<br>        <span class="hljs-keyword">if</span> man &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        fire_pos = [(i, j) <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(grid) <span class="hljs-keyword">for</span> j, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row) <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>]<br>        fire, f1, f2 = bfs(fire_pos)<br>        <span class="hljs-keyword">if</span> fire &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> ** <span class="hljs-number">9</span><br>        <br>        d = fire - man<br>        <span class="hljs-keyword">if</span> d &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> m1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> m1 + d &lt; f1 <span class="hljs-keyword">or</span> m2 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> m2 + d &lt; f2:<br>            <span class="hljs-keyword">return</span> d<br>        <span class="hljs-keyword">return</span> d - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="Problem-1169B-Codeforces"><a href="#Problem-1169B-Codeforces" class="headerlink" title="Problem - 1169B - Codeforces"></a><a href="https://codeforces.com/problemset/problem/1169/B">Problem - 1169B - Codeforces</a></h1><p>思考题 乍一看很难  但是其实很简单 </p><p>找是否有两个数 x y 使得每个数对至少有一个x 或y</p><p>那我们就用第一个数对的两个数 这两个数 必定有一个是x </p><p>但是不知道哪个是  于是枚举</p><p>假设a[0] 是x  到所有的数对中找 是否都含了a[0] 如果不含 那么这个数对中  的a[i] b[i] 必定有一个数 是y 然后再用x y 到后面的每个数组中找 如果有不含x y 的就是NO 否则为YES  实现的话这里可以从0到m 找到就++ 看最后是不是m个  </p><p>注意 不要用+&#x3D;i 最后算 (m - 1) * m &#x2F; 2 会爆int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//这段代码还可以优化就是说...</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span>, <span class="hljs-title">b</span><span class="hljs-params">(N)</span>, <span class="hljs-title">ca</span><span class="hljs-params">(N)</span>, <span class="hljs-title">cb</span><span class="hljs-params">(N)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>, q = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            p = a[i];<br>            q = b[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> va = <span class="hljs-number">0</span>, vb = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x || a[i] == p || b[i] == p)<br>            va++;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x || a[i] == q || b[i] == q)<br>            vb++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (va == m || vb == m)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(a[<span class="hljs-number">0</span>]) || <span class="hljs-built_in">check</span>(b[<span class="hljs-number">0</span>]))<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="1457-二叉树中的伪回文路径-力扣（LeetCode）"><a href="#1457-二叉树中的伪回文路径-力扣（LeetCode）" class="headerlink" title="1457. 二叉树中的伪回文路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/">1457. 二叉树中的伪回文路径 - 力扣（LeetCode）</a></h1><h2 id="朴素1"><a href="#朴素1" class="headerlink" title="朴素1"></a>朴素1</h2><p>主要问题在于判断叶子结点  直接写root is None： 可能会出现 某结点只有一个孩子  也进入判断的情况 （这肯定不是叶子）</p><p>所以要改成左右都为空才是叶子  相应的 cnt计数的操作也需要变化</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        cnt = [<span class="hljs-number">0</span>] * <span class="hljs-number">11</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> res, cnt<br>            <br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cnt[root.val] += <span class="hljs-number">1</span><br>                odd = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>                    <span class="hljs-built_in">print</span>(cnt[i],end=<span class="hljs-string">&#x27;&#x27;</span>)<br>                    <span class="hljs-keyword">if</span> cnt[i] % <span class="hljs-number">2</span>:<br>                        odd += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>()<br>                <span class="hljs-keyword">if</span> odd &lt;= <span class="hljs-number">1</span>:<br>                    res += <span class="hljs-number">1</span><br>                cnt[root.val] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span><br>            cnt[root.val] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> root.left:<br>                dfs(root.left)<br>            <span class="hljs-keyword">if</span> root.right:<br>                dfs(root.right)<br>            cnt[root.val] -= <span class="hljs-number">1</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="朴素2"><a href="#朴素2" class="headerlink" title="朴素2"></a>朴素2</h2><p>这个是 res作为返回值的 要注意 res 什么时候是直接return  什么时候是res +&#x3D;   什么时候是 res &#x3D;</p><p>然后是这个 用了一个 root is None 判空  空 就不用加</p><p>再用一个 if root.left is root.right 判叶子 是叶子就看能不能加1  不是叶子就继续递归 注意不是return</p><p>还有 不需要记录cnt 的值 然后去数  只需要记录cnt 的奇偶就可以了 （由此导出位运算</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = [<span class="hljs-number">0</span>] * <span class="hljs-number">10</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            cnt[root.val] ^= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> root.right:<br>                res = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(cnt) &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                res = dfs(root.left) + dfs(root.right)<br>             <br>            cnt[root.val] ^= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>既然只需要看每一位的奇偶  那也不用数组了  直接用一个数 的每一位 来异或就可以</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        mask = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> mask<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            mask ^= <span class="hljs-number">1</span> &lt;&lt; root.val<br><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> root.right:<br>                res = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> mask &amp; (mask - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                res = dfs(root.left) + dfs(root.right)<br><br>            mask ^= <span class="hljs-number">1</span> &lt;&lt; root.val             <br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h1 id="1038-从二叉搜索树到更大和树-力扣（LeetCode）"><a href="#1038-从二叉搜索树到更大和树-力扣（LeetCode）" class="headerlink" title="1038. 从二叉搜索树到更大和树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树 - 力扣（LeetCode）</a></h1><p>从右往左遍历 可以达到一次遍历的效果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    su = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bstToGst</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.bstToGst(root.right)<br>        self.su += root.val<br>        root.val = self.su<br>        self.bstToGst(root.left)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h1 id="0最少刷题数-蓝桥云课-lanqiao-cn"><a href="#0最少刷题数-蓝桥云课-lanqiao-cn" class="headerlink" title="0最少刷题数 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2143/learning/">0最少刷题数 - 蓝桥云课 (lanqiao.cn)</a></h1><p>求中间的数 因为有重复数字  就需要用计数的方法 遍历 而不能用数学方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> ret[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>        ret[i] = nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums + <span class="hljs-number">1</span>, nums + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; ans == <span class="hljs-number">-1</span>; )<br>    &#123;<br>        j = i++;<br>        <span class="hljs-keyword">while</span> (i &lt;= n &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])i++;<br>        <span class="hljs-type">int</span> l = j - <span class="hljs-number">1</span>, r = n - i + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt; &quot; &quot;&lt;&lt;nums[j]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (l &gt; r)ans = nums[j];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &lt; r)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> ans = nums[j] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;ans&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ret[i] &lt; nums[j])x = ans - ret[i];<br>        cout&lt;&lt; x &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="0矩形拼接-蓝桥云课-lanqiao-cn"><a href="#0矩形拼接-蓝桥云课-lanqiao-cn" class="headerlink" title="0矩形拼接 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2154/learning/">0矩形拼接 - 蓝桥云课 (lanqiao.cn)</a></h1><p>枚举 先选3个矩形的顺序  再选每个矩形的边的顺序</p><p>枚举就是要达到 每个图形的每条边 都可以直接表示出来 比如a[i] [ii] 这样 而且比如第二个if （if (a[i] [ii] &#x3D;&#x3D; a[j] [jj] + a[k] [kk])）这里只用写一个 而**不需要写a[j] [jj] &#x3D; a[i] [ii] + a[k] [kk] ** 因为循环会枚举到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>    cin&gt;&gt;a[i][j];<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>    <span class="hljs-keyword">if</span> (i != j)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++)<br>    <span class="hljs-keyword">if</span> (i != k &amp;&amp; j != k)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">2</span>; ii++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">0</span>; jj &lt; <span class="hljs-number">2</span>; jj++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> kk = <span class="hljs-number">0</span>; kk &lt; <span class="hljs-number">2</span>; kk++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i][ii] == a[j][jj] || a[i][ii] == a[k][kk])<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">if</span> (a[j][jj] == a[k][kk])<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">4</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[i][ii] == a[j][jj] + a[k][kk])<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">if</span> (a[j][<span class="hljs-number">1</span> - jj] == a[k][<span class="hljs-number">1</span> - kk])<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">4</span>);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1405-最长快乐字符串-力扣（LeetCode）"><a href="#1405-最长快乐字符串-力扣（LeetCode）" class="headerlink" title="1405. 最长快乐字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-happy-string/description/">1405. 最长快乐字符串 - 力扣（LeetCode）</a></h1><p>思路很好想 就是先放多的 再放少的 但是具体的实现比较困难</p><p>由于只有三个数 不用优先队列 可以直接用排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; PII;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestDiverseString</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        vector&lt;PII&gt;arr = &#123;&#123;a, <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="hljs-string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="hljs-string">&#x27;c&#x27;</span>&#125;&#125;;<br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), [&amp;](PII a, PII b)&#123;a.first &gt; b.first;&#125;);<br>            <span class="hljs-type">bool</span> hasNext = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[n, c]: arr)<br>            &#123;<br>                <span class="hljs-type">int</span> len = ans.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">2</span> &amp;&amp; ans[len - <span class="hljs-number">1</span>] == c &amp;&amp; ans[len - <span class="hljs-number">2</span>] == c)<br>                    <span class="hljs-keyword">continue</span>;<br>                hasNext = <span class="hljs-literal">true</span>;<br>                ans += c;<br>                n--;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!hasNext)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA</title>
    <link href="/2023/08/22/LCA/"/>
    <url>/2023/08/22/LCA/</url>
    
    <content type="html"><![CDATA[<h1 id="最近公共祖先-数组"><a href="#最近公共祖先-数组" class="headerlink" title="最近公共祖先 数组"></a>最近公共祖先 数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python">root = <span class="hljs-number">1</span><br>num = <span class="hljs-number">0</span><br>dep = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000010</span><br>f = [[<span class="hljs-number">0</span>] * <span class="hljs-number">21</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br>head = [-<span class="hljs-number">1</span>] * <span class="hljs-number">10000010</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, to, <span class="hljs-built_in">next</span></span>):<br>self.to = to<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addedge</span>(<span class="hljs-params">from_,to</span>):<br><span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    e[num] = Edge(to, head[from_])<br>    head[from_] = num<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">v, father</span>):<br>dep[v] = dep[father] + <span class="hljs-number">1</span><br>    f[v][<span class="hljs-number">0</span>] = father<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):<br>        f[v][i] = f[f[v][i-<span class="hljs-number">1</span>]][i-<span class="hljs-number">1</span>]<br>        <br>    i = head[v]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        p1 = e[i].to<br>        <span class="hljs-keyword">if</span> p1 == father:<br>            i = e[i].<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        dfs(p1,v)<br>        i = e[i].<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-keyword">if</span> dep[x] &lt; dep[y]:<br>        x, y = y, x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dep[f[x][i]] &gt;= dep[y]:<br>            x = f[x][i]<br>         <span class="hljs-keyword">if</span> x == y:<br><span class="hljs-keyword">return</span> x<br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> f[x][i] != f[y][i]:<br>            x = f[x][i]<br>            y = f[y][i]<br>            <br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]<br><br><br>n, m, root = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>e = [Edge(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    addedge(u, v)<br>    addedge(v, u)<br><br><span class="hljs-comment"># 建立 LCA 预处理</span><br>dfs(root, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 查询 LCA</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    result = lca(x, y)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[x] = father;<br>de[x] = de[father] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i; i = edge[i].next)<br>&#123;<br><span class="hljs-keyword">if</span> (edge[i].to != father)<br>&#123;<br><span class="hljs-built_in">dfs</span>(edge[i].to, x);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (x != y)<br>&#123;<br><span class="hljs-keyword">if</span> (de[x] &gt;= de[y])<br>&#123;<br>x = fa[x];<br>&#125;<br><span class="hljs-keyword">else</span><br>y = fa[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="当是链表形式的时候-较为简单"><a href="#当是链表形式的时候-较为简单" class="headerlink" title="当是链表形式的时候 较为简单"></a>当是链表形式的时候 较为简单</h1><h2 id="236-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#236-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="236. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        <br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; right)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> left ? left : right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2096-从二叉树一个节点到另一个节点每一步的方向-力扣（LeetCode）"><a href="#2096-从二叉树一个节点到另一个节点每一步的方向-力扣（LeetCode）" class="headerlink" title="2096. 从二叉树一个节点到另一个节点每一步的方向 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description/">2096. 从二叉树一个节点到另一个节点每一步的方向 - 力扣（LeetCode）</a></h2><p>从st到end的路程中 必定会经过两个点的最近公共祖先 </p><p>1如果两个点没关系  那就先上升到最近公共祖先再下降</p><p>2如果st是end的父节点 那么st就是lca </p><p>3如果st是end的子节点 那么end就是lca</p><p>所以必定经过lca</p><p>再思考 从st到lca到end 是怎样的路程  首先不断上升 再下降</p><p>上升可以反过来想 从lca下降到st 再把路程中的L R换成U</p><p>所以就需要dfs 求出lca到st 和end的路程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lca</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> destValue)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root-&gt;val == startValue || root-&gt;val == destValue)<br>        <span class="hljs-keyword">return</span> root;<br><br>        TreeNode *left = <span class="hljs-built_in">lca</span>(root-&gt;left, startValue, destValue);<br>        TreeNode *right = <span class="hljs-built_in">lca</span>(root-&gt;right, startValue, destValue);<br><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> left ? left : right;<br>    &#125;<br>    string res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> t, string&amp; path)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val == t)<br>        &#123;<br>            res = path;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;left)<br>        &#123;<br>            path += <span class="hljs-string">&#x27;L&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(cur-&gt;left, t, path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right)<br>        &#123;<br>            path += <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(cur-&gt;right, t, path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">getDirections</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> destValue)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        TreeNode* newroot = <span class="hljs-built_in">lca</span>(root, startValue, destValue);<br><br>        string path = <span class="hljs-string">&quot;&quot;</span>;<br>        res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(newroot, startValue, path);<br>        <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-string">&#x27;U&#x27;</span>)</span></span>;<br>        res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(newroot, destValue, path);<br>        ans += res;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lca</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论相关算法</title>
    <link href="/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> to, w;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;Edge&gt; edges[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    Edge e = &#123;to, w&#125;;<br>    edges[from].<span class="hljs-built_in">push_back</span>(e);<br>&#125;<br><span class="hljs-comment">// 无向图调用两次add即可</span><br><span class="hljs-comment">// vector的size方法可以返回其包含的元素个数 用于遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>(); i++);<br><span class="hljs-comment">//或者range-base for</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;e: edges[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> to, w, next;<br>&#125;;<br><span class="hljs-type">int</span> head[MAXN], cnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    edges[++cnt].w = w; <span class="hljs-comment">// 新增一条边为cnt + 1的边 边权w</span><br>    edges[cnt].to = to; <span class="hljs-comment">// 该边的终点为to</span><br>    edges[cnt].next = head[from]; <span class="hljs-comment">// 把下一条边 设置为当前起点的第一条边</span><br>    head[from] = cnt;<br>    <span class="hljs-comment">// 最后两步相当于一个头插 会把新元素插到最前面而不是最后面 </span><br>&#125;<br><br><span class="hljs-comment">// 遍历结束的标志为 edges[i].next = 0 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[<span class="hljs-number">2</span>]; e != <span class="hljs-number">0</span>; e = edges[e].next);<br><br></code></pre></td></tr></table></figure><p>感谢金牌✌[pecco的学习笔记](<a href="https://zhuanlan.zhihu.com/p/105467597">算法学习笔记（目录） - 知乎 (zhihu.com)</a>)</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>单源点最短路，不可判负权和环</p><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>cnt = <span class="hljs-number">0</span><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>ans = [INF] * (n + <span class="hljs-number">1</span>)<br>vis = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>edge = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>edge[i] = INF<br><br><span class="hljs-comment"># 初始化到s点的距离为0</span><br>ans[s] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 重边取最小</span><br>    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">in</span> edge:<br>edge[a][b] = <span class="hljs-built_in">min</span>(edge[a].get(b, INF), c)<br>    <span class="hljs-keyword">else</span>:<br>        edge[a] = &#123;b:c&#125;<br>pos = s<br><br><span class="hljs-comment"># pos 未遍历时</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vis[pos]:<br>    minn = INF<br>    <span class="hljs-comment"># 标记</span><br>    vis[pos] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># pos 顶点在边上时</span><br>    <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> edge:<br>        <span class="hljs-comment"># 取pos顶点指向的顶点（设为终点（有向图））和权值</span><br>        <span class="hljs-keyword">for</span> to, wei <span class="hljs-keyword">in</span> edge[pos].items():<br><span class="hljs-comment"># 如果终点未访问并且终点的值大于pos+wei 那就更新终点值的最短路</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[to] <span class="hljs-keyword">and</span> ans[to] &gt; ans[pos] + wei:<br>                ans[to] = ans[pos] + wei<br>        <span class="hljs-comment"># 遍历所有未遍历的点  如果小于minn 就更新minn（最短路） 并且让pos = i（最短子路）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i] <span class="hljs-keyword">and</span> ans[i] &lt; minn:<br>                minn = ans[i]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-comment"># 邻接矩阵</span><br>graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    graph[u].append((v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br><span class="hljs-comment"># 距离 初始化为无穷  源点初始化为0</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><span class="hljs-comment"># 先放入源点 第一个参数d表示源点s到当前结点的最短路   第二个参数node表示当前节点编号</span><br>q = [(<span class="hljs-number">0</span>,s)]<br><span class="hljs-comment"># 队列不空的时候</span><br><span class="hljs-keyword">while</span> q:<br><span class="hljs-comment"># 取出源点和起点</span><br>    d, node = heapq.heappop(q)<br>    <span class="hljs-comment"># 当当前最短路小于源点到node的距离时 跳过</span><br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br><span class="hljs-keyword">continue</span><br>    <span class="hljs-comment"># 从图中取出node结点的终点和权值</span><br>    <span class="hljs-keyword">for</span> neighbor, wei <span class="hljs-keyword">in</span> graph[node]:<br><span class="hljs-keyword">if</span> dist[node] + wei &lt; dist[neighbor]:<br>dist[neighbor] = dist[node] + wei<br>             heapq.heappush(q,(dist[neighbor],neighbor))<br>                <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br>    <span class="hljs-type">int</span> dist, id;<br>    <span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dist, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">dist</span>(dist), <span class="hljs-built_in">id</span>(id)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.dist &gt; b.dist; <span class="hljs-comment">//这里是大于 使得距离短的先出队</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[s] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(<span class="hljs-number">0</span>, s));<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[p])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[p] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edge[e].next)<br>        &#123;<br>            <span class="hljs-type">int</span> to = edges[e].to;<br>            dist[to] = <span class="hljs-built_in">min</span>(dist[to], dist[p] + edges[e].w);<br>            <span class="hljs-keyword">if</span> (!vis[to])<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(dist[to], to));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>edge = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 判重</span><br>    exist = <span class="hljs-literal">False</span><br>    i = head[u]<br>    <span class="hljs-keyword">while</span> i:<br>        <span class="hljs-keyword">if</span> edge[i][<span class="hljs-number">0</span>] == v:<br>            exist = <span class="hljs-literal">True</span><br>            edge[i] = (v, <span class="hljs-built_in">min</span>(edge[i][<span class="hljs-number">1</span>],w), edge[i][<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">break</span><br>        i = edge[i][<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:<br>        edge.append((v,w,head[u]))<br>        head[u] = <span class="hljs-built_in">len</span>(edge) - <span class="hljs-number">1</span><br><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>priority_queue = [(<span class="hljs-number">0</span>,s)]<br><br><span class="hljs-keyword">while</span> priority_queue:<br>    d,node = heapq.heappop(priority_queue)<br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br>        <span class="hljs-keyword">continue</span><br>    i = head[node]<br>    <span class="hljs-keyword">while</span> i:<br>        neighbor, weight, nextt = edge[i]<br>        <span class="hljs-keyword">if</span> dist[node] + weight &lt; dist[neighbor]:<br>            dist[neighbor] = dist[node] + weight<br>            heapq.heappush(priority_queue, (dist[neighbor],neighbor))<br>        i = nextt<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h2><p>一般用链式前向星或者 邻接表存图 用结构体存结点</p><p>首先除起点外所有顶点到起点的距离dis数组初始化为无穷大</p><p>遍历每条边 对每条边的两个顶点进行松弛操作 直到不能再松弛</p><p>判断负环 如果迭代超过n - 1次还能继续松弛则说明存在负环</p><p>每次迭代k如果进行了松弛操作 则一定是经历了k条边的最短路</p><p>一共是n个顶点 如果不存在负环 某点到另一个点最多只有n - 1条边 </p><p>如果迭代k后没有点进行松弛操作 则代表已经找出了所有的最短路 迭代结束跳出循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, w;<br>&#125;;<br>vector&lt;vector&lt;edge&gt;&gt;<span class="hljs-built_in">e</span>(MAXN);<br><span class="hljs-type">int</span> dis[MAXN];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellman</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dis[u] == inf)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : e[u])<br>            &#123;<br>                <span class="hljs-type">int</span> v = x.v, w = x.w;<br>                <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w)<br>                &#123;<br>                    dis[v] = dis[u] + w;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p>单源点最短路，可判负权和环</p><p>“只更新可能更新的点”：</p><p>只让当前点能到达的点入队 </p><p>如果一个点已经在队列中 不重复入队 </p><p>如果u一条边未更新 那么他的终点不入队</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v, w</span>):<br>        self.v = v<br>        self.w = w<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br><br>graph = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> graph[u] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> graph[u].w &gt; w:<br>graph[u] = []<br>    graph[u].append(edge(v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>q = deque([s])<br><br><span class="hljs-comment"># 标记是否在队列中  以及计数 用来判断环</span><br>in_queue = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>in_queue[s] = <span class="hljs-literal">True</span><br>enqueue_count = [<span class="hljs-number">0</span>]  * (n + <span class="hljs-number">1</span>)<br>enqueue_count[s] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">while</span> q:<br>    <span class="hljs-comment"># 取出当前点 </span><br>    node = q.popleft()<br>    in_queue[node] = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 取当前点相连的所有边</span><br>    <span class="hljs-keyword">for</span> ed <span class="hljs-keyword">in</span> graph[node]:<br>        <span class="hljs-comment"># 取出终点和权值</span><br>        v, w = ed.v, ed.w<br>    <span class="hljs-keyword">if</span> dist[v] &gt;  dist[node] + w:<br>            dist[v] = dist[node] + w<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> in_queue[v]:<br>                q.append(v)<br>                in_queue[v] = <span class="hljs-literal">True</span><br>                enqueue_count[v] += <span class="hljs-number">1</span><br>                <br>                <span class="hljs-keyword">if</span> enqueue_count[v] &gt; n:<br>                    exit(<span class="hljs-number">0</span>)<br>                    <br></code></pre></td></tr></table></figure><h3 id="C-版-1"><a href="#C-版-1" class="headerlink" title="C++版"></a>C++版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        inqueue[p] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edges[e].next)<br>        &#123;<br>            <span class="hljs-type">int</span> to = edges[e].to;<br>            <span class="hljs-keyword">if</span> (dist[to] &gt; dist[p] + edges[e].w)<br>            &#123;<br>                pre[to] = p; <span class="hljs-comment">// 存储路径 </span><br>                dist[to] = dist[p] + edges[e].w;<br>                <span class="hljs-keyword">if</span> (!inqueue[to])<br>                &#123;<br>                    inqueue[to] = <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(to);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>多源最短路</p><p>看是否可以是否可以通过k 来更新i到j的最短路 所以k在最外层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x3f3f3f3f</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>d = [[INF] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][i] = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], w)<br>    <span class="hljs-comment"># 同时要更新另一条边</span><br>    d[b][a] = <span class="hljs-built_in">min</span>(d[b][a], w)<br>    <br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k] + d[k][j])<br>            <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(d[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="Kahn"><a href="#Kahn" class="headerlink" title="Kahn"></a>Kahn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Kahn算法</span><br><span class="hljs-keyword">from</span> collection <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = []<br>din = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-comment"># 每次从队列取出 让他所有出边减一 当某点入度为0时加入队列  如果最后队列长n则有拓扑序 否则有环</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>(<span class="hljs-params">n</span>):<br>queue = deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> din[i] == <span class="hljs-number">0</span>:<br>queue.append(i)<br>    <span class="hljs-keyword">while</span> queue:<br>        x = queue.popleft()<br>        tp.append(x)<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>            din[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> din[y] == <span class="hljs-number">0</span>:<br>queue.append(y)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp) == n<br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    e[a].append(b)<br>    din[b] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> toposort(n):<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tp:<br><span class="hljs-built_in">print</span>(x,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = [<span class="hljs-number">0</span>] * N<br>c = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> tp<br>    c[x] = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>        <span class="hljs-keyword">if</span> c[y] &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> c[y]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(y):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    c[x] = <span class="hljs-number">1</span><br>    tp.append(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>():<br>    <span class="hljs-keyword">global</span> c, tp<br>    c = [<span class="hljs-number">0</span>] * N<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c[i]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    tp.reverse()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入为字典</span><br>activities = &#123;&#125;<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    name, duration, dependencies = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    activities[name] = &#123;<span class="hljs-string">&#x27;duration&#x27;</span>:duration, <span class="hljs-string">&#x27;dependencies&#x27;</span>:dependencies&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_early_late_times</span>(<span class="hljs-params">activities</span>):<br>    <span class="hljs-comment"># 初始化每个工作的最早开始时间和最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-comment"># 计算最早开始时间</span><br>    <span class="hljs-comment"># 遍历所有工作 如果依赖于前一项工作 就为前面所有工作的最早开始时间加上持续时间的最大值 如果没有依赖于其他工作则为0</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            max_dependency_end = <span class="hljs-built_in">max</span>([activities[dep][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[dep][<span class="hljs-string">&#x27;duration&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = max_dependency_end<br><br>    <span class="hljs-comment"># 计算最后完成的工作的最晚开始时间 为所有工作的最晚的（最早开始时间+持续时间）</span><br>    end_activity = <span class="hljs-built_in">max</span>(activities,key=<span class="hljs-keyword">lambda</span> activity: activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>])<br>    activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[end_activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>    <span class="hljs-comment"># 反向计算最晚开始时间</span><br>    <span class="hljs-comment"># 如果不依赖于其他工作 最晚开始时间为最后工作的最晚开始时间-持续时间  否则为最早的最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">list</span>(activities.key())):<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] - activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            min_dependency_start = <span class="hljs-built_in">min</span>([activities[dep][<span class="hljs-string">&#x27;LS&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = min_dependency_start<br><br><br><span class="hljs-comment"># 最早开始时间=最晚开始时间即为关键路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_critical_path</span>(<span class="hljs-params">activities</span>):<br>    critical_path = []<br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        <span class="hljs-keyword">if</span> activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] == activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>]:<br>            critical_path.append(activity)<br>    <span class="hljs-keyword">return</span> critical_path<br></code></pre></td></tr></table></figure><h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><p><a href="https://leetcode.cn/problems/critical-connections-in-a-network/solutions/?envType=study-plan-v2&envId=graph-theory">例题</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="朴素算法-1"><a href="#朴素算法-1" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, w;<br>&#125;;<br>vector&lt;edge&gt;e;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>    d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; d[j] &lt; d[u])u = j;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        ans += d[u];<br>        <span class="hljs-comment">// 非连通图到u距离还是无穷  判断是否连通</span><br>        <span class="hljs-keyword">if</span> (d[u] != inf) cnt ++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed: e[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = ed.v, w = ed.w;<br>            <span class="hljs-keyword">if</span> (d[v] &gt; w)d[v] = w;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化-1"><a href="#堆优化-1" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">堆的第一个元素是他的边权 仅仅用来排序 没有其他任何作用 因为在使用到边权的时候 会使用d[u] 而不会使用q.top().first</span><br><span class="hljs-comment">所以直接建大根堆 放负边权即可</span><br><span class="hljs-comment">*/</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;q;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)d[i] = inf;<br>   d[s] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[u])<span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 先取出的必小 后取出的大 直接不看了</span><br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans += d[u];<br>        cnt ++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed: e[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = ed.v, w = ed.w;<br>            <span class="hljs-keyword">if</span> (d[v] &gt; w)<br>            &#123;<br>                d[v] = w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> u, v, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> edge&amp; t)<span class="hljs-type">const</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; t.w;<br>    &#125;<br>&#125;e[N];<br><span class="hljs-type">int</span> fa[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x])<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(e, e + m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)p[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(e[i].v);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(e[i].u);<br>        <span class="hljs-keyword">if</span>(x != y)<br>        &#123;<br>            fa[x] = y;<br>            ans += e[i].w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树题解</title>
    <link href="/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1827-USACO3-4-美国血统-American-Heritage"><a href="#P1827-USACO3-4-美国血统-American-Heritage" class="headerlink" title="[P1827 USACO3.4] 美国血统 American Heritage"></a>[P1827 <a href="https://www.luogu.com.cn/problem/P1827">USACO3.4] 美国血统 American Heritage</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 其实就是前中序转后序 递归 当前序为空的时候退出，否则取前序的第一个为根，再中序中找左边为左子树，右边为右子树。注意前序中，左边的前k个就是左子树的，后面就是右子树的。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(string pre, string inor)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">char</span> root = pre[<span class="hljs-number">0</span>];<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-type">int</span> k = inor.<span class="hljs-built_in">find</span>(root);<br>string leftinor = inor.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightinor = inor.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 注意这里</span><br>string leftpre = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightpre = pre.<span class="hljs-built_in">substr</span>(k);<br><br><span class="hljs-built_in">change</span>(leftpre, leftinor);<br><span class="hljs-built_in">change</span>(rightpre, rightinor);<br><br>cout &lt;&lt; root;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string pre, inor;<br>cin &gt;&gt; inor &gt;&gt; pre;<br><span class="hljs-built_in">change</span>(pre, inor);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="449-序列化和反序列化二叉搜索树-力扣（LeetCode）"><a href="#449-序列化和反序列化二叉搜索树-力扣（LeetCode）" class="headerlink" title="449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br>    <span class="hljs-comment"># 序列化比较简单 就是一个后序遍历 注意最后的return部分 &#x27; &#x27;.join(map(str, arr)) 首先是&#x27;&#x27;要有空格 然后是map的用法 把arr转str</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            postOrder(root.left)<br>            postOrder(root.right)<br>            arr.append(root.val)<br>        postOrder(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,arr))<br>        <br><span class="hljs-comment"># 对于二叉搜索树来说 每个点的位置确定 所以比反序列化普通二叉树简单</span><br>    <span class="hljs-comment"># 首先把data还原成arr 当到达叶子节点的时候（也就是当前点不能插入这个地方）返回None    从arr中取出一个数作为跟 然后取出一个数作为右孩子 取出一个数作为左孩子 （后序遍历 先右再左）然后返回根   注意 初始的时候不限范围  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, data.split()))<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">lower,upper</span>):<br>            <span class="hljs-keyword">if</span> arr == [] <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &lt; lower <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &gt; upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            val = arr.pop()<br>            root = TreeNode(val)<br>            root.right = construct(val, upper)<br>            root.left = construct(lower,val)<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> construct(-inf,inf)<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化-力扣（LeetCode）"><a href="#297-二叉树的序列化与反序列化-力扣（LeetCode）" class="headerlink" title="297. 二叉树的序列化与反序列化 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(root.val) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.left)) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.right)) <br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">dataList</span>):<br>            val = dataList.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> val == <span class="hljs-string">&#x27;None&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            root = TreeNode(<span class="hljs-built_in">int</span>(val))<br>            root.left = dfs(dataList)<br>            root.right = dfs(dataList)<br>            <span class="hljs-keyword">return</span> root<br>        dataList = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">return</span> dfs(dataList)<br>        <br></code></pre></td></tr></table></figure><h1 id="1080-根到叶路径上的不足节点-力扣（LeetCode）"><a href="#1080-根到叶路径上的不足节点-力扣（LeetCode）" class="headerlink" title="1080. 根到叶路径上的不足节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点 - 力扣（LeetCode）</a></h1><p>很经典的二叉树  搜索问题 分为三步  1 判断根节点 2判断叶子节点 3递归左右 同时变化条件（limit）</p><p>这个题关键就是 看出来 只有左右都不满足的时候 （把左右都删掉）根才能不满足 如果左右没删除 说明有满足大于limit的 那么根必定是有大于limit的 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sufficientSubset</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> limit)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (limit &gt; <span class="hljs-number">0</span>)<br>                root = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (root-&gt;left) root-&gt;left = <span class="hljs-built_in">sufficientSubset</span>(root-&gt;left, limit - root-&gt;val);<br>        <span class="hljs-keyword">if</span> (root-&gt;right) root-&gt;right = <span class="hljs-built_in">sufficientSubset</span>(root-&gt;right, limit - root-&gt;val);<br>        <br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树</title>
    <link href="/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Splay树"><a href="#Splay树" class="headerlink" title="Splay树"></a><a href="https://www.luogu.com.cn/problem/P3369">Splay树</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, p, val;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> s[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> siz;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>cnt = siz = <span class="hljs-number">1</span>;<br>p = p1, v = v1;<br>&#125;<br>&#125;tree[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-comment">// 更新树的大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 旋转 旋转不仅使得x转到y处，x的其中一个儿子也要给y</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找到x的父节点y和y的父节点z，k判断x是否为y的右儿子 假设x为y的右儿子 k为1</span><br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = tree[y].s[<span class="hljs-number">1</span>] == x;<br><span class="hljs-comment">// 先转动使 y的右儿子处放上x的左儿子 然后让x的左儿子的父节点为y</span><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><span class="hljs-comment">// 然后使x的右儿子为y，y的父亲为x</span><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><span class="hljs-comment">// 如果z的右儿子为y 那么z的右儿子为x （x替代y） 然后x的父亲为z</span><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><span class="hljs-comment">//记得更新节点</span><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-comment">// splay 伸展结点，使x为k的儿子  k为0的时候使x为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br>        <span class="hljs-comment">// 当x的祖父结点不为k的时候 旋转</span><br><span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-comment">// y的左儿子为x 并且z的左儿子为y 也就是直线型 转动y（1^1=0） 折线型转动x</span><br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-comment">// 再转一次（双旋</span><br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br>    <span class="hljs-comment">// k为0的时候 让x为根</span><br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><span class="hljs-comment">// 查找v并让v为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 找前驱 先找到v 然后如果根的值小于v，直接返回x，因为比根大，不可能有前驱了（前驱是比）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br><span class="hljs-comment">// 根节点的左子树的最大结点就是前驱</span><br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>]) x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 找后继 同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br><br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 删除 并不是真的结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找前驱和后继</span><br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v);<br><span class="hljs-type">int</span> suc = <span class="hljs-built_in">get_suc</span>(v);<br><span class="hljs-comment">// 转动前驱到根，转动后继为前驱的儿子，就是逻辑上的删除了该结点（此时待删除结点为后继的左儿子）</span><br><span class="hljs-built_in">splay</span>(pre, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(suc, pre);<br>    <span class="hljs-comment">// 后继的左儿子设为del（即待删除的点）</span><br><span class="hljs-type">int</span> del = tree[suc].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[del].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">// 如果待删点不止一个，只删除一个并把他放回到根结点</span><br>tree[del].cnt--, <span class="hljs-built_in">splay</span>(del, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 后继的左儿子为0 即删除了待删除结点</span><br>tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">splay</span>(suc, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">return</span> tree[tree[root].s[<span class="hljs-number">0</span>]].siz;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[y].siz + tree[x].cnt &lt; k)<br>&#123;<br>k -= tree[y].siz + tree[x].cnt;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[y].siz &gt;= k)x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> tree[x].v;<br>&#125;<br><span class="hljs-comment">// 插入结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; tree[x].v != v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br>    <span class="hljs-comment">// 转动新插入的结点为根</span><br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意先插入哨兵</span><br><span class="hljs-built_in">insert</span>(-INF), <span class="hljs-built_in">insert</span>(INF);<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; p &gt;&gt; val;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>)<span class="hljs-built_in">insert</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">2</span>)<span class="hljs-built_in">del</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">3</span>)cout &lt;&lt; <span class="hljs-built_in">get_rank</span>(val) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">4</span>)cout &lt;&lt; <span class="hljs-built_in">get_val</span>(val + <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">5</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_pre</span>(val)].v &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">6</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_suc</span>(val)].v &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91rotate.png" alt="rotate"></p><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91splay.png" alt="splay"></p><h2 id="flag-写个python版的！"><a href="#flag-写个python版的！" class="headerlink" title="flag 写个python版的！"></a><del>flag</del> 写个python版的！</h2><h2 id="例题-营业额统计"><a href="#例题-营业额统计" class="headerlink" title="例题  营业额统计"></a>例题  <a href="https://www.luogu.com.cn/problem/P2234">营业额统计</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>, root;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>, N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> v, s[<span class="hljs-number">2</span>], cnt, siz, p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>v = v1, p = p1;<br>cnt = siz = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;tree[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = (tree[y].s[<span class="hljs-number">1</span>] == x);<br><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-keyword">if</span> (z != k)<br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; v != tree[x].v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>])x = tree[x].s[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span> (tree[root].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v), suc = <span class="hljs-built_in">get_suc</span>(v);<br><br><span class="hljs-type">int</span> a = tree[pre].v, b = tree[suc].v;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - v) &lt; <span class="hljs-built_in">fabs</span>(b - v) ? <span class="hljs-built_in">fabs</span>(a - v) : <span class="hljs-built_in">fabs</span>(b - v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">insert</span>(INF), <span class="hljs-built_in">insert</span>(-INF);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; x;<br><span class="hljs-built_in">insert</span>(x);<br><span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>ret += <span class="hljs-built_in">search</span>(x);<br><span class="hljs-keyword">else</span> ret += x;<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h2><h3 id="几个需要注意的地方"><a href="#几个需要注意的地方" class="headerlink" title="几个需要注意的地方"></a>几个需要注意的地方</h3><ul><li>Node的siz和cnt需要设置为0 而不是1  在申请结点之后设置为1</li><li>idx需要自增（C++转python的时候 由于++idx并不是放在单独的一句，写的时候容易漏掉</li><li>idx自增之后x &#x3D; idx即可</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.s = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-comment"># son</span><br>        self.p = <span class="hljs-number">0</span> <span class="hljs-comment"># parent</span><br>        self.v = key <span class="hljs-comment"># val</span><br>        self.cnt = <span class="hljs-number">0</span><br>        self.siz = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SplayTree</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.N = <span class="hljs-number">100010</span><br>        self.INF = <span class="hljs-number">0x7fffffff</span><br>        self.tree = [Node(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N)]<br>        self.root = <span class="hljs-number">0</span><br>        self.idx = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 更新树的大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pushup</span>(<span class="hljs-params">self, x</span>):<br>        self.tree[x].siz = self.tree[self.tree[x].s[<span class="hljs-number">0</span>]].siz + self.tree[self.tree[x].s[<span class="hljs-number">1</span>]].siz + self.tree[x].cnt<br><br>    <span class="hljs-string">&quot;&quot;&quot;旋转操作 </span><br><span class="hljs-string">    首先得到x的父节点y和y的父节点z，用k来表示左旋和右旋（如果x在y的左子树右旋，x在y的右子树左旋）</span><br><span class="hljs-string">    以右旋为例 k为0</span><br><span class="hljs-string">    首先让y的左子树放上x的右子树 同时x的右子树的父亲设置为y</span><br><span class="hljs-string">    然后让x的右子树放上y 同时y的父亲设为x</span><br><span class="hljs-string">    最后让z的右子树放上x 同时x的父亲设为z</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    更新x y结点树的大小</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, x</span>):<br>        y = self.tree[x].p<br>        z = self.tree[y].p<br>        k = self.tree[y].s[<span class="hljs-number">1</span>] == x<br><br>        self.tree[y].s[k] = self.tree[x].s[k ^ <span class="hljs-number">1</span>]<br>        self.tree[self.tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y<br><br>        self.tree[x].s[k ^ <span class="hljs-number">1</span>] = y<br>        self.tree[y].p = x<br><br>        self.tree[z].s[self.tree[z].s[<span class="hljs-number">1</span>] == y] = x<br>        self.tree[x].p = z<br><br>        self.pushup(y)<br>        self.pushup(x)<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    splay 使x为k的儿子 有三种情况 </span><br><span class="hljs-string">    k是根 做单旋  </span><br><span class="hljs-string">    k不是根 直线型 做双旋 </span><br><span class="hljs-string">    k不是根 折线形 做双旋</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    先不断向上找x的父节点 当不为k时继续循环：取出父节点y和祖先结点z 如果z不是x的祖先就旋转 </span><br><span class="hljs-string">    当为直线型的时候（用^判断）转x  折线形转y   最后还要再转一下x 双旋（y是根的时候只会转一次x）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    如果k为0 表示k为根节点 要设置x为根</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">splay</span>(<span class="hljs-params">self, x, k</span>):<br>        <span class="hljs-keyword">while</span> self.tree[x].p != k:<br>            y = self.tree[x].p<br>            z = self.tree[y].p<br>            <span class="hljs-keyword">if</span> z != k:<br>                <span class="hljs-keyword">if</span> (self.tree[y].s[<span class="hljs-number">0</span>] == x) ^ (self.tree[z].s[<span class="hljs-number">0</span>] == y):<br>                    self.rotate(x)<br>                <span class="hljs-keyword">else</span>:<br>                    self.rotate(y)<br>            self.rotate(x)<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            self.root = x<br><br>    <span class="hljs-comment"># 树的查找 找到之后要把x设为根（splay）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> self.tree[x].s[v &gt; self.tree[x].v] <span class="hljs-keyword">and</span> v != self.tree[x].v:<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        self.splay(x, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    找前驱 由于find是找到v且当v不存在时找到的是最接近v的值并将其设置为根</span><br><span class="hljs-string">    当该结点小于v的时候直接返回 否则返回他的左子树的最右边的值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pre</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &lt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">1</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_suc</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &gt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">0</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    删除结点，并非真的删除，而是让他访问不到</span><br><span class="hljs-string">    先取出v的前驱和后继结点 并splay</span><br><span class="hljs-string">    设删除结点为del_node 如果出现次数大于1 就减一并splay del_node 否则splay 后继结点</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, v</span>):<br>        pre = self.get_pre(v)<br>        suc = self.get_suc(v)<br>        self.splay(pre, <span class="hljs-number">0</span>)<br>        self.splay(suc, pre)<br>        del_node = self.tree[suc].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> self.tree[del_node].cnt &gt; <span class="hljs-number">1</span>:<br>            self.tree[del_node].cnt -= <span class="hljs-number">1</span><br>            self.splay(del_node, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            self.splay(suc, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># v的排位即v为根的时候v的左子树大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rank</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        <span class="hljs-keyword">return</span> self.tree[self.tree[self.root].s[<span class="hljs-number">0</span>]].siz<br><br>    <span class="hljs-comment"># k位的值 不断找到x的左子树 如果左子树的siz加x的cnt大于k 就往左子树走 否则就让k减去他们俩的和并往右子树走</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_val</span>(<span class="hljs-params">self, k</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            y = self.tree[x].s[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> self.tree[y].siz + self.tree[x].cnt &lt; k:<br>                k -= self.tree[y].siz + self.tree[x].cnt<br>                x = self.tree[x].s[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.tree[y].siz &gt;= k:<br>                    x = self.tree[x].s[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>        self.splay(x,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.tree[x].v<br><br>    <span class="hljs-comment"># 插入操作 先取出根节点 父节点为0 不断向下递归找到x的插入位置  找到之后 如果该结点已经存在 就让cnt+1 否则创建新节点（idx+1 p的儿子为x 初始化x</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> x <span class="hljs-keyword">and</span> self.tree[x].v != v:<br>            p = x<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        <span class="hljs-keyword">if</span> x:<br>            self.tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 注意 这里的idx要先++</span><br>            self.idx += <span class="hljs-number">1</span><br>            x = self.idx<br>            self.tree[p].s[v &gt; self.tree[p].v] = x<br>            self.tree[x].p = p<br>            self.tree[x].v = v<br>            self.tree[x].cnt = <span class="hljs-number">1</span><br>            self.tree[x].siz = <span class="hljs-number">1</span><br>        self.splay(x, <span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st = SplayTree()<br>    st.insert(-st.INF)<br>    st.insert(st.INF)<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        p, val = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:<br>            st.insert(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">2</span>:<br>            st.delete(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">print</span>(st.get_rank(val))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">print</span>(st.get_val(val + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_pre(val)].v)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_suc(val)].v)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> key;<br>Node* left, * right;<br><span class="hljs-type">int</span> Height;<br>&#125;;<br><br><span class="hljs-function">Node* <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>Node* newNode = <span class="hljs-keyword">new</span> Node;<br>newNode-&gt;Height = <span class="hljs-number">0</span>;<br>newNode-&gt;key = key;<br>newNode-&gt;left = newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> newNode;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetHeight</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetHeight</span>(root-&gt;left), <span class="hljs-built_in">GetHeight</span>(root-&gt;right));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetBalanceFactor</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">GetHeight</span>(root-&gt;left) - <span class="hljs-built_in">GetHeight</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">LRotate</span><span class="hljs-params">(Node* y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">   y</span><br><span class="hljs-comment">  / \</span><br><span class="hljs-comment"> O   x</span><br><span class="hljs-comment">/ \</span><br><span class="hljs-comment">   O   O</span><br><span class="hljs-comment">   */</span><br>Node* x = y-&gt;right;<br>Node* t = x-&gt;left;<br><br>x-&gt;left = y;<br>y-&gt;right = t;<br><br>x-&gt;Height = <span class="hljs-built_in">GetHeight</span>(x);<br>y-&gt;Height = <span class="hljs-built_in">GetHeight</span>(y);<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">RRotate</span><span class="hljs-params">(Node* y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">   y</span><br><span class="hljs-comment">  / \</span><br><span class="hljs-comment"> x   O</span><br><span class="hljs-comment">/ \</span><br><span class="hljs-comment">   O   O</span><br><span class="hljs-comment">   */</span><br>Node* x = y-&gt;left;<br>Node* t = x-&gt;right;<br><br>x-&gt;right = y;<br>y-&gt;left = t;<br><br>x-&gt;Height = <span class="hljs-built_in">GetHeight</span>(x);<br>y-&gt;Height = <span class="hljs-built_in">GetHeight</span>(y);<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function">Node* <span class="hljs-title">Insert</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">newNode</span>(key);<br><span class="hljs-keyword">if</span> (key &lt; root-&gt;key)<br>root-&gt;left = <span class="hljs-built_in">Insert</span>(root-&gt;left, key);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key)<br>root-&gt;right = <span class="hljs-built_in">Insert</span>(root-&gt;right, key);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> root;<br><br>root-&gt;Height = <span class="hljs-built_in">GetHeight</span>(root);<br><br><span class="hljs-type">int</span> bf = <span class="hljs-built_in">GetBalanceFactor</span>(root);<br><span class="hljs-comment">// L</span><br><span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// L</span><br><span class="hljs-keyword">if</span> (key &lt; root-&gt;left-&gt;key)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">RRotate</span>(root); <span class="hljs-comment">// 左左 右</span><br><span class="hljs-comment">// R</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;left-&gt;key)<br>&#123;<br>root-&gt;left = <span class="hljs-built_in">LRotate</span>(root-&gt;left);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">RRotate</span>(root);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (key &gt; root-&gt;right-&gt;key)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">LRotate</span>(root);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;right-&gt;key)<br>&#123;<br>root-&gt;right = <span class="hljs-built_in">RRotate</span>(root-&gt;right);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">LRotate</span>(root);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BST树"><a href="#BST树" class="headerlink" title="BST树"></a>BST树</h1><p>其中insert函数未使用引用 delete函数使用了引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left, * right;<br><span class="hljs-type">int</span> data;<br>&#125;Node;<br><br><span class="hljs-function">Node* <span class="hljs-title">searchBST</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> x, Node* f)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<span class="hljs-keyword">return</span> f;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data == x)<span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data &gt; x)<span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, x, root);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, x, root);<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">insertBST</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>Node* p = <span class="hljs-built_in">searchBST</span>(root, x, <span class="hljs-literal">NULL</span>);<br>Node* s = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>s-&gt;data = x;<br>s-&gt;right = s-&gt;left = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (!p)<span class="hljs-keyword">return</span> s;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;data &gt; x)p-&gt;left = s;<br><span class="hljs-keyword">else</span> p-&gt;right = s;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Node*&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!T-&gt;left &amp;&amp; !T-&gt;right)<br>&#123;<br>T = <span class="hljs-literal">NULL</span>; <br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (T-&gt;left)<br>&#123;<br>Node* s = T-&gt;left;<br>Node* q = T;<br><span class="hljs-keyword">while</span> (s-&gt;right)<br>&#123;<br>q = s;<br>s = s-&gt;right;<br>&#125;<br>T-&gt;data = s-&gt;data;<br><span class="hljs-keyword">if</span> (T != q)q-&gt;right = s-&gt;left;<br><span class="hljs-keyword">else</span> T-&gt;left = s-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Node* s = T-&gt;right;<br>Node* q = T;<br><span class="hljs-keyword">while</span> (s-&gt;left)<br>&#123;<br>q = s;<br>s = s-&gt;left;<br>&#125;<br>T-&gt;data = s-&gt;data;<br><span class="hljs-keyword">if</span> (T != q)q-&gt;left = s-&gt;right;<br><span class="hljs-keyword">else</span> T-&gt;right = s-&gt;right;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeBST</span><span class="hljs-params">(Node*&amp; T, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!T)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (T-&gt;data == e)<br>&#123;<br><span class="hljs-built_in">Delete</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data &gt; e)<br><span class="hljs-built_in">removeBST</span>(T-&gt;left, e);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">removeBST</span>(T-&gt;right, e);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二叉树</title>
    <link href="/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><a href="https://www.luogu.com.cn/problem/P5076">二叉搜索树</a></h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> cont = <span class="hljs-number">0</span>; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span><br>&#123;<br><span class="hljs-type">int</span> ls, rs, val, cnt, siz;<br>&#125;tree[<span class="hljs-number">1000010</span>];<br><br><span class="hljs-type">int</span> n,q,val;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz++;<span class="hljs-comment">// 首先，插入的这个结点的siz++</span><br><span class="hljs-comment">// 如果已经有这个结点，就cnt++，因为搜索树中不能有重复结点</span><br><span class="hljs-keyword">if</span> (val == tree[x].val)<br>&#123;<br>tree[x].cnt++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (val &lt; tree[x].val)<br>&#123;<br>        <span class="hljs-comment">// 到最左边</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">// 开辟新结点并赋值</span><br>cont++;<br>tree[cont].val = val;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[x].ls = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].ls, val);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>tree[x].rs = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].rs, val);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 找前驱</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryfr</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果小于当前结点</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt;= val)<br>&#123;<br>        <span class="hljs-comment">// 找到最左边了，直接返回ans</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//不然就继续找</span><br><span class="hljs-built_in">queryfr</span>(tree[x].ls, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &gt; val ? ans : tree[x].val;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">queryfr</span>(tree[x].rs, val, tree[x].val);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// 找后继</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryne</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (tree[x].val &lt;= val)<br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].rs, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &lt; ans ? tree[x].val : ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].ls, val, tree[x].val);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 找val的排位</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 没找到就返回0，当找到最后还没有找到的时候，就会走到ls或rs==0，赋值给x，就会从这里退出</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 找到了就返回，当前这个结点的左子树的长度</span><br><span class="hljs-keyword">if</span> (tree[x].val == val)<br><span class="hljs-keyword">return</span> tree[tree[x].ls].siz;<br>    <span class="hljs-comment">// 如果小于当前结点的值，往左</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].ls, val);<br>    <span class="hljs-comment">// 往右的时候要先减掉左子树和自身的值</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].rs, val) + tree[tree[x].ls].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 找排位为rk的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertrk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> rk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// rk索引越界</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> INF;<br><span class="hljs-comment">// 左子树大于rk，说明在左子树里面找</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz &gt;= rk)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].ls, rk);<br>    <span class="hljs-comment">// 左子树+cnt大于rk，说明就是当前的val</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz + tree[x].cnt &gt;= rk)<br><span class="hljs-keyword">return</span> tree[x].val;<br>    <span class="hljs-comment">// 否则在右子树，要先减掉左子树和cnt</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].rs, rk - tree[tree[x].ls].siz - tree[x].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; q &gt;&gt; val;<br><span class="hljs-keyword">switch</span> (q)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertval</span>(<span class="hljs-number">1</span>, val) + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertrk</span>(<span class="hljs-number">1</span>, val) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">queryfr</span>(<span class="hljs-number">1</span>, val, -INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout &lt;&lt; <span class="hljs-built_in">queryne</span>(<span class="hljs-number">1</span>, val, INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-comment">//特判根节点</span><br><span class="hljs-keyword">if</span> (cont == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, val);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="这个小伙居然还用python写了一遍"><a href="#这个小伙居然还用python写了一遍" class="headerlink" title="这个小伙居然还用python写了一遍"></a><del>这个小伙居然还用python写了一遍</del></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x7fffffff</span><br>cont = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,val=<span class="hljs-number">0</span>,siz=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ls=<span class="hljs-number">0</span>,rs=<span class="hljs-number">0</span></span>):<br>        self.val = val<br>        self.siz = siz<br>        self.cnt = cnt<br>        self.ls = ls<br>        self.rs = rs<br><br><br><span class="hljs-comment"># 神奇的方法</span><br>tree = [Node() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,v</span>):<br>    <span class="hljs-keyword">global</span> cont,tree<br>    tree[x].siz += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> tree[x].val == v:<br>        tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> tree[x].val &gt; v:<br>        <span class="hljs-keyword">if</span> tree[x].ls != <span class="hljs-number">0</span>:<br>            add(tree[x].ls,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].ls = cont<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs != <span class="hljs-number">0</span>:<br>            add(tree[x].rs,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].rs = cont<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryfr</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &gt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].ls,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &lt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].rs,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x],val,ans)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryne</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &lt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].rs,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &gt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-comment"># 这里有点多余</span><br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls, val,ans)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryrk</span>(<span class="hljs-params">x,rk</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> INF<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz &gt;= rk:<br>        <span class="hljs-keyword">return</span> queryrk(tree[x].ls,rk)<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz + tree[x].cnt &gt;= rk:<br>        <span class="hljs-keyword">return</span> tree[x].val<br>    <span class="hljs-keyword">return</span> queryrk(tree[x].rs,rk - tree[tree[x].ls].siz-tree[x].cnt)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryval</span>(<span class="hljs-params">x,val</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> val == tree[x].val:<br>        <span class="hljs-keyword">return</span> tree[tree[x].ls].siz<br>    <span class="hljs-keyword">if</span> val &lt; tree[x].val:<br>        <span class="hljs-keyword">return</span> queryval(tree[x].ls,val)<br>    <span class="hljs-keyword">return</span> queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt<br><br><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    q,v = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    <span class="hljs-keyword">if</span> q == <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">if</span> cont == <span class="hljs-number">0</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span><br>            tree[cont].val = v<br>        <span class="hljs-keyword">else</span>:<br>            add(<span class="hljs-number">1</span>,v)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(queryval(<span class="hljs-number">1</span>,v)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(queryrk(<span class="hljs-number">1</span>,v))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(queryfr(<span class="hljs-number">1</span>,v,-INF))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(queryne(<span class="hljs-number">1</span>,v,INF))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex学习</title>
    <link href="/2023/08/02/latex%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/latex%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li><p>首先\documentclass[UTF8]{ctexart}</p><p>….(宏包)</p><p>\begin{document}</p><p>……</p><p>\end{document}</p></li><li><p>行内要用$$括起来 行间要用$$$$括起来</p></li><li><p>公式对齐 不同的环境语法不同 eqnarray是&amp;&#x3D;&amp;；align是&amp;&#x3D;</p></li><li><p>分段函数  cases环境  使用&amp; 对齐  \\换行</p></li><li><p>矩阵 array begin后面加{ccc}表示格式  需要$$$$和自己加括号</p></li><li><p>要表示带省略号的矩阵 用pmatrix环境</p></li><li><p>表格 数字表格即矩阵加|，带汉字的要使用tabular环境。表格的横线为\hline</p></li><li><p>插图 \includegraphics[scale&#x3D;<em>] [width&#x3D;</em>][height&#x3D;*]{.png}</p><p>或使用\figure环境</p><p>\begin{figure}[H]</p><p> \centering</p><p> % Requires \usepackage{graphicx}</p><p> \includegraphics[width&#x3D;12pt]{.png}\</p><p> \caption{图1}</p><p>\end{figure}</p></li></ul><h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><ul><li>\textbf{}加粗</li><li>\textit{}斜体</li><li>underline 下划线</li></ul><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125; //正文<br><br><span class="hljs-keyword">\part</span>&#123;A&#125; // 该部分标题为A 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\chapter</span>&#123;B&#125; //该章节标题为B 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\section</span>&#123;C&#125; //该章节标题为C 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\subsection</span>&#123;D&#125; //创建子章节<br><br><span class="hljs-keyword">\subsubsection</span> //.<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125; //引入宏包<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;figure&#125;<br><span class="hljs-keyword">\centering</span> // 居中<br><span class="hljs-keyword">\includegraphics</span>[width=0.5<span class="hljs-keyword">\textwidth</span>]&#123;head&#125;<br><span class="hljs-keyword">\caption</span>&#123;...&#125; //图片标题<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>//无序列表环境为itemize<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\item</span> 列表项1<br><span class="hljs-keyword">\item</span> 列表项2<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>// 行内公式<br>AAAAA <span class="hljs-built_in">$</span>E = mc<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span><br>// 行间公式<br>// 使用equation环境<br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br>// 或者用<span class="hljs-keyword">\[</span> 和 <span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\[</span><br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="表-格"><a href="#表-格" class="headerlink" title="表 格"></a>表 格</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;table&#125;// 需要标题和居中的时候要把表格放在table环境中<br><br><span class="hljs-keyword">\center</span><br><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c c c&#125;  // c | c c代表表格共三列 每列内容都居中对齐 用l表示左对齐 r右 添加竖线代表竖边框 水平边框通过<span class="hljs-keyword">\hline</span>添加 每格之间用<span class="hljs-built_in">&amp;</span>隔开 每行之间用<span class="hljs-keyword">\\</span>隔开<br>// 把c改成p&#123;2cm&#125;自定义列宽<br><span class="hljs-keyword">\hline</span><br>单元格1 <span class="hljs-built_in">&amp;</span> 单元格2 <span class="hljs-built_in">&amp;</span> 单元格3 <span class="hljs-keyword">\\</span>      <br><span class="hljs-keyword">\hline</span> //双横线<br><span class="hljs-keyword">\hline</span><br>单元格4 <span class="hljs-built_in">&amp;</span> 单元格5 <span class="hljs-built_in">&amp;</span> 单元格6 <span class="hljs-keyword">\\</span><br>单元格7 <span class="hljs-built_in">&amp;</span> 单元格8 <span class="hljs-built_in">&amp;</span> 单元格9 <br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><br><span class="hljs-keyword">\caption</span>&#123;title&#125;<br><br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab学习</title>
    <link href="/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>部分表</li></ul><table><thead><tr><th><strong>help</strong></th><th>帮助查询</th></tr></thead><tbody><tr><td><strong>clc</strong></td><td>删除命令窗口的内容（已使用过的命令）</td></tr><tr><td><strong>clear</strong></td><td>删除内存中的变量（数据）</td></tr><tr><td><strong>clf</strong></td><td>删除图形窗口的内容</td></tr><tr><td><strong>who</strong></td><td>列出在MATLAB工作空间中已有的变量</td></tr><tr><td><strong>whos</strong></td><td>列出驻留变量的同时,还给出维数及性质</td></tr><tr><td><strong>home</strong></td><td>光标移到命令窗口的左上角</td></tr><tr><td><strong>↑</strong></td><td>调出刚才使用过的命令</td></tr><tr><td><strong>quit</strong></td><td>退出MATLAB</td></tr></tbody></table><table><thead><tr><th>r</th><th>红色</th><th>-</th><th>实线</th></tr></thead><tbody><tr><td>g</td><td>绿色</td><td>–</td><td>虚线</td></tr><tr><td>b</td><td>蓝色</td><td>:</td><td>点线</td></tr><tr><td>y</td><td>黄色</td><td>-.</td><td>点划线</td></tr><tr><td>m</td><td>洋红色</td><td>o</td><td>圆圈</td></tr><tr><td>c</td><td>青色</td><td>x</td><td>叉号</td></tr><tr><td>w</td><td>白色</td><td>+</td><td>加号</td></tr><tr><td>k</td><td>黑色</td><td>s</td><td>正方形</td></tr><tr><td>*</td><td>星号</td><td>d</td><td>菱形</td></tr><tr><td>v</td><td>向下三角</td><td>^</td><td>向上三角</td></tr><tr><td>.</td><td>点号</td><td>h</td><td>六角形</td></tr></tbody></table><ul><li><p>首先注意和数字运算的时候运算符要加点</p></li><li><p>axis([])设置坐标轴范围</p></li><li><p>grid on 显示网格线 title显示标题 xlabel标记x轴 legend添加图例</p></li></ul><h2 id="plot-x-y-’color-style-marker’-绘制图像"><a href="#plot-x-y-’color-style-marker’-绘制图像" class="headerlink" title="plot(x,y,’color-style-marker’)绘制图像"></a>plot(x,y,’color-style-marker’)绘制图像</h2><ul><li><p>选点：x &#x3D; linspace(0,1,100)  也可以使用x &#x3D; a : step : b</p><p>y1 &#x3D; linspace(0,1,100) 选择对应的点 plot(x,y,’r’) 需要保证是同维的</p><p>也可以使用解析式的方式，先确定x的范围，然后用x表示y即可，但是要注意表示的各个符号是否加点。</p><p>例：y &#x3D; -0,0234 * x + 1.2551 * x .^(2&#x2F;3)   y &#x3D; sin(x) </p></li><li><p>三维图像 plot3 用来绘制一组三维曲线  需要保证是同维的   </p><p> mesh 用来绘制三维曲面的网格线图 先选点 然后 [X,Y] &#x3D; meshgrid(x,y) Z &#x3D;  X.^2+Y.^2 最后mesh(X,Y,Z)\</p></li><li><p>如果想要画圆圈和连线那就是plot(x,a,’o’,x,a)  ‘bo’是蓝色圆圈</p><p> 前一个xa画圆圈（散点）后一个xa画直线</p></li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><p>solve 解线性方程组 使用前要定义变量 syms a b x …</p><p>S &#x3D; solve(方程，变量（默认x)  </p><p>[a,b] &#x3D; solve(90* a + 90^(2&#x2F;3)<em>b&#x3D;&#x3D;23.1,180</em>a+180^(2&#x2F;3)*b &#x3D;&#x3D; 35.8)</p></li></ul><h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><ul><li><p>for i &#x3D; n1:(step):n2</p><p>commands;</p><p>end</p></li><li><p>while …</p></li></ul><p>  commands;</p><p>  end</p><ul><li><p>if…</p><p>elseif…</p><p>else…</p><p>end</p></li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>function [x,y,z] &#x3D; f1(a,b)</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>csape(x,y,’compelete’,[-1,0])</p><p>complete代表通过给定数据点的完全样条函数 </p><p>[-1,0]表示一阶导数的边界</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表题解</title>
    <link href="/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><del>超，格式怎么这样了，下次再改</del></p><h1 id="妖梦拼木棒"><a href="#妖梦拼木棒" class="headerlink" title="妖梦拼木棒"></a><a href="https://www.luogu.com.cn/problem/P3799">妖梦拼木棒</a></h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>上道题中，妖梦斩了一地的木棒，现在她想要将木棒拼起来。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？</p><p>答案对 $10^9+7$ 取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$。</p><p>第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数代表答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $n \le 5 \times 10^3$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。</li></ul><p>一开始想错了，导致后面也被带偏。必须要两只一样长的木棒，剩下两个只需要和跟另外两个一样长就行了。并不需要相等长度，（想错，导致之后改错）其实也并不需要一开始的两只相等长度，比如7 7 2 +5这样。然后就是简单的组合数学</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">5001</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>nums[x]++;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">2</span>)<br>&#123;<br>a = nums[i] * (nums[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> == i &amp;&amp; nums[j] &gt;= <span class="hljs-number">2</span>)cnt += a * (nums[j] * (nums[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod) % mod;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> != i &amp;&amp; nums[j] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i - j] &gt;= <span class="hljs-number">1</span>)cnt += a * ((nums[j] * nums[i - j]) % mod) % mod;<br>&#125;<br>cnt %= mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; cnt % mod &lt;&lt; endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="kkksc03考前临时抱佛脚"><a href="#kkksc03考前临时抱佛脚" class="headerlink" title="kkksc03考前临时抱佛脚"></a><a href="https://www.luogu.com.cn/problem/P2392">kkksc03考前临时抱佛脚</a></h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">20<br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><p>本来是贪心+模拟。。但是有几个过不了，大概是情况没考虑全。btw别人想的都是把题目分成尽量平均的两部分啊。（模拟不是下意识就出来了吗，窝好菜</p><p>用dp求尽量平均的两部分，即01背包问题，分到左边和分到右边，状态表示为二维，集合为到j的时候的体积，状态计算为给左大脑和给右大脑，此处视左大脑为背包1，右大脑为0，放到让左边为1&#x2F;2总体积。每道题的时间既是价值，也是体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2000</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>)]<br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>            f[j][k] = f[j - <span class="hljs-number">1</span>][k]<br>            <span class="hljs-keyword">if</span> k &gt;= nums[j]:<br>                f[j][k] = <span class="hljs-built_in">max</span>(f[j][k],f[j - <span class="hljs-number">1</span>][k - nums[j]] + nums[j])<br>            t = <span class="hljs-built_in">max</span>(t,f[j][k])<br><br>    ans += <span class="hljs-built_in">max</span>(t, m-t)<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p>一维优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span>, nums[j]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[k] = <span class="hljs-built_in">max</span>(f[k],f[k - nums[j]] + nums[j])<br><br><br>    ans += m - f[m//<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>        f[i] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="COCI2008-2009-2-PERKET"><a href="#COCI2008-2009-2-PERKET" class="headerlink" title="[COCI2008-2009#2] PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">[COCI2008-2009#2] PERKET</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。</p><p>众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。</p><p>另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示可供选用的食材种类数。</p><p>接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示可能的总酸度和总苦度的最小绝对差。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>本题满分 $70$ 分。</li><li>题目译自 <a href="https://hsin.hr/coci/archive/2008_2009/">COCI2008-2009</a> <a href="https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf">CONTEST #2</a> PERKET，译者 @<a href="https://www.luogu.com.cn/user/115711">mnesia</a>。</li></ul><p>简单dfs 选或不选###的思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>minn = <span class="hljs-number">0x7fffffff</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u,sor,bit</span>):<br>    <span class="hljs-keyword">global</span> minn<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">if</span> sor == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> bit == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            minn = <span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">abs</span>(sor - bit))<br>            <span class="hljs-keyword">return</span><br><br>    dfs(u + <span class="hljs-number">1</span>,sor,bit)<br>    dfs(u + <span class="hljs-number">1</span>,sor * nums[u][<span class="hljs-number">0</span>], bit + nums[u][<span class="hljs-number">1</span>])<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>   nums[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><br>dfs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(minn)<br></code></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [NOIP2016 普及组 海港]([P2058 NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [NOIP2016 普及组 海港]([P2058 <a href="https://www.luogu.com.cn/problem/P2058">NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T3</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。</p><p>小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。</p><p>小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $&#x3D;86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。</p><p>形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400&lt;t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。</p><p>接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。</p><p>保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。</p><p>保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。</p><p>其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">86401 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">86402 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>3<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>【样例解释 1】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；</p><p>第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 &#x3D; 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；</p><p>第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1&#x3D;7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。</p><p>【样例解释 2】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。</p><p>第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2&#x3D;6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。</p><p>第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2&#x3D;4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。</p><p>第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1&#x3D;5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。</p><p>【数据范围】</p><ul><li>对于 $10%$ 的测试点，$n&#x3D;1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。</li><li>对于 $20%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。</li><li>对于 $40%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。</li><li>对于 $70%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。</li><li>对于 $100%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是python的语法 ship.num = lis[2:]把2和后面的全都赋到num里面，然后就是python的语法，双端队列deque的使用方法，支持[]访问，直接用shiparr[Ship()]*100000，会导致错误，应该是类似于地址出错（所有的数组里面都是同一个值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    time = <span class="hljs-number">0</span><br>    num = []<br>    numpass = <span class="hljs-number">0</span><br><br><br>q = deque()<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>peo = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000000</span><br>lis = []<br>shiparr = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>    ship = Ship()<br>    ship.time = lis[<span class="hljs-number">0</span>]<br>    ship.numpass = lis[<span class="hljs-number">1</span>]<br>    ship.num = lis[<span class="hljs-number">2</span>:]<br>    shiparr.append(ship)<br><br><br>country = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    ship = shiparr[j]<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> ship.time - q[<span class="hljs-number">0</span>].time &lt; <span class="hljs-number">86400</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q[<span class="hljs-number">0</span>].num:<br>            peo[x] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>                country -= <span class="hljs-number">1</span><br>        q.popleft()<br>        i += <span class="hljs-number">1</span><br>    q.append(ship)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ship.num:<br>        <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>            country += <span class="hljs-number">1</span><br>        peo[x] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(country)<br><br></code></pre></td></tr></table></figure><h1 id="括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [括号序列](P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [括号序列](<a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p><ol><li>空串是「平衡括号序列」</li><li>若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」</li><li>若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。</li></ol><p>例如，下面的字符串都是平衡括号序列：</p><p><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></p><p>而以下几个则不是：</p><p><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></p><p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：</p><ol><li>从左到右扫描整个字符串。</li><li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li></ol><p>配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 $s$。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([()<br></code></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">([)</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $s$ 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 主要是题目，2.的意思是从遇到第一个右括号开始向左寻找第一个未匹配的左括号（其实根本不需要栈）。只需要在找到的地方做个标记表示已匹配即可。最后，输出的时候未匹配的就直接输出同类的完整括号，匹配的就正常输出。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt;stleft;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">char</span> ch;<br>string str;<br>cin &gt;&gt; str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>ch = str[j];<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> || str[i] == <span class="hljs-string">&#x27;)&#x27;</span>))cout &lt;&lt; <span class="hljs-string">&quot;()&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;[&#x27;</span>||str[i] == <span class="hljs-string">&#x27;]&#x27;</span>)) cout &lt;&lt; <span class="hljs-string">&quot;[]&quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; str[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Our Game!</title>
    <link href="/2023/07/27/Our-Game/"/>
    <url>/2023/07/27/Our-Game/</url>
    
    <content type="html"><![CDATA[<h1 id="我们的游戏做完啦！"><a href="#我们的游戏做完啦！" class="headerlink" title="我们的游戏做完啦！"></a>我们的游戏做完啦！</h1><p>&emsp;好激动，四周的时间过的好快，好像昨天还在讨论游戏的原型设计。现在居然已经完成了所有的工作。感谢tllwtg和wegret的付出，<del>我们三个真强</del>（哈哈哈）。<br>希望zlgg和xyjj不要嫌我菜。</p><p><a href="https://github.com/tLLWtG/Capoo-Survival/releases">这里是我们的游戏</a>，点点star（可怜）</p><p>没错 就是开放世界冒险游戏（没有虚假宣传。。。开放、世界、冒险都有）</p><p>做游戏的过程还是很开心的（可能是给我的活太少了），感觉自己没做什么，还好通过我精密的计算，最后障碍物终于没有重叠了，不然就没脸见人了。<br>好怀念教室只剩下我们在讨论和实现，在群里商量分工，一件件地完成TODO。本来是很讨厌组队的，<br>但是这种组队的感觉真的好棒！跟某些课程全部都是摆子的组队感觉完全不一样哇）</p><p>第一次上去汇报手都在发抖捏，但是后面感觉还行，对！根本就没人会听，啊，你说我吗？我也不听别人讲😀（wow，居然能插入表情嘛）。一开始做ppt只会白底黑字，<br>后面加了模板，是好看一点wo。</p><p>啊!台风了，最后一次汇报没有了，本来还想拍个照片然后一起去恰个饭的，不知道下次还有没有机会，呜呜。</p><p>贴一些图片（才不是太久没写说说，写不出来东西了呢</p><p>靠 截图审美好差</p><p>部分代码截图和游戏使用图片</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog1-16907768245555.png" alt="部分代码截图和游戏使用图片"></p><p>汇报ppt</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog2-16907767706092.png" alt="汇报ppt"></p><p>还没写完，但是不想写了，嘿嘿。</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法</title>
    <link href="/2023/07/23/python%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/23/python%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python语法注意事项"><a href="#python语法注意事项" class="headerlink" title="python语法注意事项"></a>python语法注意事项</h1><p><del>啊，受不了了，写了几个题不是运错就是编错，还有一堆奇奇怪怪的报错，痛苦.jpg。</del><br>已经遇见未来不短的时间内会不断报错并且看不懂然后写在这里了，希望这篇可以早日停更。</p><ul><li><p>n &#x3D; int(input())</p></li><li><p>控制不住if后面加()，哭，剁手</p></li><li><p>xmuoj不支持类型注解，呜呜</p></li><li><p>没有while(n–)的操作了，用while会忘记–，死循环了，好蠢</p></li><li><p>range的范围</p></li><li><p>读入二维列表 (老是忘记lis的append，想半天)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lis = <span class="hljs-selector-attr">[]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    d = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(int,<span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>()))<br>    lis<span class="hljs-selector-class">.append</span>()<br></code></pre></td></tr></table></figure></li><li><p>浮点数确定精度输出 print(“%.1f” % n) 注意是双引号并且没有逗号</p></li><li><p>dx &#x3D; [1,0,-1,0] <del>这里是今晚最佳</del> 加了个list怎么找也找不出来，list dx[]-&gt;笑死</p></li><li><p>全排列 选哪个？ 标记选过的不再选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">sol,num,on_path</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sol) == <span class="hljs-built_in">len</span>(num):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(sol[i], <span class="hljs-string">&quot;&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> on_path[i] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                on_path[i] = <span class="hljs-number">1</span><br>                permute(sol+[num[i]],num,on_path)<br>                on_path[i] = <span class="hljs-number">0</span><br>                <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>sol = []<br>num = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)]<br>on_path = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>permute(sol,num,onpath]<br></code></pre></td></tr></table></figure></li><li><p>字典的使用方法  记得一定要先判断是否存在 <del>呜呜，明明之前才记过，写的时候又忘记了，泰蠢辣</del></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">st</span> = input()<br><br>d = dict()<br>for <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">st</span>:<br>    if <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> d:<br>        d[<span class="hljs-number">ch</span>] += <span class="hljs-number">1</span><br><span class="hljs-symbol">    else:</span><br>        d[<span class="hljs-number">ch</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>上面的题是用来求只出现一次的字符的 难过 在c++知道用count 在python就变蠢力</p></li><li><p>python线性筛 芜湖~</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">N</span> = <span class="hljs-number">100010</span><br><span class="hljs-attribute">st</span> =<span class="hljs-meta"> [False for _ in range(N)]</span><br><span class="hljs-attribute">prime</span> =<span class="hljs-meta"> [0 for _ in range(N)]</span><br><br><span class="hljs-attribute">def</span> get_prime(n):<br>    <span class="hljs-attribute">cnt</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">if</span> not st[i]:<br>            <span class="hljs-attribute">prime</span>[cnt] = i<br>            <span class="hljs-attribute">cnt</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> prime[j] &lt; n // i:<br>        <span class="hljs-attribute">st</span>[prime[j] * i] = True<br>        <span class="hljs-attribute">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">break</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>range是左开右闭</p></li><li><p>我超 在函数里面用全局变量的时候要加global </p></li><li><p>python归并</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = int(input(n))<br><span class="hljs-attribute">nums</span> = list(map(int,input()))<br><span class="hljs-attribute">temp</span> =<span class="hljs-meta"> [0 for _ in range(n)]</span><br><br><span class="hljs-attribute">merge_sort</span>(l, r):<br>    <span class="hljs-attribute">if</span> l &gt;= r:<br>        <span class="hljs-attribute">return</span> <br>    <span class="hljs-attribute">mid</span> = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-attribute">merge_sort</span>(l, mid)<br>    <span class="hljs-attribute">merge_sort</span>(mid + <span class="hljs-number">1</span>, r)<br>    <span class="hljs-attribute">i</span>, j, k = l, mid + <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-attribute">if</span> nums[i] &lt;= nums[j]:<br>            <span class="hljs-attribute">temp</span>[k] = nums[i]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">temp</span>[k] = nums[j]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid:<br>        <span class="hljs-attribute">temp</span>[k] = nums[i]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> j &lt;= r:<br>        <span class="hljs-attribute">temp</span>[k] = nums[j]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(l, r + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">nums</span>[i] = temp[j]<br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>        <br>        <br><span class="hljs-attribute">merge_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>)# n-<span class="hljs-number">1</span>!!<br></code></pre></td></tr></table></figure></li><li><p>python手动增加递归的层数<br>import sys<br>sys.setrecursionlimit(5000)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训题目整理</title>
    <link href="/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
    <url>/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.10">熄灯问题</a></h1><p>枚举&#x2F;二进制优化</p><p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。</p><p>在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。</p><p>请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。</p><ul><li>输入<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p><ul><li>输出<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p><ul><li>输入样例</li></ul><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0</p><ul><li>输出样例</li></ul><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>注意：PUZZLE行结尾没有空格，数字行最后有一个空格。   </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/* 每次碰一个开关就会使他上下左右（还有自己！）的灯都改变状态，灯只有开关两种状态，那么要使灯全部关掉，</span><br><span class="hljs-comment">其实每个灯最多只需要按一次。</span><br><span class="hljs-comment">  如何枚举？从第二排开始，只关注当前行和上一行的状态，用当前行把上一行的灯都关掉，而不考虑其他变</span><br><span class="hljs-comment">化，这样到最后一行，如果恰好全部熄灭，就是结果。能够影响结果的，就是第一行的状态，枚举第一行。</span><br><span class="hljs-comment">  第一行的状态怎么表示？由于只有开关（1/0）两种状态，可以用二进制数来表示，之后再按顺序输入到矩阵中</span><br><span class="hljs-comment">*/</span><br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>bool <span class="hljs-symbol">ButtomStatu</span>(const int m, int ori[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>], int res[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])<br>&#123;<br>//枚举第一行的所有按键情况 利用二进制数来枚举 由于有<span class="hljs-number">6</span>列 情况为<span class="hljs-number">2</span>^<span class="hljs-number">6</span>种 得到第一行的按键情况<br>int temp = m;<br><br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>res[<span class="hljs-number">0</span>][i] = temp <span class="hljs-comment">% 2;</span><br>temp /= <span class="hljs-number">2</span>;<br>&#125;<br> <br>//把上面的情况按一遍 记得按自己所在的位置<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>if (res[<span class="hljs-number">0</span>][i])<br>&#123;<br>ori[<span class="hljs-number">0</span>][i]= (ori[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[<span class="hljs-number">1</span>][i] = (ori[<span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>&#125;<br>&#125;<br><br>//从第一行下面的每一行枚举 （核心是 第一行决定了下面每一行的情况 所以只需要枚举第一行<br>for (int i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>if (ori[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">0</span>)<br>&#123;<br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">5</span>)ori[i + <span class="hljs-number">1</span>][j] = (ori[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[i][j + <span class="hljs-number">1</span>] = (ori[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i][j - <span class="hljs-number">1</span>] = (ori[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[i][j]= (ori[i][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>res[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>//如果灯全部关完 则为true<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>if (ori[i][j] != <span class="hljs-number">0</span>)return false;<br><br>return true;<br>&#125;<br><br><br>int main()<br>&#123;<br>int n;<br>cin &gt;&gt; n;<br>int orilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int resultlight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int constorilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>for(int k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br>for (int row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">5</span>; row++)<br>&#123;<br>for (int col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">6</span>; col++)<br>&#123;<br>cin &gt;&gt; constorilight[row][col];<br>&#125;<br>&#125;<br>//枚举<span class="hljs-number">64</span>种情况<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>&#123;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>orilight[i][j] = constorilight[i][j];<br>resultlight[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>//如果得到结果就输出<br>if (<span class="hljs-symbol">ButtomStatu</span>(i, orilight, resultlight))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;PUZZLE #&quot;</span> &lt;&lt; k &lt;&lt; endl;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>cout &lt;&lt; resultlight[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.5">假币问题</a></h1><p>枚举</p><p>林克有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但林克不知道假币比真币轻还是重。</p><p>于是他向他朋友约珥借了一架天平，用这架天平称了这些币三次。</p><p>如果用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。</p><p>经过精心的设计，聪明的林克根据这三次称量结果找出假币，并且能够确定假币是轻是重。</p><p>如果给你林克的称量数据，你也可以找出假币并且确定假币是轻是重吗？（林克提供的称量数据保证一定能找出假币）。</p><ul><li>输入</li></ul><p>第一行有一个数字n，表示有n组测试用例。</p><p>对于每组测试用例：</p><p>输入有三行，每行表示一次称量的结果。林克事先将银币标号为A-L。</p><p>每次称量的结果用三个以空格隔开的字符串表示：</p><p>天平左边放置的硬币  天平右边放置的硬币  平衡状态。</p><p>其中平衡状态用’’up’’, ‘’down’’, 或 ‘’even’’表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p><ul><li>输出</li></ul><p>输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)</p><ul><li>输入样例 1</li></ul><p>1<br>ABCD EFGH even<br>ABCI EFJK up<br>ABIJ EFGH even  </p><ul><li>输出样例 1</li></ul><p>K is the counterfeit coin and it is light. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 枚举十二枚硬币和轻重共24种状态，先设假币为轻，那么一定在上升的一边，依次枚举十二枚硬币是否在</span><br><span class="hljs-comment">上升的一边，如果不是，说明为真币或者假币不为轻，那么返回false。否则遍历三次称重，最后返回true，说明</span><br><span class="hljs-comment">这个就是假币并且为轻。</span><br><span class="hljs-comment">优化：不需要分别写轻，重的函数，只需要传一个参数表示状态，当判断重时把左右交换，就与判断轻的代码一样</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>vector&lt;string&gt;<span class="hljs-built_in">lef</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">rig</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">zt</span>(<span class="hljs-number">3</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> iCoin,<span class="hljs-type">bool</span> is_light)</span></span><br><span class="hljs-function"></span>&#123;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>string l = lef[i];<br>string r = rig[i];<br>string z = zt[i];<br><span class="hljs-keyword">if</span> (!is_light)<br><span class="hljs-built_in">swap</span>(l, r);<br><span class="hljs-keyword">switch</span> (zt[i][<span class="hljs-number">0</span>])<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)!=string::npos||r.<span class="hljs-built_in">find</span>(iCoin)!=string::npos)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//说明在平衡的地方找到了  肯定是真币</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//现在枚举的是轻的 那么假币一定在上升的一方 </span><br><span class="hljs-comment">//右边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//左边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> cmp[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cin &gt;&gt; lef[i]&gt;&gt;rig[i]&gt;&gt; zt[i];<br>&#125;<br><br><span class="hljs-comment">//枚举十二枚硬币</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> iCoin = <span class="hljs-string">&#x27;A&#x27;</span>; iCoin &lt;= <span class="hljs-string">&#x27;L&#x27;</span>; iCoin++) <br>&#123;<br><span class="hljs-comment">//枚举假币为轻的情况</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">true</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is light. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">false</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is heavy. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>lef.<span class="hljs-built_in">clear</span>(), rig.<span class="hljs-built_in">clear</span>(), zt.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拨钟问题"><a href="#拨钟问题" class="headerlink" title="拨钟问题"></a><a href="http://www.xmuoj.com/problem/GW102">拨钟问题</a></h1><p>子集型回溯</p><p>有9个时钟，排成一个3*3的矩阵。</p><p>(图 1)<del>明显显示不出来嘛！</del>  </p><p>现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。</p><p>移动    影响的时钟</p><p> 1         ABDE<br> 2         ABC<br> 3         BCEF<br> 4         ADG<br> 5         BDEFH<br> 6         CFI<br> 7         DEGH<br> 8         GHI<br> 9         EFHI         </p><ul><li>输入</li></ul><p>9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0&#x3D;12点、1&#x3D;3点、2&#x3D;6点、3&#x3D;9点。</p><ul><li>输出</li></ul><p>输出一个最短的时钟指针移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。 相邻两个整数之间用单个空格隔开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*子集型回溯：进入dfs之后首先判断退出条件。之后是选或不选，对于1~9每个拨钟的方法，都可以选择拨或者</span><br><span class="hljs-comment">不拨！！然后是每个数字循环三次（最多只需要拨三次）。</span><br><span class="hljs-comment">判断，k&gt;9的时候判断是否符合，符合判断最短，之前应记录每一步。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;inf = &#123; <span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;ABDE&quot;</span> ,<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-string">&quot;BCEF&quot;</span>,<span class="hljs-string">&quot;ADG&quot;</span>,<span class="hljs-string">&quot;BDEFH&quot;</span>,<span class="hljs-string">&quot;CFI&quot;</span>,<span class="hljs-string">&quot;DEGH&quot;</span>,<span class="hljs-string">&quot;GHI&quot;</span>,<span class="hljs-string">&quot;EFHI&quot;</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ori</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">movevec</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">showvec</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> si = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mi = <span class="hljs-number">50</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;ori)</span><span class="hljs-comment">//检查是否符合条件（全为0</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (ori[i] != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><span class="hljs-comment">//移动的距离</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inf[k].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] = (ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">9</span>)<span class="hljs-comment">//相当于循环9次  即枚举9种拨钟方法</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ori) &amp;&amp; si &lt; mi)<span class="hljs-comment">//由于需要最少的次数所以用mi记录（当全为0时）最少次数</span><br>&#123;<br>mi = si;<br>showvec = movevec;<span class="hljs-comment">//记录最少次数的走法 由于是按顺序枚举 所以一定是从小到大的</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br> <span class="hljs-comment">//子集型回溯  可以一个都不选</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<span class="hljs-comment">//先进去9次  这样才可以回溯 只拨第9个不行 从这里退出 拨第8个和第9个 由于move（K） 则可以枚举到1次8 1次9 2次9 3次9 ） 2次8 1次9 2次9 3次9 ）3次8 1次9 2次9 3次9。。。依次类推可以枚举到全部的情况</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<span class="hljs-comment">//每一种方法拨三次</span><br>&#123;<br>movevec[si++] = k;<span class="hljs-comment">//记录拨钟方法和次数</span><br><span class="hljs-built_in">move</span>(k);<span class="hljs-comment">//拨钟</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br>si -= <span class="hljs-number">3</span>;<br><span class="hljs-built_in">move</span>(k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>cin &gt;&gt; ori[i];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;mi ; i++)<br>&#123;<br>cout &lt;&lt; showvec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2的幂次方表示"><a href="#2的幂次方表示" class="headerlink" title="2的幂次方表示"></a><a href="http://www.xmuoj.com/problem/GW104">2的幂次方表示</a></h1><p>递归  <del>呜呜 递归真的好抽象 难过 tllwtg和wegret怎么都说自然就会了</del></p><p><del>题目居然是图片 那就点链接了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 当n=1的时候怎么办？n=2的时候怎么办？n=其他数的时候怎么办？再把次方也递归一下（1次方要特判！！）</span><br><span class="hljs-comment">然后减去这个数，剩下的数再拆分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 1不可划分 直接输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2(0)&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-comment">// 2不可划分</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 其他数 可划分 </span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a * <span class="hljs-number">2</span> &lt;= n)<br>&#123;<br>a *= <span class="hljs-number">2</span>;<br>k++;<br>&#125;<br><span class="hljs-comment">// 分解次方</span><br><span class="hljs-comment">// 这个地方要特判  因为只剩一个2的时候就直接输出了 而不是把k=1再拿去递归</span><br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-built_in">mf</span>(k);<br>cout &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> x = n - a;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;+&quot;</span>;<br><span class="hljs-built_in">mf</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">mf</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直接用python写算了"><a href="#直接用python写算了" class="headerlink" title="直接用python写算了"></a>直接用python写算了</h2><h1 id="算24"><a href="#算24" class="headerlink" title="算24"></a><a href="http://www.xmuoj.com/problem/NQ079">算24</a></h1><p>回溯<br>熟悉了递归和深度优先搜索，小华知道现在是让小鲁综合运用所学知识的时候了，他让小鲁调整一道经典题：算24.</p><p>给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。</p><p>这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。</p><p>比如，对于5，5，5，1，我们知道5 * (5 – 1 &#x2F; 5) &#x3D; 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。</p><p>注意：输入数字的次序可以改变。</p><ul><li><p>输入<br>输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。</p></li><li><p>输出<br>对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;回溯，首先寻找结束条件，当等于24时退出递归，记得用绝对值和浮点数判断。</span><br><span class="hljs-string">然后基本思路时把每种组合的加减乘除都算一遍，如何储存状态？使用一个列表，每次选出两个数，进行四则</span><br><span class="hljs-string">运算，然后把剩余的没算的数也加进shengyu数组里面，递归运算。记得要回溯pop，还要排除b == 0的情况（被除数）。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">lis</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lis) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> math.fabs(lis[<span class="hljs-number">0</span>] - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">1e-6</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br><br>            <span class="hljs-keyword">if</span> i == j:<br>                <span class="hljs-keyword">continue</span><br><br>            a = lis[i]<br>            b = lis[j]<br>            shengyu = []<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>                <span class="hljs-keyword">if</span> k != i <span class="hljs-keyword">and</span> k != j:<br>                    shengyu.append(lis[k])<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            sum1 = a + b<br>            sub = a - b<br>            mul = a * b<br>            div = a / b<br>            left = [sum1, sub, mul, div]<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> left:<br>                shengyu.append(x)<br>                <span class="hljs-keyword">if</span> cal(shengyu):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                shengyu.pop()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">if</span> lis.count(<span class="hljs-number">0</span>) == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> cal(lis):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;YES&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="求排列的逆序数"><a href="#求排列的逆序数" class="headerlink" title="求排列的逆序数"></a><a href="http://www.xmuoj.com/problem/GW108">求排列的逆序数</a></h1><p>分治 递归</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-string">&quot;&quot;</span>&quot;<br>首先分治的思路分别来求逆序数，只在左半边的，只在右半边的和跨两边的。利用归并排序的模板，当左边<br>的数大于右边的时候，就是逆序数，由于归并排序已经排好了数，所以逆序数的个数为 mid - i + 1，<br>（mid右边的比i小）<br><span class="hljs-string">&quot;&quot;</span>&quot;<br><span class="hljs-keyword">n</span> = int(<span class="hljs-keyword">input</span>())<br>temp = [0 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">n</span>)]<br><span class="hljs-keyword">lis</span> = <span class="hljs-keyword">list</span>(map(int, <span class="hljs-keyword">input</span>().<span class="hljs-keyword">split</span>()))<br><span class="hljs-keyword">ret</span> = 0<br><br>def <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, r):<br>    <span class="hljs-keyword">global</span> <span class="hljs-keyword">ret</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">l</span> &gt;= r:<br>        <span class="hljs-keyword">return</span><br>    mid = (<span class="hljs-keyword">l</span> + r) &gt;&gt; 1<br>    <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, mid)<br>    <span class="hljs-keyword">merge</span>(mid + 1, r)<br>    i, j, k = <span class="hljs-keyword">l</span>, mid + 1, 0<br>    <span class="hljs-keyword">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">lis</span>[i] &lt;= <span class="hljs-keyword">lis</span>[j]:<br>            temp[k] = <span class="hljs-keyword">lis</span>[i]<br>            i += 1<br>            k += 1<br>        <span class="hljs-keyword">else</span>:<br>            temp[k] = <span class="hljs-keyword">lis</span>[j]<br>            j += 1<br>            k += 1<br>            <span class="hljs-keyword">ret</span> += mid - i + 1<br>    <span class="hljs-keyword">while</span> i &lt;= mid:<br>        temp[k] = <span class="hljs-keyword">lis</span>[i]<br>        i += 1<br>        k += 1<br>    <span class="hljs-keyword">while</span> j &lt;= r:<br>        temp[k] = <span class="hljs-keyword">lis</span>[j]<br>        j += 1<br>        k += 1<br><br>    j = 0<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">l</span>, r + 1):<br>        <span class="hljs-keyword">lis</span>[i] = temp[j]<br>        j += 1<br><br><span class="hljs-keyword">merge</span>(0, <span class="hljs-keyword">n</span> - 1)<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ret</span>)<br></code></pre></td></tr></table></figure><h1 id="海拉鲁城堡问题"><a href="#海拉鲁城堡问题" class="headerlink" title="海拉鲁城堡问题"></a><a href="http://www.xmuoj.com/problem/GW090">海拉鲁城堡问题</a></h1><p>深搜 位运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;因为需要找到所有房间中最大的，而一次搜索只能找一个房间的面积，可以遍历寻找未搜索过的房间。</span><br><span class="hljs-string">深搜和广搜选哪个，一看是找面积最大的本来想用广搜但是判断条件写出来可能会比深搜麻烦很多，所以还是用深搜。</span><br><span class="hljs-string">每次搜索之前，位运算判断该位是否可以走</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> sys<br>sys.setrecursionlimit(<span class="hljs-number">5000</span>)<br>N = <span class="hljs-number">100</span><br>row = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>col = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>lis = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>color = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>maxArea = <span class="hljs-number">0</span><br>maxRoom = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask3</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask4</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">8</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> maxArea, maxRoom<br>    <span class="hljs-keyword">if</span> color[a][b] != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    maxArea += <span class="hljs-number">1</span><br>    color[a][b] = maxRoom<br>    <span class="hljs-keyword">if</span> mask1(lis[a][b]):<br>        dfs(a, b - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask2(lis[a][b]):<br>        dfs(a - <span class="hljs-number">1</span>, b)<br>    <span class="hljs-keyword">if</span> mask3(lis[a][b]):<br>        dfs(a, b + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask4(lis[a][b]):<br>        dfs(a + <span class="hljs-number">1</span>, b)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>        lis[i][j+<span class="hljs-number">1</span>] = a[j]<br><br>retArea = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> color[i][j] == <span class="hljs-number">0</span>:<br>            maxArea = <span class="hljs-number">0</span><br>            maxRoom += <span class="hljs-number">1</span><br>            dfs(i, j)<br>            retArea = <span class="hljs-built_in">max</span>(retArea, maxArea)<br><br><span class="hljs-built_in">print</span>(maxRoom)<br><span class="hljs-built_in">print</span>(retArea)<br></code></pre></td></tr></table></figure><h1 id="英杰们的蛋糕塔"><a href="#英杰们的蛋糕塔" class="headerlink" title="英杰们的蛋糕塔"></a><a href="http://www.xmuoj.com/problem/GW092">英杰们的蛋糕塔</a></h1><p>深搜 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-comment">//宏定义简化</span><br>#define <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span> (r*r)<br>#define sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> (<span class="hljs-number">2</span>*r*h)<br>#define <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> ((r)*(r)*(h))<br>#define <span class="hljs-constructor">V2surArea(<span class="hljs-params">r</span>,<span class="hljs-params">v</span>)</span> (<span class="hljs-number">2</span>*v/(r))<br>#define INF <span class="hljs-number">0x7fffffff</span> <br><span class="hljs-built_in">int</span> N, V, minsurArea = INF;<br><span class="hljs-built_in">int</span> sumMinS<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>, sumMinV<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>;<br><br><span class="hljs-comment">// 搜索的主体是 枚举每一层的R H 寻找体积符合时 最小的表面积</span><br>void dfs(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> nr,<span class="hljs-built_in">int</span> nh,<span class="hljs-built_in">int</span> lv,<span class="hljs-built_in">int</span> cs)<br>&#123;<br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (lv<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>cs &lt; minsurArea)minsurArea = cs;<br>return;<br>&#125;<br><span class="hljs-comment">// 剪枝操作 1.当前剩余的体积小于上面累加起来最小的体积 说明已经不符合 </span><br><span class="hljs-comment">// 2.当前表面积加上上面的最小表面积 大于minsurArea 不符合</span><br><span class="hljs-comment">// 3.启发式剪枝 提前看到下一步的结果 当nr没到最后一层 并且 上一层的表面积加上当前累加的面积已经大于minsurArea 不符合</span><br><span class="hljs-keyword">if</span> (lv &lt; sumMinV<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>)return;<br><span class="hljs-keyword">if</span> (cs + sumMinS<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> &gt;= minsurArea)return;<br><span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">V2surArea(<span class="hljs-params">nr</span> - 1, <span class="hljs-params">lv</span>)</span> + cs &gt;= minsurArea)return;<br><br><span class="hljs-comment">//从最大层 （r最大） 到最小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = nr - <span class="hljs-number">1</span>; r &gt;= u; r--)<br>&#123;<br><span class="hljs-comment">// 当到达最高层的时候 让这一层的面积等于 底面积（后面是加上表面积 是每个都有的操作 </span><br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span>N)cs = <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>;<br><span class="hljs-comment">// 预处理出最大高度的最小值 （如果把当前剩余的体积 全部做成一层 除以当前的表面积 就是最大高度</span><br><span class="hljs-built_in">int</span> H_max = (<span class="hljs-number">1.0</span><span class="hljs-operator"> * </span>lv<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (H_max &gt; nh - <span class="hljs-number">1</span>)H_max = nh - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 枚举h</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = H_max; h &gt;= u; h--)<br>&#123;<br><span class="hljs-built_in">int</span> s = sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br><span class="hljs-built_in">int</span> v = <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br>dfs(u - <span class="hljs-number">1</span>, r, h, lv - v, cs + s);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>cin &gt;&gt; V &gt;&gt; N;<br><br><span class="hljs-comment">//预处理出 累加到每一层的最小的面积和体积 用于后面的剪枝</span><br>sumMinS<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>&#123;<br>sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + sur<span class="hljs-constructor">Area(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + <span class="hljs-constructor">Volume(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>&#125;<br><span class="hljs-comment">//预处理出 最下面一层的 R H的上界 减少计算</span><br><span class="hljs-built_in">int</span> maxH = (V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(N)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> maxR = sqrt(double((V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>) + <span class="hljs-number">1</span>));<br><br>dfs(N, maxR, maxH, V, <span class="hljs-number">0</span>);<span class="hljs-comment">//从最大的蛋糕往上搜索</span><br><span class="hljs-keyword">if</span> (minsurArea<span class="hljs-operator"> == </span>INF)<br>cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; minsurArea &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="击杀黄金蛋糕人马"><a href="#击杀黄金蛋糕人马" class="headerlink" title="击杀黄金蛋糕人马"></a><a href="http://www.xmuoj.com/problem/NQ090">击杀黄金蛋糕人马</a></h1><p>记忆化搜索 动态规划   </p><p>在海拉鲁大陆冒险，没有绝佳的剑法+想象力是不可能存活下来的。<br>这不，林克遇到了一个特别巨大的敌人——黄金蛋糕人马（莱尼尔的变种）<br>这黄金蛋糕人马长相非常特别，没有脚没有手没有嘴巴没有头，整个身材就是一个大矩形（喂喂，这不就是黄金莱尼尔吗？）<br>它的长和宽分别是整数w、h。<br>林克举起大师之剑，挥向黄金蛋糕人马，要将其切成m块矩形小块打包走，分给自己的朋友（每块都必须是矩形、且长和宽均为整数）。<br>大师之剑无比锐利，每一斩带出的剑气能将黄金蛋糕人马劈成两半（形成两个小矩形蛋糕）<br>经过m-1斩，黄金蛋糕人马居然被劈成m块小蛋糕（喂喂，你的想象力也太丰富了，明明切不开好吗？）<br>请计算：最后得到的m块小蛋糕中，最大的那块蛋糕的面积下限。<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 4，则下面的斩击可使得其中最大蛋糕块的面积最小。(十字斩)<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 3，则下面的斩击可使得其中最大蛋糕块的面积最小:.(二连斩)</p><ul><li>输入</li></ul><p>共有多行，每行表示一个测试案例。<br>每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh.<br>当 w &#x3D; h &#x3D; m &#x3D; 0 时不需要处理，表示输入结束。</p><ul><li>输出</li></ul><p>每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 记忆化搜索 储存已经搜过的值 下次需要时直接返回 储存的一般为搜索的值 dfs返回值一般定义为int（不为void）</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 原来的方法主要是分成左右两边的时候不好表示 </span><br><span class="hljs-comment">* 该方法dfs传入的是当前的方块的长和宽 分为左右两边（分治）枚举左右边切的位置 和左右边分别切的刀数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w, h, m;<br><span class="hljs-type">int</span> maxCake[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>][<span class="hljs-number">500</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当m为0的时候返回当前的面积</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> w * h;<br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-keyword">if</span> (maxCake[w][h][m])<span class="hljs-keyword">return</span> maxCake[w][h][m];<br><br><span class="hljs-type">int</span> a, b, ans = inf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; w; j++) <br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(j, h, i);<span class="hljs-comment">// 切m 刀的蛋糕是由切i刀和m - i - 1刀组成的   w - i 最后会反转 可以变量所有情况</span><br>b = <span class="hljs-built_in">dfs</span>(w - j, h, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<span class="hljs-comment">// 得到最大的蛋糕 取最小</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; h; j++)<br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(w, j, i);<br>b = <span class="hljs-built_in">dfs</span>(w, h - j, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br>&#125;<br>maxCake[w][h][m] = ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; h &gt;&gt; m)<br>&#123;<br><span class="hljs-keyword">if</span> (w == h &amp;&amp; h == m &amp;&amp; m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">dfs</span>(w, h, m - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">memset</span>(maxCake, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> maxCake);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滚石柱"><a href="#滚石柱" class="headerlink" title="滚石柱"></a><a href="http://www.xmuoj.com/problem/XMU023">滚石柱</a></h1><p>广搜 结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs arduino">广搜加上结构体表示物体的状态，主要难点就在于状态的表示。用结构体表示物体的状态，更新状<br>态时，用三维数组，增加的一维用来表示<span class="hljs-number">0</span>立着横着竖着<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> d[N][N][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> row, col;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State start, State end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; row &gt;&gt; col, row || col)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>cin &gt;&gt; g[i];<br><br>State start = &#123; <span class="hljs-number">-1</span> &#125;, end;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(start, end);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python速成笔记</title>
    <link href="/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python速成的一些学习笔记"><a href="#python速成的一些学习笔记" class="headerlink" title="python速成的一些学习笔记"></a>python速成的一些学习笔记</h1><p>什么？！你说python速成？-&gt;[<a href="https://oi.wiki/lang/python/">Python 速成 - OI Wiki</a>]</p><ul><li><p>pow函数可以实现快速幂</p></li><li><p>对Unicode的字符使用函数ord可以将其转换成对应的Unicode编码 逆向转换使用chr</p></li><li><p>字符串居然也可以用加和乘的运算 但是好像不能用减？ </p></li><li><p>字符串和列表都有方便的子串&#x2F;元素检测 in 如 a in str</p></li><li><p>字符串与列表的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">70</span>))            <br>lis = [<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num]           <br><span class="hljs-built_in">print</span>(lis)                  <br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(lis)                    <br><span class="hljs-built_in">print</span>(s)            <br></code></pre></td></tr></table></figure></li><li><p>二维[数组]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">via = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]                    <br><span class="hljs-built_in">print</span>(via)              <br>via[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>               <br><span class="hljs-built_in">print</span>(via)              <br></code></pre></td></tr></table></figure></li><li><p>使用NumPy建立多维数组和访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np      <br><br><span class="hljs-comment">#容量为3 未初始化       </span><br>lis = np.empty(<span class="hljs-number">3</span>)       <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#3*3 初始化为0      </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)     <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#整数数组       </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>, dtype=<span class="hljs-built_in">int</span>)      <br><span class="hljs-built_in">print</span>(lis.shape)        <br><span class="hljs-comment">#获取数组最大值         </span><br>np.<span class="hljs-built_in">max</span>(lis)     <br><span class="hljs-comment">#展平       </span><br>lis.flatten()       <br><span class="hljs-comment">#对每行排序 返回排序结果</span><br>np.sort(lis, axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#行方向原地排序</span><br>lis.sort(axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#浮点数输出</span><br>pi = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.4f&quot;</span> % pi)<br><span class="hljs-string">&quot;%.4f - %8f = %d&quot;</span> % (pi, <span class="hljs-number">0.1416</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">#输入</span><br>s = <span class="hljs-built_in">input</span>()<br>a = s.split()<br><span class="hljs-built_in">print</span>(a)<br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]<br><span class="hljs-comment">#或者</span><br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment">#固定输入</span><br>u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典</span><br>dic = &#123;&#125;<br>dic = &#123;<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>&#125;<br>dic1 = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">69</span>)&#125;<br><span class="hljs-comment"># 翻转</span><br>dic1 = &#123;dic1[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1&#125;<br><span class="hljs-built_in">print</span>(dic1)<br><span class="hljs-comment"># 要先判断才能打印</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">in</span> dic1:<br>    <span class="hljs-built_in">print</span>(dic1[<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-keyword">else</span>:<br>    dic1[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">98</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="更新！学了两个月之后再看一遍"><a href="#更新！学了两个月之后再看一遍" class="headerlink" title="更新！学了两个月之后再看一遍"></a>更新！学了两个月之后再看一遍</h1><ul><li><p>format() 输出浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br>formatted_pi = <span class="hljs-string">&quot;圆周率的近似值是 &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi)<br><span class="hljs-built_in">print</span>(formatted_pi)<br>:<span class="hljs-number">.2</span>f 是一个格式规范，它指定了要显示小数点后两位的浮点数<br><br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">20</span><br>result = <span class="hljs-string">&quot;x 的值是 &#123;&#125;，y 的值是 &#123;&#125;，它们的和是 &#123;&#125;。&quot;</span>.<span class="hljs-built_in">format</span>(x, y, x + y)<br><span class="hljs-built_in">print</span>(result)<br><br>name = <span class="hljs-string">&quot;Alice&quot;</span><br>age = <span class="hljs-number">30</span><br>message = <span class="hljs-string">f&quot;我的名字是 <span class="hljs-subst">&#123;name&#125;</span>，年龄是 <span class="hljs-subst">&#123;age&#125;</span>。&quot;</span><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><br><span class="hljs-comment"># 二维数组</span><br>mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>N = <span class="hljs-number">4</span>; mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>mat  <span class="hljs-comment"># 先按行读入二维数组</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*mat))   <br><span class="hljs-comment"># *将 mat 解包得到里层的多个列表</span><br><span class="hljs-comment"># zip() 将多个列表中对应元素聚合成元组，得到一个迭代器</span><br><span class="hljs-comment">## 内置函数 zip() 可以将多个等长序列中的对应元素拼接在「元组」内，得到新序列</span><br><span class="hljs-comment"># map(list, iterable) 将序列中的元素（这里为元组）转成列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u, v, w)  <span class="hljs-comment"># 直接将 map() 得到的迭代器拆包，分别赋值给 u, v, w</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dict</span><br>dic = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)&#125;<br>dic = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)], <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))<br><span class="hljs-comment"># 键值对逆转</span><br>dic = &#123;dic[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic&#125;<br>dic = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()&#125;  <span class="hljs-comment"># 和上行作用相同，dic.items() 以元组存放单个键值对</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dic.items(), key=<span class="hljs-keyword">lambda</span> x:-x[<span class="hljs-number">1</span>])&#125;  <span class="hljs-comment"># 字典按值逆排序，用到了 lambda 表达式</span><br></code></pre></td></tr></table></figure></li><li><p>装饰器</p><p>lru_cache转记忆化</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2023/07/22/My-first-blog/"/>
    <url>/2023/07/22/My-first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>做这个网站真的做了好久，教程确实很详细了，但是还是有些地方默认读者已经会了（我现在确实会了）。感谢tllwtg的帮助，没有tllwtg，就没有这个网站，呜呜。<br>tllwtg告诉我教程之后还帮我调了两次（&#x2F;跪谢）。</p><p>之后自己做的过程中也好多次感觉根本搞不出来，不想搞了。但是但是，这个好有意思，最后还是做出来了。tllwtg还跟我说做两三天是很正常的，我真的哭死。做完还是很开心的。<br>我也学到了好多东西，自己去看教程，搜资料，虽然会花很多时间，但是效果确实好欸，比如之前觉得很难的git的操作，，，一直不愿意去学（卧室蓝苟）最后也被迫学会了，<br>除了做网站本身，还学到好多其他的东西。效果比tllwtg直接帮我打出来好很多。（如果我那天不是删了重新做，而是让tllwtg帮我弄一下，我现在估计还是什么都不会&#x2F;难过）。</p><p>好！不当蓝苟从现在开始。（QQ机器人？好难，下次再说吧</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/22/hello-world/"/>
    <url>/2023/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
