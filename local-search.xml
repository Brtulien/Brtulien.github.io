<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图论入门题解</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="省份数量-547-省份数量-力扣（LeetCode）"><a href="#省份数量-547-省份数量-力扣（LeetCode）" class="headerlink" title="[省份数量](547. 省份数量 - 力扣（LeetCode）)"></a>[省份数量](<a href="https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory">547. 省份数量 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>cities = <span class="hljs-built_in">len</span>(isConnected)<br>        province = <span class="hljs-number">0</span><br>        vis = [<span class="hljs-number">0</span>] * cities<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[j] <span class="hljs-keyword">and</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    vis[j] = <span class="hljs-number">1</span><br>                    dfs(j)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                vis[i] = <span class="hljs-number">1</span><br>                province += <span class="hljs-number">1</span><br>                dfs(i)<br><br>        <span class="hljs-keyword">return</span> province<br>    <br>   <span class="hljs-comment"># 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 </span><br><span class="hljs-comment"># 重点在并查集的写法</span><br>uf = UnionFind()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(isConnected)):<br>            uf.add(i)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    uf.merge(i,j)<br>        <span class="hljs-keyword">return</span> uf.num_of_sets<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.father = &#123;&#125;<br>        self.num_of_sets = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self,x</span>):<br>        root = x<br>        <span class="hljs-keyword">while</span> self.father[root] != <span class="hljs-literal">None</span>:<br>            root = self.father[root]<br><span class="hljs-comment"># 让并查集更宽 减少时间复杂度</span><br>        <span class="hljs-keyword">while</span> x != root:<br>            original_father = self.father[x]<br>            self.father[x] = root<br>            x = original_father<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self,x,y</span>):<br>        root_x, root_y = self.find(x),self.find(y)<br><br>        <span class="hljs-keyword">if</span> root_x != root_y:<br>            self.father[root_x] = root_y<br>            self.num_of_sets -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.father:<br>            self.father[x] = <span class="hljs-literal">None</span><br>            self.num_of_sets += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）"><a href="#找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="[找到最终的安全状态](802. 找到最终的安全状态 - 力扣（LeetCode）)"></a>[找到最终的安全状态](<a href="https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory">802. 找到最终的安全状态 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2</span><br><span class="hljs-string">一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全</span><br><span class="hljs-string">&quot;&quot;&quot;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>n = <span class="hljs-built_in">len</span>(graph)<br>        color = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>            <span class="hljs-comment"># 访问已经搜过的结点 1为有环 2为无环</span><br>            <span class="hljs-keyword">if</span> color[x] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span><br>            <span class="hljs-comment"># 如果是0</span><br>            color[x] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-comment"># 快速退出</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> safe(y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True</span><br>            color[x] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>       <br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> safe(i)]<br>    <br>    <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的</span><br><span class="hljs-string">    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序</span><br><span class="hljs-string">    循环结束后 所有入度为0的结点都是安全的</span><br><span class="hljs-string">    意思是，原图的出度为0的结点，和指向出度为0的结点的结点</span><br><span class="hljs-string">    （由于存了反图并拓扑排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> graph]<br>        <span class="hljs-comment"># 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0</span><br>        <span class="hljs-keyword">for</span>  x, ys <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:<br>rg[y].append(x)<br>        <span class="hljs-comment"># in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）</span><br>        in_deg = [<span class="hljs-built_in">len</span>(ys) <span class="hljs-keyword">for</span> ys <span class="hljs-keyword">in</span> graph]<br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>])<br><span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rg[q.popleft()]:<br>                in_deg[x] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[x] == <span class="hljs-number">0</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i, d  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="颜色交替的最短路径"><a href="#颜色交替的最短路径" class="headerlink" title=" 颜色交替的最短路径 "></a><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory"> 颜色交替的最短路径 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestAlternatingPaths</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, redEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], blueEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> redEdges:<br>            g[x].append((y,<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> blueEdges:<br>            g[x].append((y,<span class="hljs-number">1</span>))<br>        <br><br>        dis = [-<span class="hljs-number">1</span>] * n<br>        vis = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        q = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> x, color <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">if</span> dis[x] == -<span class="hljs-number">1</span>:<br>                    dis[x] = level<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-keyword">if</span> p[<span class="hljs-number">1</span>] != color <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        vis.add(p)<br>                        q.append(p)<br>            level += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dis<br></code></pre></td></tr></table></figure><h1 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间 "></a><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/">通知所有员工所需的时间 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            g[manager[i]].append(i)<br><br>        q = collections.deque()<br>        q.append((headID, <span class="hljs-number">0</span>))<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tid, val = q.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g[tid]) == <span class="hljs-number">0</span>:<br>                res = <span class="hljs-built_in">max</span>(res, val)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> ne <span class="hljs-keyword">in</span> g[tid]:<br>                    q.append((ne, val + informTime[tid]))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="1466-重新规划路线-力扣（LeetCode）"><a href="#1466-重新规划路线-力扣（LeetCode）" class="headerlink" title="1466. 重新规划路线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory">1466. 重新规划路线 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> connections:<br>            g[a].append((b, <span class="hljs-number">1</span>))<br>            g[b].append((a, <span class="hljs-number">0</span>))<br>        <br>        q = deque([<span class="hljs-number">0</span>])<br>        vis = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">while</span> q:<br>            cur = q.popleft()<br>            <span class="hljs-comment"># 遍历所有和cur相邻的边</span><br>            <span class="hljs-keyword">for</span> end, dirction <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g[cur]):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[end]:<br>                    vis[end] = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果方向不对就反转</span><br>                    res += dirction<br>                    q.append(end)<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <br><span class="hljs-comment"># 或者 用set一次遍历  有点问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = &#123;<span class="hljs-number">0</span>&#125;<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> connection:<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> s:<br>                s.add(l)<br>            <span class="hljs-comment"># 右边不通向0 并且左边通向0 （左边通向右边） 那就让r-&gt;l r就可以到0</span><br>            <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">in</span> s:<br>                s.add(r)<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>                <br>        <br></code></pre></td></tr></table></figure><h1 id="1192-查找集群内的关键连接-力扣（LeetCode）"><a href="#1192-查找集群内的关键连接-力扣（LeetCode）" class="headerlink" title="1192. 查找集群内的关键连接 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory">1192. 查找集群内的关键连接 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环 （此时的curnode为入口结点）</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一题题解</title>
    <link href="/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5166-对称山脉-AcWing题库"><a href="#5166-对称山脉-AcWing题库" class="headerlink" title="5166. 对称山脉 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5169/">5166. 对称山脉 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])</span><br><span class="hljs-comment"># 用ans记录每个长度j下的最小值</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>s = [[<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5010</span>)]<br>ans = [<span class="hljs-number">0x3f3f3f3f</span>] * <span class="hljs-number">5010</span><br>h = [<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    h[i+<span class="hljs-number">1</span>] =  nums[i]   <br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n-j+<span class="hljs-number">2</span>):<br>        s[i][i + j - <span class="hljs-number">1</span>] = s[i + <span class="hljs-number">1</span>][i + j - <span class="hljs-number">2</span>] + <span class="hljs-built_in">abs</span>(h[i] - h[i + j - <span class="hljs-number">1</span>])<br>        ans[j] = <span class="hljs-built_in">min</span>(ans[j], s[i][i + j - <span class="hljs-number">1</span>])<br><br>ans[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[j],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="5180-正方形泳池-AcWing题库"><a href="#5180-正方形泳池-AcWing题库" class="headerlink" title="5180. 正方形泳池 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5183/">5180. 正方形泳池 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>tree = []<br>tree.append([-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 占位</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,t + <span class="hljs-number">1</span>):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    tree.append([a, b])<br><br>tree.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>tree.append([<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>])<br>tree.append([n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>tree.append([n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>])<br>t += <span class="hljs-number">4</span> <span class="hljs-comment"># 四个顶点插入树 树的个数要加上</span><br><br>ans = -<span class="hljs-number">1</span><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]) <span class="hljs-comment">#  对x排序</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]</span><br><span class="hljs-string">不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）</span><br><span class="hljs-string">更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    d, u = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> x - a - <span class="hljs-number">1</span> &gt; u - d - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, x - a - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> y &gt;= b:<br>            u = <span class="hljs-built_in">min</span>(u, y)<br>        <span class="hljs-keyword">if</span> y &lt;= b:<br>            d = <span class="hljs-built_in">max</span>(d, y)<br><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    l, r = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> y - b - <span class="hljs-number">1</span> &gt; r - l - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, y - b - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x &gt;= a:<br>            r = <span class="hljs-built_in">min</span>(r, x)<br>        <span class="hljs-keyword">if</span> x &lt;= a:<br>            l = <span class="hljs-built_in">max</span>(l, x)<br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="1654-到家的最少跳跃次数-力扣（LeetCode）"><a href="#1654-到家的最少跳跃次数-力扣（LeetCode）" class="headerlink" title="1654. 到家的最少跳跃次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BFS 搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumJumps</span>(<span class="hljs-params">self, forbidden: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q,vis = deque([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]), <span class="hljs-built_in">set</span>([<span class="hljs-number">0</span>])<br>        lower, upper = <span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(forbidden) + a, x) + b<br>        forbiddenSet = <span class="hljs-built_in">set</span>(forbidden)<br>        <span class="hljs-keyword">while</span> q:<br>            position, direction, step = q.popleft()<br>            <span class="hljs-keyword">if</span> x == position:<br>                <span class="hljs-keyword">return</span> step<br>            nextposition = position + a<br>            nextdirection = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                vis.add(nextposition * nextdirection)<br>                q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 不能两次退后</span><br>            <span class="hljs-keyword">if</span> direction == <span class="hljs-number">1</span>:<br>                nextposition = position - b<br>                nextdirection = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                    vis.add(nextposition * nextdirection)<br>                    q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="823-带因子的二叉树-力扣（LeetCode）"><a href="#823-带因子的二叉树-力扣（LeetCode）" class="headerlink" title="823. 带因子的二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-trees-with-factors/">823. 带因子的二叉树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = <span class="hljs-built_in">set</span>(arr)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">val</span>):<br>            ans = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> s:<br>                    ans += dfs(x) * dfs(val // x)<br>            <span class="hljs-keyword">return</span> ans<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(dfs(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>    <br><span class="hljs-comment"># 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        idx = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr)&#125;<br>        f = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                val = arr[i]<br>                x = arr[j]<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> idx:<br>                    f[i] += f[j] * f[idx[val // x]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(f) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br><br></code></pre></td></tr></table></figure><h1 id="1761-一个图中连通三元组的最小度数-力扣（LeetCode）"><a href="#1761-一个图中连通三元组的最小度数-力扣（LeetCode）" class="headerlink" title="1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/">1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次</span><br><span class="hljs-comment"># 用邻接矩阵来储存 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minTrioDegree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        degree = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> edges:<br>            x, y = x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span><br>            g[x][y] = g[y][x] = <span class="hljs-number">1</span><br>            degree[x] += <span class="hljs-number">1</span><br>            degree[y] += <span class="hljs-number">1</span><br>        <br>        ans = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                <span class="hljs-keyword">if</span> g[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, n):<br>                        <span class="hljs-keyword">if</span> g[i][k] == g[j][k] == <span class="hljs-number">1</span>:<br>                            ans = <span class="hljs-built_in">min</span>(ans, degree[i] + degree[j] + degree[k] - <span class="hljs-number">6</span>)<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ans == inf <span class="hljs-keyword">else</span> ans<br><br></code></pre></td></tr></table></figure><h1 id="5183-好三元组-AcWing题库"><a href="#5183-好三元组-AcWing题库" class="headerlink" title="5183. 好三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5186/">5183. 好三元组 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。</span><br><span class="hljs-string">所有情况为n * (n - 1) * (n - 2) // 6</span><br><span class="hljs-string">当三个数在同一点上时 不合规</span><br><span class="hljs-string">两个点在同一点上 不合规</span><br><span class="hljs-string">三个点在同一个半圆内时 不合规</span><br><span class="hljs-string">同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规</span><br><span class="hljs-string">所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1</span><br><span class="hljs-string">最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>N = <span class="hljs-number">2000100</span><br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>p = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>cnt = [<span class="hljs-number">0</span>] * N<br>s = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt[p[i - <span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    cnt[p[i - <span class="hljs-number">1</span>] + c] += <span class="hljs-number">1</span><br><br>res = n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br><br>s[<span class="hljs-number">0</span>] = cnt[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * c):<br>    s[i] = s[i - <span class="hljs-number">1</span>] + cnt[i]<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c):<br>    <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">continue</span><br>    t = cnt[i]<br>    d = s[i + c // <span class="hljs-number">2</span>] - s[i]<br>    <br>    <span class="hljs-comment"># 其实不需要判断也行</span><br>    <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">3</span>:<br>            res -= t * (t - <span class="hljs-number">1</span>) * (t - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br>        res -= t * (t - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * d<br>    res -= t * d * (d - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c // <span class="hljs-number">2</span>):<br>        u, v = cnt[i], cnt[i + c // <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">2</span>:<br>            res += u * (u - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * v<br>        <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">2</span>:<br>            res += v * (v - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * u<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="5145-同色环-AcWing题库"><a href="#5145-同色环-AcWing题库" class="headerlink" title="5145. 同色环 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5148/">5145. 同色环 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> nums[N][N];<br><span class="hljs-type">bool</span> vis[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> ox, <span class="hljs-type">int</span> oy)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx = x + dx[i];<br>        <span class="hljs-type">int</span> ny = y + dy[i];<br><br>        <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m<br>            <span class="hljs-comment">// 这一句的意思是 不能退回</span><br>            &amp;&amp; !(nx == ox &amp;&amp; ny == oy)<br>            <span class="hljs-comment">// 颜色相同</span><br>            &amp;&amp; nums[nx][ny] == nums[x][y])<br>        &#123;<br>            <span class="hljs-comment">// 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况</span><br>            <span class="hljs-keyword">if</span> (vis[nx][ny] || <span class="hljs-built_in">dfs</span>(nx, ny, x, y))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            cin &gt;&gt; nums[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i][j])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1921-消灭怪物的最大数量-力扣（LeetCode）"><a href="#1921-消灭怪物的最大数量-力扣（LeetCode）" class="headerlink" title="1921. 消灭怪物的最大数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03">1921. 消灭怪物的最大数量 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eliminateMaximum</span>(<span class="hljs-params">self, dist: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(dist)<br>        <span class="hljs-comment"># 上取整</span><br>        arrivetime = [math.ceil(dist[i] / speed[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>        arrivetime.sort()<br>        <span class="hljs-keyword">for</span> attacktime, arrivetime <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arrivetime):<br>            <span class="hljs-keyword">if</span> attacktime &gt;= arrivetime:<br>                <span class="hljs-keyword">return</span> attacktime<br>        <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure><h1 id="统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛"><a href="#统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛" class="headerlink" title="统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛"></a><a href="https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/">统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Counter 返回字典 每个元素是键 出现次数为值</span><br><span class="hljs-comment"># dfs</span><br><span class="hljs-comment"># 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        mx = -<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        keys = <span class="hljs-built_in">list</span>(c.keys())<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, count, add, mul</span>):<br>            <span class="hljs-keyword">nonlocal</span> mx, ans<br>            <span class="hljs-keyword">if</span> count == k:<br>                <span class="hljs-keyword">if</span> add &gt; mx:<br>                    mx = add<br>                    ans = mul<br>                <span class="hljs-keyword">elif</span> add == mx:<br>                    ans += mul<br>                ans %= Mod<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> i + k - count &gt; <span class="hljs-built_in">len</span>(keys):<br>                <span class="hljs-keyword">return</span><br>            dfs(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, add + c[keys[i]], mul * c[keys[i]] % Mod)<br>            dfs(i + <span class="hljs-number">1</span>, count, add, mul)<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-comment"># 数学</span><br><span class="hljs-comment"># 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> comb<br>            Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>            values = <span class="hljs-built_in">sorted</span>(c.values(), reverse=<span class="hljs-literal">True</span>)<br>            ans = <span class="hljs-number">1</span><br>            c = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                <span class="hljs-keyword">if</span> values[i] &gt; values[k - <span class="hljs-number">1</span>]:<br>                    ans *= values[i]<br>                    ans %= Mod<br>                <span class="hljs-keyword">elif</span> values[i] == values[k - <span class="hljs-number">1</span>]:<br>                    c += <span class="hljs-number">1</span><br>                    ans *= values[i]<br>                    ans %= Mod<br>            <span class="hljs-keyword">return</span> ans * comb(values.count(values[k - <span class="hljs-number">1</span>]),c) % Mod<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA</title>
    <link href="/2023/08/22/LCA/"/>
    <url>/2023/08/22/LCA/</url>
    
    <content type="html"><![CDATA[<p>·最近公共祖先</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python">root = <span class="hljs-number">1</span><br>num = <span class="hljs-number">0</span><br>dep = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000010</span><br>f = [[<span class="hljs-number">0</span>] * <span class="hljs-number">21</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br>head = [-<span class="hljs-number">1</span>] * <span class="hljs-number">10000010</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, to, <span class="hljs-built_in">next</span></span>):<br>self.to = to<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addedge</span>(<span class="hljs-params">from_,to</span>):<br><span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    e[num] = Edge(to, head[from_])<br>    head[from_] = num<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">v, father</span>):<br>dep[v] = dep[father] + <span class="hljs-number">1</span><br>    f[v][<span class="hljs-number">0</span>] = father<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):<br>        f[v][i] = f[f[v][i-<span class="hljs-number">1</span>]][i-<span class="hljs-number">1</span>]<br>        <br>    i = head[v]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        p1 = e[i].to<br>        <span class="hljs-keyword">if</span> p1 == father:<br>            i = e[i].<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        dfs(p1,v)<br>        i = e[i].<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-keyword">if</span> dep[x] &lt; dep[y]:<br>        x, y = y, x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dep[f[x][i]] &gt;= dep[y]:<br>            x = f[x][i]<br>         <span class="hljs-keyword">if</span> x == y:<br><span class="hljs-keyword">return</span> x<br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> f[x][i] != f[y][i]:<br>            x = f[x][i]<br>            y = f[y][i]<br>            <br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]<br><br><br>n, m, root = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>e = [Edge(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    addedge(u, v)<br>    addedge(v, u)<br><br><span class="hljs-comment"># 建立 LCA 预处理</span><br>dfs(root, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 查询 LCA</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    result = lca(x, y)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[x] = father;<br>de[x] = de[father] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i; i = edge[i].next)<br>&#123;<br><span class="hljs-keyword">if</span> (edge[i].to != father)<br>&#123;<br><span class="hljs-built_in">dfs</span>(edge[i].to, x);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (x != y)<br>&#123;<br><span class="hljs-keyword">if</span> (de[x] &gt;= de[y])<br>&#123;<br>x = fa[x];<br>&#125;<br><span class="hljs-keyword">else</span><br>y = fa[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lca</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论相关算法</title>
    <link href="/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>单源点最短路，不可判负权和环</p><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>cnt = <span class="hljs-number">0</span><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>ans = [INF] * (n + <span class="hljs-number">1</span>)<br>vis = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>edge = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>edge[i] = INF<br><br><span class="hljs-comment"># 初始化到s点的距离为0</span><br>ans[s] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 重边取最小</span><br>    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">in</span> edge:<br>edge[a][b] = <span class="hljs-built_in">min</span>(edge[a].get(b, INF), c)<br>    <span class="hljs-keyword">else</span>:<br>        edge[a] = &#123;b:c&#125;<br>pos = s<br><br><span class="hljs-comment"># pos 未遍历时</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vis[pos]:<br>    minn = INF<br>    <span class="hljs-comment"># 标记</span><br>    vis[pos] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># pos 顶点在边上时</span><br>    <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> edge:<br>        <span class="hljs-comment"># 取pos顶点指向的顶点（设为终点（有向图））和权值</span><br>        <span class="hljs-keyword">for</span> to, wei <span class="hljs-keyword">in</span> edge[pos].items():<br><span class="hljs-comment"># 如果终点未访问并且终点的值大于pos+wei 那就更新终点值的最短路</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[to] <span class="hljs-keyword">and</span> ans[to] &gt; ans[pos] + wei:<br>                ans[to] = ans[pos] + wei<br>        <span class="hljs-comment"># 遍历所有未遍历的点  如果小于minn 就更新minn（最短路） 并且让pos = i（最短子路）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i] <span class="hljs-keyword">and</span> ans[i] &lt; minn:<br>                minn = ans[i]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-comment"># 邻接矩阵</span><br>graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    graph[u].append((v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br><span class="hljs-comment"># 距离 初始化为无穷  源点初始化为0</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><span class="hljs-comment"># 先放入源点 第一个参数d表示源点s到当前结点的最短路   第二个参数node表示当前节点编号</span><br>q = [(<span class="hljs-number">0</span>,s)]<br><span class="hljs-comment"># 队列不空的时候</span><br><span class="hljs-keyword">while</span> q:<br><span class="hljs-comment"># 取出源点和起点</span><br>    d, node = heapq.heappop(q)<br>    <span class="hljs-comment"># 当当前最短路小于源点到node的距离时 跳过</span><br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br><span class="hljs-keyword">continue</span><br>    <span class="hljs-comment"># 从图中取出node结点的终点和权值</span><br>    <span class="hljs-keyword">for</span> neighbor, wei <span class="hljs-keyword">in</span> graph[node]:<br><span class="hljs-keyword">if</span> dist[node] + wei &lt; dist[neighbor]:<br>dist[neighbor] = dist[node] + wei<br>             heapq.heappush(q,(dist[neighbor],neighbor))<br>                <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>edge = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 判重</span><br>    exist = <span class="hljs-literal">False</span><br>    i = head[u]<br>    <span class="hljs-keyword">while</span> i:<br>        <span class="hljs-keyword">if</span> edge[i][<span class="hljs-number">0</span>] == v:<br>            exist = <span class="hljs-literal">True</span><br>            edge[i] = (v, <span class="hljs-built_in">min</span>(edge[i][<span class="hljs-number">1</span>],w), edge[i][<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">break</span><br>        i = edge[i][<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:<br>        edge.append((v,w,head[u]))<br>        head[u] = <span class="hljs-built_in">len</span>(edge) - <span class="hljs-number">1</span><br><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>priority_queue = [(<span class="hljs-number">0</span>,s)]<br><br><span class="hljs-keyword">while</span> priority_queue:<br>    d,node = heapq.heappop(priority_queue)<br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br>        <span class="hljs-keyword">continue</span><br>    i = head[node]<br>    <span class="hljs-keyword">while</span> i:<br>        neighbor, weight, nextt = edge[i]<br>        <span class="hljs-keyword">if</span> dist[node] + weight &lt; dist[neighbor]:<br>            dist[neighbor] = dist[node] + weight<br>            heapq.heappush(priority_queue, (dist[neighbor],neighbor))<br>        i = nextt<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p>单源点最短路，可判负权和环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v, w</span>):<br>        self.v = v<br>        self.w = w<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br><br>graph = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> graph[u] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> graph[u].w &gt; w:<br>graph[u] = []<br>    graph[u].append(edge(v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>q = deque([s])<br><br><span class="hljs-comment"># 标记是否在队列中  以及计数 用来判断环</span><br>in_queue = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>in_queue[s] = <span class="hljs-literal">True</span><br>enqueue_count = [<span class="hljs-number">0</span>]  * (n + <span class="hljs-number">1</span>)<br>enqueue_count[s] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">while</span> q:<br>    <span class="hljs-comment"># 取出当前点 </span><br>    node = q.popleft()<br>    in_queue[node] = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 取当前点相连的所有边</span><br>    <span class="hljs-keyword">for</span> ed <span class="hljs-keyword">in</span> graph[node]:<br>        <span class="hljs-comment"># 取出终点和权值</span><br>        v, w = ed.v, ed.w<br>    <span class="hljs-keyword">if</span> dist[v] &gt;  dist[node] + w:<br>            dist[v] = dist[node] + w<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> in_queue[v]:<br>                q.append(v)<br>                in_queue[v] = <span class="hljs-literal">True</span><br>                enqueue_count[v] += <span class="hljs-number">1</span><br>                <br>                <span class="hljs-keyword">if</span> enqueue_count[v] &gt; n:<br>                    exit(<span class="hljs-number">0</span>)<br>                    <br></code></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>多源最短路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x3f3f3f3f</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>d = [[INF] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][i] = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], w)<br>    <span class="hljs-comment"># 同时要更新另一条边</span><br>    d[b][a] = <span class="hljs-built_in">min</span>(d[b][a], w)<br>    <br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k] + d[k][j])<br>            <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(d[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="Kahn"><a href="#Kahn" class="headerlink" title="Kahn"></a>Kahn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Kahn算法</span><br><span class="hljs-keyword">from</span> collection <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = []<br>din = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-comment"># 每次从队列取出 让他所有出边减一 当某点入度为0时加入队列  如果最后队列长n则有拓扑序 否则有环</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>(<span class="hljs-params">n</span>):<br>queue = deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> din[i] == <span class="hljs-number">0</span>:<br>queue.append(i)<br>    <span class="hljs-keyword">while</span> queue:<br>        x = queue.popleft()<br>        tp.append(x)<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>            din[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> din[y] == <span class="hljs-number">0</span>:<br>queue.append(y)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp) == n<br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    e[a].append(b)<br>    din[b] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> toposort(n):<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tp:<br><span class="hljs-built_in">print</span>(x,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = [<span class="hljs-number">0</span>] * N<br>c = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> tp<br>    c[x] = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>        <span class="hljs-keyword">if</span> c[y] &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> c[y]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(y):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    c[x] = <span class="hljs-number">1</span><br>    tp.append(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>():<br>    <span class="hljs-keyword">global</span> c, tp<br>    c = [<span class="hljs-number">0</span>] * N<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c[i]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    tp.reverse()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入为字典</span><br>activities = &#123;&#125;<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    name, duration, dependencies = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    activities[name] = &#123;<span class="hljs-string">&#x27;duration&#x27;</span>:duration, <span class="hljs-string">&#x27;dependencies&#x27;</span>:dependencies&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_early_late_times</span>(<span class="hljs-params">activities</span>):<br>    <span class="hljs-comment"># 初始化每个工作的最早开始时间和最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-comment"># 计算最早开始时间</span><br>    <span class="hljs-comment"># 遍历所有工作 如果依赖于前一项工作 就为前面所有工作的最早开始时间加上持续时间的最大值 如果没有依赖于其他工作则为0</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            max_dependency_end = <span class="hljs-built_in">max</span>([activities[dep][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[dep][<span class="hljs-string">&#x27;duration&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = max_dependency_end<br><br>    <span class="hljs-comment"># 计算最后完成的工作的最晚开始时间 为所有工作的最晚的（最早开始时间+持续时间）</span><br>    end_activity = <span class="hljs-built_in">max</span>(activities,key=<span class="hljs-keyword">lambda</span> activity: activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>])<br>    activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[end_activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>    <span class="hljs-comment"># 反向计算最晚开始时间</span><br>    <span class="hljs-comment"># 如果不依赖于其他工作 最晚开始时间为最后工作的最晚开始时间-持续时间  否则为最早的最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">list</span>(activities.key())):<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] - activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            min_dependency_start = <span class="hljs-built_in">min</span>([activities[dep][<span class="hljs-string">&#x27;LS&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = min_dependency_start<br><br><br><span class="hljs-comment"># 最早开始时间=最晚开始时间即为关键路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_critical_path</span>(<span class="hljs-params">activities</span>):<br>    critical_path = []<br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        <span class="hljs-keyword">if</span> activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] == activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>]:<br>            critical_path.append(activity)<br>    <span class="hljs-keyword">return</span> critical_path<br></code></pre></td></tr></table></figure><h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><p><a href="https://leetcode.cn/problems/critical-connections-in-a-network/solutions/?envType=study-plan-v2&envId=graph-theory">例题</a></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution:<br>    def criticalConnections(self, n: int, connections: List<span class="hljs-comment">[List<span class="hljs-comment">[int]</span>]</span>) -&gt; List<span class="hljs-comment">[List<span class="hljs-comment">[int]</span>]</span>:<br>        graph = defaultdict(list)<br>        for con in connections:<br>            graph<span class="hljs-comment">[con<span class="hljs-comment">[0]</span>]</span>.append(con<span class="hljs-comment">[1]</span>)<br>            graph<span class="hljs-comment">[con<span class="hljs-comment">[1]</span>]</span>.append(con<span class="hljs-comment">[0]</span>)<br><br>        <br>        idx = <span class="hljs-comment">[-1]</span> * n<br>        res = <span class="hljs-comment">[]</span><br><br>        def dfs(curnode, curid, parent):<br>            idx<span class="hljs-comment">[curnode]</span> = curid<br><br>            for nextnode in graph<span class="hljs-comment">[curnode]</span>:<br>                if nextnode == parent:<br>                    continue<br>                elif idx<span class="hljs-comment">[nextnode]</span> == -1:<br>                    idx<span class="hljs-comment">[curnode]</span> = min(dfs(nextnode,curid + 1, curnode),idx<span class="hljs-comment">[curnode]</span>)<br>                else:<br>                    idx<span class="hljs-comment">[curnode]</span> = min(idx<span class="hljs-comment">[curnode]</span>,idx<span class="hljs-comment">[nextnode]</span>)<br><br>            # 说明存在环<br>            if idx<span class="hljs-comment">[curnode]</span> == curid and curnode != 0:<br>                res.append((parent, curnode))<br>            # 记得返回idx<br>            return idx<span class="hljs-comment">[curnode]</span><br>        <br><br>        dfs(0,0,-1)<br>        return res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树题解</title>
    <link href="/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1827-USACO3-4-美国血统-American-Heritage"><a href="#P1827-USACO3-4-美国血统-American-Heritage" class="headerlink" title="[P1827 USACO3.4] 美国血统 American Heritage"></a>[P1827 <a href="https://www.luogu.com.cn/problem/P1827">USACO3.4] 美国血统 American Heritage</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 其实就是前中序转后序 递归 当前序为空的时候退出，否则取前序的第一个为根，再中序中找左边为左子树，右边为右子树。注意前序中，左边的前k个就是左子树的，后面就是右子树的。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(string pre, string inor)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">char</span> root = pre[<span class="hljs-number">0</span>];<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-type">int</span> k = inor.<span class="hljs-built_in">find</span>(root);<br>string leftinor = inor.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightinor = inor.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 注意这里</span><br>string leftpre = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightpre = pre.<span class="hljs-built_in">substr</span>(k);<br><br><span class="hljs-built_in">change</span>(leftpre, leftinor);<br><span class="hljs-built_in">change</span>(rightpre, rightinor);<br><br>cout &lt;&lt; root;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string pre, inor;<br>cin &gt;&gt; inor &gt;&gt; pre;<br><span class="hljs-built_in">change</span>(pre, inor);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="449-序列化和反序列化二叉搜索树-力扣（LeetCode）"><a href="#449-序列化和反序列化二叉搜索树-力扣（LeetCode）" class="headerlink" title="449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br>    <span class="hljs-comment"># 序列化比较简单 就是一个后序遍历 注意最后的return部分 &#x27; &#x27;.join(map(str, arr)) 首先是&#x27;&#x27;要有空格 然后是map的用法 把arr转str</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            postOrder(root.left)<br>            postOrder(root.right)<br>            arr.append(root.val)<br>        postOrder(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,arr))<br>        <br><span class="hljs-comment"># 对于二叉搜索树来说 每个点的位置确定 所以比反序列化普通二叉树简单</span><br>    <span class="hljs-comment"># 首先把data还原成arr 当到达叶子节点的时候（也就是当前点不能插入这个地方）返回None    从arr中取出一个数作为跟 然后取出一个数作为右孩子 取出一个数作为左孩子 （后序遍历 先右再左）然后返回根   注意 初始的时候不限范围  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, data.split()))<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">lower,upper</span>):<br>            <span class="hljs-keyword">if</span> arr == [] <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &lt; lower <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &gt; upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            val = arr.pop()<br>            root = TreeNode(val)<br>            root.right = construct(val, upper)<br>            root.left = construct(lower,val)<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> construct(-inf,inf)<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化-力扣（LeetCode）"><a href="#297-二叉树的序列化与反序列化-力扣（LeetCode）" class="headerlink" title="297. 二叉树的序列化与反序列化 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(root.val) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.left)) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.right)) <br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">dataList</span>):<br>            val = dataList.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> val == <span class="hljs-string">&#x27;None&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            root = TreeNode(<span class="hljs-built_in">int</span>(val))<br>            root.left = dfs(dataList)<br>            root.right = dfs(dataList)<br>            <span class="hljs-keyword">return</span> root<br>        dataList = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">return</span> dfs(dataList)<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树</title>
    <link href="/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><a href="https://www.luogu.com.cn/problem/P3369">平衡树</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, p, val;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> s[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> siz;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>cnt = siz = <span class="hljs-number">1</span>;<br>p = p1, v = v1;<br>&#125;<br>&#125;tree[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-comment">// 更新树的大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 旋转 旋转不仅使得x转到y处，x的其中一个儿子也要给y</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找到x的父节点y和y的父节点z，k判断x是否为y的右儿子 假设x为y的右儿子 k为1</span><br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = tree[y].s[<span class="hljs-number">1</span>] == x;<br><span class="hljs-comment">// 先转动使 y的右儿子处放上x的左儿子 然后让x的左儿子的父节点为y</span><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><span class="hljs-comment">// 然后使x的右儿子为y，y的父亲为x</span><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><span class="hljs-comment">// 如果z的右儿子为y 那么z的右儿子为x （x替代y） 然后x的父亲为z</span><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><span class="hljs-comment">//记得更新节点</span><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-comment">// splay 伸展结点，使x为k的儿子  k为0的时候使x为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br>        <span class="hljs-comment">// 当x的祖父结点不为k的时候 旋转</span><br><span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-comment">// y的左儿子为x 并且z的左儿子为y 也就是直线型 转动y（1^1=0） 折线型转动x</span><br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-comment">// 再转一次（双旋</span><br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br>    <span class="hljs-comment">// k为0的时候 让x为根</span><br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><span class="hljs-comment">// 查找v并让v为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 找前驱 先找到v 然后如果根的值小于v，直接返回x，因为比根大，不可能有前驱了（前驱是比）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br><span class="hljs-comment">// 根节点的左子树的最大结点就是前驱</span><br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>]) x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 找后继 同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br><br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 删除 并不是真的结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找前驱和后继</span><br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v);<br><span class="hljs-type">int</span> suc = <span class="hljs-built_in">get_suc</span>(v);<br><span class="hljs-comment">// 转动前驱到根，转动后继为前驱的儿子，就是逻辑上的删除了该结点（此时待删除结点为后继的左儿子）</span><br><span class="hljs-built_in">splay</span>(pre, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(suc, pre);<br>    <span class="hljs-comment">// 后继的左儿子设为del（即待删除的点）</span><br><span class="hljs-type">int</span> del = tree[suc].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[del].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">// 如果待删点不止一个，只删除一个并把他放回到根结点</span><br>tree[del].cnt--, <span class="hljs-built_in">splay</span>(del, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 后继的左儿子为0 即删除了待删除结点</span><br>tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">splay</span>(suc, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">return</span> tree[tree[root].s[<span class="hljs-number">0</span>]].siz;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[y].siz + tree[x].cnt &lt; k)<br>&#123;<br>k -= tree[y].siz + tree[x].cnt;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[y].siz &gt;= k)x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> tree[x].v;<br>&#125;<br><span class="hljs-comment">// 插入结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; tree[x].v != v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br>    <span class="hljs-comment">// 转动新插入的结点为根</span><br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意先插入哨兵</span><br><span class="hljs-built_in">insert</span>(-INF), <span class="hljs-built_in">insert</span>(INF);<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; p &gt;&gt; val;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>)<span class="hljs-built_in">insert</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">2</span>)<span class="hljs-built_in">del</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">3</span>)cout &lt;&lt; <span class="hljs-built_in">get_rank</span>(val) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">4</span>)cout &lt;&lt; <span class="hljs-built_in">get_val</span>(val + <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">5</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_pre</span>(val)].v &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">6</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_suc</span>(val)].v &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91rotate.png" alt="rotate"></p><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91splay.png" alt="splay"></p><h2 id="flag-写个python版的！"><a href="#flag-写个python版的！" class="headerlink" title="flag 写个python版的！"></a><del>flag</del> 写个python版的！</h2><h2 id="例题-营业额统计"><a href="#例题-营业额统计" class="headerlink" title="例题  营业额统计"></a>例题  <a href="https://www.luogu.com.cn/problem/P2234">营业额统计</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>, root;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>, N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> v, s[<span class="hljs-number">2</span>], cnt, siz, p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>v = v1, p = p1;<br>cnt = siz = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;tree[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = (tree[y].s[<span class="hljs-number">1</span>] == x);<br><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-keyword">if</span> (z != k)<br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; v != tree[x].v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>])x = tree[x].s[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span> (tree[root].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v), suc = <span class="hljs-built_in">get_suc</span>(v);<br><br><span class="hljs-type">int</span> a = tree[pre].v, b = tree[suc].v;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - v) &lt; <span class="hljs-built_in">fabs</span>(b - v) ? <span class="hljs-built_in">fabs</span>(a - v) : <span class="hljs-built_in">fabs</span>(b - v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">insert</span>(INF), <span class="hljs-built_in">insert</span>(-INF);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; x;<br><span class="hljs-built_in">insert</span>(x);<br><span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>ret += <span class="hljs-built_in">search</span>(x);<br><span class="hljs-keyword">else</span> ret += x;<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h2><h3 id="几个需要注意的地方"><a href="#几个需要注意的地方" class="headerlink" title="几个需要注意的地方"></a>几个需要注意的地方</h3><ul><li>Node的siz和cnt需要设置为0 而不是1  在申请结点之后设置为1</li><li>idx需要自增（C++转python的时候 由于++idx并不是放在单独的一句，写的时候容易漏掉</li><li>idx自增之后x &#x3D; idx即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.s = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-comment"># son</span><br>        self.p = <span class="hljs-number">0</span> <span class="hljs-comment"># parent</span><br>        self.v = key <span class="hljs-comment"># val</span><br>        self.cnt = <span class="hljs-number">0</span><br>        self.siz = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SplayTree</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.N = <span class="hljs-number">100010</span><br>        self.INF = <span class="hljs-number">0x7fffffff</span><br>        self.tree = [Node(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N)]<br>        self.root = <span class="hljs-number">0</span><br>        self.idx = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 更新树的大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pushup</span>(<span class="hljs-params">self, x</span>):<br>        self.tree[x].siz = self.tree[self.tree[x].s[<span class="hljs-number">0</span>]].siz + self.tree[self.tree[x].s[<span class="hljs-number">1</span>]].siz + self.tree[x].cnt<br><br>    <span class="hljs-string">&quot;&quot;&quot;旋转操作 </span><br><span class="hljs-string">    首先得到x的父节点y和y的父节点z，用k来表示左旋和右旋（如果x在y的左子树右旋，x在y的右子树左旋）</span><br><span class="hljs-string">    以右旋为例 k为0</span><br><span class="hljs-string">    首先让y的左子树放上x的右子树 同时x的右子树的父亲设置为y</span><br><span class="hljs-string">    然后让x的右子树放上y 同时y的父亲设为x</span><br><span class="hljs-string">    最后让z的右子树放上x 同时x的父亲设为z</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    更新x y结点树的大小</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, x</span>):<br>        y = self.tree[x].p<br>        z = self.tree[y].p<br>        k = self.tree[y].s[<span class="hljs-number">1</span>] == x<br><br>        self.tree[y].s[k] = self.tree[x].s[k ^ <span class="hljs-number">1</span>]<br>        self.tree[self.tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y<br><br>        self.tree[x].s[k ^ <span class="hljs-number">1</span>] = y<br>        self.tree[y].p = x<br><br>        self.tree[z].s[self.tree[z].s[<span class="hljs-number">1</span>] == y] = x<br>        self.tree[x].p = z<br><br>        self.pushup(y)<br>        self.pushup(x)<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    splay 使x为k的儿子 有三种情况 </span><br><span class="hljs-string">    k是根 做单旋  </span><br><span class="hljs-string">    k不是根 直线型 做双旋 </span><br><span class="hljs-string">    k不是根 折线形 做双旋</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    先不断向上找x的父节点 当不为k时继续循环：取出父节点y和祖先结点z 如果z不是x的祖先就旋转 </span><br><span class="hljs-string">    当为直线型的时候（用^判断）转x  折线形转y   最后还要再转一下x 双旋（y是根的时候只会转一次x）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    如果k为0 表示k为根节点 要设置x为根</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">splay</span>(<span class="hljs-params">self, x, k</span>):<br>        <span class="hljs-keyword">while</span> self.tree[x].p != k:<br>            y = self.tree[x].p<br>            z = self.tree[y].p<br>            <span class="hljs-keyword">if</span> z != k:<br>                <span class="hljs-keyword">if</span> (self.tree[y].s[<span class="hljs-number">0</span>] == x) ^ (self.tree[z].s[<span class="hljs-number">0</span>] == y):<br>                    self.rotate(x)<br>                <span class="hljs-keyword">else</span>:<br>                    self.rotate(y)<br>            self.rotate(x)<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            self.root = x<br><br>    <span class="hljs-comment"># 树的查找 找到之后要把x设为根（splay）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> self.tree[x].s[v &gt; self.tree[x].v] <span class="hljs-keyword">and</span> v != self.tree[x].v:<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        self.splay(x, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    找前驱 由于find是找到v且当v不存在时找到的是最接近v的值并将其设置为根</span><br><span class="hljs-string">    当该结点小于v的时候直接返回 否则返回他的左子树的最右边的值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pre</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &lt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">1</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_suc</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &gt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">0</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    删除结点，并非真的删除，而是让他访问不到</span><br><span class="hljs-string">    先取出v的前驱和后继结点 并splay</span><br><span class="hljs-string">    设删除结点为del_node 如果出现次数大于1 就减一并splay del_node 否则splay 后继结点</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, v</span>):<br>        pre = self.get_pre(v)<br>        suc = self.get_suc(v)<br>        self.splay(pre, <span class="hljs-number">0</span>)<br>        self.splay(suc, pre)<br>        del_node = self.tree[suc].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> self.tree[del_node].cnt &gt; <span class="hljs-number">1</span>:<br>            self.tree[del_node].cnt -= <span class="hljs-number">1</span><br>            self.splay(del_node, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            self.splay(suc, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># v的排位即v为根的时候v的左子树大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rank</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        <span class="hljs-keyword">return</span> self.tree[self.tree[self.root].s[<span class="hljs-number">0</span>]].siz<br><br>    <span class="hljs-comment"># k位的值 不断找到x的左子树 如果左子树的siz加x的cnt大于k 就往左子树走 否则就让k减去他们俩的和并往右子树走</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_val</span>(<span class="hljs-params">self, k</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            y = self.tree[x].s[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> self.tree[y].siz + self.tree[x].cnt &lt; k:<br>                k -= self.tree[y].siz + self.tree[x].cnt<br>                x = self.tree[x].s[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.tree[y].siz &gt;= k:<br>                    x = self.tree[x].s[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>        self.splay(x,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.tree[x].v<br><br>    <span class="hljs-comment"># 插入操作 先取出根节点 父节点为0 不断向下递归找到x的插入位置  找到之后 如果该结点已经存在 就让cnt+1 否则创建新节点（idx+1 p的儿子为x 初始化x</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> x <span class="hljs-keyword">and</span> self.tree[x].v != v:<br>            p = x<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        <span class="hljs-keyword">if</span> x:<br>            self.tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 注意 这里的idx要先++</span><br>            self.idx += <span class="hljs-number">1</span><br>            x = self.idx<br>            self.tree[p].s[v &gt; self.tree[p].v] = x<br>            self.tree[x].p = p<br>            self.tree[x].v = v<br>            self.tree[x].cnt = <span class="hljs-number">1</span><br>            self.tree[x].siz = <span class="hljs-number">1</span><br>        self.splay(x, <span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st = SplayTree()<br>    st.insert(-st.INF)<br>    st.insert(st.INF)<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        p, val = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:<br>            st.insert(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">2</span>:<br>            st.delete(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">print</span>(st.get_rank(val))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">print</span>(st.get_val(val + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_pre(val)].v)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_suc(val)].v)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二叉树</title>
    <link href="/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><a href="https://www.luogu.com.cn/problem/P5076">二叉搜索树</a></h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> cont = <span class="hljs-number">0</span>; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span><br>&#123;<br><span class="hljs-type">int</span> ls, rs, val, cnt, siz;<br>&#125;tree[<span class="hljs-number">1000010</span>];<br><br><span class="hljs-type">int</span> n,q,val;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz++;<span class="hljs-comment">// 首先，插入的这个结点的siz++</span><br><span class="hljs-comment">// 如果已经有这个结点，就cnt++，因为搜索树中不能有重复结点</span><br><span class="hljs-keyword">if</span> (val == tree[x].val)<br>&#123;<br>tree[x].cnt++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (val &lt; tree[x].val)<br>&#123;<br>        <span class="hljs-comment">// 到最左边</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">// 开辟新结点并赋值</span><br>cont++;<br>tree[cont].val = val;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[x].ls = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].ls, val);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>tree[x].rs = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].rs, val);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 找前驱</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryfr</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果小于当前结点</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt;= val)<br>&#123;<br>        <span class="hljs-comment">// 找到最左边了，直接返回ans</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//不然就继续找</span><br><span class="hljs-built_in">queryfr</span>(tree[x].ls, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &gt; val ? ans : tree[x].val;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">queryfr</span>(tree[x].rs, val, tree[x].val);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// 找后继</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryne</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (tree[x].val &lt;= val)<br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].rs, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &lt; ans ? tree[x].val : ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].ls, val, tree[x].val);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 找val的排位</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 没找到就返回0，当找到最后还没有找到的时候，就会走到ls或rs==0，赋值给x，就会从这里退出</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 找到了就返回，当前这个结点的左子树的长度</span><br><span class="hljs-keyword">if</span> (tree[x].val == val)<br><span class="hljs-keyword">return</span> tree[tree[x].ls].siz;<br>    <span class="hljs-comment">// 如果小于当前结点的值，往左</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].ls, val);<br>    <span class="hljs-comment">// 往右的时候要先减掉左子树和自身的值</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].rs, val) + tree[tree[x].ls].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 找排位为rk的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertrk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> rk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// rk索引越界</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> INF;<br><span class="hljs-comment">// 左子树大于rk，说明在左子树里面找</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz &gt;= rk)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].ls, rk);<br>    <span class="hljs-comment">// 左子树+cnt大于rk，说明就是当前的val</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz + tree[x].cnt &gt;= rk)<br><span class="hljs-keyword">return</span> tree[x].val;<br>    <span class="hljs-comment">// 否则在右子树，要先减掉左子树和cnt</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].rs, rk - tree[tree[x].ls].siz - tree[x].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; q &gt;&gt; val;<br><span class="hljs-keyword">switch</span> (q)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertval</span>(<span class="hljs-number">1</span>, val) + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertrk</span>(<span class="hljs-number">1</span>, val) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">queryfr</span>(<span class="hljs-number">1</span>, val, -INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout &lt;&lt; <span class="hljs-built_in">queryne</span>(<span class="hljs-number">1</span>, val, INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-comment">//特判根节点</span><br><span class="hljs-keyword">if</span> (cont == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, val);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="这个小伙居然还用python写了一遍"><a href="#这个小伙居然还用python写了一遍" class="headerlink" title="这个小伙居然还用python写了一遍"></a><del>这个小伙居然还用python写了一遍</del></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x7fffffff</span><br>cont = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,val=<span class="hljs-number">0</span>,siz=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ls=<span class="hljs-number">0</span>,rs=<span class="hljs-number">0</span></span>):<br>        self.val = val<br>        self.siz = siz<br>        self.cnt = cnt<br>        self.ls = ls<br>        self.rs = rs<br><br><br><span class="hljs-comment"># 神奇的方法</span><br>tree = [Node() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,v</span>):<br>    <span class="hljs-keyword">global</span> cont,tree<br>    tree[x].siz += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> tree[x].val == v:<br>        tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> tree[x].val &gt; v:<br>        <span class="hljs-keyword">if</span> tree[x].ls != <span class="hljs-number">0</span>:<br>            add(tree[x].ls,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].ls = cont<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs != <span class="hljs-number">0</span>:<br>            add(tree[x].rs,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].rs = cont<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryfr</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &gt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].ls,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &lt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].rs,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x],val,ans)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryne</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &lt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].rs,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &gt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-comment"># 这里有点多余</span><br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls, val,ans)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryrk</span>(<span class="hljs-params">x,rk</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> INF<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz &gt;= rk:<br>        <span class="hljs-keyword">return</span> queryrk(tree[x].ls,rk)<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz + tree[x].cnt &gt;= rk:<br>        <span class="hljs-keyword">return</span> tree[x].val<br>    <span class="hljs-keyword">return</span> queryrk(tree[x].rs,rk - tree[tree[x].ls].siz-tree[x].cnt)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryval</span>(<span class="hljs-params">x,val</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> val == tree[x].val:<br>        <span class="hljs-keyword">return</span> tree[tree[x].ls].siz<br>    <span class="hljs-keyword">if</span> val &lt; tree[x].val:<br>        <span class="hljs-keyword">return</span> queryval(tree[x].ls,val)<br>    <span class="hljs-keyword">return</span> queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt<br><br><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    q,v = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    <span class="hljs-keyword">if</span> q == <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">if</span> cont == <span class="hljs-number">0</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span><br>            tree[cont].val = v<br>        <span class="hljs-keyword">else</span>:<br>            add(<span class="hljs-number">1</span>,v)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(queryval(<span class="hljs-number">1</span>,v)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(queryrk(<span class="hljs-number">1</span>,v))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(queryfr(<span class="hljs-number">1</span>,v,-INF))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(queryne(<span class="hljs-number">1</span>,v,INF))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex学习</title>
    <link href="/2023/08/02/latex%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/latex%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li><p>首先\documentclass[UTF8]{ctexart}</p><p>….(宏包)</p><p>\begin{document}</p><p>……</p><p>\end{document}</p></li><li><p>行内要用$$括起来 行间要用$$$$括起来</p></li><li><p>公式对齐 不同的环境语法不同 eqnarray是&amp;&#x3D;&amp;；align是&amp;&#x3D;</p></li><li><p>分段函数  cases环境  使用&amp; 对齐  \\换行</p></li><li><p>矩阵 array begin后面加{ccc}表示格式  需要$$$$和自己加括号</p></li><li><p>要表示带省略号的矩阵 用pmatrix环境</p></li><li><p>表格 数字表格即矩阵加|，带汉字的要使用tabular环境。表格的横线为\hline</p></li><li><p>插图 \includegraphics[scale&#x3D;<em>] [width&#x3D;</em>][height&#x3D;*]{.png}</p><p>或使用\figure环境</p><p>\begin{figure}[H]</p><p> \centering</p><p> % Requires \usepackage{graphicx}</p><p> \includegraphics[width&#x3D;12pt]{.png}\</p><p> \caption{图1}</p><p>\end{figure}</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab学习</title>
    <link href="/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>部分表</li></ul><table><thead><tr><th><strong>help</strong></th><th>帮助查询</th></tr></thead><tbody><tr><td><strong>clc</strong></td><td>删除命令窗口的内容（已使用过的命令）</td></tr><tr><td><strong>clear</strong></td><td>删除内存中的变量（数据）</td></tr><tr><td><strong>clf</strong></td><td>删除图形窗口的内容</td></tr><tr><td><strong>who</strong></td><td>列出在MATLAB工作空间中已有的变量</td></tr><tr><td><strong>whos</strong></td><td>列出驻留变量的同时,还给出维数及性质</td></tr><tr><td><strong>home</strong></td><td>光标移到命令窗口的左上角</td></tr><tr><td><strong>↑</strong></td><td>调出刚才使用过的命令</td></tr><tr><td><strong>quit</strong></td><td>退出MATLAB</td></tr></tbody></table><table><thead><tr><th>r</th><th>红色</th><th>-</th><th>实线</th></tr></thead><tbody><tr><td>g</td><td>绿色</td><td>–</td><td>虚线</td></tr><tr><td>b</td><td>蓝色</td><td>:</td><td>点线</td></tr><tr><td>y</td><td>黄色</td><td>-.</td><td>点划线</td></tr><tr><td>m</td><td>洋红色</td><td>o</td><td>圆圈</td></tr><tr><td>c</td><td>青色</td><td>x</td><td>叉号</td></tr><tr><td>w</td><td>白色</td><td>+</td><td>加号</td></tr><tr><td>k</td><td>黑色</td><td>s</td><td>正方形</td></tr><tr><td>*</td><td>星号</td><td>d</td><td>菱形</td></tr><tr><td>v</td><td>向下三角</td><td>^</td><td>向上三角</td></tr><tr><td>.</td><td>点号</td><td>h</td><td>六角形</td></tr></tbody></table><ul><li><p>首先注意和数字运算的时候运算符要加点</p></li><li><p>axis([])设置坐标轴范围</p></li><li><p>grid on 显示网格线 title显示标题 xlabel标记x轴 legend添加图例</p></li></ul><h2 id="plot-x-y-’color-style-marker’-绘制图像"><a href="#plot-x-y-’color-style-marker’-绘制图像" class="headerlink" title="plot(x,y,’color-style-marker’)绘制图像"></a>plot(x,y,’color-style-marker’)绘制图像</h2><ul><li><p>选点：x &#x3D; linspace(0,1,100)  也可以使用x &#x3D; a : step : b</p><p>y1 &#x3D; linspace(0,1,100) 选择对应的点 plot(x,y,’r’) 需要保证是同维的</p><p>也可以使用解析式的方式，先确定x的范围，然后用x表示y即可，但是要注意表示的各个符号是否加点。</p><p>例：y &#x3D; -0,0234 * x + 1.2551 * x .^(2&#x2F;3)   y &#x3D; sin(x) </p></li><li><p>三维图像 plot3 用来绘制一组三维曲线  需要保证是同维的   </p><p> mesh 用来绘制三维曲面的网格线图 先选点 然后 [X,Y] &#x3D; meshgrid(x,y) Z &#x3D;  X.^2+Y.^2 最后mesh(X,Y,Z)\</p></li><li><p>如果想要画圆圈和连线那就是plot(x,a,’o’,x,a)  ‘bo’是蓝色圆圈</p><p> 前一个xa画圆圈（散点）后一个xa画直线</p></li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><p>solve 解线性方程组 使用前要定义变量 syms a b x …</p><p>S &#x3D; solve(方程，变量（默认x)  </p><p>[a,b] &#x3D; solve(90* a + 90^(2&#x2F;3)<em>b&#x3D;&#x3D;23.1,180</em>a+180^(2&#x2F;3)*b &#x3D;&#x3D; 35.8)</p></li></ul><h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><ul><li><p>for i &#x3D; n1:(step):n2</p><p>commands;</p><p>end</p></li><li><p>while …</p></li></ul><p>  commands;</p><p>  end</p><ul><li><p>if…</p><p>elseif…</p><p>else…</p><p>end</p></li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>function [x,y,z] &#x3D; f1(a,b)</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>csape(x,y,’compelete’,[-1,0])</p><p>complete代表通过给定数据点的完全样条函数 </p><p>[-1,0]表示一阶导数的边界</p>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表题解</title>
    <link href="/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><del>超，格式怎么这样了，下次再改</del></p><h1 id="妖梦拼木棒"><a href="#妖梦拼木棒" class="headerlink" title="妖梦拼木棒"></a><a href="https://www.luogu.com.cn/problem/P3799">妖梦拼木棒</a></h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>上道题中，妖梦斩了一地的木棒，现在她想要将木棒拼起来。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？</p><p>答案对 $10^9+7$ 取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$。</p><p>第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数代表答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $n \le 5 \times 10^3$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。</li></ul><p>一开始想错了，导致后面也被带偏。必须要两只一样长的木棒，剩下两个只需要和跟另外两个一样长就行了。并不需要相等长度，（想错，导致之后改错）其实也并不需要一开始的两只相等长度，比如7 7 2 +5这样。然后就是简单的组合数学</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">5001</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>nums[x]++;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">2</span>)<br>&#123;<br>a = nums[i] * (nums[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> == i &amp;&amp; nums[j] &gt;= <span class="hljs-number">2</span>)cnt += a * (nums[j] * (nums[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod) % mod;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> != i &amp;&amp; nums[j] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i - j] &gt;= <span class="hljs-number">1</span>)cnt += a * ((nums[j] * nums[i - j]) % mod) % mod;<br>&#125;<br>cnt %= mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; cnt % mod &lt;&lt; endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="kkksc03考前临时抱佛脚"><a href="#kkksc03考前临时抱佛脚" class="headerlink" title="kkksc03考前临时抱佛脚"></a><a href="https://www.luogu.com.cn/problem/P2392">kkksc03考前临时抱佛脚</a></h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">20<br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><p>本来是贪心+模拟。。但是有几个过不了，大概是情况没考虑全。btw别人想的都是把题目分成尽量平均的两部分啊。（模拟不是下意识就出来了吗，窝好菜</p><p>用dp求尽量平均的两部分，即01背包问题，分到左边和分到右边，状态表示为二维，集合为到j的时候的体积，状态计算为给左大脑和给右大脑，此处视左大脑为背包1，右大脑为0，放到让左边为1&#x2F;2总体积。每道题的时间既是价值，也是体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2000</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>)]<br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>            f[j][k] = f[j - <span class="hljs-number">1</span>][k]<br>            <span class="hljs-keyword">if</span> k &gt;= nums[j]:<br>                f[j][k] = <span class="hljs-built_in">max</span>(f[j][k],f[j - <span class="hljs-number">1</span>][k - nums[j]] + nums[j])<br>            t = <span class="hljs-built_in">max</span>(t,f[j][k])<br><br>    ans += <span class="hljs-built_in">max</span>(t, m-t)<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p>一维优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span>, nums[j]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[k] = <span class="hljs-built_in">max</span>(f[k],f[k - nums[j]] + nums[j])<br><br><br>    ans += m - f[m//<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>        f[i] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="COCI2008-2009-2-PERKET"><a href="#COCI2008-2009-2-PERKET" class="headerlink" title="[COCI2008-2009#2] PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">[COCI2008-2009#2] PERKET</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。</p><p>众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。</p><p>另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示可供选用的食材种类数。</p><p>接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示可能的总酸度和总苦度的最小绝对差。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>本题满分 $70$ 分。</li><li>题目译自 <a href="https://hsin.hr/coci/archive/2008_2009/">COCI2008-2009</a> <a href="https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf">CONTEST #2</a> PERKET，译者 @<a href="https://www.luogu.com.cn/user/115711">mnesia</a>。</li></ul><p>简单dfs 选或不选###的思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>minn = <span class="hljs-number">0x7fffffff</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u,sor,bit</span>):<br>    <span class="hljs-keyword">global</span> minn<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">if</span> sor == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> bit == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            minn = <span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">abs</span>(sor - bit))<br>            <span class="hljs-keyword">return</span><br><br>    dfs(u + <span class="hljs-number">1</span>,sor,bit)<br>    dfs(u + <span class="hljs-number">1</span>,sor * nums[u][<span class="hljs-number">0</span>], bit + nums[u][<span class="hljs-number">1</span>])<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>   nums[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><br>dfs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(minn)<br></code></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [NOIP2016 普及组 海港]([P2058 NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [NOIP2016 普及组 海港]([P2058 <a href="https://www.luogu.com.cn/problem/P2058">NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T3</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。</p><p>小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。</p><p>小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $&#x3D;86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。</p><p>形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400&lt;t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。</p><p>接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。</p><p>保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。</p><p>保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。</p><p>其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">86401 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">86402 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>3<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>【样例解释 1】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；</p><p>第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 &#x3D; 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；</p><p>第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1&#x3D;7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。</p><p>【样例解释 2】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。</p><p>第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2&#x3D;6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。</p><p>第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2&#x3D;4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。</p><p>第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1&#x3D;5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。</p><p>【数据范围】</p><ul><li>对于 $10%$ 的测试点，$n&#x3D;1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。</li><li>对于 $20%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。</li><li>对于 $40%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。</li><li>对于 $70%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。</li><li>对于 $100%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是python的语法 ship.num = lis[2:]把2和后面的全都赋到num里面，然后就是python的语法，双端队列deque的使用方法，支持[]访问，直接用shiparr[Ship()]*100000，会导致错误，应该是类似于地址出错（所有的数组里面都是同一个值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    time = <span class="hljs-number">0</span><br>    num = []<br>    numpass = <span class="hljs-number">0</span><br><br><br>q = deque()<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>peo = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000000</span><br>lis = []<br>shiparr = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>    ship = Ship()<br>    ship.time = lis[<span class="hljs-number">0</span>]<br>    ship.numpass = lis[<span class="hljs-number">1</span>]<br>    ship.num = lis[<span class="hljs-number">2</span>:]<br>    shiparr.append(ship)<br><br><br>country = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    ship = shiparr[j]<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> ship.time - q[<span class="hljs-number">0</span>].time &lt; <span class="hljs-number">86400</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q[<span class="hljs-number">0</span>].num:<br>            peo[x] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>                country -= <span class="hljs-number">1</span><br>        q.popleft()<br>        i += <span class="hljs-number">1</span><br>    q.append(ship)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ship.num:<br>        <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>            country += <span class="hljs-number">1</span><br>        peo[x] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(country)<br><br></code></pre></td></tr></table></figure><h1 id="括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [括号序列](P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [括号序列](<a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p><ol><li>空串是「平衡括号序列」</li><li>若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」</li><li>若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。</li></ol><p>例如，下面的字符串都是平衡括号序列：</p><p><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></p><p>而以下几个则不是：</p><p><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></p><p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：</p><ol><li>从左到右扫描整个字符串。</li><li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li></ol><p>配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 $s$。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([()<br></code></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">([)</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $s$ 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 主要是题目，2.的意思是从遇到第一个右括号开始向左寻找第一个未匹配的左括号（其实根本不需要栈）。只需要在找到的地方做个标记表示已匹配即可。最后，输出的时候未匹配的就直接输出同类的完整括号，匹配的就正常输出。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt;stleft;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">char</span> ch;<br>string str;<br>cin &gt;&gt; str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>ch = str[j];<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> || str[i] == <span class="hljs-string">&#x27;)&#x27;</span>))cout &lt;&lt; <span class="hljs-string">&quot;()&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;[&#x27;</span>||str[i] == <span class="hljs-string">&#x27;]&#x27;</span>)) cout &lt;&lt; <span class="hljs-string">&quot;[]&quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; str[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Our Game!</title>
    <link href="/2023/07/27/Our-Game/"/>
    <url>/2023/07/27/Our-Game/</url>
    
    <content type="html"><![CDATA[<h1 id="我们的游戏做完啦！"><a href="#我们的游戏做完啦！" class="headerlink" title="我们的游戏做完啦！"></a>我们的游戏做完啦！</h1><p>&emsp;好激动，四周的时间过的好快，好像昨天还在讨论游戏的原型设计。现在居然已经完成了所有的工作。感谢tllwtg和wegret的付出，<del>我们三个真强</del>（哈哈哈）。<br>希望zlgg和xyjj不要嫌我菜。</p><p><a href="https://github.com/tLLWtG/Capoo-Survival/releases">这里是我们的游戏</a>，点点star（可怜）</p><p>没错 就是开放世界冒险游戏（没有虚假宣传。。。开放、世界、冒险都有）</p><p>做游戏的过程还是很开心的（可能是给我的活太少了），感觉自己没做什么，还好通过我精密的计算，最后障碍物终于没有重叠了，不然就没脸见人了。<br>好怀念教室只剩下我们在讨论和实现，在群里商量分工，一件件地完成TODO。本来是很讨厌组队的，<br>但是这种组队的感觉真的好棒！跟某些课程全部都是摆子的组队感觉完全不一样哇）</p><p>第一次上去汇报手都在发抖捏，但是后面感觉还行，对！根本就没人会听，啊，你说我吗？我也不听别人讲😀（wow，居然能插入表情嘛）。一开始做ppt只会白底黑字，<br>后面加了模板，是好看一点wo。</p><p>啊!台风了，最后一次汇报没有了，本来还想拍个照片然后一起去恰个饭的，不知道下次还有没有机会，呜呜。</p><p>贴一些图片（才不是太久没写说说，写不出来东西了呢</p><p>靠 截图审美好差</p><p>部分代码截图和游戏使用图片</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog1-16907768245555.png" alt="部分代码截图和游戏使用图片"></p><p>汇报ppt</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog2-16907767706092.png" alt="汇报ppt"></p><p>还没写完，但是不想写了，嘿嘿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法</title>
    <link href="/2023/07/23/python%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/23/python%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python语法注意事项"><a href="#python语法注意事项" class="headerlink" title="python语法注意事项"></a>python语法注意事项</h1><p><del>啊，受不了了，写了几个题不是运错就是编错，还有一堆奇奇怪怪的报错，痛苦.jpg。</del><br>已经遇见未来不短的时间内会不断报错并且看不懂然后写在这里了，希望这篇可以早日停更。</p><ul><li><p>n &#x3D; int(input())</p></li><li><p>控制不住if后面加()，哭，剁手</p></li><li><p>xmuoj不支持类型注解，呜呜</p></li><li><p>没有while(n–)的操作了，用while会忘记–，死循环了，好蠢</p></li><li><p>range的范围</p></li><li><p>读入二维列表 (老是忘记lis的append，想半天)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lis = <span class="hljs-selector-attr">[]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    d = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(int,<span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>()))<br>    lis<span class="hljs-selector-class">.append</span>()<br></code></pre></td></tr></table></figure></li><li><p>浮点数确定精度输出 print(“%.1f” % n) 注意是双引号并且没有逗号</p></li><li><p>dx &#x3D; [1,0,-1,0] <del>这里是今晚最佳</del> 加了个list怎么找也找不出来，list dx[]-&gt;笑死</p></li><li><p>全排列 选哪个？ 标记选过的不再选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">sol,num,on_path</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sol) == <span class="hljs-built_in">len</span>(num):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(sol[i], <span class="hljs-string">&quot;&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> on_path[i] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                on_path[i] = <span class="hljs-number">1</span><br>                permute(sol+[num[i]],num,on_path)<br>                on_path[i] = <span class="hljs-number">0</span><br>                <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>sol = []<br>num = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)]<br>on_path = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>permute(sol,num,onpath]<br></code></pre></td></tr></table></figure></li><li><p>字典的使用方法  记得一定要先判断是否存在 <del>呜呜，明明之前才记过，写的时候又忘记了，泰蠢辣</del></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">st</span> = input()<br><br>d = dict()<br>for <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">st</span>:<br>    if <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> d:<br>        d[<span class="hljs-number">ch</span>] += <span class="hljs-number">1</span><br><span class="hljs-symbol">    else:</span><br>        d[<span class="hljs-number">ch</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>上面的题是用来求只出现一次的字符的 难过 在c++知道用count 在python就变蠢力</p></li><li><p>python线性筛 芜湖~</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">N</span> = <span class="hljs-number">100010</span><br><span class="hljs-attribute">st</span> =<span class="hljs-meta"> [False for _ in range(N)]</span><br><span class="hljs-attribute">prime</span> =<span class="hljs-meta"> [0 for _ in range(N)]</span><br><br><span class="hljs-attribute">def</span> get_prime(n):<br>    <span class="hljs-attribute">cnt</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">if</span> not st[i]:<br>            <span class="hljs-attribute">prime</span>[cnt] = i<br>            <span class="hljs-attribute">cnt</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> prime[j] &lt; n // i:<br>        <span class="hljs-attribute">st</span>[prime[j] * i] = True<br>        <span class="hljs-attribute">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">break</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>range是左开右闭</p></li><li><p>我超 在函数里面用全局变量的时候要加global </p></li><li><p>python归并</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = int(input(n))<br><span class="hljs-attribute">nums</span> = list(map(int,input()))<br><span class="hljs-attribute">temp</span> =<span class="hljs-meta"> [0 for _ in range(n)]</span><br><br><span class="hljs-attribute">merge_sort</span>(l, r):<br>    <span class="hljs-attribute">if</span> l &gt;= r:<br>        <span class="hljs-attribute">return</span> <br>    <span class="hljs-attribute">mid</span> = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-attribute">merge_sort</span>(l, mid)<br>    <span class="hljs-attribute">merge_sort</span>(mid + <span class="hljs-number">1</span>, r)<br>    <span class="hljs-attribute">i</span>, j, k = l, mid + <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-attribute">if</span> nums[i] &lt;= nums[j]:<br>            <span class="hljs-attribute">temp</span>[k] = nums[i]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">temp</span>[k] = nums[j]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid:<br>        <span class="hljs-attribute">temp</span>[k] = nums[i]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> j &lt;= r:<br>        <span class="hljs-attribute">temp</span>[k] = nums[j]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(l, r + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">nums</span>[i] = temp[j]<br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>        <br>        <br><span class="hljs-attribute">merge_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>)# n-<span class="hljs-number">1</span>!!<br></code></pre></td></tr></table></figure></li><li><p>python手动增加递归的层数<br>import sys<br>sys.setrecursionlimit(5000)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训题目整理</title>
    <link href="/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
    <url>/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.10">熄灯问题</a></h1><p>枚举&#x2F;二进制优化</p><p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。</p><p>在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。</p><p>请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。</p><ul><li>输入<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p><ul><li>输出<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p><ul><li>输入样例</li></ul><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0</p><ul><li>输出样例</li></ul><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>注意：PUZZLE行结尾没有空格，数字行最后有一个空格。   </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/* 每次碰一个开关就会使他上下左右（还有自己！）的灯都改变状态，灯只有开关两种状态，那么要使灯全部关掉，</span><br><span class="hljs-comment">其实每个灯最多只需要按一次。</span><br><span class="hljs-comment">  如何枚举？从第二排开始，只关注当前行和上一行的状态，用当前行把上一行的灯都关掉，而不考虑其他变</span><br><span class="hljs-comment">化，这样到最后一行，如果恰好全部熄灭，就是结果。能够影响结果的，就是第一行的状态，枚举第一行。</span><br><span class="hljs-comment">  第一行的状态怎么表示？由于只有开关（1/0）两种状态，可以用二进制数来表示，之后再按顺序输入到矩阵中</span><br><span class="hljs-comment">*/</span><br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>bool <span class="hljs-symbol">ButtomStatu</span>(const int m, int ori[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>], int res[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])<br>&#123;<br>//枚举第一行的所有按键情况 利用二进制数来枚举 由于有<span class="hljs-number">6</span>列 情况为<span class="hljs-number">2</span>^<span class="hljs-number">6</span>种 得到第一行的按键情况<br>int temp = m;<br><br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>res[<span class="hljs-number">0</span>][i] = temp <span class="hljs-comment">% 2;</span><br>temp /= <span class="hljs-number">2</span>;<br>&#125;<br> <br>//把上面的情况按一遍 记得按自己所在的位置<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>if (res[<span class="hljs-number">0</span>][i])<br>&#123;<br>ori[<span class="hljs-number">0</span>][i]= (ori[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[<span class="hljs-number">1</span>][i] = (ori[<span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>&#125;<br>&#125;<br><br>//从第一行下面的每一行枚举 （核心是 第一行决定了下面每一行的情况 所以只需要枚举第一行<br>for (int i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>if (ori[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">0</span>)<br>&#123;<br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">5</span>)ori[i + <span class="hljs-number">1</span>][j] = (ori[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[i][j + <span class="hljs-number">1</span>] = (ori[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i][j - <span class="hljs-number">1</span>] = (ori[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[i][j]= (ori[i][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>res[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>//如果灯全部关完 则为true<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>if (ori[i][j] != <span class="hljs-number">0</span>)return false;<br><br>return true;<br>&#125;<br><br><br>int main()<br>&#123;<br>int n;<br>cin &gt;&gt; n;<br>int orilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int resultlight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int constorilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>for(int k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br>for (int row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">5</span>; row++)<br>&#123;<br>for (int col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">6</span>; col++)<br>&#123;<br>cin &gt;&gt; constorilight[row][col];<br>&#125;<br>&#125;<br>//枚举<span class="hljs-number">64</span>种情况<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>&#123;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>orilight[i][j] = constorilight[i][j];<br>resultlight[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>//如果得到结果就输出<br>if (<span class="hljs-symbol">ButtomStatu</span>(i, orilight, resultlight))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;PUZZLE #&quot;</span> &lt;&lt; k &lt;&lt; endl;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>cout &lt;&lt; resultlight[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.5">假币问题</a></h1><p>枚举</p><p>林克有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但林克不知道假币比真币轻还是重。</p><p>于是他向他朋友约珥借了一架天平，用这架天平称了这些币三次。</p><p>如果用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。</p><p>经过精心的设计，聪明的林克根据这三次称量结果找出假币，并且能够确定假币是轻是重。</p><p>如果给你林克的称量数据，你也可以找出假币并且确定假币是轻是重吗？（林克提供的称量数据保证一定能找出假币）。</p><ul><li>输入</li></ul><p>第一行有一个数字n，表示有n组测试用例。</p><p>对于每组测试用例：</p><p>输入有三行，每行表示一次称量的结果。林克事先将银币标号为A-L。</p><p>每次称量的结果用三个以空格隔开的字符串表示：</p><p>天平左边放置的硬币  天平右边放置的硬币  平衡状态。</p><p>其中平衡状态用’’up’’, ‘’down’’, 或 ‘’even’’表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p><ul><li>输出</li></ul><p>输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)</p><ul><li>输入样例 1</li></ul><p>1<br>ABCD EFGH even<br>ABCI EFJK up<br>ABIJ EFGH even  </p><ul><li>输出样例 1</li></ul><p>K is the counterfeit coin and it is light. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 枚举十二枚硬币和轻重共24种状态，先设假币为轻，那么一定在上升的一边，依次枚举十二枚硬币是否在</span><br><span class="hljs-comment">上升的一边，如果不是，说明为真币或者假币不为轻，那么返回false。否则遍历三次称重，最后返回true，说明</span><br><span class="hljs-comment">这个就是假币并且为轻。</span><br><span class="hljs-comment">优化：不需要分别写轻，重的函数，只需要传一个参数表示状态，当判断重时把左右交换，就与判断轻的代码一样</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>vector&lt;string&gt;<span class="hljs-built_in">lef</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">rig</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">zt</span>(<span class="hljs-number">3</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> iCoin,<span class="hljs-type">bool</span> is_light)</span></span><br><span class="hljs-function"></span>&#123;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>string l = lef[i];<br>string r = rig[i];<br>string z = zt[i];<br><span class="hljs-keyword">if</span> (!is_light)<br><span class="hljs-built_in">swap</span>(l, r);<br><span class="hljs-keyword">switch</span> (zt[i][<span class="hljs-number">0</span>])<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)!=string::npos||r.<span class="hljs-built_in">find</span>(iCoin)!=string::npos)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//说明在平衡的地方找到了  肯定是真币</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//现在枚举的是轻的 那么假币一定在上升的一方 </span><br><span class="hljs-comment">//右边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//左边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> cmp[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cin &gt;&gt; lef[i]&gt;&gt;rig[i]&gt;&gt; zt[i];<br>&#125;<br><br><span class="hljs-comment">//枚举十二枚硬币</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> iCoin = <span class="hljs-string">&#x27;A&#x27;</span>; iCoin &lt;= <span class="hljs-string">&#x27;L&#x27;</span>; iCoin++) <br>&#123;<br><span class="hljs-comment">//枚举假币为轻的情况</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">true</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is light. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">false</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is heavy. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>lef.<span class="hljs-built_in">clear</span>(), rig.<span class="hljs-built_in">clear</span>(), zt.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拨钟问题"><a href="#拨钟问题" class="headerlink" title="拨钟问题"></a><a href="http://www.xmuoj.com/problem/GW102">拨钟问题</a></h1><p>子集型回溯</p><p>有9个时钟，排成一个3*3的矩阵。</p><p>(图 1)<del>明显显示不出来嘛！</del>  </p><p>现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。</p><p>移动    影响的时钟</p><p> 1         ABDE<br> 2         ABC<br> 3         BCEF<br> 4         ADG<br> 5         BDEFH<br> 6         CFI<br> 7         DEGH<br> 8         GHI<br> 9         EFHI         </p><ul><li>输入</li></ul><p>9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0&#x3D;12点、1&#x3D;3点、2&#x3D;6点、3&#x3D;9点。</p><ul><li>输出</li></ul><p>输出一个最短的时钟指针移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。 相邻两个整数之间用单个空格隔开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*子集型回溯：进入dfs之后首先判断退出条件。之后是选或不选，对于1~9每个拨钟的方法，都可以选择拨或者</span><br><span class="hljs-comment">不拨！！然后是每个数字循环三次（最多只需要拨三次）。</span><br><span class="hljs-comment">判断，k&gt;9的时候判断是否符合，符合判断最短，之前应记录每一步。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;inf = &#123; <span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;ABDE&quot;</span> ,<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-string">&quot;BCEF&quot;</span>,<span class="hljs-string">&quot;ADG&quot;</span>,<span class="hljs-string">&quot;BDEFH&quot;</span>,<span class="hljs-string">&quot;CFI&quot;</span>,<span class="hljs-string">&quot;DEGH&quot;</span>,<span class="hljs-string">&quot;GHI&quot;</span>,<span class="hljs-string">&quot;EFHI&quot;</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ori</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">movevec</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">showvec</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> si = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mi = <span class="hljs-number">50</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;ori)</span><span class="hljs-comment">//检查是否符合条件（全为0</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (ori[i] != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><span class="hljs-comment">//移动的距离</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inf[k].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] = (ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">9</span>)<span class="hljs-comment">//相当于循环9次  即枚举9种拨钟方法</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ori) &amp;&amp; si &lt; mi)<span class="hljs-comment">//由于需要最少的次数所以用mi记录（当全为0时）最少次数</span><br>&#123;<br>mi = si;<br>showvec = movevec;<span class="hljs-comment">//记录最少次数的走法 由于是按顺序枚举 所以一定是从小到大的</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br> <span class="hljs-comment">//子集型回溯  可以一个都不选</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<span class="hljs-comment">//先进去9次  这样才可以回溯 只拨第9个不行 从这里退出 拨第8个和第9个 由于move（K） 则可以枚举到1次8 1次9 2次9 3次9 ） 2次8 1次9 2次9 3次9 ）3次8 1次9 2次9 3次9。。。依次类推可以枚举到全部的情况</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<span class="hljs-comment">//每一种方法拨三次</span><br>&#123;<br>movevec[si++] = k;<span class="hljs-comment">//记录拨钟方法和次数</span><br><span class="hljs-built_in">move</span>(k);<span class="hljs-comment">//拨钟</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br>si -= <span class="hljs-number">3</span>;<br><span class="hljs-built_in">move</span>(k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>cin &gt;&gt; ori[i];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;mi ; i++)<br>&#123;<br>cout &lt;&lt; showvec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2的幂次方表示"><a href="#2的幂次方表示" class="headerlink" title="2的幂次方表示"></a><a href="http://www.xmuoj.com/problem/GW104">2的幂次方表示</a></h1><p>递归  <del>呜呜 递归真的好抽象 难过 tllwtg和wegret怎么都说自然就会了</del></p><p><del>题目居然是图片 那就点链接了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 当n=1的时候怎么办？n=2的时候怎么办？n=其他数的时候怎么办？再把次方也递归一下（1次方要特判！！）</span><br><span class="hljs-comment">然后减去这个数，剩下的数再拆分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 1不可划分 直接输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2(0)&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-comment">// 2不可划分</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 其他数 可划分 </span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a * <span class="hljs-number">2</span> &lt;= n)<br>&#123;<br>a *= <span class="hljs-number">2</span>;<br>k++;<br>&#125;<br><span class="hljs-comment">// 分解次方</span><br><span class="hljs-comment">// 这个地方要特判  因为只剩一个2的时候就直接输出了 而不是把k=1再拿去递归</span><br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-built_in">mf</span>(k);<br>cout &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> x = n - a;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;+&quot;</span>;<br><span class="hljs-built_in">mf</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">mf</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直接用python写算了"><a href="#直接用python写算了" class="headerlink" title="直接用python写算了"></a>直接用python写算了</h2><h1 id="算24"><a href="#算24" class="headerlink" title="算24"></a><a href="http://www.xmuoj.com/problem/NQ079">算24</a></h1><p>回溯<br>熟悉了递归和深度优先搜索，小华知道现在是让小鲁综合运用所学知识的时候了，他让小鲁调整一道经典题：算24.</p><p>给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。</p><p>这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。</p><p>比如，对于5，5，5，1，我们知道5 * (5 – 1 &#x2F; 5) &#x3D; 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。</p><p>注意：输入数字的次序可以改变。</p><ul><li><p>输入<br>输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。</p></li><li><p>输出<br>对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;回溯，首先寻找结束条件，当等于24时退出递归，记得用绝对值和浮点数判断。</span><br><span class="hljs-string">然后基本思路时把每种组合的加减乘除都算一遍，如何储存状态？使用一个列表，每次选出两个数，进行四则</span><br><span class="hljs-string">运算，然后把剩余的没算的数也加进shengyu数组里面，递归运算。记得要回溯pop，还要排除b == 0的情况（被除数）。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">lis</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lis) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> math.fabs(lis[<span class="hljs-number">0</span>] - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">1e-6</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br><br>            <span class="hljs-keyword">if</span> i == j:<br>                <span class="hljs-keyword">continue</span><br><br>            a = lis[i]<br>            b = lis[j]<br>            shengyu = []<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>                <span class="hljs-keyword">if</span> k != i <span class="hljs-keyword">and</span> k != j:<br>                    shengyu.append(lis[k])<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            sum1 = a + b<br>            sub = a - b<br>            mul = a * b<br>            div = a / b<br>            left = [sum1, sub, mul, div]<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> left:<br>                shengyu.append(x)<br>                <span class="hljs-keyword">if</span> cal(shengyu):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                shengyu.pop()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">if</span> lis.count(<span class="hljs-number">0</span>) == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> cal(lis):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;YES&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="求排列的逆序数"><a href="#求排列的逆序数" class="headerlink" title="求排列的逆序数"></a><a href="http://www.xmuoj.com/problem/GW108">求排列的逆序数</a></h1><p>分治 递归</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-string">&quot;&quot;</span>&quot;<br>首先分治的思路分别来求逆序数，只在左半边的，只在右半边的和跨两边的。利用归并排序的模板，当左边<br>的数大于右边的时候，就是逆序数，由于归并排序已经排好了数，所以逆序数的个数为 mid - i + 1，<br>（mid右边的比i小）<br><span class="hljs-string">&quot;&quot;</span>&quot;<br><span class="hljs-keyword">n</span> = int(<span class="hljs-keyword">input</span>())<br>temp = [0 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">n</span>)]<br><span class="hljs-keyword">lis</span> = <span class="hljs-keyword">list</span>(map(int, <span class="hljs-keyword">input</span>().<span class="hljs-keyword">split</span>()))<br><span class="hljs-keyword">ret</span> = 0<br><br>def <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, r):<br>    <span class="hljs-keyword">global</span> <span class="hljs-keyword">ret</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">l</span> &gt;= r:<br>        <span class="hljs-keyword">return</span><br>    mid = (<span class="hljs-keyword">l</span> + r) &gt;&gt; 1<br>    <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, mid)<br>    <span class="hljs-keyword">merge</span>(mid + 1, r)<br>    i, j, k = <span class="hljs-keyword">l</span>, mid + 1, 0<br>    <span class="hljs-keyword">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">lis</span>[i] &lt;= <span class="hljs-keyword">lis</span>[j]:<br>            temp[k] = <span class="hljs-keyword">lis</span>[i]<br>            i += 1<br>            k += 1<br>        <span class="hljs-keyword">else</span>:<br>            temp[k] = <span class="hljs-keyword">lis</span>[j]<br>            j += 1<br>            k += 1<br>            <span class="hljs-keyword">ret</span> += mid - i + 1<br>    <span class="hljs-keyword">while</span> i &lt;= mid:<br>        temp[k] = <span class="hljs-keyword">lis</span>[i]<br>        i += 1<br>        k += 1<br>    <span class="hljs-keyword">while</span> j &lt;= r:<br>        temp[k] = <span class="hljs-keyword">lis</span>[j]<br>        j += 1<br>        k += 1<br><br>    j = 0<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">l</span>, r + 1):<br>        <span class="hljs-keyword">lis</span>[i] = temp[j]<br>        j += 1<br><br><span class="hljs-keyword">merge</span>(0, <span class="hljs-keyword">n</span> - 1)<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ret</span>)<br></code></pre></td></tr></table></figure><h1 id="海拉鲁城堡问题"><a href="#海拉鲁城堡问题" class="headerlink" title="海拉鲁城堡问题"></a><a href="http://www.xmuoj.com/problem/GW090">海拉鲁城堡问题</a></h1><p>深搜 位运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;因为需要找到所有房间中最大的，而一次搜索只能找一个房间的面积，可以遍历寻找未搜索过的房间。</span><br><span class="hljs-string">深搜和广搜选哪个，一看是找面积最大的本来想用广搜但是判断条件写出来可能会比深搜麻烦很多，所以还是用深搜。</span><br><span class="hljs-string">每次搜索之前，位运算判断该位是否可以走</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> sys<br>sys.setrecursionlimit(<span class="hljs-number">5000</span>)<br>N = <span class="hljs-number">100</span><br>row = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>col = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>lis = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>color = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>maxArea = <span class="hljs-number">0</span><br>maxRoom = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask3</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask4</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">8</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> maxArea, maxRoom<br>    <span class="hljs-keyword">if</span> color[a][b] != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    maxArea += <span class="hljs-number">1</span><br>    color[a][b] = maxRoom<br>    <span class="hljs-keyword">if</span> mask1(lis[a][b]):<br>        dfs(a, b - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask2(lis[a][b]):<br>        dfs(a - <span class="hljs-number">1</span>, b)<br>    <span class="hljs-keyword">if</span> mask3(lis[a][b]):<br>        dfs(a, b + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask4(lis[a][b]):<br>        dfs(a + <span class="hljs-number">1</span>, b)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>        lis[i][j+<span class="hljs-number">1</span>] = a[j]<br><br>retArea = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> color[i][j] == <span class="hljs-number">0</span>:<br>            maxArea = <span class="hljs-number">0</span><br>            maxRoom += <span class="hljs-number">1</span><br>            dfs(i, j)<br>            retArea = <span class="hljs-built_in">max</span>(retArea, maxArea)<br><br><span class="hljs-built_in">print</span>(maxRoom)<br><span class="hljs-built_in">print</span>(retArea)<br></code></pre></td></tr></table></figure><h1 id="英杰们的蛋糕塔"><a href="#英杰们的蛋糕塔" class="headerlink" title="英杰们的蛋糕塔"></a><a href="http://www.xmuoj.com/problem/GW092">英杰们的蛋糕塔</a></h1><p>深搜 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-comment">//宏定义简化</span><br>#define <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span> (r*r)<br>#define sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> (<span class="hljs-number">2</span>*r*h)<br>#define <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> ((r)*(r)*(h))<br>#define <span class="hljs-constructor">V2surArea(<span class="hljs-params">r</span>,<span class="hljs-params">v</span>)</span> (<span class="hljs-number">2</span>*v/(r))<br>#define INF <span class="hljs-number">0x7fffffff</span> <br><span class="hljs-built_in">int</span> N, V, minsurArea = INF;<br><span class="hljs-built_in">int</span> sumMinS<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>, sumMinV<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>;<br><br><span class="hljs-comment">// 搜索的主体是 枚举每一层的R H 寻找体积符合时 最小的表面积</span><br>void dfs(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> nr,<span class="hljs-built_in">int</span> nh,<span class="hljs-built_in">int</span> lv,<span class="hljs-built_in">int</span> cs)<br>&#123;<br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (lv<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>cs &lt; minsurArea)minsurArea = cs;<br>return;<br>&#125;<br><span class="hljs-comment">// 剪枝操作 1.当前剩余的体积小于上面累加起来最小的体积 说明已经不符合 </span><br><span class="hljs-comment">// 2.当前表面积加上上面的最小表面积 大于minsurArea 不符合</span><br><span class="hljs-comment">// 3.启发式剪枝 提前看到下一步的结果 当nr没到最后一层 并且 上一层的表面积加上当前累加的面积已经大于minsurArea 不符合</span><br><span class="hljs-keyword">if</span> (lv &lt; sumMinV<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>)return;<br><span class="hljs-keyword">if</span> (cs + sumMinS<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> &gt;= minsurArea)return;<br><span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">V2surArea(<span class="hljs-params">nr</span> - 1, <span class="hljs-params">lv</span>)</span> + cs &gt;= minsurArea)return;<br><br><span class="hljs-comment">//从最大层 （r最大） 到最小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = nr - <span class="hljs-number">1</span>; r &gt;= u; r--)<br>&#123;<br><span class="hljs-comment">// 当到达最高层的时候 让这一层的面积等于 底面积（后面是加上表面积 是每个都有的操作 </span><br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span>N)cs = <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>;<br><span class="hljs-comment">// 预处理出最大高度的最小值 （如果把当前剩余的体积 全部做成一层 除以当前的表面积 就是最大高度</span><br><span class="hljs-built_in">int</span> H_max = (<span class="hljs-number">1.0</span><span class="hljs-operator"> * </span>lv<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (H_max &gt; nh - <span class="hljs-number">1</span>)H_max = nh - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 枚举h</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = H_max; h &gt;= u; h--)<br>&#123;<br><span class="hljs-built_in">int</span> s = sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br><span class="hljs-built_in">int</span> v = <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br>dfs(u - <span class="hljs-number">1</span>, r, h, lv - v, cs + s);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>cin &gt;&gt; V &gt;&gt; N;<br><br><span class="hljs-comment">//预处理出 累加到每一层的最小的面积和体积 用于后面的剪枝</span><br>sumMinS<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>&#123;<br>sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + sur<span class="hljs-constructor">Area(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + <span class="hljs-constructor">Volume(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>&#125;<br><span class="hljs-comment">//预处理出 最下面一层的 R H的上界 减少计算</span><br><span class="hljs-built_in">int</span> maxH = (V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(N)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> maxR = sqrt(double((V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>) + <span class="hljs-number">1</span>));<br><br>dfs(N, maxR, maxH, V, <span class="hljs-number">0</span>);<span class="hljs-comment">//从最大的蛋糕往上搜索</span><br><span class="hljs-keyword">if</span> (minsurArea<span class="hljs-operator"> == </span>INF)<br>cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; minsurArea &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="击杀黄金蛋糕人马"><a href="#击杀黄金蛋糕人马" class="headerlink" title="击杀黄金蛋糕人马"></a><a href="http://www.xmuoj.com/problem/NQ090">击杀黄金蛋糕人马</a></h1><p>记忆化搜索 动态规划   </p><p>在海拉鲁大陆冒险，没有绝佳的剑法+想象力是不可能存活下来的。<br>这不，林克遇到了一个特别巨大的敌人——黄金蛋糕人马（莱尼尔的变种）<br>这黄金蛋糕人马长相非常特别，没有脚没有手没有嘴巴没有头，整个身材就是一个大矩形（喂喂，这不就是黄金莱尼尔吗？）<br>它的长和宽分别是整数w、h。<br>林克举起大师之剑，挥向黄金蛋糕人马，要将其切成m块矩形小块打包走，分给自己的朋友（每块都必须是矩形、且长和宽均为整数）。<br>大师之剑无比锐利，每一斩带出的剑气能将黄金蛋糕人马劈成两半（形成两个小矩形蛋糕）<br>经过m-1斩，黄金蛋糕人马居然被劈成m块小蛋糕（喂喂，你的想象力也太丰富了，明明切不开好吗？）<br>请计算：最后得到的m块小蛋糕中，最大的那块蛋糕的面积下限。<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 4，则下面的斩击可使得其中最大蛋糕块的面积最小。(十字斩)<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 3，则下面的斩击可使得其中最大蛋糕块的面积最小:.(二连斩)</p><ul><li>输入</li></ul><p>共有多行，每行表示一个测试案例。<br>每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh.<br>当 w &#x3D; h &#x3D; m &#x3D; 0 时不需要处理，表示输入结束。</p><ul><li>输出</li></ul><p>每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 记忆化搜索 储存已经搜过的值 下次需要时直接返回 储存的一般为搜索的值 dfs返回值一般定义为int（不为void）</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 原来的方法主要是分成左右两边的时候不好表示 </span><br><span class="hljs-comment">* 该方法dfs传入的是当前的方块的长和宽 分为左右两边（分治）枚举左右边切的位置 和左右边分别切的刀数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w, h, m;<br><span class="hljs-type">int</span> maxCake[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>][<span class="hljs-number">500</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当m为0的时候返回当前的面积</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> w * h;<br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-keyword">if</span> (maxCake[w][h][m])<span class="hljs-keyword">return</span> maxCake[w][h][m];<br><br><span class="hljs-type">int</span> a, b, ans = inf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; w; j++) <br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(j, h, i);<span class="hljs-comment">// 切m 刀的蛋糕是由切i刀和m - i - 1刀组成的   w - i 最后会反转 可以变量所有情况</span><br>b = <span class="hljs-built_in">dfs</span>(w - j, h, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<span class="hljs-comment">// 得到最大的蛋糕 取最小</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; h; j++)<br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(w, j, i);<br>b = <span class="hljs-built_in">dfs</span>(w, h - j, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br>&#125;<br>maxCake[w][h][m] = ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; h &gt;&gt; m)<br>&#123;<br><span class="hljs-keyword">if</span> (w == h &amp;&amp; h == m &amp;&amp; m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">dfs</span>(w, h, m - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">memset</span>(maxCake, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> maxCake);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滚石柱"><a href="#滚石柱" class="headerlink" title="滚石柱"></a><a href="http://www.xmuoj.com/problem/XMU023">滚石柱</a></h1><p>广搜 结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs arduino">广搜加上结构体表示物体的状态，主要难点就在于状态的表示。用结构体表示物体的状态，更新状<br>态时，用三维数组，增加的一维用来表示<span class="hljs-number">0</span>立着横着竖着<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> d[N][N][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> row, col;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State start, State end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; row &gt;&gt; col, row || col)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>cin &gt;&gt; g[i];<br><br>State start = &#123; <span class="hljs-number">-1</span> &#125;, end;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(start, end);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python速成笔记</title>
    <link href="/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python速成的一些学习笔记"><a href="#python速成的一些学习笔记" class="headerlink" title="python速成的一些学习笔记"></a>python速成的一些学习笔记</h1><p>什么？！你说python速成？-&gt;[<a href="https://oi.wiki/lang/python/">Python 速成 - OI Wiki</a>]</p><ul><li><p>pow函数可以实现快速幂</p></li><li><p>对Unicode的字符使用函数ord可以将其转换成对应的Unicode编码 逆向转换使用chr</p></li><li><p>字符串居然也可以用加和乘的运算 但是好像不能用减？ </p></li><li><p>字符串和列表都有方便的子串&#x2F;元素检测 in 如 a in str</p></li><li><p>字符串与列表的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">70</span>))            <br>lis = [<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num]           <br><span class="hljs-built_in">print</span>(lis)                  <br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(lis)                    <br><span class="hljs-built_in">print</span>(s)            <br></code></pre></td></tr></table></figure></li><li><p>二维[数组]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">via = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]                    <br><span class="hljs-built_in">print</span>(via)              <br>via[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>               <br><span class="hljs-built_in">print</span>(via)              <br></code></pre></td></tr></table></figure></li><li><p>使用NumPy建立多维数组和访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np      <br><br><span class="hljs-comment">#容量为3 未初始化       </span><br>lis = np.empty(<span class="hljs-number">3</span>)       <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#3*3 初始化为0      </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)     <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#整数数组       </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>, dtype=<span class="hljs-built_in">int</span>)      <br><span class="hljs-built_in">print</span>(lis.shape)        <br><span class="hljs-comment">#获取数组最大值         </span><br>np.<span class="hljs-built_in">max</span>(lis)     <br><span class="hljs-comment">#展平       </span><br>lis.flatten()       <br><span class="hljs-comment">#对每行排序 返回排序结果</span><br>np.sort(lis, axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#行方向原地排序</span><br>lis.sort(axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#浮点数输出</span><br>pi = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.4f&quot;</span> % pi)<br><span class="hljs-string">&quot;%.4f - %8f = %d&quot;</span> % (pi, <span class="hljs-number">0.1416</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">#输入</span><br>s = <span class="hljs-built_in">input</span>()<br>a = s.split()<br><span class="hljs-built_in">print</span>(a)<br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]<br><span class="hljs-comment">#或者</span><br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment">#固定输入</span><br>u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典</span><br>dic = &#123;&#125;<br>dic = &#123;<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>&#125;<br>dic1 = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">69</span>)&#125;<br><span class="hljs-comment"># 翻转</span><br>dic1 = &#123;dic1[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1&#125;<br><span class="hljs-built_in">print</span>(dic1)<br><span class="hljs-comment"># 要先判断才能打印</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">in</span> dic1:<br>    <span class="hljs-built_in">print</span>(dic1[<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-keyword">else</span>:<br>    dic1[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">98</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="更新！学了两个月之后再看一遍"><a href="#更新！学了两个月之后再看一遍" class="headerlink" title="更新！学了两个月之后再看一遍"></a>更新！学了两个月之后再看一遍</h1><ul><li><p>format() 输出浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br>formatted_pi = <span class="hljs-string">&quot;圆周率的近似值是 &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi)<br><span class="hljs-built_in">print</span>(formatted_pi)<br>:<span class="hljs-number">.2</span>f 是一个格式规范，它指定了要显示小数点后两位的浮点数<br><br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">20</span><br>result = <span class="hljs-string">&quot;x 的值是 &#123;&#125;，y 的值是 &#123;&#125;，它们的和是 &#123;&#125;。&quot;</span>.<span class="hljs-built_in">format</span>(x, y, x + y)<br><span class="hljs-built_in">print</span>(result)<br><br>name = <span class="hljs-string">&quot;Alice&quot;</span><br>age = <span class="hljs-number">30</span><br>message = <span class="hljs-string">f&quot;我的名字是 <span class="hljs-subst">&#123;name&#125;</span>，年龄是 <span class="hljs-subst">&#123;age&#125;</span>。&quot;</span><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><br><span class="hljs-comment"># 二维数组</span><br>mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>N = <span class="hljs-number">4</span>; mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>mat  <span class="hljs-comment"># 先按行读入二维数组</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*mat))   <br><span class="hljs-comment"># *将 mat 解包得到里层的多个列表</span><br><span class="hljs-comment"># zip() 将多个列表中对应元素聚合成元组，得到一个迭代器</span><br><span class="hljs-comment">## 内置函数 zip() 可以将多个等长序列中的对应元素拼接在「元组」内，得到新序列</span><br><span class="hljs-comment"># map(list, iterable) 将序列中的元素（这里为元组）转成列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u, v, w)  <span class="hljs-comment"># 直接将 map() 得到的迭代器拆包，分别赋值给 u, v, w</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dict</span><br>dic = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)&#125;<br>dic = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)], <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))<br><span class="hljs-comment"># 键值对逆转</span><br>dic = &#123;dic[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic&#125;<br>dic = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()&#125;  <span class="hljs-comment"># 和上行作用相同，dic.items() 以元组存放单个键值对</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dic.items(), key=<span class="hljs-keyword">lambda</span> x:-x[<span class="hljs-number">1</span>])&#125;  <span class="hljs-comment"># 字典按值逆排序，用到了 lambda 表达式</span><br></code></pre></td></tr></table></figure></li><li><p>装饰器</p><p>lru_cache转记忆化</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2023/07/22/My-first-blog/"/>
    <url>/2023/07/22/My-first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>做这个网站真的做了好久，教程确实很详细了，但是还是有些地方默认读者已经会了（我现在确实会了）。感谢tllwtg的帮助，没有tllwtg，就没有这个网站，呜呜。<br>tllwtg告诉我教程之后还帮我调了两次（&#x2F;跪谢）。</p><p>之后自己做的过程中也好多次感觉根本搞不出来，不想搞了。但是但是，这个好有意思，最后还是做出来了。tllwtg还跟我说做两三天是很正常的，我真的哭死。做完还是很开心的。<br>我也学到了好多东西，自己去看教程，搜资料，虽然会花很多时间，但是效果确实好欸，比如之前觉得很难的git的操作，，，一直不愿意去学（卧室蓝苟）最后也被迫学会了，<br>除了做网站本身，还学到好多其他的东西。效果比tllwtg直接帮我打出来好很多。（如果我那天不是删了重新做，而是让tllwtg帮我弄一下，我现在估计还是什么都不会&#x2F;难过）。</p><p>好！不当蓝苟从现在开始。（QQ机器人？好难，下次再说吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/22/hello-world/"/>
    <url>/2023/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
