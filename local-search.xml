<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>5月</title>
    <link href="/2024/05/13/5%E6%9C%88/"/>
    <url>/2024/05/13/5%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="xmuoj-最小化蒙德城的旅行者队伍"><a href="#xmuoj-最小化蒙德城的旅行者队伍" class="headerlink" title="xmuoj | 最小化蒙德城的旅行者队伍"></a><a href="http://www.xmuoj.com/contest/235/problem/1">xmuoj | 最小化蒙德城的旅行者队伍</a></h2><p>相同的车队是一个等差数列 要最小化车队的数量 就要找出等差数列包含尽可能多的车队</p><p>可以先预处理出所有可能的行进路线。将问题转化为在合法的线路中找出多少条才能覆盖所有的车队。</p><p>由于可能有同时到达的，且所有的车队都在0~59之间到达，因此可以用哈希表来存储，符合要求时-1表示已经属于某个车队。当全部为0时表示覆盖了所有车队。</p><p>预处理线路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">60</span>];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;PII;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, PII&gt;&gt;routes;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; <span class="hljs-number">60</span>; i += d)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        nums[x]++;<br>    &#125;<br>    <span class="hljs-comment">// i表示开始时间 即初项 j表示公差</span><br>    <span class="hljs-comment">// check计算这个组合是否每个时间都有车队到达</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">60</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; i + j &lt; <span class="hljs-number">60</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i, j))<br>            routes.<span class="hljs-built_in">push_back</span>(&#123;(<span class="hljs-number">59</span> - i) / j + <span class="hljs-number">1</span>, &#123;i, j&#125;&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 按（59 - i）/ j排序 从可以包含更多的数的等差数列开始回溯 更快找到最优解</span><br>    <span class="hljs-built_in">sort</span>(routes.<span class="hljs-built_in">begin</span>(), routes.<span class="hljs-built_in">end</span>(), greater&lt;&gt;);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后就对所有可能的等差数列进行回溯，求出覆盖所有车队需要的最小数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// depth表示选了几条路线可以覆盖所有的车（迭代到第几层） 也就是最终的结果，因为已经按覆盖的多少排序了，所以覆盖的多的先选肯定是更好的 当覆盖完一定是最优解</span><br><span class="hljs-comment">// 比如depth=2 表示最多迭代2层 在depth==u的时候(u从0开始增加depth不变)就判断是否覆盖完了 </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (depth == u)<br>    &#123;<br>        <span class="hljs-keyword">return</span> sum == n;<br>    &#125;<br>    <span class="hljs-comment">//剪枝 当前层最多可以覆盖的车数量 * （层数） + 已经覆盖了的车的数量 如果小于总数 那必不可能 直接return false</span><br>    <span class="hljs-keyword">if</span> (routes[start].first * (depth - u) + sum &lt; n)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; routes.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> r = routes[i];<br>        <span class="hljs-type">int</span> a = r.second.first, d = r.second.second;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(a, d))<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//回溯</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a; j &lt; <span class="hljs-number">60</span>; j+=d)nums[j]--;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(depth, u + <span class="hljs-number">1</span>, sum + r.first, i))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a; j &lt; <span class="hljs-number">60</span>; j+=d)nums[j]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>补充main函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">backtrack</span>(depth, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))depth++;<br>cout &lt;&lt; depth &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>主要的难点在于题意比较难读懂 还有预处理出等差数列之后用迭代加深的做法进行求解(设depth的深度，每次增加depth 用depth限制迭代深度)这种做法适用于n较大但是答案较小的情况，比如本题说了最多17条路线，depth最多为17.</p><h2 id="xmuoj-恢复破碎的符咒木牌"><a href="#xmuoj-恢复破碎的符咒木牌" class="headerlink" title="xmuoj | 恢复破碎的符咒木牌"></a><a href="http://www.xmuoj.com/contest/235/problem/2">xmuoj | 恢复破碎的符咒木牌</a></h2><p>因为有很多重复的长度 所以用哈希表存储</p><p>枚举可以选择的长度：最小就是【所有木棍里最大的长度】</p><p>最大就是【所有木棍的总长&#x2F;2】（最大可以分成这样 再往后只能直接用总长了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], maxn, minn, sum;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;n &amp;&amp; n)<br>    &#123;<br>        finished = <span class="hljs-literal">false</span>;<br>        maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">1e9</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            nums[x]++;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, x);<br>            minn = <span class="hljs-built_in">min</span>(minn, x);<br>            sum += x;<br>        &#125;<br>        <span class="hljs-type">int</span> temp = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxn; i &lt;= temp; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sum % i == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(sum / i, <span class="hljs-number">0</span>, i, maxn);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!finished)cout&lt;&lt;sum&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设当前的答案长度为one_len 一共有all_left根这样长的棍子 每次选一段 当前的这根的长度为now_len 当now_len&#x3D;&#x3D;one_len表示已经凑够了一根</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> all_left, <span class="hljs-type">int</span> now_len, <span class="hljs-type">int</span> one_len, <span class="hljs-type">int</span> now_max)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(finished)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (all_len == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout&lt;&lt;one_len&lt;&lt;endl;<br>        finished = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (one_len == now_len)<br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(all_left + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, one_len, maxn);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从大的开始 可以更早到达临界 状态更少回溯更快</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now_max; i &gt;= minn; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &amp;&amp; i + now_len &lt;= one_len)<br>        &#123;<br>            nums[i]--;<br>            <span class="hljs-built_in">dfs</span>(all_left, now_len + i, one_len, i);<br>            nums[i]++;<br>            <span class="hljs-keyword">if</span> (now_len == <span class="hljs-number">0</span> || now_len + i == one_len)<br>                <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>难点在于剪枝的部分和dfs的参数表示，要用哪些参数来表示，一开始只能想到all_left one_len 和now_len 但是要加上now_max才能减少搜索次数</p><h2 id="xmuoj-提瓦特情报传递网络"><a href="#xmuoj-提瓦特情报传递网络" class="headerlink" title="xmuoj | 提瓦特情报传递网络"></a><a href="http://www.xmuoj.com/contest/235/problem/3">xmuoj | 提瓦特情报传递网络</a></h2><p>建图+bfs 建立有向图然后进行bfs搜索 只要step小于层数L即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">bool</span> g[N][N], vis[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;PII&gt;q;<br>q.<span class="hljs-built_in">push</span>(&#123; s, <span class="hljs-number">0</span> &#125;);<br>vis[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><br><span class="hljs-type">int</span> step = q.<span class="hljs-built_in">front</span>().second, now = q.<span class="hljs-built_in">front</span>().first;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (vis[i] || !g[now][i])<span class="hljs-keyword">continue</span>;<br>vis[i] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &lt;= m)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(&#123; i, step + <span class="hljs-number">1</span> &#125;);<br>maxn++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; x; j++)<br>&#123;<br><span class="hljs-type">int</span> y;<br>cin &gt;&gt; y;<br>g[y][i] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i++)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>maxn = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> y;<br>cin &gt;&gt; y;<br><span class="hljs-built_in">bfs</span>(y);<br>cout &lt;&lt; maxn &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-神庙石塔挑战"><a href="#xmuoj-神庙石塔挑战" class="headerlink" title="xmuoj | 神庙石塔挑战"></a><a href="http://www.xmuoj.com/contest/238/problem/2">xmuoj | 神庙石塔挑战</a></h2><p>生日蛋糕</p><p>每次减少一层 直到最后一层的时候 体积如果等于题目要求的体积 就可以更新答案</p><p>dfs中需要有参数【当前是第几层 当前层的高和半径 当前的总体积总面积】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, d;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v == n)<br>            mins = <span class="hljs-built_in">min</span>(mins, s);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r - <span class="hljs-number">1</span>; i &gt;= step; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (step == m)s = i * i;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h - <span class="hljs-number">1</span>; j &gt;= step; j--)<br>        &#123;<br>            <span class="hljs-built_in">backtrack</span>(step - <span class="hljs-number">1</span>, i, j, s + <span class="hljs-number">2</span> * i * j, v + i * i * j);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;d;<br>    <span class="hljs-built_in">backtrack</span>(m, n, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显这样是过不了的 需要剪枝</p><p>当当前的体积+后面几层体积已经大于要求的体积时 没有解（约束函数）</p><p>当当前面积+后面几层面积已经大于最小面积时 不可能导出最优解（限界函数）</p><p>当当前的面积加上后面的所有层的可能的最小面积 大于最小面积时 不可能导出最优解</p><p>当i &#x3D; r - 1进行回溯的时候，如果h - 1超出了体积 可以计算当前可能到达的最大的h &#x3D; 总体积-当前体积-后几层体积&#x2F;当前的底面积 &#x3D;高&#x3D;maxh</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> mins = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> leftmins[N], leftminv[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (step == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (v == n)<br>mins = <span class="hljs-built_in">min</span>(mins, s);<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s + leftmins[step] &gt;= mins)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (v + leftminv[step] &gt; n)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (s + <span class="hljs-number">2.0</span> * (n - v) / r &gt;= mins)<span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r - <span class="hljs-number">1</span>; i &gt;= step; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (step == m)s = i * i;<br>      <span class="hljs-type">int</span> maxh = <span class="hljs-built_in">min</span>((n - v - leftminv[step - <span class="hljs-number">1</span>]) / (i * i), h - <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = maxh; j &gt;= step; j--)<br>&#123;<br><span class="hljs-built_in">backtrack</span>(step - <span class="hljs-number">1</span>, i, j, s + <span class="hljs-number">2</span> * i * j, v + i * i * j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m + <span class="hljs-number">1</span>; i++)<br>&#123;<br>leftmins[i] = leftmins[i - <span class="hljs-number">1</span>] + i * <span class="hljs-number">2</span> * i;<br>leftminv[i] = leftminv[i - <span class="hljs-number">1</span>] + i * i * i;<br>&#125;<br><br><span class="hljs-built_in">backtrack</span>(m, n, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (mins == <span class="hljs-number">0x3f3f3f3f</span>)cout &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; mins;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-“原神”探秘：穿越神秘迷宫"><a href="#xmuoj-“原神”探秘：穿越神秘迷宫" class="headerlink" title="xmuoj | “原神”探秘：穿越神秘迷宫"></a><a href="http://www.xmuoj.com/contest/238/problem/1">xmuoj | “原神”探秘：穿越神秘迷宫</a></h2><p>dfs每次将当前的位置保存在数组中，深度优先搜索，直到找到出口。如果无法继续向下走，就回溯。回溯到上一状态时需要把原来的路径也同时删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;rode;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rode.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; rode[i].first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; rode[i].second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (flag)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">2</span> &amp;&amp; y == n - <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">Print</span>();<br>flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i];<br><span class="hljs-keyword">if</span> (nums[nx][ny] == <span class="hljs-number">0</span>)<br>&#123;<br>nums[nx][ny] = <span class="hljs-number">1</span>;<br>rode.<span class="hljs-built_in">push_back</span>(&#123; nx, ny &#125;);<br><span class="hljs-built_in">dfs</span>(nx, ny);<br>rode.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br>cin &gt;&gt; nums[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>rode.<span class="hljs-built_in">push_back</span>(&#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (!flag)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="37-解数独-力扣（LeetCode）"><a href="#37-解数独-力扣（LeetCode）" class="headerlink" title="37. 解数独 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sudoku-solver/description/">37. 解数独 - 力扣（LeetCode）</a></h2><p>主要是注意行、列、宫的表示方法 用哈希表填数 表示这个数已经用过</p><p>将需要填的坐标放在队列中 每次取出填数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">bool</span> hang[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br><span class="hljs-type">bool</span> lie[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br><span class="hljs-type">bool</span> gezi[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br><span class="hljs-type">bool</span> valid=<span class="hljs-literal">false</span>;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;spaces;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp;board,<span class="hljs-type">int</span> pos)</span><span class="hljs-comment">//pos 代表第pos个填上的空格</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pos==spaces.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            valid=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <br>        <span class="hljs-comment">//每次处理掉一个格子 第pos个空格 的行和列为i j</span><br>        <span class="hljs-keyword">auto</span> [i,j]=spaces[pos];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> digit=<span class="hljs-number">0</span>;digit&lt;<span class="hljs-number">9</span>&amp;&amp;!valid;digit++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!hang[i][digit]&amp;&amp;!lie[j][digit]&amp;&amp;!gezi[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][digit])<br>            &#123;<br>                hang[i][digit]=lie[j][digit]=gezi[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][digit]=<span class="hljs-literal">true</span>;<br>                board[i][j]=digit+<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//0-8  +1  1-9</span><br><br>                <span class="hljs-built_in">dfs</span>(board,pos+<span class="hljs-number">1</span>);<br><br>                hang[i][digit]=lie[j][digit]=gezi[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][digit]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-comment">//填入 初始状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    spaces.<span class="hljs-built_in">emplace_back</span>(i,j);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-type">int</span> digit=board[i][j]-<span class="hljs-string">&#x27;0&#x27;</span><span class="hljs-number">-1</span>;<span class="hljs-comment">//1-9 越界 -1 表示 0-8</span><br>                    hang[i][digit]=lie[j][digit]=gezi[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][digit]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(board,<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-提瓦特地图探险"><a href="#xmuoj-提瓦特地图探险" class="headerlink" title="xmuoj | 提瓦特地图探险"></a><a href="https://www.xmuoj.com/contest/239/problem/1">xmuoj | 提瓦特地图探险</a></h2><ul><li>方法一 记忆化搜索</li></ul><p>复杂度较低的做法，在回溯的过程中记录每个点所能到达的最长上坡路径的长度。</p><p>分四个方向进行递归，使用temp记录当前这个格子下，最长的路径，用备忘录记录后，返回最长路径。</p><p>dfs函数就处理每个格子的最长路径，对每个格子都作为起点进行一次搜索（搜索中记录已访问的结点）即可得到最长的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++">define _CRT_SECURE_NO_WARNINGS<br>include &lt;iostream&gt;<br>include&lt;vector&gt;<br>include &lt;queue&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;nums;<br><span class="hljs-type">int</span> memo[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> nx = dx[i] + x, ny = dy[i] + y;<br><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; row &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; col &amp;&amp; nums[nx][ny] &gt; nums[x][y])<br>&#123;<br>temp = <span class="hljs-built_in">max</span>(temp, memo[nx][ny] != <span class="hljs-number">0</span> ? memo[nx][ny] : <span class="hljs-built_in">dfs</span>(nx, ny));<br>&#125;<br>&#125;<br>memo[x][y] = temp + <span class="hljs-number">1</span>;<br>ans = <span class="hljs-built_in">max</span>(ans, memo[x][y]);<br><span class="hljs-keyword">return</span> memo[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; row &gt;&gt; col;<br>nums = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br>cin &gt;&gt; nums[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(i, j);<br>&#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><p>暴力的做法，直接对每个点进行搜索，但是不记录每个点的长度。最后用打擂台的方式记录最长的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;nums;<br><span class="hljs-type">int</span> memo[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, step);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i];<br><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; row &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; col &amp;&amp; nums[nx][ny] &gt; nums[x][y])<br><span class="hljs-built_in">dfs</span>(step + <span class="hljs-number">1</span>, nx, ny);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; row &gt;&gt; col;<br>nums = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br>cin &gt;&gt; nums[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, i, j);<br>&#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-石碑之谜：滚动机关"><a href="#xmuoj-石碑之谜：滚动机关" class="headerlink" title="xmuoj | 石碑之谜：滚动机关"></a><a href="https://www.xmuoj.com/contest/239/problem/2">xmuoj | 石碑之谜：滚动机关</a></h2><p>bfs搜索。本题要注意很多细节问题。</p><p>首先是状态定义，与二维的走迷宫不同，在每个点可能有三个状态 横竖立，那么这个点可以以不同的方式被经过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<span class="hljs-comment">//0立1横2竖</span><br></code></pre></td></tr></table></figure><p>在记录每个点的步数的时候，d[1] [1] [0]和d[1] [1] [1] 同样是在1 1这一格，但是状态不同，因此要走的步数也是不同的。</p><p>接下来是状态更新，每一步如何走:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当立着的时候，如果转为横着，那就是向左或右倒下，状态改变为1，同时走过了1格。以此类推就可以求出每一种状态转移的方式。</p><p>check函数判断是否越界或为墙壁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数中输入的时候就要处理好开始和结束位置</p><p>开始位置为搜索到X之后，马上搜索X的下右，是否还有第二个X，表示初始状态是横？竖？立？最终状态只会是立着。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键函数bfs函数，只需要在每一步都判断一下当前这一步是否可以走（不能越界，立着不能站在易碎平台，横竖多出来的一格不能越界）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br></code></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<span class="hljs-comment">//0立1横2竖</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> d[N][N][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> row, col;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State start, State end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; row &gt;&gt; col, row || col)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>cin &gt;&gt; g[i];<br><br>State start = &#123; <span class="hljs-number">-1</span> &#125;, end;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(start, end);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-璃月森林探险：符文之路"><a href="#xmuoj-璃月森林探险：符文之路" class="headerlink" title="xmuoj | 璃月森林探险：符文之路"></a><a href="https://www.xmuoj.com/contest/239/problem/3">xmuoj | 璃月森林探险：符文之路</a></h2><p>回溯法</p><p>本题需要有较多的分类主要为：本来没有颜色，现在也没有颜色；本来没有颜色，现在有颜色；本来有颜色，现在有相同、不同颜色</p><p>需要分类讨论</p><p> 关键在于回溯的同时需要保存用魔法改变的 、只能存在一回合的颜色。</p><p>可以在函数中使用参数color，记录上一格的颜色（使用魔法变化后）然后原本的数组中的颜色不变，这样就可以将魔法变化的颜色区分开。</p><p>都没有颜色的时候直接返回</p><p>前面有颜色现在没颜色，花费2使用魔法变成与前面一样的颜色。并且在像下一格搜索时颜色要记录为魔法改变后的颜色。</p><p>都有颜色如果相同直接向下搜索，如果不同，需要花费1的代价改变颜色。</p><p>对每种情况分别回溯，记录每个点可以达到的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> g[N][N], vis[N][N], dis[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> color, <span class="hljs-type">int</span> cost)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a == n &amp;&amp; b == n)<br>&#123;<br>ans = <span class="hljs-built_in">min</span>(ans, cost);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> nx = a + dx[i], ny = b + dy[i];<br><span class="hljs-keyword">if</span> (nx &gt; <span class="hljs-number">0</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; <span class="hljs-number">0</span> &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny])<br>&#123;<br><span class="hljs-comment">//都没有颜色</span><br><span class="hljs-keyword">if</span> (g[a][b] == <span class="hljs-number">0</span> &amp;&amp; g[nx][ny] == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//前面有颜色 现在没颜色 变为前面的颜色 花费2</span><br><span class="hljs-keyword">if</span> (g[nx][ny] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (cost + <span class="hljs-number">2</span> &lt; dis[nx][ny])<br>&#123;<br>vis[nx][ny] = <span class="hljs-number">1</span>;<br>dis[nx][ny] = cost + <span class="hljs-number">2</span>;<br><span class="hljs-built_in">dfs</span>(nx, ny, color, cost + <span class="hljs-number">2</span>);<br>vis[nx][ny] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 现在位置有颜色（前面位置不管 &quot;本来&quot; 有没有颜色 他站在那 肯定是要么本来有 要么用了魔法有）</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 如果颜色和前面相等 不花费 直接进</span><br><span class="hljs-keyword">if</span> (color == g[nx][ny] &amp;&amp; cost &lt; dis[nx][ny])<br>&#123;<br>vis[nx][ny] = <span class="hljs-number">1</span>;<br>dis[nx][ny] = cost;<br><span class="hljs-built_in">dfs</span>(nx, ny, color, cost);<br>vis[nx][ny] = <span class="hljs-number">0</span>;<br><br>&#125;<br><span class="hljs-comment">// 如果颜色不相等 需要花费1</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cost + <span class="hljs-number">1</span> &lt; dis[nx][ny] &amp;&amp; cost + <span class="hljs-number">1</span> &lt; ans)<br>&#123;<br>dis[nx][ny] = cost + <span class="hljs-number">1</span>;<br>vis[nx][ny] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(nx, ny, g[nx][ny], cost + <span class="hljs-number">1</span>);<br>vis[nx][ny] = <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><br>g[u][v] = w + <span class="hljs-number">1</span>;<br>&#125;<br>vis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/*for (int i = 1; i &lt;= n; i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">for (int j = 1; j &lt;= n; j++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">cout &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0x3f3f3f3f</span>)cout &lt;&lt; <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="2981-找出出现至少三次的最长特殊子字符串-I-力扣（LeetCode）"><a href="#2981-找出出现至少三次的最长特殊子字符串-I-力扣（LeetCode）" class="headerlink" title="2981. 找出出现至少三次的最长特殊子字符串 I - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i/">2981. 找出出现至少三次的最长特殊子字符串 I - 力扣（LeetCode）</a></h2><p>使用贪心的思想。注意题目要求的特殊字符串只能由单一的字符组成，那么就可以记录每段连续相同字符的最长长度。</p><p>对这些长度进行排序，有多种情况</p><ul><li><p>第一种 a[0] - 2:</p><p>aaaaa要使其连续出现三次，那么就可以为<strong>aaa</strong>aa、a<strong>aaa</strong>a、aa<strong>aaa</strong>，可以发现最长的就是长度-2.</p></li><li><p>第二种 a[2]:</p></li></ul><p>​假设a字符有3个长为5的串，那么a[0],a[1],a[2]都为5，此时最长的 就是a[2]</p><ul><li><p>第三种 a[1]&#x3D;&#x3D;a[0]-1:</p><p>当a[1] &#x3D;&#x3D; a[0] - 1的时候 类似第一种情况 ，a[0] - 1可以凑两个，再加上a[1]就可以达到三个</p></li></ul><p>选出其中的最大值，由于第一种和第三种相差1 可以直接取其中的较小值来决定是1还是3</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumLength</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = <span class="hljs-number">0</span><br>        groups = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">or</span> x != s[i + <span class="hljs-number">1</span>]:<br>                groups[x].append(cnt)<br>                cnt = <span class="hljs-number">0</span><br>        <br>        ans = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> groups.values():<br>            a.sort(reverse=<span class="hljs-literal">True</span>)<br>            a.extend([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br>            ans = <span class="hljs-built_in">max</span>(ans, a[<span class="hljs-number">0</span>] - <span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>(a[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, a[<span class="hljs-number">1</span>]), a[<span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ans == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> ans<br></code></pre></td></tr></table></figure><h2 id="56-合并-力扣（LeetCode）"><a href="#56-合并-力扣（LeetCode）" class="headerlink" title="56. 合并- 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并- 力扣（LeetCode）</a></h2><p>类似区间合并，但是要求输出修改后的区间值，首先对区间进行排序，然后就可以不断更新区间的右端点</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals = <span class="hljs-built_in">sorted</span>(intervals, key=<span class="hljs-keyword">lambda</span> x:(x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        n = <span class="hljs-built_in">len</span>(intervals)<br>        ans = [intervals[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> ele[<span class="hljs-number">0</span>] &gt; ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                ans.append(ele)<br>            <span class="hljs-keyword">else</span>:<br>                ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], ele[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="2028-找出缺失的观测数据-力扣（LeetCode）"><a href="#2028-找出缺失的观测数据-力扣（LeetCode）" class="headerlink" title="2028. 找出缺失的观测数据 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-missing-observations/description/">2028. 找出缺失的观测数据 - 力扣（LeetCode）</a></h2><p>求出缺失值，可以由输入数据求出数据的总和，再减去输入数据的和，就可以得到缺失值的和。</p><p>关键在于缺失值必须都在1-6之间。可以从6开始枚举，可以选择多少个，尽量多选择大的数，只要在区间内，就一定可以求出解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">missingRolls</span>(<span class="hljs-params">self, rolls: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], mean: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        sz = n + <span class="hljs-built_in">len</span>(rolls)<br>        left = mean * sz - <span class="hljs-built_in">sum</span>(rolls)<br>        a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">if</span> left &lt; n <span class="hljs-keyword">or</span> left &gt; <span class="hljs-number">6</span> * n:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">else</span>:<br>            ans = [left // n] * n<br>            <span class="hljs-keyword">if</span> left % n == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> ans<br>            <span class="hljs-keyword">else</span>:<br>                left = left % n<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left):<br>                    ans[i] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="2935-找出强数对的最大异或值-II-力扣（LeetCode）"><a href="#2935-找出强数对的最大异或值-II-力扣（LeetCode）" class="headerlink" title="2935. 找出强数对的最大异或值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/submissions/482713400/">2935. 找出强数对的最大异或值 II - 力扣（LeetCode）</a></h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>():<br>    __slots__ = <span class="hljs-string">&#x27;children&#x27;</span>, <span class="hljs-string">&#x27;cnt&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.children = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]<br>        self.cnt = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>():<br>    HIGH_BIT = <span class="hljs-number">19</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = Node()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cur.children[bit] = Node()<br>            cur = cur.children[bit]<br>            cur.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            cur = cur.children[(val &gt;&gt; i) &amp; <span class="hljs-number">1</span>]<br>            cur.cnt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_xor</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cur = self.root<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit ^ <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> cur.children[bit ^ <span class="hljs-number">1</span>].cnt:<br>                ans |= <span class="hljs-number">1</span> &lt;&lt; i<br>                bit ^= <span class="hljs-number">1</span><br>            cur = cur.children[bit]<br>        <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumStrongPairXor</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        root = Trie()        <br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ret = left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> nums:<br>            root.insert(y)<br>            <span class="hljs-keyword">while</span> nums[left] * <span class="hljs-number">2</span> &lt; y:<br>                root.remove(nums[left])<br>                left += <span class="hljs-number">1</span><br>            ret = <span class="hljs-built_in">max</span>(ret, root.max_xor(y))            <br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="贡献法"><a href="#贡献法" class="headerlink" title="贡献法"></a>贡献法</h1><h2 id="828-统计子串中的唯一字符-力扣（LeetCode）"><a href="#828-统计子串中的唯一字符-力扣（LeetCode）" class="headerlink" title="828. 统计子串中的唯一字符 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/?envType=daily-question&envId=2023-11-26">828. 统计子串中的唯一字符 - 力扣（LeetCode）</a></h2><p>贡献法  一个字符 能贡献1 代表他在这个子数组里 是唯一的 那就求这样的子数组有多少个 那就在前后找 他上一个和下一个相同元素 这中间的所有数的子数组个数 就是贡献度</p><p>预处理这个字符的前后的相同的字符的位置 然后再用乘法原理算出来相同子数组的个数  注意这里的子数组是类子串而不是类子序列</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniqueLetterString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        res = <span class="hljs-number">0</span><br>        m = &#123;&#125;<br>        l = [<span class="hljs-number">0</span>] * n<br>        r = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            x = s[i]<br>            l[i] = m.get(x, -<span class="hljs-number">1</span>)<br>            m[x] = i<br>        m.clear()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            x = s[i]<br>            r[i] = m.get(x, n)<br>            m[x] = i<br>        <br>        res = <span class="hljs-built_in">sum</span>((i - a) * (b - i) <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(l, r)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="907-子数组的最小值之和-力扣（LeetCode）"><a href="#907-子数组的最小值之和-力扣（LeetCode）" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h2><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="2477-到达首都的最少油耗-力扣（LeetCode）-https-leetcode-cn-problems-minimum-fuel-cost-to-report-to-the-capital-description"><a href="#2477-到达首都的最少油耗-力扣（LeetCode）-https-leetcode-cn-problems-minimum-fuel-cost-to-report-to-the-capital-description" class="headerlink" title="2477. 到达首都的最少油耗 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/)"></a>2477. 到达首都的最少油耗 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/</a>)</h2><p>计算每条边的贡献 到首都的人数是固定的 每个人要走的边也是固定的 因此可以用贡献法直接计算出每条边会有多少人经过 然后再把这个贡献 &#x2F;&#x2F; 车载数 就可以得到这条边上要消耗的油量 然后把所有边加起来就行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumFuelCost</span>(<span class="hljs-params">self, roads: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], seats: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    g = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> roads:<br>        g[a].append(b)<br>        g[b].append(a)<br>    <br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 令dfs返回这条路的人数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, fa</span>):<br>        <span class="hljs-comment"># 每条路至少有端点这一个人走</span><br>        ret = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>            <span class="hljs-keyword">if</span> y != fa:<br>                <span class="hljs-keyword">nonlocal</span> ans<br>                t = dfs(y, x)<br>                ans += (t - <span class="hljs-number">1</span>) // seats + <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 现在ret 就是这个点到终点的人数 （注意一个点可通向多个点 有多个终点 这些终点是不算在这个ret里的 而是算在fa的ret里）</span><br>            ret += t<br>        <span class="hljs-keyword">return</span> ret<br>dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> ans<br>                <br></code></pre></td></tr></table></figure><h2 id="979-在二叉树中分配硬币-力扣（LeetCode）"><a href="#979-在二叉树中分配硬币-力扣（LeetCode）" class="headerlink" title="979. 在二叉树中分配硬币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/">979. 在二叉树中分配硬币 - 力扣（LeetCode）</a></h2><p>类似于贡献法 算出棵子树的硬币总数 和结点数 就可以算出 有多少硬币要移出这棵子树  然后就可以算出 有多少硬币要移出这个子树的边<img src="/../images/$%7Bfiilename%7D/image-20231206230837411.png" alt="image-20231206230837411"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCoins</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 返回硬币数和结点数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root:TreeNode</span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            l_c, l_n = dfs(root.left)<br>            r_c, r_n = dfs(root.right)<br>          coin = l_c + r_c + root.val<br>            node = l_n + r_n + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">nonlocal</span> ans<br>            ans += <span class="hljs-built_in">abs</span>(coin - node)<br>            <span class="hljs-keyword">return</span> (coin, node)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="907-子数组的最小值之和-力扣（LeetCode）-1"><a href="#907-子数组的最小值之和-力扣（LeetCode）-1" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h2><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="2454-下一个更大元素-IV-力扣（LeetCode）"><a href="#2454-下一个更大元素-IV-力扣（LeetCode）" class="headerlink" title="2454. 下一个更大元素 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-iv/description/">2454. 下一个更大元素 IV - 力扣（LeetCode）</a></h2><p>要找到下下个更大的元素   其实就是用单调栈  一个单调栈用于找下一个更大的元素  两个单调栈就可以找下下个更大的元素</p><p>st1存放 (暂时没找到比他大的)元素   st2存放(已经有一个比他大)的元素</p><p>每次先判断当前元素x 是否大于st2中的元素 如果是  就直接更新ans</p><p>然后判断有多少个st1中的数可以被更新到st2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">secondGreaterElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        st1 = []<br>        st2 = []<br>        ans = [-<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">while</span> st2 <span class="hljs-keyword">and</span> nums[st2[-<span class="hljs-number">1</span>]] &lt; x:<br>                ans[st2.pop()] = x<br>            j = <span class="hljs-built_in">len</span>(st1) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[st1[j]] &lt; x:<br>                j -= <span class="hljs-number">1</span><br>            st2 += st1[j + <span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">del</span> st1[j + <span class="hljs-number">1</span>:]<br>            st1.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="1673-找出最具竞争力的子序列-力扣（LeetCode）"><a href="#1673-找出最具竞争力的子序列-力扣（LeetCode）" class="headerlink" title="1673. 找出最具竞争力的子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/">1673. 找出最具竞争力的子序列 - 力扣（LeetCode）</a></h2><p>主要是没看出来是用单调栈的题目 </p><p>一般来说需要从小到大（比如每日温度那个题）就是用单调栈</p><p>这个题目就满足 为了取最小的数 需要小数放前面 大数放后面 而且要按照数组中出现的顺序 所以可以考虑用单调栈</p><p>特别的是 这个题还有数量要求 必须是k个数字</p><p><strong>那就设置last &#x3D; n - k 表示pop的次数</strong> 在单调栈循环内 如果pop超过了last次 后面就不再pop了 否则数量不够k个  在单调栈循环结束后 如果last大于0 表示超过了k个数 需要再pop掉last次 由于小的数字放越前面越好 所以pop肯定是越早越好 所以就是遇到可以pop的就pop 后面的次数不够了就直接push进来</p><p>然后注意这题单调栈里面放的是数 不是下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mostCompetitive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> last = n - k;<br>        vector&lt;<span class="hljs-type">int</span>&gt;st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; last &gt; <span class="hljs-number">0</span> &amp;&amp; st.<span class="hljs-built_in">back</span>() &gt; nums[i])<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                last--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(last--)<br>            st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> st;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2302-统计得分小于-K-的子数组数目-力扣（LeetCode）"><a href="#2302-统计得分小于-K-的子数组数目-力扣（LeetCode）" class="headerlink" title="2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）</a></h2><p>这题首先是个数学问题  当出现连续的子数组的时候 每次答案增加的数量是 <strong>r - l + 1</strong> 知道这个之后就好想到滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0L</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++)<br>        &#123;<br>            sum += nums[r];<br>            <span class="hljs-keyword">while</span> (sum * (r - l + <span class="hljs-number">1</span>) &gt;= k) <br>            &#123;<br>                sum -= nums[l++];<br>            &#125;<br>            ans += r - l + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn-https-www-luogu-com-cn-problem-P5318"><a href="#P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn-https-www-luogu-com-cn-problem-P5318" class="headerlink" title="P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5318)"></a>P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](<a href="https://www.luogu.com.cn/problem/P5318">https://www.luogu.com.cn/problem/P5318</a>)</h2><p>用vector<int>graph[N]存图 类似于defaultdict(list)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>vis[x] = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[x][i]])<br>&#123;<br><span class="hljs-built_in">dfs</span>(graph[x][i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(x);<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[a].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[a][i]])<br>&#123;<br>vis[graph[a][i]] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(graph[a][i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">emplace_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">sort</span>(graph[i].<span class="hljs-built_in">begin</span>(), graph[i].<span class="hljs-built_in">end</span>());<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>有向图求每个点能到达的编号最大的点</p><p>图论的经典做法  存反图然后从最大的点开始遍历他能到达的所有点 更新  后续如果这个点已经更新过了 就不再更新了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;fgraph[N];<br><span class="hljs-type">int</span> dis[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>dis[x] = d;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fgraph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(fgraph[x][i], d);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>fgraph[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">dfs</span>(i, i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1113">P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>经典拓扑+动态规划</p><p>把前面的杂物干完才能干后面的事  拓扑排序</p><p>并且加上了动态规划（有点类似dijkstra）   完成所有杂物的最短时间 每次循环更新 到u这个任务需要的最短时间 （即f[u] &#x3D; max(f[u], f[x] + t[u]）到u的最短 即到源点到x的最短加上到x到u的最短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">500500</span>;<br><br>vector&lt;<span class="hljs-built_in">int</span>&gt;graph[N];<br><span class="hljs-built_in">int</span> deg[N];<br><span class="hljs-built_in">int</span> f[N];<br><span class="hljs-built_in">int</span> t[N];<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; t[i];<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v &amp;&amp; v)<br>&#123;<br>graph[v].push_back(u);<br>deg[u]++;<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-built_in">int</span>&gt;q;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(i);<br>f[i] = t[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.empty())<br>&#123;<br><span class="hljs-built_in">int</span> x = q.front();<br>q.pop();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].size(); i++)<br>&#123;<br><span class="hljs-built_in">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(u);<br>&#125;<br>f[u] = <span class="hljs-built_in">max</span>(f[u], f[x] + t[u]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>求食物链的数量（食物链必须到最高消费者 即不被捕食的动物 即出度为0的）</p><p>拓扑排序+动态规划 </p><p>比如a-&gt;b-&gt;c   每次更新时 nums[b] &#x3D; nums[b] + nums[a] 把到第a的食物链条数全部累加到b中  最后把出度为0的点的条数加上 即为答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">80112002</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> deg[N], out[N], nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>deg[b]++;<br>out[a]++;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>nums[i] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(u);<br>&#125;<br>nums[u] = (nums[u] + nums[x]) % mod;<br>&#125;<br><br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>)<br>&#123;<br>ans = (nums[i] + ans)%mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1807">P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>最长路问题   还是动态规划  d[i] &#x3D; max(d[x]  + mp[x ] [ i ], d[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000</span>, M = <span class="hljs-number">55000</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> d[N], mp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> u, v, w;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>mp[u][v] = <span class="hljs-built_in">max</span>(mp[u][v], w);<br>&#125;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (mp[x][i] &amp;&amp; d[i] &lt; d[x] + mp[x][i])<br>&#123;<br>d[i] = d[x] + mp[x][i];<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>&#125;<br>&#125;<br><br>cout &lt;&lt; d[n] &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2853 USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2853 <a href="https://www.luogu.com.cn/problem/P2853">USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>求有几个地方 是所有的奶牛都可以的到达的</p><p>那每次走过的时候次数+1  当all[x] &#x3D;&#x3D; k 的时候就代表这个点都可以到达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> a[N], vis[N], all[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>vis[x] = <span class="hljs-number">1</span>;<br>all[x] += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> y = graph[x][i];<br><span class="hljs-keyword">if</span> (vis[y] == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(a[i]);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (all[i] == k)<br>ans += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1363">P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>无线的地图 那么只要它能够回到原点 就说明可以从一个点到另一个点  就可以无限走 就符合题意</p><p>用vis储存横纵坐标和是否访问  </p><p>每次进入先判断该点（是取模过的点 ***）是否已经访问过  如果访问过 并且x， y跟之前的不一样（只要有一个不一样就行）那就说明走到了另一个地图的原点 说明可以无限</p><p>如果访问过 并且是回到了原点 那就退回</p><p>标记该点为已访问 像四个方向拓展  lx和ly用来记录是否走出  要取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m, n, sx, sy, dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;, dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;, ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">bool</span> graph[N][N] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">int</span> vis[N][N][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> ly)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; (vis[lx][ly][<span class="hljs-number">0</span>] != x || vis[lx][ly][<span class="hljs-number">1</span>] != y))<br>&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; vis[lx][ly][<span class="hljs-number">0</span>] == x &amp;&amp; vis[lx][ly][<span class="hljs-number">1</span>] == y)<span class="hljs-keyword">return</span>;<br>vis[lx][ly][<span class="hljs-number">0</span>] = x; vis[lx][ly][<span class="hljs-number">1</span>] = y; vis[lx][ly][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nx, ny;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">4</span>; w++)<br>&#123;<br>nx = (lx + dx[w] + n) % n;<br>ny = (ly + dy[w] + m) % m;<br><span class="hljs-keyword">if</span> (graph[nx][ny])<span class="hljs-built_in">dfs</span>(x + dx[w], y + dy[w], nx, ny);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(graph, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(graph));<br>ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>)graph[i][j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;S&#x27;</span>)<br>&#123;<br>sx = i, sy = j;<br>graph[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> graph[i][j] = <span class="hljs-literal">false</span>;<br>&#125; <br>&#125;<br><span class="hljs-built_in">dfs</span>(sx, sy, sx, sy);<br><span class="hljs-keyword">if</span> (ans)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="省份数量-547-省份数量-力扣（LeetCode）"><a href="#省份数量-547-省份数量-力扣（LeetCode）" class="headerlink" title="[省份数量](547. 省份数量 - 力扣（LeetCode）)"></a>[省份数量](<a href="https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory">547. 省份数量 - 力扣（LeetCode）</a>)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>cities = <span class="hljs-built_in">len</span>(isConnected)<br>        province = <span class="hljs-number">0</span><br>        vis = [<span class="hljs-number">0</span>] * cities<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[j] <span class="hljs-keyword">and</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    vis[j] = <span class="hljs-number">1</span><br>                    dfs(j)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                vis[i] = <span class="hljs-number">1</span><br>                province += <span class="hljs-number">1</span><br>                dfs(i)<br><br>        <span class="hljs-keyword">return</span> province<br>    <br>   <span class="hljs-comment"># 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 </span><br><span class="hljs-comment"># 重点在并查集的写法</span><br>uf = UnionFind()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(isConnected)):<br>            uf.add(i)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    uf.merge(i,j)<br>        <span class="hljs-keyword">return</span> uf.num_of_sets<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.father = &#123;&#125;<br>        self.num_of_sets = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self,x</span>):<br>        root = x<br>        <span class="hljs-keyword">while</span> self.father[root] != <span class="hljs-literal">None</span>:<br>            root = self.father[root]<br><span class="hljs-comment"># 让并查集更宽 减少时间复杂度</span><br>        <span class="hljs-keyword">while</span> x != root:<br>            original_father = self.father[x]<br>            self.father[x] = root<br>            x = original_father<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self,x,y</span>):<br>        root_x, root_y = self.find(x),self.find(y)<br><br>        <span class="hljs-keyword">if</span> root_x != root_y:<br>            self.father[root_x] = root_y<br>            self.num_of_sets -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.father:<br>            self.father[x] = <span class="hljs-literal">None</span><br>            self.num_of_sets += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h2 id="找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）"><a href="#找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="[找到最终的安全状态](802. 找到最终的安全状态 - 力扣（LeetCode）)"></a>[找到最终的安全状态](<a href="https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory">802. 找到最终的安全状态 - 力扣（LeetCode）</a>)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2</span><br><span class="hljs-string">一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全</span><br><span class="hljs-string">&quot;&quot;&quot;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>n = <span class="hljs-built_in">len</span>(graph)<br>        color = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>            <span class="hljs-comment"># 访问已经搜过的结点 1为有环 2为无环</span><br>            <span class="hljs-keyword">if</span> color[x] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span><br>            <span class="hljs-comment"># 如果是0</span><br>            color[x] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-comment"># 快速退出</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> safe(y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True</span><br>            color[x] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>       <br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> safe(i)]<br>    <br>    <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的</span><br><span class="hljs-string">    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序</span><br><span class="hljs-string">    循环结束后 所有入度为0的结点都是安全的</span><br><span class="hljs-string">    意思是，原图的出度为0的结点，和指向出度为0的结点的结点</span><br><span class="hljs-string">    （由于存了反图并拓扑排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> graph]<br>        <span class="hljs-comment"># 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0</span><br>        <span class="hljs-keyword">for</span>  x, ys <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:<br>rg[y].append(x)<br>        <span class="hljs-comment"># in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）</span><br>        in_deg = [<span class="hljs-built_in">len</span>(ys) <span class="hljs-keyword">for</span> ys <span class="hljs-keyword">in</span> graph]<br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>])<br><span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rg[q.popleft()]:<br>                in_deg[x] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[x] == <span class="hljs-number">0</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i, d  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="颜色交替的最短路径"><a href="#颜色交替的最短路径" class="headerlink" title=" 颜色交替的最短路径 "></a><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory"> 颜色交替的最短路径 </a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestAlternatingPaths</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, redEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], blueEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> redEdges:<br>            g[x].append((y,<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> blueEdges:<br>            g[x].append((y,<span class="hljs-number">1</span>))<br>        <br><br>        dis = [-<span class="hljs-number">1</span>] * n<br>        vis = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        q = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> x, color <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">if</span> dis[x] == -<span class="hljs-number">1</span>:<br>                    dis[x] = level<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-keyword">if</span> p[<span class="hljs-number">1</span>] != color <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        vis.add(p)<br>                        q.append(p)<br>            level += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dis<br></code></pre></td></tr></table></figure><h2 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间 "></a><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/">通知所有员工所需的时间 </a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            g[manager[i]].append(i)<br><br>        q = collections.deque()<br>        q.append((headID, <span class="hljs-number">0</span>))<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tid, val = q.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g[tid]) == <span class="hljs-number">0</span>:<br>                res = <span class="hljs-built_in">max</span>(res, val)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> ne <span class="hljs-keyword">in</span> g[tid]:<br>                    q.append((ne, val + informTime[tid]))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="1466-重新规划路线-力扣（LeetCode）"><a href="#1466-重新规划路线-力扣（LeetCode）" class="headerlink" title="1466. 重新规划路线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory">1466. 重新规划路线 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> connections:<br>            g[a].append((b, <span class="hljs-number">1</span>))<br>            g[b].append((a, <span class="hljs-number">0</span>))<br>        <br>        q = deque([<span class="hljs-number">0</span>])<br>        vis = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">while</span> q:<br>            cur = q.popleft()<br>            <span class="hljs-comment"># 遍历所有和cur相邻的边</span><br>            <span class="hljs-keyword">for</span> end, dirction <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g[cur]):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[end]:<br>                    vis[end] = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果方向不对就反转</span><br>                    res += dirction<br>                    q.append(end)<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <br><span class="hljs-comment"># 或者 用set一次遍历  有点问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = &#123;<span class="hljs-number">0</span>&#125;<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> connection:<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> s:<br>                s.add(l)<br>            <span class="hljs-comment"># 右边不通向0 并且左边通向0 （左边通向右边） 那就让r-&gt;l r就可以到0</span><br>            <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">in</span> s:<br>                s.add(r)<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>                <br>        <br></code></pre></td></tr></table></figure><h2 id="1192-查找集群内的关键连接-力扣（LeetCode）"><a href="#1192-查找集群内的关键连接-力扣（LeetCode）" class="headerlink" title="1192. 查找集群内的关键连接 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory">1192. 查找集群内的关键连接 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环 （此时的curnode为入口结点）</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="934-最短的桥-力扣（LeetCode）"><a href="#934-最短的桥-力扣（LeetCode）" class="headerlink" title="934. 最短的桥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory">934. 最短的桥 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两座相同的岛 先找到第一个不为0的数然后dfs标记这个岛的全部，然后用bfs搜索当第一次搜到第二个岛的step即是答案，注意dfs的时候要把第一个岛全部放入q（因为每个点都可能是距离第二个岛最近的点）搜完上下左右一圈后step + 1 （不需要vis数组记录 直接把走过的设为-1即可）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBridge</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = -<span class="hljs-number">1</span><br>            q.append((x, y))<br>            <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                    dfs(nx, ny)<br><br>        n = <span class="hljs-built_in">len</span>(grid)<br>        q = deque()<br>        i, j = <span class="hljs-built_in">next</span>((i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> grid[i][j])<br>        dfs(i, j)<br>        step = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x, y = q.popleft()<br>                <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n :<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">return</span> step<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">0</span>:<br>                            grid[nx][ny] = -<span class="hljs-number">1</span><br>                            q.append((nx, ny))<br>            step += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="127-单词接龙-力扣（LeetCode）"><a href="#127-单词接龙-力扣（LeetCode）" class="headerlink" title="127. 单词接龙 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=graph-theory">127. 单词接龙 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每次枚举26个字母 一一替换单词 直到找到wordList的单词 如果是end的话就直接返回 否则step+1放入q继续bfs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> beginWord == endWord:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        word = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)]<br>        q = deque([(beginWord, <span class="hljs-number">1</span>)])<br>        <span class="hljs-keyword">while</span> q:<br>            cur, step = q.popleft()<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cur):<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> word:<br>                    <span class="hljs-keyword">if</span> x != y:<br>                        nxt = cur[:i] + y + cur[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">in</span> wordList:<br>                            <span class="hljs-keyword">if</span> nxt == endWord:<br>                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                            q.append((nxt, step + <span class="hljs-number">1</span>))<br>                            wordList.remove(nxt)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="126-单词接龙-II-力扣（LeetCode）"><a href="#126-单词接龙-II-力扣（LeetCode）" class="headerlink" title="126. 单词接龙 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个方法相当于是每次把step=1的所有数都找出来并且加进去 把所有step=2的都找出来加进去这样（&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot; and &quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;）     当q（内层）取完之后表示当前步数可以链接的下一个单词已经全部找到 可以step+1 然后把s中暂存的给q 再次循环    直到end 加入答案 （当内层q为0的时候表示所有路径都已经加进去 就直接return） 当q（外层）取完（也就是sq交换的时候s为[]）之后表示所有路径都已经走过 但是还没有遇到end 这时返回[]</span><br><span class="hljs-comment"># 首先 建图方面 建立这个单词可以变的其他单词 变化处用* 表示 用defaultdict后面可以快速访问 </span><br><span class="hljs-comment"># 然后q用来存储当前值和当前路径 s与q相同 但是s是用来存储每轮的数据 每次开始时s都为[] （保证数据 相当于temp）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLadders</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> []<br>        dic = defaultdict(<span class="hljs-built_in">list</span>)<br>        n = <span class="hljs-built_in">len</span>(beginWord)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]].append(w)<br>        <br>        q, s = [(beginWord, [beginWord])], []<br>        res = []<br>        vis = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">while</span> q:<br>                w, path = q.pop()<br>                vis.add(w)<br>                <span class="hljs-keyword">if</span> w == endWord:<br>                    res.append(path)<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]]:<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                            s.append((nxt, path + [nxt]))<br>            <span class="hljs-keyword">if</span> res:<br>                <span class="hljs-keyword">return</span> res<br>            q, s = s, q<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="542-01-矩阵-力扣（LeetCode）"><a href="#542-01-矩阵-力扣（LeetCode）" class="headerlink" title="542. 01 矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/01-matrix/description/?envType=study-plan-v2&envId=graph-theory">542. 01 矩阵 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多起点的最短路问题 可以将所有的0 看成同一个源点 然后使用bfs 因为每次扩散一轮 所有的都加一时候再扩散下一轮（队列 先进先出）每次只需要搜索四个方向 然后再原来的ret的基础上加一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n, m = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        ret = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        q = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:<br>                    ret[i][j] = <span class="hljs-number">0</span><br>                    q.append([i,j])<br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j = q.popleft()<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> ret[ni][nj] == -<span class="hljs-number">1</span>:<br>                    ret[ni][nj] = ret[i][j] + <span class="hljs-number">1</span><br>                    q.append([ni, nj])<br><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h2 id="863-二叉树中所有距离为-K-的结点-力扣（LeetCode）"><a href="#863-二叉树中所有距离为-K-的结点-力扣（LeetCode）" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/?envType=study-plan-v2&envId=graph-theory">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distanceK</span>(<span class="hljs-params">self, root: TreeNode, target: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 首先用字典node_parent存储每个结点的父节点</span><br>        node_parent = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_find_parent</span>(<span class="hljs-params">node: TreeNode</span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">if</span> node.left:<br>                node_parent[node.left] = node<br>            <span class="hljs-keyword">if</span> node.right:<br>                node_parent[node.right] = node<br>            dfs_find_parent(node.left)<br>            dfs_find_parent(node.right)<br><br><br>        dfs_find_parent(root)<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [target.val]<br>        res = []<br><br>        q = deque()<br>        vis = <span class="hljs-built_in">set</span>()<br>        q.append(target)<br>        vis.add(target)<br>        <span class="hljs-comment"># 现在依次遍历和target距离为level的结点（波纹法 一层层搜索）</span><br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> level &lt; k:<br>            level += <span class="hljs-number">1</span> <span class="hljs-comment"># 先加还是后加取决于level初值</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [node_parent[x] <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> node_parent <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, x.left, x.right]: <span class="hljs-comment"># 遍历和当前点相邻的所有结点（每次搜索一层 注意要用set判重）</span><br>                    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">and</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        <span class="hljs-keyword">if</span> level == k:<br>                            res.append(y.val)<br>                        q.append(y)<br>                        vis.add(y)<br>        <span class="hljs-keyword">return</span> res<br><br>                <br></code></pre></td></tr></table></figure><h2 id="864-获取所有钥匙的最短路径-力扣（LeetCode）"><a href="#864-获取所有钥匙的最短路径-力扣（LeetCode）" class="headerlink" title="864. 获取所有钥匙的最短路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/?envType=study-plan-v2&envId=graph-theory">864. 获取所有钥匙的最短路径 - 力扣（LeetCode）</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不同之处在于 并不是一个点只能走一次 而是可以多次走 找到最短的路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathAllKeys</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dis 用于记录每个点走的距离 不同的是 现在有3个状态 多了一个钥匙数的状态 </span><br>        dis = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0x3f3f3f3f</span>)<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>:<br>                    q = deque([(i, j, <span class="hljs-number">0</span>)])<br>                    dis[(i, j, <span class="hljs-number">0</span>)] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> grid[i][j].islower():<br>                    cnt += <span class="hljs-number">1</span><br><br><br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        <br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j, cur = q.popleft()<br>            step = dis[(i,  j, cur)]<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m:<br>                    c = grid[ni][nj]<br>                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 先将cur右移c位然后&amp;1判断是否为1</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> <span class="hljs-keyword">and</span> (cur &gt;&gt; (<span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    ncur = cur<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:<br>                        <span class="hljs-comment"># 标记为已有</span><br>                        ncur |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-keyword">if</span> ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 如果曾经走到过这里 并且步数更少的话 更新 （如果没有走到过的话 那就是0x3f3f3f3f 必定更新）</span><br>                    <span class="hljs-keyword">if</span> step + <span class="hljs-number">1</span> &lt; dis[(ni, nj, ncur)]:<br>                        dis[(ni, nj, ncur)] = step + <span class="hljs-number">1</span><br>                        q.append((ni, nj, ncur))<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h2 id="1334-阈值距离内邻居最少的城市-力扣（LeetCode）"><a href="#1334-阈值距离内邻居最少的城市-力扣（LeetCode）" class="headerlink" title="1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></h2><p>题目要求一个城市在距离小于distanceThreshold下能够到达的城市</p><p>可以直接求 对每个城市进行搜索 也可以直接用Floyd 算法求出每两个城市之间的距离 再找距离小于dis的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheCity</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], distanceThreshold: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        graph = [[inf] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b, w <span class="hljs-keyword">in</span> edges:<br>            graph[a][b] = graph[b][a] = w<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])<br>        <br>        ans = min_cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> j != i <span class="hljs-keyword">and</span> graph[i][j] &lt;= distanceThreshold:<br>                    cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt &lt;= min_cnt:<br>                min_cnt = cnt<br>                ans = i<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="2646-最小化旅行的价格总和-力扣（LeetCode）"><a href="#2646-最小化旅行的价格总和-力扣（LeetCode）" class="headerlink" title="2646. 最小化旅行的价格总和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/">2646. 最小化旅行的价格总和 - 力扣（LeetCode）</a></h2><p>树形DP  要算所有的路径  的总和可以先暴力DFS算出所有的路径的<strong>贡献</strong>：也就是比如0-1-2中求(0,2)(1,2) 那么1-2 算了两次 这样求出所有边走的次数cnt[x]</p><p>遍历(start, end) 求cnt</p><p>然后知道每个边的 次数之后再用树形DP（打家劫舍3）求出最小值   每个点减或不减</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotalPrice</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], price: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], trips: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            g[a].append(b)<br>            g[b].append(a)<br>        cnt = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> trips:<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>                <span class="hljs-keyword">if</span> x == end:<br>                    cnt[x] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-comment"># dfs(y) 是为了说明这是可以到end的路(到end之后再往回更新cnt)</span><br>                    <span class="hljs-keyword">if</span> y != fa <span class="hljs-keyword">and</span> dfs(y):<br>                        cnt[x] += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dfs(start, -<span class="hljs-number">1</span>)<br>        <br>       <span class="hljs-comment"># 现在就得到了走的边的次数 再加上已知点的权值 用树形DP求</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            now_not_halve = price[x] * cnt[x]<br>            now_halve = price[x] * cnt[x] // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                <span class="hljs-keyword">if</span> y != fa:<br>                    kid_not_halve, kid_halve = dfs(y, x)<br>                    now_not_halve += <span class="hljs-built_in">min</span>(kid_not_halve, kid_halve)<br>                    now_halve += kid_not_halve<br>            <span class="hljs-keyword">return</span> now_not_halve, now_halve<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))<br>        <br>                        <br></code></pre></td></tr></table></figure><h2 id="1631-最小体力消耗路径-力扣（LeetCode）"><a href="#1631-最小体力消耗路径-力扣（LeetCode）" class="headerlink" title="1631. 最小体力消耗路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径 - 力扣（LeetCode）</a></h2><p>看起来像DP但是其实是图论的题  为什么呢  因为dp只能向一个方向更新 比如只能一直向下 选择 [i + 1] [j - 1] 、[i + 1] [j] 、[i + 1] [j + 1] 这三种 但是这个题明显就是有4个方向 类似BFS</p><h2 id="方法一、-二分-BFS"><a href="#方法一、-二分-BFS" class="headerlink" title="方法一、 二分+BFS"></a>方法一、 二分+BFS</h2><p>二分可能的最大差异值 用bfs计算 如果最大差异大于x则…</p><p>注意这里维护的是最大差异  每次当更新的时候如果差异值小于x才更新 最终如果能到达右下角说明这个x可以</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">10</span>**<span class="hljs-number">6</span>+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">mid</span>):<br>            dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>            dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>            q = deque()<br>            q.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            minn = maxn = heights[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>            vis = [[<span class="hljs-literal">False</span>] * m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> q:<br>                x, y = q.popleft()<br><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                    nx = x + dx[i]<br>                    ny = y + dy[i]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> vis[nx][ny] <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]) &lt;= mid:<br>                        vis[nx][ny] = <span class="hljs-number">1</span><br>                        q.append((nx, ny))<br><br>            <span class="hljs-keyword">return</span> vis[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="方法二、并查集"><a href="#方法二、并查集" class="headerlink" title="方法二、并查集"></a>方法二、并查集</h2><p>其实是Kruskal算法  对所有边排序之后 不断添加边 同时维护最大差异值 直到左上角和右下角联通 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">if</span> fa[x] == x:<br>                <span class="hljs-keyword">return</span> x<br>            fa[x] = find(fa[x])<br>            <span class="hljs-keyword">return</span> fa[x]<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>            fa[find(x)] = find(y)<br><br>        edgelen = []<br>        fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                pos = i * m + j<br>                <span class="hljs-keyword">if</span> i &lt; n - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i + <span class="hljs-number">1</span>][j] - heights[i][j]), pos, pos + m])<br>                <span class="hljs-keyword">if</span> j &lt; m - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i][j + <span class="hljs-number">1</span>] - heights[i][j]), pos, pos + <span class="hljs-number">1</span>])<br>        <br>        edgelen.sort()<br>        <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edgelen:<br>            union(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">if</span> find(<span class="hljs-number">0</span>) == find(m * n - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> e[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="方法三、最短路"><a href="#方法三、最短路" class="headerlink" title="方法三、最短路"></a>方法三、最短路</h2><p>Dijikstra算法  只不过本来维护最短距离  现在维护最大差异 本来是存边  现在不需要存边 直接用BFS</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        q = [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]<br>        dis = [inf] * (m * n)<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        vis = <span class="hljs-built_in">set</span>()<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> q:<br>            d, x, y = heapq.heappop(q)<br>            pos = x * m + y<br>            <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> vis:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> (x, y) == (n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">break</span><br>            vis.add(pos)<br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = dx[i] + x<br>                ny = dy[i] + y<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny])) &lt;= dis[nx * m + ny]:<br>                    dis[nx * m + ny] = <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]))<br>                    heapq.heappush(q, (dis[nx * m + ny], nx, ny))<br>        <span class="hljs-keyword">return</span> dis[m * n - <span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><h2 id="1345-跳跃游戏-IV-力扣（LeetCode）"><a href="#1345-跳跃游戏-IV-力扣（LeetCode）" class="headerlink" title="1345. 跳跃游戏 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game-iv/">1345. 跳跃游戏 IV - 力扣（LeetCode）</a></h2><p>BFS 但是要分情况 主要是存图要用map存 map[arr[i]].push_back(i);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            mp[arr[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dist</span>(n, inf);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(), step = dist[x];<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; n &amp;&amp; dist[x + <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x + <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dist[x - <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x - <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : mp[arr[x]])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dist[y] == inf)<br>                &#123;<br>                    dist[y] = step + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125;<br>            &#125;<br>            mp[arr[x]].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1207-大臣的旅费-AcWing题库"><a href="#1207-大臣的旅费-AcWing题库" class="headerlink" title="1207. 大臣的旅费 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1209/">1207. 大臣的旅费 - AcWing题库</a></h2><p>求树的直径问题</p><p>要求相距最远的两个城市 也就是求树的直径 </p><p>先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径</p><p>用dis记录任意点到i点的最远距离</p><p>dfs中需要添加father 防止回头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ;<br><span class="hljs-type">int</span> w[N] , e[N] , ne[N] , h[N] , idx ;<br><span class="hljs-type">int</span> maxu , maxd ;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b , <span class="hljs-type">int</span> c )</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> fa , <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    dis[u] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i != <span class="hljs-number">-1</span> ; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j != fa)<br>            <span class="hljs-built_in">dfs</span>(j,u,d + w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a , b , c ;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxd * <span class="hljs-number">10</span> + (maxd + <span class="hljs-number">1ll</span>) * maxd / <span class="hljs-number">2</span> &lt;&lt; endl ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4月</title>
    <link href="/2024/03/31/4%E6%9C%88/"/>
    <url>/2024/03/31/4%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="53-最大子数组和-力扣（LeetCode）"><a href="#53-最大子数组和-力扣（LeetCode）" class="headerlink" title="53. 最大子数组和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;1</li></ul><img src="../images/$%7Bfiilename%7D/image-20240401074028052.png" alt="image-20240401074028052" style="zoom:25%;" /><p>最大子段和 动态规划写法状态表示到i为止最大的字段和</p><p> 如果和左边拼起来 那就是f[i] &#x3D; f[i - 1] + nums[i]</p><p>如果不和左边拼起来 那就是 f[i] &#x3D; nums[i]</p><p>状态计算：f[i] &#x3D; max(f[i - 1], 0) + nums[i]</p><p>发现只用到了f[i] 和f[i - 1] 可以进行压缩   只用f2来表示</p><p>用res 记录最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> f2 = <span class="hljs-number">0</span>;<br>        f2 = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = <span class="hljs-built_in">max</span>(f2, <span class="hljs-number">0</span>) + nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, f2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2606-找到最大开销的子字符串-力扣（LeetCode）"><a href="#2606-找到最大开销的子字符串-力扣（LeetCode）" class="headerlink" title="2606. 找到最大开销的子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">2606. 找到最大开销的子字符串 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;1</li></ul><img src="../images/$%7Bfiilename%7D/image-20240401075827824.png" alt="image-20240401075827824" style="zoom:25%;" /><p>同样是最大子段和  但是要注意和上题的区别 这题中可以一个都不取 也就是字符为空  当第一个为负数的时候 直接取空（0）是更大的  所以res初始化为max(0, nums[0])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumCostSubstring</span><span class="hljs-params">(string s, string chars, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vals)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">mp</span>(<span class="hljs-number">26</span>, <span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            mp[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = vals[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">10000</span>)<br>                mp[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> f2 = mp[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, mp[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = <span class="hljs-built_in">max</span>(f2, <span class="hljs-number">0</span>) + mp[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            res = <span class="hljs-built_in">max</span>(res, f2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1749-任意子数组和的绝对值的最大值-力扣（LeetCode）"><a href="#1749-任意子数组和的绝对值的最大值-力扣（LeetCode）" class="headerlink" title="1749. 任意子数组和的绝对值的最大值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/submissions/518892405/">1749. 任意子数组和的绝对值的最大值 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;1</li></ul><img src="../images/$%7Bfiilename%7D/image-20240401082601673.png" alt="image-20240401082601673" style="zoom:25%;" /><p>前面求最大子段和的时候用f2 表示到nums[i]为止的最大字段和</p><p>对应于fmax &#x3D; max(fmax, 0) + x</p><p>但是这题可以取绝对值 因此可以再加一个fmin &#x3D; min(fmin, 0) + x  取尽量小的数   因为越小的数 取反就越大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAbsoluteSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> fmax = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, fmin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>        &#123;<br>            fmax = <span class="hljs-built_in">max</span>(fmax, <span class="hljs-number">0</span>) + x;<br>            fmin = <span class="hljs-built_in">min</span>(fmin, <span class="hljs-number">0</span>) + x;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(fmax, -fmin));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1191-K-次串联后最大子数组之和-力扣（LeetCode）"><a href="#1191-K-次串联后最大子数组之和-力扣（LeetCode）" class="headerlink" title="1191. K 次串联后最大子数组之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/k-concatenation-maximum-sum/submissions/518906997/">1191. K 次串联后最大子数组之和 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;1</li></ul><img src="../images/$%7Bfiilename%7D/image-20240401093700946.png" alt="image-20240401093700946" style="zoom:25%;" /><p>连续k段arr 的最大子段和 </p><p>分情况讨论  如果只有一段 直接算最大子段和</p><p>如果有两段就算两段的最大字段和</p><p>如果大于两段 算两段的最大子段和 将这两段视为左右两段 加上max（中间所有的和， 0）就是一个连续的子数组</p><img src="../images/$%7Bfiilename%7D/37cb29513e8f1293b1296b6a8ad01136.jpg" alt="37cb29513e8f1293b1296b6a8ad01136" style="zoom:25%;" /><p>因为中间要是大于0的话 一定要取  可以变得更大 而两边的可以由中间接上</p><p>假设是-1 6 -4 -1 6 -4这样的 最大的就是中间连起来（上图2）  sum &gt; 0 </p><p>假设是 sum &lt;&#x3D; 0的才会出现图1 这时候就不用连起来了 直接取最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> f2 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            sum = (arr[i] + sum) % mod;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">0</span>; e &lt; <span class="hljs-built_in">min</span>(k, <span class="hljs-number">2</span>); e++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = (<span class="hljs-built_in">max</span>(f2, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">0</span>) + arr[i]);<br>            res = (<span class="hljs-built_in">max</span>(res, f2));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> res % mod;<br>        <span class="hljs-keyword">return</span> (res % mod + <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)sum * (k - <span class="hljs-number">2</span>) % mod, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">0</span>)) % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="918-环形子数组的最大和-力扣（LeetCode）"><a href="#918-环形子数组的最大和-力扣（LeetCode）" class="headerlink" title="918. 环形子数组的最大和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;1</li></ul><img src="../images/$%7Bfiilename%7D/image-20240401130808479.png" alt="image-20240401130808479" style="zoom:25%;" /><p><strong>环形</strong> 可以将数组*2之后求 但是太麻烦 需要判断最多只能取n个数</p><p>仔细思考发现只有两种情况 </p><ol><li><p>不利用到环形 本身直接取就可以取到最大  就是普通的最大子列和问题</p></li><li><p>利用到环形 这时候就会选取数组前后端的数字 空出中间的  那么就可以计算中间的最小值 再用总和减去</p></li></ol><p>上面两种情况分别如下图所示</p><img src="../images/$%7Bfiilename%7D/image-20240401130901616.png" alt="image-20240401130901616" style="zoom:25%;" /><p>分析完后其实跟前两题 求绝对值的有点类似 </p><p>注意由于数组不能为空 当resx小于等于0的时候 此时sum - resn肯定为0（resn是尽量小 resx小于0 那么说明整个数组全为负数 resx没有可以选的  resn此时全部选上了）那么最后就会返回0</p><p>但是其实答案是resx   这种全负数的情况就没有分取不取环形 只需要找最大的负数  就相当于普通最大子列和 直接返回resx</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">0</span>, maxn = <span class="hljs-number">0</span>, resx = nums[<span class="hljs-number">0</span>], resn = nums[<span class="hljs-number">0</span>], sum = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, <span class="hljs-number">0</span>) + nums[i];<br>            minn = <span class="hljs-built_in">min</span>(minn, <span class="hljs-number">0</span>) + nums[i];<br>            resx = <span class="hljs-built_in">max</span>(resx, maxn);<br>            resn = <span class="hljs-built_in">min</span>(resn, minn);<br>            sum += nums[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> resx &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">max</span>(resx, sum - resn): resx;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2321-拼接数组的最大分数-力扣（LeetCode）"><a href="#2321-拼接数组的最大分数-力扣（LeetCode）" class="headerlink" title="2321. 拼接数组的最大分数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">2321. 拼接数组的最大分数 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;2</li></ul><img src="../images/$%7Bfiilename%7D/image-20240402224213797.png" alt="image-20240402224213797" style="zoom:25%;" /><p>直接求的话很难算 可以转换成最大字段和来求解  令diff[i] &#x3D; nums1[i] - nums2[i]  求出的最大子段和就是交换的区间 此时求出来的是1比2大的 把大的全部换到2中去 </p><p>diff[i] &#x3D; nums2[i] - nums1[i] 求出的是2比1大的 把大的全部换到1中 然后二者取较大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumsSplicedArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">diff</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>,  sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            diff[i] = nums1[i] - nums2[i];<br>            sum1 += nums1[i];<br>            sum2 += nums2[i];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f + diff[i], <span class="hljs-number">0</span>) ;<br>            res = <span class="hljs-built_in">max</span>(res, f);<br>        &#125;<br>        <span class="hljs-type">int</span> res1 = <span class="hljs-number">0</span>;<br>        f = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f - diff[i], <span class="hljs-number">0</span>);<br>            res1 = <span class="hljs-built_in">max</span>(res1, f);<br>        &#125;   <br>        ans = <span class="hljs-built_in">max</span>(sum1 + res1, sum2 + res);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="363-矩形区域不超过-K-的最大数值和-力扣（LeetCode）"><a href="#363-矩形区域不超过-K-的最大数值和-力扣（LeetCode）" class="headerlink" title="363. 矩形区域不超过 K 的最大数值和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;2</li></ul><h3 id="前缀和-暴力"><a href="#前缀和-暴力" class="headerlink" title="前缀和+暴力"></a>前缀和+暴力</h3><p>（前缀和数组-&gt;动态规划）</p><p>四重循环暴力求解 枚举每个矩形的解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>(), col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">qzh</span>(row + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                qzh[i][j] = qzh[i][j - <span class="hljs-number">1</span>] + qzh[i - <span class="hljs-number">1</span>][j] - qzh[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; i; ii++)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">0</span>; jj &lt; j; jj++)<br>                    &#123;<br>                        <br>                        <span class="hljs-type">int</span> u = qzh[i][j] - qzh[i][jj] - qzh[ii][j] + qzh[ii][jj];<br>                        cout&lt;&lt;u&lt;&lt;endl;<br>                        <span class="hljs-keyword">if</span> (u &lt;= k)<br>                        res = <span class="hljs-built_in">max</span>(u, res);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-comment">// for (int i = 1; i &lt;= row; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt;= col; j++)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         cout&lt;&lt;qzh[i][j]&lt;&lt;endl;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>苦鲁西~四重暴力会超时</p><h3 id="枚举左右边界-最大子列和"><a href="#枚举左右边界-最大子列和" class="headerlink" title="枚举左右边界+最大子列和"></a>枚举左右边界+最大子列和</h3><p>可以转为三重循环  枚举左 右边界 然后求每一行的前缀和   再求每一个前缀和的 <strong>最大子列和</strong> 就是最大的矩阵<img src="../images/$%7Bfiilename%7D/13fb1fcc1203665fe1c4ccc6221cef7e01921fe614b0e6b22a81a70eca4e79aa-image.png" alt="image.png" style="zoom: 80%;" /></p><p>把他转换成 每个最大子列和（左边的） 就是右边的一个黄色区域 将$O(n^2)$的复杂度的枚举转为$2O(n)$的前缀和+最大子列和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dpmax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;rowsum, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxn = rowsum[<span class="hljs-number">0</span>], f = rowsum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; rowsum.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f, <span class="hljs-number">0</span>) + rowsum[i];<br>            maxn = <span class="hljs-built_in">max</span>(maxn, f);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maxn &lt;= k)<br>            <span class="hljs-keyword">return</span> maxn;<br><br>        maxn = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rowsum.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; rowsum.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                sum += rowsum[j];<br>                <span class="hljs-keyword">if</span> (sum &gt; maxn &amp;&amp; sum &lt;= k)<br>                    maxn = sum;<br>                <span class="hljs-keyword">if</span> (maxn == k)<span class="hljs-keyword">return</span> k;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>(), col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; col; l++) <br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rowsum</span><span class="hljs-params">(row, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; col; r++) <br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>                &#123;<br>                    rowsum[i] += matrix[i][r];<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dpmax</span>(rowsum, k)); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二分-前缀和"><a href="#二分-前缀和" class="headerlink" title="二分+前缀和"></a>二分+前缀和</h3><p>枚举上下边界和左边界  通过二分快速找有边界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>(), n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">sum</span>(m + <span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> top = <span class="hljs-number">1</span>; top &lt;= m; top++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bot = top; bot &lt;= m; bot++)<br>        &#123;<br>            set&lt;<span class="hljs-type">int</span>&gt;st;<br>            st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt;= n; r++)<br>            &#123;<br>                <span class="hljs-type">int</span> right = sum[bot][r] - sum[top - <span class="hljs-number">1</span>][r];<br>                <span class="hljs-keyword">auto</span> left = st.<span class="hljs-built_in">lower_bound</span>(right - k);<br>                <span class="hljs-keyword">if</span> (left != st.<span class="hljs-built_in">end</span>())<br>                &#123;<br>                    <span class="hljs-type">int</span> cur = right - *left;<br>                    ans = <span class="hljs-built_in">max</span>(ans, cur);<br>                &#125;<br>                st.<span class="hljs-built_in">insert</span>(right);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><h2 id="894-所有可能的真二叉树-力扣（LeetCode）"><a href="#894-所有可能的真二叉树-力扣（LeetCode）" class="headerlink" title="894. 所有可能的真二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-possible-full-binary-trees/?envType=daily-question&envId=2024-04-02">894. 所有可能的真二叉树 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;2</li></ul><img src="../images/$%7Bfiilename%7D/image-20240402092713887.png" alt="image-20240402092713887" style="zoom:25%;" /><p>对于二叉树相关的题目 一般就是先求左右的信息然后再合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">process</span>(n);<br>    &#125;<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;TreeNode*&gt; res = ....;<br>        ....<span class="hljs-comment">//根节点和基本操作</span><br>        vector&lt;TreeNode*&gt;lefttree = <span class="hljs-built_in">process</span>();<br>        vector&lt;TreeNode*&gt;righttree = <span class="hljs-built_in">process</span>();<br>        ....<span class="hljs-comment">//合并</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>很容易想到n &#x3D;&#x3D; 0  n &#x3D;&#x3D; 1 n为偶数的时候 三个特判条件</p><p>要求按所有可能的结果返回  肯定需要遍历 </p><p>结点总数为n 可以枚举左子树的结点数 左子树结点数为i的时候 右子树结点数为n - i - 1   (其实就是左右节点再接上一个结点数较少的数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i+=<span class="hljs-number">2</span>) <span class="hljs-comment">// 结点数至少为1 每次加两个</span><br>&#123;<br>    lefttree = <span class="hljs-built_in">process</span>(i);<br>    righttree = <span class="hljs-built_in">process</span>(n - i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 得到了左右子树 现在需要合并 也就是把左右子树加到根节点 然后储存</span><br>    <span class="hljs-keyword">for</span> (TreeNode* leftnode:leftsub)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode* rightnode:rightsub)<br>                &#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, leftnode, rightnode);<br>                    ret.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键在于对题目的分析 想到枚举左子树的节点数目</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt;ret;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>)&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>)<br>        &#123;<br>            vector&lt;TreeNode*&gt;leftsub = <span class="hljs-built_in">allPossibleFBT</span>(i);<br>            vector&lt;TreeNode*&gt;rightsub = <span class="hljs-built_in">allPossibleFBT</span>(n - i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (TreeNode* leftnode:leftsub)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode* rightnode:rightsub)<br>                &#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, leftnode, rightnode);<br>                    ret.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-矩阵链乘法问题（附加）"><a href="#xmuoj-矩阵链乘法问题（附加）" class="headerlink" title="xmuoj | 矩阵链乘法问题（附加）"></a><a href="https://www.xmuoj.com/contest/226/problem/6">xmuoj | 矩阵链乘法问题（附加）</a></h2><ul><li>4&#x2F;3</li></ul><p>矩阵连乘问题 </p><p>状态表示为dp[i] [j]表示从i到j 的最少次数 </p><p>状态计算为在i j 中间选出一个分割点k 使dp[i] [j] &#x3D; min(dp[i] [j], dp[i] [k] + dp[k + 1] [j] + nums[i - 1] * nums[k] * nums[j])</p><p>也就是i到k最少的次数 加上k + 1到j最少的次数 再加上两个合并到一起所需要的次数</p><p>需要注意 由于求得是最小值 如果k直接i到j循环取min的话 最后取出来全是0  所以得先给dp[i] [j]赋值为k &#x3D; i的情况 然后枚举i + 1到j</p><p>枚举<strong>区间长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>nums[i] = a;<br>&#125;<br>nums[n] = b;<br><span class="hljs-keyword">for</span> (len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[i] * nums[j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[k] * nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来再看如何构造最优子序列</p><p>添加一个s[i]数组 每次记录分割的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N], s[N][N];<br><span class="hljs-type">int</span> nums[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i == j)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A&quot;</span>&lt;&lt;i;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>;<br>    <span class="hljs-built_in">traceback</span>(i, s[i][j]);<br>    <span class="hljs-built_in">traceback</span>(s[i][j] + <span class="hljs-number">1</span>, j);<br>    cout&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>nums[i] = a;<br>&#125;<br>nums[n] = b;<br><span class="hljs-keyword">for</span> (len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[i] * nums[j];<br>            s[i][j] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>            &#123;<br>                <span class="hljs-type">int</span> t = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[k] * nums[j];<br>                <span class="hljs-keyword">if</span> (t &lt; dp[i][j])<br>                &#123;<br>                    dp[i][j] = t;<br>                    s[i][j] = k;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-元素共鸣：唤醒神之眼"><a href="#xmuoj-元素共鸣：唤醒神之眼" class="headerlink" title="xmuoj | 元素共鸣：唤醒神之眼"></a><a href="https://www.xmuoj.com/contest/226/problem/1">xmuoj | 元素共鸣：唤醒神之眼</a></h2><ul><li>4&#x2F;3</li></ul><p>相邻的两座石柱合并  其实跟书上的矩阵连乘问题很类似 （如上题）</p><p>同样是在相邻的两个之间进行操作 并且每次操作都是寻找最小的划分区间 然后再计算合并所需的值（一般根据区间决定）</p><p>代码几乎一样  只不过在合并相加的时候有区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], qzh[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">500</span>][<span class="hljs-number">500</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; nums[i];<br>&#125;<br>qzh[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) <br>&#123;<br><span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>          dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + qzh[j] - qzh[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>&#123;<br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i][k] + dp[k + <span class="hljs-number">1</span>][j]  + qzh[j] - qzh[i - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-元素共鸣：深层次的唤醒"><a href="#xmuoj-元素共鸣：深层次的唤醒" class="headerlink" title="xmuoj | 元素共鸣：深层次的唤醒"></a><a href="https://www.xmuoj.com/contest/226/problem/2">xmuoj | 元素共鸣：深层次的唤醒</a></h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">1000. 合并石头的最低成本 - 力扣（LeetCode）</a></p><ul><li>4&#x2F;3</li></ul><p>是上一题的变式 由于要合并k个区间 首先要判断什么区间不能合并  n堆变成1堆  减少了 n - 1堆  每次合并都减少k - 1堆 所以n - 1需要是k - 1的倍数 </p><p>状态表示 dp[i] [j] [k] 表示i到j分成k堆的最小消耗</p><p>状态计算 仍然是分成两份 一份1 一份k - 1 dp[i] [j] [k] &#x3D; dp[i] [p] [1] + dp[p + 1] [j] [k - 1]  然后剩下的需要枚举的就是p了 枚举p就很简单 注意每次增加k - 1</p><p>然后在计算、合并完 得到dp[i] [j] [k] 的时候 再将他合并（到k个了 可以合并）dp[i] [j] [1]就为dp[i] [j] [k]加上消耗sum[j] - sum[i - 1]（这个消耗是每次合并产生的）</p><p>注意初始化 其实也可以直接用memset将dp全部变为1e9 然后dp[i] [i] [1] i i本来就是一堆 不需要代价 所以为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], sum[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">500</span>][<span class="hljs-number">500</span>][<span class="hljs-number">50</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; nums[i];<br>&#125;<br><span class="hljs-comment">// dp i j i到j的最小  状态计算-</span><br>cin &gt;&gt; k;<br><br><span class="hljs-keyword">if</span> ((n - <span class="hljs-number">1</span>) % (k - <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">2</span>; m &lt;= k; m++)<br>                dp[i][j][m] = <span class="hljs-number">1e9</span>;<br>        &#125;<br>        dp[i][i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">2</span>; m &lt;= k; m++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = i; p &lt; j; p += k - <span class="hljs-number">1</span>)<br>                &#123;<br>                    dp[i][j][m] = <span class="hljs-built_in">min</span>(dp[i][j][m], dp[i][p][<span class="hljs-number">1</span>] + dp[p + <span class="hljs-number">1</span>][j][m - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            dp[i][j][<span class="hljs-number">1</span>] = dp[i][j][k] + sum[j] - sum[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-提瓦特庆典策划"><a href="#xmuoj-提瓦特庆典策划" class="headerlink" title="xmuoj | 提瓦特庆典策划"></a><a href="https://www.xmuoj.com/contest/226/problem/3">xmuoj | 提瓦特庆典策划</a></h2><ul><li>4&#x2F;3</li></ul><p>经典树上DP 没有上司的舞会</p><p>首先要考虑数据的存储  每个人的情绪用nums[i]来存 上司和下属的关系可以用树的方式来存 用邻接表会简单很多（邻接矩阵也可以 但是浪费空间）</p><p>之后就是动态规划  树上dp用递归+备忘录的方法会更好写 也更符合直觉 dp[i] [0] 表示i不来的情况下 最大情绪  dp[i] [1]表示i来的情况下 最大情绪  </p><p>状态计算 dp[i] [0] +&#x3D; max(dp[son] [0], dp[son] [1])</p><p>dp[i] [1] +&#x3D; dp[son] [0] 这里的son表示i的下属 注意当i不来的时候 下属并不是一定都来  也有不来会更好的情况 所以用max</p><p>由状态转移方程可以很容易看出来 想算上司的 就要先把下属的算出来  所以递归要放在前面 先把下属的状态算好</p><p>然后要找出最大的上司 从他开始计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6005</span>;<br><span class="hljs-type">int</span> n, nums[N], v[N], boss;<br>vector&lt;<span class="hljs-type">int</span>&gt;son[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dpmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[x][<span class="hljs-number">1</span>] = nums[x];<br>    <span class="hljs-comment">// 算当前这个人去/不去的最大价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y:son[x])<br>    &#123;<br>        <span class="hljs-comment">// 先算下属</span><br>        <span class="hljs-built_in">dpmax</span>(y);<br>        dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[y][<span class="hljs-number">0</span>], dp[y][<span class="hljs-number">1</span>]);<br>        dp[x][<span class="hljs-number">1</span>] += dp[y][<span class="hljs-number">0</span>]; <span class="hljs-comment">// x去y只能不去</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin&gt;&gt;nums[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> p, q;<br>        cin&gt;&gt;p&gt;&gt;q;<br>        son[q].<span class="hljs-built_in">push_back</span>(p);<br>        v[p] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            boss = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dpmax</span>(boss);<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[boss][<span class="hljs-number">0</span>], dp[boss][<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-装配线调度问题（附加）⁤"><a href="#xmuoj-装配线调度问题（附加）⁤" class="headerlink" title="xmuoj | 装配线调度问题（附加）⁤"></a><a href="https://www.xmuoj.com/contest/226/problem/4">xmuoj | 装配线调度问题（附加）⁤</a></h2><ul><li>4&#x2F;3</li></ul><p>一开始看到题目这么长有点懵 但是其实题意很简单 就是一个物品 从0走到n 每一步都可以选择在当前线装配 或者换一条线装配（换线需要时间）然后加上进厂出厂时间 得到最短出场时间</p><p>本来想用dp[i]表示到i的最短时间 但是这样状态没办法转移 不知道当前在哪条线上 所以可以多加一个维度 记录每一条线上到i的最短时间  </p><p>状态表示为dp[i] [0] dp[i] [1] (提交的时候写的是dp1[i]和dp2[i])</p><p>状态计算  到i的最短时间为 两条线的 i-1的时候的最短时间加上转移&#x2F;不转移所需要的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> change[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> e1, e2, x1, x2;<br><span class="hljs-type">int</span> dp1[N], dp2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; nums[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; nums[<span class="hljs-number">2</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; change[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; change[<span class="hljs-number">2</span>][i];<br>&#125;<br>cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; x1 &gt;&gt; x2;<br>    <br>    dp1[<span class="hljs-number">0</span>] = e1 + nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    dp2[<span class="hljs-number">0</span>] = e2 + nums[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        dp1[i] = <span class="hljs-built_in">min</span>(dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i], dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>]);<br>        dp2[i] = <span class="hljs-built_in">min</span>(dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i], dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(dp1[n] + x1, dp2[n] + x2);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来构造最优子结构</p><p>添加 s1[N] s2[N]数组记录最优解的时候 第i - 1个配件是在第一条线还是第二条线 s记录最后那条线出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> change[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> e1, e2, x1, x2;<br><span class="hljs-type">int</span> dp1[N], dp2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; nums[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; nums[<span class="hljs-number">2</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; change[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; change[<span class="hljs-number">2</span>][i];<br>&#125;<br>cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; x1 &gt;&gt; x2;<br>    <br>    dp1[<span class="hljs-number">0</span>] = e1 + nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    dp2[<span class="hljs-number">0</span>] = e2 + nums[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] &lt; dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>])<br>        &#123;<br>            dp1[i] = dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i];<br>            s1[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp1[i] = dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>];<br>            s1[i] = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] &lt; dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])<br>        &#123;<br>            dp2[i] = dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i];<br>            s2[i] = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp2[i] = dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br>            s2[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (dp1[n] + x1 &lt; dp2[n] + x2)<br>    &#123;<br>        ans = dp1[n] + x1;<br>        l = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ans = dp2[n] + x2;<br>        l = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// traceback</span><br>    <span class="hljs-type">int</span> i = l;<br>    cout&lt;&lt;<span class="hljs-string">&quot;station&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot; line&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= <span class="hljs-number">2</span>; j--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>            i = s1[j];<br>        <span class="hljs-keyword">else</span> i = s2[j];<br>        cout&lt;&lt;<span class="hljs-string">&quot;station&quot;</span>&lt;&lt;j - <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; line&quot;</span>&lt;&lt;i&lt;&lt;endl;<span class="hljs-comment">// 第j个步骤 在i流水线</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LCR-166-珠宝的最高价值-力扣（LeetCode）"><a href="#LCR-166-珠宝的最高价值-力扣（LeetCode）" class="headerlink" title="LCR 166. 珠宝的最高价值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/">LCR 166. 珠宝的最高价值 - 力扣（LeetCode）</a></h2><p>从左上到右下，二维DP。</p><p>状态表示：dp[i] [j] 到第i行第j列的最高价值。</p><p>状态计算：dp[i] [j] &#x3D; max(dp[i -1] [j], dp[i] [j - 1]) + frame[i] [j]表示从较大的位置转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jewelleryValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; frame)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = frame.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = frame[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + frame[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></h2><p>同样是网格图DP，相当于二维的爬楼梯</p><p>跟其他题不一样的在于初始化，第一行和第一列都是1，只有一种走法。</p><p>状态表示：dp[i] [j] 表示到第i行第j列的走法</p><p>状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++)<br>            &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// debug</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="63-不同路径-II-力扣（LeetCode）"><a href="#63-不同路径-II-力扣（LeetCode）" class="headerlink" title="63. 不同路径 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></h2><p>上题的变式，图中增加了障碍物，只有在没有遇到障碍物的时候才可以转移，障碍物位设置为0，表示到这里有0种走法。</p><p>状态表示：dp[i] [j] 表示到第i行第j列的走法</p><p>状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(row + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][col];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="120-三角形最小路径和-力扣（LeetCode）"><a href="#120-三角形最小路径和-力扣（LeetCode）" class="headerlink" title="120. 三角形最小路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/triangle/submissions/523893909/">120. 三角形最小路径和 - 力扣（LeetCode）</a></h2><h3 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h3><p>状态表示：dp[i] [j] 到第i行第j列的最小路径和。</p><p>状态计算：每一步只能从上一行的j或j - 1列移动到当前行的第j列。</p><p>要特殊处理第0列（因为第0列只能由上一行的第0列转移）和第i列（第i列只能由i - 1列转移）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = triangle[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + triangle[i][j];<br>            &#125;<br>            dp[i][i] = dp[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + triangle[i][i];<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, dp[n - <span class="hljs-number">1</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h3><p>注意到只用了i和i - 1两行，可以进行状态压缩。直接更新到原来的位置上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        f[<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + triangle[i][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--)<br>            &#123;<br>                f[j] = <span class="hljs-built_in">min</span>(f[j], f[j - <span class="hljs-number">1</span>]) + triangle[i][j];<br>            &#125;<br>            f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">0</span>] + triangle[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><h2 id="312-戳气球-力扣（LeetCode）"><a href="#312-戳气球-力扣（LeetCode）" class="headerlink" title="312. 戳气球 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球 - 力扣（LeetCode）</a></h2><p>状态表示：dp[i] [j] 表示从i到j的最大数量</p><p>状态计算：枚举k（每一个断点）求出在每个k断开的sum。dp[i] [j] &#x3D; max(sum)</p><p>初始化：注意两边的为1，所以一开始要初始化为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        ll val[n + <span class="hljs-number">2</span>];<br>        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            val[i] = nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>                &#123;<br>                    ll sum = dp[i][k] + dp[k][j];<br>                    sum += val[i] * val[j] * val[k];<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="377-组合总和-Ⅳ-力扣（LeetCode）"><a href="#377-组合总和-Ⅳ-力扣（LeetCode）" class="headerlink" title="377. 组合总和 Ⅳ - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></h2><p>还是爬楼梯问题，target为最终楼梯层数，dp[i] 表示到i有多少种走法</p><p>每次可以走nums[k]步</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum4</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        状态表示：dp[i] 1~i有多少种</span><br><span class="hljs-string">        状态计算：dp[i - 1] = dp</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br><br>        <span class="hljs-comment"># @cache</span><br>        <span class="hljs-comment"># def dfs(i):</span><br>        <span class="hljs-comment">#     if i == 0:</span><br>        <span class="hljs-comment">#         return 1</span><br>        <span class="hljs-comment">#     return sum(dfs(i - x) for x in nums if x &lt;= i)</span><br>        <span class="hljs-comment"># return dfs(target)</span><br>        <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * target<br>        <span class="hljs-comment"># for i in range(1, target + 1):    </span><br>        <span class="hljs-comment">#     dp[i] += sum(dp[i - x] for x in nums if x &lt;= i)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> x &lt;= i:<br>                    dp[i] += dp[i - x]<br>        <span class="hljs-keyword">return</span> dp[target]<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="2192-有向无环图中一个节点的所有祖先-力扣（LeetCode）"><a href="#2192-有向无环图中一个节点的所有祖先-力扣（LeetCode）" class="headerlink" title="2192. 有向无环图中一个节点的所有祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/submissions/520849062/?envType=daily-question&envId=2024-04-04">2192. 有向无环图中一个节点的所有祖先 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;4</li></ul><img src="../images/$%7Bfiilename%7D/image-20240407164600674.png" alt="image-20240407164600674" style="zoom:25%;" /><p>计算有向无环图的所有祖先 首先先用邻接矩阵存图 </p><p>然后用dfs的方法求每个点的祖先</p><h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3><p>存反图 循环到这个结点的时候 就反向往上走 直到根节点 记录下每次走的结点 加入数组中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e:edges)<br>        &#123;<br>            g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">ans</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n);<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            vis[x] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 避免重复访问</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : g[x]) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[y]) &#123;<br>                    <span class="hljs-built_in">dfs</span>(y); <span class="hljs-comment">// 只递归没有访问过的点</span><br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ranges::<span class="hljs-built_in">fill</span>(vis, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">dfs</span>(i);<br>            vis[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (vis[j])<br>                    ans[i].<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><h3 id="正向遍历"><a href="#正向遍历" class="headerlink" title="正向遍历"></a>正向遍历</h3><p>存正图 但是遍历方式改变 不是对每个结点先找到他的所有祖先 而是对每个结点作为根 找他的孩子 然后在孩子数组中存入根</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">g</span>(n);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: edges)<br>        &#123;<br>            g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        &#125;   <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">ans</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> start;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x)<br>        &#123;<br>            vis[x] = start;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y:g[x])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (vis[y] != start)<br>                &#123;<br>                    ans[y].<span class="hljs-built_in">push_back</span>(start);<br>                    <span class="hljs-built_in">dfs</span>(y);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; n; start++) &#123;<br>            <span class="hljs-built_in">dfs</span>(start); <span class="hljs-comment">// 从 start 开始 DFS</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><h2 id="1026-节点与其祖先之间的最大差值-力扣（LeetCode）"><a href="#1026-节点与其祖先之间的最大差值-力扣（LeetCode）" class="headerlink" title="1026. 节点与其祖先之间的最大差值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/submissions/520874666/?envType=daily-question&envId=2024-04-05">1026. 节点与其祖先之间的最大差值 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;5</li></ul><img src="../images/$%7Bfiilename%7D/image-20240407170407950.png" alt="image-20240407170407950" style="zoom:25%;" /><p>遍历整棵树 在每个结点记录到当前节点为止最大和最小值</p><p>（回溯的思想）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode*root, <span class="hljs-type">int</span> minn, <span class="hljs-type">int</span> maxn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;<br>    ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(minn - root-&gt;val));<br>    ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(maxn - root-&gt;val));<br>    <span class="hljs-keyword">if</span> (root-&gt;left)<span class="hljs-built_in">dfs</span>(root-&gt;left, <span class="hljs-built_in">min</span>(root-&gt;left-&gt;val, minn), <span class="hljs-built_in">max</span>(root-&gt;left-&gt;val, maxn));<br>    <span class="hljs-keyword">if</span> (root-&gt;right)<span class="hljs-built_in">dfs</span>(root-&gt;right, <span class="hljs-built_in">min</span>(root-&gt;right-&gt;val, minn), <span class="hljs-built_in">max</span>(root-&gt;right-&gt;val, maxn));<br>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAncestorDiff</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, root-&gt;val, root-&gt;val);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1483-树节点的第-K-个祖先-力扣（LeetCode）、"><a href="#1483-树节点的第-K-个祖先-力扣（LeetCode）、" class="headerlink" title="1483. 树节点的第 K 个祖先 - 力扣（LeetCode）、"></a><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/submissions/520993127/?envType=daily-question&envId=2024-04-06">1483. 树节点的第 K 个祖先 - 力扣（LeetCode）</a>、</h2><ul><li>4&#x2F;6</li></ul><img src="../images/$%7Bfiilename%7D/image-20240407172214527.png" alt="image-20240407172214527" style="zoom:25%;" /><p>直接暴力求解很简单 但是会超时 由于需要多次访问祖先  可以用倍增的思想 每次访问第1 2 4 8 … $2^n$的祖先</p><p>用二维数组pa存每个结点x的祖先 pa[0] [0] 表示0的第1个祖先 pa[0] [1]表示0的第2个祖先（父节点的父节点）</p><p>pa[x] [0]&#x3D;parent[x]父节点</p><p>pa[x] [1] &#x3D; pa[pa[x] [0]] [0]爷爷节点</p><p>pa[x] [i + 1] &#x3D; pa[pa[x] [i]] [i]表示x的第$2^i$个祖先结点  如果不够的话会直接存成根节点（因为最上面的祖先肯定存的是根）</p><p>注意循环初始化外层是i内层是x 因为必须先把所有第i层的x更新完 才能更新第i + 1层的 （i + 1层有用到i的 如果顺序反了可能有些没更新到就被使用了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;pa;<br>    <span class="hljs-built_in">TreeAncestor</span>(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent) <br>    &#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span>;<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            pa[i][<span class="hljs-number">0</span>] = parent[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">31</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++)<br>            &#123;<br>                <span class="hljs-type">int</span> p = pa[x][i]; <br>                <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span>)<br>                &#123;<br>                    pa[x][i + <span class="hljs-number">1</span>] = pa[p][i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKthAncestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((k &gt;&gt; i) &amp; <span class="hljs-number">1</span>)<br>            &#123;<br>                node = pa[node][i];<br>                <span class="hljs-keyword">if</span> (node &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;   <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TreeAncestor object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="1600-王位继承顺序-力扣（LeetCode）"><a href="#1600-王位继承顺序-力扣（LeetCode）" class="headerlink" title="1600. 王位继承顺序 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/throne-inheritance/submissions/520803923/">1600. 王位继承顺序 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;7</li></ul><p>王位继承制 皇上-嫡长子-嫡长孙…这一脉亖绝了轮到次长子一脉</p><p>要记录的东西比较多 可以用map&lt;string, vector&lt;string&gt;&gt;来记录每个人的儿子 用set来记录死亡的人</p><p>最后get的时候  用dfs 深搜  按每一脉的人来搜索 如果死了就不用记录</p><img src="../images/$%7Bfiilename%7D/image-20240407164502464.png" alt="image-20240407164502464" style="zoom:25%;" /><h2 id="924-尽量减少恶意软件的传播-力扣（LeetCode）"><a href="#924-尽量减少恶意软件的传播-力扣（LeetCode）" class="headerlink" title="924. 尽量减少恶意软件的传播 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播 - 力扣（LeetCode）</a></h2><p>要读懂题意，假设以一个连通图中有两个以上的原始病毒，那么删除其中一个是<strong>毫无作用</strong>的，因此这个题就是要找<strong>只有一个</strong>原始病毒的最大连通图。</p><p>关键在于这么判断这个连通图中有多少原始病毒。</p><p>将node_id初始化为-1，第一次遇到原始病毒的时候，就更新为x，表示待删去的原始病毒。但是如果第二次再遇到了病毒，那么就要将这个结点置为-2，表示这个连通图不可能减少感染次数了。同时再dfs中记录连通图的大小。</p><p>最后如果node_id &gt;&#x3D; 0 并且size &gt; max_size 或者size &#x3D;&#x3D; max_size 但是下标较小（node_id &lt; ans）就更新ans</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMalwareSpread</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; initial)</span> </span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-comment">// 如果一个连通块有多个感染节点 去掉了跟没去掉一样</span><br>        <span class="hljs-comment">// 找只有一个感染结点的连通块 最大连通数量</span><br><br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">st</span>(initial.<span class="hljs-built_in">begin</span>(), initial.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n);<br><br>        <span class="hljs-built_in">sort</span>(initial.<span class="hljs-built_in">begin</span>(), initial.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans = initial[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>, node_id = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;dfs = [&amp;](<span class="hljs-type">int</span> x)<br>        &#123;<br>            vis[x] = <span class="hljs-number">1</span>;<br>            size++;<br>            <span class="hljs-keyword">if</span> (node_id != <span class="hljs-number">-2</span> &amp;&amp; st.<span class="hljs-built_in">contains</span>(x))<br>            &#123;<br>                node_id = node_id == <span class="hljs-number">-1</span> ? x : <span class="hljs-number">-2</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (graph[x][y] &amp;&amp; !vis[y])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(y);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> max_size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: initial)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[x])<span class="hljs-keyword">continue</span>;<br><br>            node_id = <span class="hljs-number">-1</span>;<br>            size = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(x);<br>            <span class="hljs-keyword">if</span> (node_id &gt;= <span class="hljs-number">0</span> &amp;&amp; (size &gt; max_size || size == max_size &amp;&amp; node_id &lt; ans))<br>            &#123;<br>                ans = node_id;<br>                max_size = size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="xmuoj-蒙德冒险者的游戏"><a href="#xmuoj-蒙德冒险者的游戏" class="headerlink" title="xmuoj | 蒙德冒险者的游戏"></a><a href="https://www.xmuoj.com/contest/229/problem/2">xmuoj | 蒙德冒险者的游戏</a></h2><p>显然可以发现 承受能力强的需要放下面 重量大的需要放下面 但是这里有两个条件 应该按什么标准来放呢  可以假设最有序列为$y_1y_2y_3…y_n$贪心所得的序列为$x_1x_2x_3…x_n$ 假设$x_k$与$x_i$交换可以得到更优的序列</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">ans1 = w1+w2...wk+..wn - si<br>ans2 = w1+w2...wi+..wn - sk<br>假设ans2 &lt; ans1 则 wi-sk&lt;wk-si即wi + si &lt; wk + sk 而ans2更优说明wk+sk大的应该放下面<br>所以按w+s的和排序<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span><br>&#123;<br>ll w, s, a;<br>&#125;nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; nums[i].w &gt;&gt; nums[i].s;<br>nums[i].a = nums[i].w + nums[i].s;<br>&#125;<br><span class="hljs-built_in">sort</span>(nums, nums + n, [&amp;](Man a, Man b) &#123;<br><span class="hljs-keyword">if</span> (a.a != b.a)<span class="hljs-keyword">return</span> a.a &lt;= b.a;<br><span class="hljs-keyword">return</span> a.s &lt;= b.s;<br>&#125;);<br>ll sum = <span class="hljs-number">0</span>;<br>ll ans = <span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, sum - nums[i].s);<br>sum += nums[i].w;<br>&#125;<br><br><br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-宝藏探索"><a href="#xmuoj-宝藏探索" class="headerlink" title="xmuoj | 宝藏探索"></a><a href="https://www.xmuoj.com/contest/229/problem/3">xmuoj | 宝藏探索</a></h2><p>贪心 关键是怎么贪，题目长条件多 要慢慢分析</p><p>贪心思路<strong>优先选择鱼最多的湖</strong> 关键是过去每个湖又需要时间 而且只能单向地走</p><p>但是可以换种思考方式  每次选择鱼最多的湖 比如先选了1 2 2 3 3 1 1 4  就可以认为是在1停留了3次 其实根往返是差不多的</p><p>然后就是过湖的时间 可以枚举每次走几个湖直接把过的时间算上  然后剩下的就是纯钓鱼的时间 然后在当前能去的几个湖里找最多的钓 然后这个湖被钓过了就递减一次 然后再循环找最大的…直到钓鱼时间耗尽 记录记录最大钓鱼数以及每个湖停留的时间 最后输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">100</span>][<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> anss[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> nu[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> n, h;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        nu[k] = n;<br>        cin &gt;&gt; h;<br>        h *= <span class="hljs-number">12</span>;<br>        <br>        <br>        <span class="hljs-type">int</span> f[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> d[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> t[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            cin &gt;&gt; f[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            cin &gt;&gt; d[i];<br>        t[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            cin &gt;&gt; t[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            t[i] += t[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">int</span> maxpool = <span class="hljs-number">0</span>, maxfishtime = <span class="hljs-number">0</span>, maxfish = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tempfish[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (h &gt; t[i])<br>            &#123;<br>                <span class="hljs-type">int</span> rec[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>                maxfishtime = h - t[i];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>                &#123;<br>                    tempfish[j] = f[j];<br>                &#125;<br>                <span class="hljs-type">int</span> nowpoolmax = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (maxfishtime &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    maxfish = <span class="hljs-number">-1e9</span>;<br>                    maxpool = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= i; k++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (maxfish &lt; tempfish[k])<br>                        &#123;<br>                            maxpool = k;<br>                            maxfish = tempfish[k];<br>                        &#125;<br>                    &#125;<br>                   <br>                    nowpoolmax += maxfish;<br>                    rec[maxpool]++;<br>                    <span class="hljs-keyword">if</span> (tempfish[maxpool] &gt; d[maxpool])<br>                        tempfish[maxpool] -= d[maxpool];<br>                    <span class="hljs-keyword">else</span><br>                        tempfish[maxpool] = <span class="hljs-number">0</span>;<br><br>                    maxfishtime--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nowpoolmax &gt; ans)<br>                &#123;<br>                    ans = nowpoolmax;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>                        res[k][i] = rec[i];<br>                &#125;<br>                anss[k] = ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nu[j]; i++)<br>        &#123;<br>          <span class="hljs-keyword">if</span>(i != nu[j])<br>            cout &lt;&lt; res[j][i] * <span class="hljs-number">5</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>          <span class="hljs-keyword">else</span> cout&lt;&lt;res[j][i] * <span class="hljs-number">5</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, anss[j]);<br>        <span class="hljs-keyword">if</span> (j != k - <span class="hljs-number">1</span>)cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1702-修改后的最大二进制字符串-力扣（LeetCode）"><a href="#1702-修改后的最大二进制字符串-力扣（LeetCode）" class="headerlink" title="1702. 修改后的最大二进制字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-binary-string-after-change/?envType=daily-question&envId=2024-04-10">1702. 修改后的最大二进制字符串 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;10</li></ul><img src="../images/$%7Bfiilename%7D/image-20240411135815782.png" alt="image-20240411135815782" style="zoom:25%;" /><p>00-&gt;10  10-&gt;01要使最后的结果最大 就需要尽可能地将前面放上1 尽可能去除0 </p><p>从左往右 前面如果有1 就不用动了 当出现第一个0的时候 往后找 如果后面全是0 就全部变成10 比如0000-&gt;1110</p><p>如果后面有1 那就把1换到最右边 把0换到中间 这必然是可行的 比如101010011 把10换成01之后 1就可以再和后面的0结合成10 再换成01 因此可以把所有的0聚到中间 再使用00换成10 这样 最终<strong>最多</strong>只会剩下一个0就是中间所有0的最后一个位置</p><p>因此可以直接构造出最后的字符串 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n = binary.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-type">int</span> i = binary.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>      <span class="hljs-keyword">if</span> (i == string::npos)<br>          <span class="hljs-keyword">return</span> binary;<br><br>      <span class="hljs-type">int</span> zeros = <span class="hljs-built_in">count</span>(binary.<span class="hljs-built_in">begin</span>(), binary.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;0&#x27;</span>);<br>      <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br>      ans[i + zeros - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>      <span class="hljs-keyword">return</span> ans;<br>  <br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列-力扣（LeetCode）"><a href="#300-最长递增子序列-力扣（LeetCode）" class="headerlink" title="300. 最长递增子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>状态表示：dp[i] 表示1~i的最长上升子序列</p><p>状态计算：if(nums[i] &gt; nums[j])dp[i] &#x3D; max(dp[i], dp[j] + 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// int n = nums.size();</span><br>        <span class="hljs-comment">// vector&lt;int&gt;dp(n);</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     dp[i] = 1;</span><br>        <span class="hljs-comment">//     for (int j = 0; j &lt; i; j++)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         if (nums[i] &gt; nums[j])</span><br>        <span class="hljs-comment">//             dp[i] = max(dp[i], dp[j] + 1);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// int ans = 1;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     ans = max(ans, dp[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return ans;</span><br><br>        vector&lt;<span class="hljs-type">int</span>&gt;g;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), x);<br>            <span class="hljs-keyword">if</span> (it == g.<span class="hljs-built_in">end</span>())<br>                g.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-keyword">else</span><br>                *it = x;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> g.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>最长上升子序列，那就找尽可能小的数，排在后面，这样的话就可以排更多的数，就更长。所以用二分法找大于当前最后一个数的最小数lower_bound</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2009-使数组连续的最少操作数-力扣（LeetCode）"><a href="#2009-使数组连续的最少操作数-力扣（LeetCode）" class="headerlink" title="2009. 使数组连续的最少操作数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/submissions/521981730/?envType=daily-question&envId=2024-04-08">2009. 使数组连续的最少操作数 - 力扣（LeetCode）</a></h2><ul><li>4&#x2F;9</li></ul><img src="../images/$%7Bfiilename%7D/image-20240411135914967.png" alt="image-20240411135914967" style="zoom:25%;" /><p>给定一个数组 求将这个数组变为连续的最小操作数 </p><p>正难则反 可以先求出最大连续的子数组 然后再用n减去 就是最小操作数</p><p>注意 这里的<strong>最大连续</strong>不是1 2 3 4这样连续 (因为1 3 4 5只需要修改1个数 关键是看修改次数少的 中间空一些也可以)而是求出来 当前这个a~b区间内 在这个区间内的有多少个数 可以用滑动窗口来处理</p><p>窗口大小为n    左端点为nums[left] 因此最大的数就是nums[left] + n - 1 将nums[i]与其比较 如果合适就加入窗口 每次滑动记录最大值</p><p>注意 可能出现重复的数字 因此需要去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()) - nums.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[left] &lt; nums[i] - n + <span class="hljs-number">1</span>)<br>            &#123;<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, i - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1052-爱生气的书店老板-力扣（LeetCode）"><a href="#1052-爱生气的书店老板-力扣（LeetCode）" class="headerlink" title="1052. 爱生气的书店老板 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板 - 力扣（LeetCode）</a></h2><p>让最多顾客感到满意 也就是让最少的顾客不满意 不满意的人数本来是固定的 现在老板控制了自己的情绪 </p><p>  其实就是求 最大子段和 使得这一段中 人最多 那就是减少不满意的人最多<br>    用滑动窗口 </p><p>答案为 减少不满意的人数+原来就满意的人数 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSatisfied</span>(<span class="hljs-params">self, customers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], grumpy: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], minutes: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>       <br><br>        sump = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, (c, x) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(customers, grumpy)):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>                grumpy[i] = c<br>            <span class="hljs-keyword">else</span>:<br>                sump += c<br>        <br>        maxp = win = <span class="hljs-built_in">sum</span>(grumpy[:minutes])<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(minutes, <span class="hljs-built_in">len</span>(grumpy)):<br>            win = win + grumpy[i] - grumpy[i - minutes]<br>            maxp = <span class="hljs-built_in">max</span>(maxp, win)<br>        <br>        <span class="hljs-keyword">return</span> sump + maxp<br><br></code></pre></td></tr></table></figure><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="2924-找到冠军-II-力扣（LeetCode）"><a href="#2924-找到冠军-II-力扣（LeetCode）" class="headerlink" title="2924. 找到冠军 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-champion-ii/description/?envType=daily-question&envId=2024-04-13">2924. 找到冠军 II - 力扣（LeetCode）</a></h2><p>图论题  但是可以用哈希过  冠军就是没有被打败过的队伍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findChampion</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: edges)<br>        &#123;<br>            ans[e[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>…        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="169-多数元素-力扣（LeetCode）"><a href="#169-多数元素-力扣（LeetCode）" class="headerlink" title="169. 多数元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素 - 力扣（LeetCode）</a></h2><p>区间的众数一定是左半区间的众数并且也是右半区间的众数。</p><p>每次选出左半区间的众数，和右半区间的众数 如果相同就直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_in_range</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++)<br>            <span class="hljs-keyword">if</span> (nums[i] == target)<br>                count++;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<span class="hljs-keyword">return</span> nums[l];<br><br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, l, mid);<br>        <span class="hljs-type">int</span> right_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, mid + <span class="hljs-number">1</span>, r);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, left_majority, l, r) &gt; (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left_majority;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, right_majority, l, r) &gt; (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> right_majority;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majority_element_rec</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>课程报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2024/03/20/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2024/03/20/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>结点由两个集合组成 两个集合内部没有边的图</p><p>也就是 存在一种方案 将结点划分成满足以上两个性质的集合</p><p>就是集合中的点都染成黑白 可以发现二分图中每条边都链接一个白点一个黑点</p><p>二分图不存在长为奇数的环（每条边都从一个集合走到另一个集合 偶数次才能回到同一个集合）</p><p>判断二分图：遍历：发现奇环就不是 否则是</p><h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p><a href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>匈牙利算法（ntr算法哈哈</p><p>就是每次先配对 然后下一个人来配对的时候 遍历她所有可以访问的点 如果没被访问过并且没有配对 就配对 如果有配对了 就看看上一个人能不能让出来 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n, m, e;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> vis[N], match[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, ne;<br>&#125; edge[N];<br><span class="hljs-type">int</span> head[N], idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[++idx] = &#123;b, head[a]&#125;;<br>    head[a] = idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = edge[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = edge[i].v;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">dfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i))<br>            ans++;<br>    &#125;<br>    cout &lt;&lt; ans;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xmuoj-AI2024春《算法设计与分析》第三次上机"><a href="#xmuoj-AI2024春《算法设计与分析》第三次上机" class="headerlink" title="xmuoj | AI2024春《算法设计与分析》第三次上机"></a><a href="https://www.xmuoj.com/contest/221/problem/6">xmuoj | AI2024春《算法设计与分析》第三次上机</a></h2><p>棋盘覆盖问题  可以当作二分图来写：</p><p>这样思考 每个块都把他当作是两个点合在一起 假设中间是一个白点 （2，2）那么（1，2）（2，1）（3，2）（2，3）都是黑点 然后建边 这样就类似与上面的二分图了  对白点或者黑点进行二分图查找就可以找到最大匹配（一个匹配就相当于是放了一块木板）</p><p>难点在于想到用二分图的做法来做这个题 还有怎样去建边 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-comment">//N开太大会超时</span><br><span class="hljs-type">int</span> b[N][N], vis[N * N], match[N * N];<span class="hljs-comment">// N*N才能过 不然数组太小</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N * N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 匈牙利算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">bfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n, t;<br>    cin &gt;&gt; n &gt;&gt; t;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        b[x][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!b[i][j])<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<br>                &#123;<br>                    <span class="hljs-type">int</span> x = dx[k] + i, y = dy[k] + j;<br>                    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= n &amp;&amp; !b[x][y])<br>                    &#123;<br>                        <span class="hljs-comment">// 建边</span><br>                        e[i * n + j].<span class="hljs-built_in">push_back</span>(x * n + y);<br>                        e[x * n + y].<span class="hljs-built_in">push_back</span>(i * n + j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((i ^ j) &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 枚举奇数结点</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-comment">//清空</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bfs</span>(i * n + j))<br>                ans++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Bipartite graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树&amp;树状数组</title>
    <link href="/2024/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>树状数组板子  注意在主函数中使用的时候 假设数组为n 需要写为BiTree(n + 1) 因为树状数组范围是1~n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="307-区域和检索-数组可修改-力扣（LeetCode）"><a href="#307-区域和检索-数组可修改-力扣（LeetCode）" class="headerlink" title="307. 区域和检索 - 数组可修改 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></h2><p>树状数组模板题 求不断修改数组的情况下的区间和 </p><p>主要是add函数 for循环结束条件是i &lt; tree.size()</p><p>然后修改了数组元素 要把数组变为val 然后tree里面的值也相应地要修改  修改了<strong>delta</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i ; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums):<span class="hljs-built_in">nums</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">tree</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-built_in">add</span>(i, nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> delta = val - nums[index];<br>        nums[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>; i &lt; tree.<span class="hljs-built_in">size</span>(); i += <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += delta;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(right + <span class="hljs-number">1</span>) - <span class="hljs-built_in">pre</span>(left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3072-将元素分配到两个数组中-II-力扣（LeetCode）"><a href="#3072-将元素分配到两个数组中-II-力扣（LeetCode）" class="headerlink" title="3072. 将元素分配到两个数组中 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></h2><p>离散化+树状数组</p><p>由于数的范围在1e9 太大了 数组开不下 所以要用离散化 为什么可以离散化  因为他只是为了比大小 那把数去重排序后映射到1~n的区间就行了  由于树状数组从1开始 建议映射也从1开始</p><p>用unordered_map把每个数映射</p><p>树状数组的部分 首先把板子打上</p><p>树状数组 存什么呢？ 别的题树状数组（如上题）可能是存前缀和 但是这个题目不一样 他主要是看前面有几个数比他大 我们又已经把数映射了 所以每次add的时候就加1表示index这个地方多了一个数 那么算出来的前缀和就是到1~n这个地方共有几个数 那就是比他小的数的个数  再用size减一下就得到比他大的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">resultArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">tmp</span>(nums);<br>        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>        tmp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()), tmp.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> m = tmp.<span class="hljs-built_in">size</span>(), n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)mp[tmp[i]] = i + <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt;a&#123;nums[<span class="hljs-number">0</span>]&#125;,b&#123;nums[<span class="hljs-number">1</span>]&#125;;<br>        <span class="hljs-function">BiTree <span class="hljs-title">t1</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>        t1.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">0</span>]], <span class="hljs-number">1</span>);<br>        t2.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-type">int</span> v = mp[nums[i]];<br>            <span class="hljs-type">int</span> gc1 = a.<span class="hljs-built_in">size</span>() - t1.<span class="hljs-built_in">pre</span>(v);<br>            <span class="hljs-type">int</span> gc2 = b.<span class="hljs-built_in">size</span>() - t2.<span class="hljs-built_in">pre</span>(v);<br><br>            <span class="hljs-keyword">if</span> (gc1 &gt; gc2 || (gc2 == gc1 &amp;&amp; a.<span class="hljs-built_in">size</span>() &lt;= b.<span class="hljs-built_in">size</span>()))<br>            &#123;<br>                a.<span class="hljs-built_in">push_back</span>(x);<br>                t1.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                b.<span class="hljs-built_in">push_back</span>(x);<br>                t2.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br>        a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1265-数星星-AcWing题库"><a href="#1265-数星星-AcWing题库" class="headerlink" title="1265. 数星星 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星 - AcWing题库</a></h2><p>主要是要理解树状数组的含义  update函数到底在加什么</p><p>像这种计数的题目 而不是求数组区间和  一般就是update(i, 1)表示在i处多了一个什么什么东西</p><p>然后还有这个题的细节 求ans[t.pre(x)]++要先求 因为如果先update的话 x这个地方就多了1（他自己）但是题目要求自己不算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp;(-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span> (<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>             sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">BiTree <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">32001</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        x ++;<br>        ans[t.<span class="hljs-built_in">pre</span>(x)]++;<br>        t.<span class="hljs-built_in">upd</span>(x, <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout&lt;&lt;ans[i]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>下面几道都是板子题 分别代表线段树处理不同的查询</p><h2 id="1270-数列区间最大值-AcWing题库（add-and-max）"><a href="#1270-数列区间最大值-AcWing题库（add-and-max）" class="headerlink" title="1270. 数列区间最大值 - AcWing题库（add and max）"></a><a href="https://www.acwing.com/problem/content/submission/code_detail/32357296/">1270. 数列区间最大值 - AcWing题库</a>（add and max）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll nums[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>];<br>ll n, m;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p * <span class="hljs-number">2</span>] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(ll l = <span class="hljs-number">1</span>, ll r = n, ll p = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <br>        tree[p] = nums[l];<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bulid</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">bulid</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = <span class="hljs-built_in">max</span>(tree[p * <span class="hljs-number">2</span>], tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p=<span class="hljs-number">1</span>, ll cl=<span class="hljs-number">1</span>, ll cr=n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tree[p];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ll mid = cl + cr &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid), <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, cr));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>    &#125;<br>    <span class="hljs-built_in">bulid</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(a, b)&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add-and-sum"><a href="#add-and-sum" class="headerlink" title="add and sum"></a>add and sum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100010</span>;<br>ll nums[MAXN], tree[MAXN * <span class="hljs-number">4</span>], mark[MAXN * <span class="hljs-number">4</span>], n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>    mark[p * <span class="hljs-number">2</span>] += mark[p];<br>    mark[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p];<br>    tree[p * <span class="hljs-number">2</span>] += mark[p] * (len - len / <span class="hljs-number">2</span>);<br>    tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += mark[p] * (len / <span class="hljs-number">2</span>);<br>    mark[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(ll l=<span class="hljs-number">1</span>, ll r=n, ll p=<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        tree[p] = nums[l];<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bulid</span>(l, mid, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">bulid</span>(mid + <span class="hljs-number">1</span>, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll l, ll r, ll d, ll p = <span class="hljs-number">1</span>, ll cl = <span class="hljs-number">1</span>, ll cr = n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        tree[p] += (cr - cl + <span class="hljs-number">1</span>) * d;<br>        <span class="hljs-keyword">if</span> (cr &gt; cl)<br>            mark[p] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">update</span>(l, r, d, p, cl, mid);<br>        <span class="hljs-built_in">update</span>(l, r, d, p, mid + <span class="hljs-number">1</span>, cr);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, ll p=<span class="hljs-number">1</span>, ll cl=<span class="hljs-number">1</span>, ll cr=n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cl &gt; r || cr &lt; l)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> tree[p];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">push_down</span>(p, cr - cl + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span>, cl, mid) + <span class="hljs-built_in">query</span>(l, r, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3月</title>
    <link href="/2024/02/27/3%E6%9C%88/"/>
    <url>/2024/02/27/3%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h1><ul><li>3月刷题的总结 </li><li>acwing、codeforces、洛谷 都没办法看当月提交的数量以及难易度 因此没有做ac截图  但是所有的题都做好了思路整理和答题总结 并附上相关代码  codeforces甚至没有难度 有点难数 填表的时候会按报告整理的题目数量来填 codeforces的难度按当时做题的感受来填</li><li>有些过于简单的题目 出现于力扣的每日一题，力扣、codeforces的竞赛靠前的题目 没有再做整理 </li><li>报告是按算法进行分类整理 [其中每题都附有相应的日期] （背包这种较大的算法 就不统一分在DP中）因为我自己一直有整理做过的题目  发在博客和网站上 我自己做的整理是按算法分类的 报告是在3月 把整理的题目复制过来形成的 </li><li>没有题目 但是附上了题目的链接 点击跳转</li></ul><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><ul><li>3&#x2F;28</li></ul><p>tip：一维的枚举可以从v[i]开始 省去条件判断（if(j &gt;&#x3D; v[i])）</p><h2 id="2-01背包问题-AcWing题库"><a href="#2-01背包问题-AcWing题库" class="headerlink" title="2. 01背包问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></h2><ul><li><strong>二维动态规划</strong></li></ul><p>状态表示 dp[i] [j] 表示到第i个物品 当前体积为j的时候的最大价值</p><p>状态转移 第i个物品取或不取</p><p>取的话要先判断当前的体积够不够取 然后从j - v[i]处更新过来 再加上第i个的价值</p><p> dp[i] [j] &#x3D; max(dp[i - 1] [j],dp[i - 1] [j - v[i]] + w[i])</p><p>不能取的话 直接从i - 1转移过来</p><p>dp[i] [j] &#x3D; dp[i - 1] [j]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-comment">// 到第i个 体积为j 的最大价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>状态压缩</strong>:一维动态规划</li></ul><p>从二维的代码中可以发现 整个转移的过程i这个维度只用到了 i - 1这一个 所以不需要记录整个的dp[i] [….] 数组 只需要一个变量就可以了 </p><p>状态表示为f[j] 表示取到体积为j的时候的最大价值</p><p>状态计算为 当前这个物品取或者不取 不取的话体积不变 仍为f[j] 取的话 从体积为f[i - v[i]] 转移过来</p><p>f[j] &#x3D; max(f[j], f[j - v[i]] + w[i])</p><p>但是在去除掉i这一维之后 就不能像二维一样直接枚举1<del>m了 因为动态规划实际上是利用之前已经计算过的<strong>重复子问题</strong>来简化计算 二维中利用的重复子问题为dp[i - 1] [j - v[i]]。在枚举到 dp[i] [j] 的时候dp[i - 1] [j - v[i]]已经被计算过了 所以可以直接拿来用。但是如果去掉了i这一维度 此时f[j - v[i]] 代表的意义是二维状态下的 dp[i] [j - v[i]] 而不是我们上一段代码中写到的dp[i - 1] [j - v[i]]。那么再从1</del>m枚举  枚举到j的时候 j - v[i] 的时候 他用到的值是 dp[i] [j - v[i]] 就会出错</p><p>所以可以从m开始倒着枚举 这样的话 枚举到j的时候 他用的值是dp[i - 1] [j - v[i]] 因为第i个物品 还没更新到j - v[i] 他用的还是上一轮也就是i - 1的时候的值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N];<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-comment">// 直接枚举 体积为j的最大价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j - v[i]] + w[i], f[j]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-完全背包问题-AcWing题库"><a href="#3-完全背包问题-AcWing题库" class="headerlink" title="3. 完全背包问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/3/">3. 完全背包问题 - AcWing题库</a></h2><ul><li>二维动态规划+三重循环</li></ul><p>每件物品无限使用的话 可以直接在01背包的基础上加一重循环k 枚举每个物品取多少个 </p><p>时间复杂度太高 需要优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>二维动态规划+二重循环</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">思考每次对于k的循环<br>dp[i][j]=max(dp[i-1][j],dp[i-1][j-v]+w,dp[i-1][j-2v]+2w,...dp[i-1][j-kv]+kw...)<br>dp[i][j-v]=max(         dp[i-1][j-v],  dp[i-1][j-2v]+w,... dp[i-1][j-kv]+(k-1)w...)<br>可以发现 dp[i][j-v] 和dp[i][j]从2开始的后半段非常相似 只相差了一个w<br>因此可以进行状态压缩 dp[i][j]=max(dp[i-1][j],dp[i][j-v]+w)<br></code></pre></td></tr></table></figure><p>接下来就可以写出二重循环的做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]); <br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维动态规划+状态压缩</li></ul><p>由此我们可以发现这个代码和01背包十分相似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]); <span class="hljs-comment">// 完全背包</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]); <span class="hljs-comment">// 01背包</span><br></code></pre></td></tr></table></figure><p>所以可以对完全背包也做状态压缩的优化 </p><p>但是需要思考：此时j是正着枚举还是倒着枚举？</p><p>看子问题，在对第i个物品进行更新的时候 完全背包用到的是dp[i] […] 是第i个的状态 而直接去掉第一维 恰好剩下的也是第i个的状态所以可以直接正着枚举  dp[i - 1] [j] 用的是i - 1? 没关系 因为现在就是要从[i - 1] [j]更新到[i] [j]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>            f[j] = <span class="hljs-built_in">max</span>(f[j - v[i]] + w[i], f[j]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-分组背包问题-AcWing题库"><a href="#9-分组背包问题-AcWing题库" class="headerlink" title="9. 分组背包问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/9/">9. 分组背包问题 - AcWing题库</a></h2><ul><li>二维动态规划+三重枚举</li></ul><p>每组只能选一个 枚举每一组的不同的数  </p><p>其实本身就是一个01背包问题  只不过加了一个组的条件 枚举处理即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> v[N][N], w[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;s[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j++)<br>        &#123;<br>            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 到i为止 体积为j的最大价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - v[i][k]] + w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维动态规划+状态压缩</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> v[N][N], w[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;s[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j++)<br>        &#123;<br>            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; j--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k++)<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-多重背包问题-I-AcWing题库"><a href="#4-多重背包问题-I-AcWing题库" class="headerlink" title="4. 多重背包问题 I - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4/">4. 多重背包问题 I - AcWing题库</a></h2><ul><li>二维动态规划+三重循环</li></ul><p>每个物品个数有限 同样可以三重枚举 在枚举的时候加一个条件判断 不超过当前物品的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> v[N], w[N], s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>二进制优化</li></ul><p>接下来用一个非常神奇的寄巧 将多重背包直接变为01背包 这就是二进制优化</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">二进制优化是将物品按1 2 4 8 ... 打包成一组一组的优化方式<br>可行性 这样的组合可以表示任何数 比如20可以被分为1 2 4 8 5<br>而这又可以表示0~20内的任何数 比如 3==1+2   16=1+2+8+5<br>这样分组就可以将时间优化到log的级别<br></code></pre></td></tr></table></figure><p>二进制优化之后 每个物品都被分成了很多组 对每一组进行选择 就可以实现对第i个物品的最佳数量的选择 比如第1个物品有20个 选16个是最优的 那就可以选择v[1]+v[2]+v[4]+v[5]   然后再选第二个物品…</p><p>每一组的<strong>数量限制</strong>就被<strong>取消</strong>了，这就是一个01背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt++;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt++;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-混合背包问题-AcWing题库"><a href="#7-混合背包问题-AcWing题库" class="headerlink" title="7. 混合背包问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/7/">7. 混合背包问题 - AcWing题库</a></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">混合背包：<br>s = -1表示只能用一次--01背包<br>s = 0表示可以用无限次--完全背包<br>s &gt; 0表示可用s次--多重背包<br></code></pre></td></tr></table></figure><ul><li>二维动态规划</li></ul><p>直接写出01背包 完全背包 多重背包的代码分s的情况来使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> v[N], s[N], w[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-number">0</span>)s[i] = INF;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)<br>                &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - v[i] * k] + w[i] * k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一维动态规划+二进制优化</li></ul><p>用二进制优化的方法 将三种背包都转化成01背包 s &lt; 0直接赋为1</p><p>s &#x3D;&#x3D; 0 就让s &#x3D; m &#x2F; a 表示最大体积m 每一个体积a 能取到的最大个数</p><p>还有原本s 就大于0 的  全部用二进制优化的方法</p><p>现在所有的限制都被消除 直接用一维的01背包解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> v[N], s[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;<br>        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)s = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)s = m / a;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt++;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt++;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DP-递归-回溯"><a href="#DP-递归-回溯" class="headerlink" title="DP&#x2F;递归&#x2F;回溯"></a>DP&#x2F;递归&#x2F;回溯</h1><h2 id="1212-地宫取宝-AcWing题库"><a href="#1212-地宫取宝-AcWing题库" class="headerlink" title="1212. 地宫取宝 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝 - AcWing题库</a></h2><ul><li>3&#x2F;1</li></ul><p>这个题目与上一个题有点像 都是矩阵型 状态转移方程也是由左(j  - 1)上(i - 1)转移到[i, j]</p><p>四维DP      状态表示 dp[i] [j] [cnt] [d] 表示i到j中 拿到cnt个物品且最大价值为d的情况</p><p>状态计算 有选或不选两种 （只有当拿的东西不多于k并且价值大于当前最大价值才可以拿）</p><p>不选就直接转移   dp[i] [j] [c] [d] &#x3D; (dp[i] [j] [c] [d] + dp[i - 1] [j] [c] [d]) % mod;</p><p>选的话 需要从c - 1转移过来 并且要加上所有价值小于d的情况</p><p>最后需要加上所有的最大价值的情况 </p><p>注意初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>, mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, M = <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> nums[N][N], dp[N][N][M][M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;row&gt;&gt;col&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>            nums[i][j]++; <span class="hljs-comment">// 防止0的情况</span><br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 不拿 c = 0  d = 0</span><br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 拿了的话 c = 1 d = nums[1][1](当前最大值)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= k; c++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; M; d++)<br>                &#123;<br>                    <span class="hljs-comment">// 不选</span><br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c][d]) % mod;<br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c][d]) % mod;<br>                    <span class="hljs-comment">// 选</span><br>                    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d == nums[i][j])<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; d; s++) <span class="hljs-comment">// 从前面每个最大值转移</span><br>                        &#123;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c - <span class="hljs-number">1</span>][s]) % mod;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c - <span class="hljs-number">1</span>][s]) % mod;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; M; i++)<br>    &#123;<br>        res = (res + dp[row][col][k][i])%mod;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环 选或不选的部分可以优化  不选的话 就直接转移    选的话 需要从c转移到c + 1那么c+1 就需要小于k 并且nums[i + 1] [j] 要大于当前最大值d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (dp[i][j][c][d])<br>&#123;<br>    dp[i + <span class="hljs-number">1</span>][j][c][d] = (dp[i + <span class="hljs-number">1</span>][j][c][d] + dp[i][j][c][d]) % mod;<br>    dp[i][j + <span class="hljs-number">1</span>][c][d] = (dp[i][j + <span class="hljs-number">1</span>][c][d] + dp[i][j][c][d]) % mod;<br>&#125;<br><span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt;= k)<br>&#123;<br>    <span class="hljs-keyword">if</span> (nums[i + <span class="hljs-number">1</span>][j] &gt; d)<br>    dp[i + <span class="hljs-number">1</span>][j][c + <span class="hljs-number">1</span>][nums[i + <span class="hljs-number">1</span>][j]] = (dp[i + <span class="hljs-number">1</span>][j][c + <span class="hljs-number">1</span>][nums[i + <span class="hljs-number">1</span>][j]] + dp[i][j][c][d]) % mod;<br>    <span class="hljs-keyword">if</span> (nums[i][j + <span class="hljs-number">1</span>] &gt; d)<br>    dp[i][j + <span class="hljs-number">1</span>][c + <span class="hljs-number">1</span>][nums[i][j + <span class="hljs-number">1</span>]] = (dp[i][j + <span class="hljs-number">1</span>][c + <span class="hljs-number">1</span>][nums[i][j + <span class="hljs-number">1</span>]] + dp[i][j][c][d]) % mod; <br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2369-检查数组是否存在有效划分-力扣（LeetCode）"><a href="#2369-检查数组是否存在有效划分-力扣（LeetCode）" class="headerlink" title="2369. 检查数组是否存在有效划分 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/">2369. 检查数组是否存在有效划分 - 力扣（LeetCode）</a></h2><p>动态规划 状态表示为f[i] 表示从0到i 是否存在有效划分    </p><p>0存在有效划分 判断 i 是否存在有效划分 如果i - 2存在并且nums[i - 2] &#x3D;&#x3D; nums[i - 1] 则可以  或者i - 3存在 并且三个相等或者连续递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span> &amp;&amp; f[i - <span class="hljs-number">2</span>] &amp;&amp; nums[i - <span class="hljs-number">2</span>] == nums[i - <span class="hljs-number">1</span>] || <br>            i &gt;= <span class="hljs-number">3</span> &amp;&amp; f[i - <span class="hljs-number">3</span>] &amp;&amp; (nums[i - <span class="hljs-number">3</span>] == nums[i - <span class="hljs-number">2</span>] &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i - <span class="hljs-number">2</span>] || nums[i - <span class="hljs-number">3</span>] == nums[i - <span class="hljs-number">2</span>] - <span class="hljs-number">1</span> &amp;&amp; nums[i - <span class="hljs-number">2</span>] == nums[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>))<br>            f[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../images/$%7Bfiilename%7D/image-20240301150042018.png" alt="image-20240301150042018" style="zoom:25%;" /><h2 id="1055-股票买卖-II-AcWing题库"><a href="#1055-股票买卖-II-AcWing题库" class="headerlink" title="1055. 股票买卖 II - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1057/">1055. 股票买卖 II - AcWing题库</a></h2><p>状态机DP 状态表示为dp[i] [0]和dp[i] [1]分别表示 到第i天的时候手上有股票和没有股票的最大获利</p><p>状态计算 第i天手上有股票的最大获利为 第i - 1天手上没股票 在第i天买入 和 第i - 1天手上有股票 第i天不进行操作  两者较大值</p><p>无股票同理</p><p>最后输出为第n天手上没有股票的最大获利（</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100010</span>][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + nums[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - nums[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>    cout&lt;&lt;dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-寻找蒙德之宝"><a href="#xmuoj-寻找蒙德之宝" class="headerlink" title="xmuoj | 寻找蒙德之宝"></a><a href="https://www.xmuoj.com/contest/215/problem/2">xmuoj | 寻找蒙德之宝</a></h2><ul><li>3&#x2F;6</li></ul><p>是之前在力扣写过的石子游戏7 很像有点像博弈论 但是其实是递归 （原题是取数游戏）</p><p>这样思考dfs(l, r)  让他表示轮到当前选手（不论是谁）的时候他可以取的nums[l] 和nums[r]</p><p>首先 递归出口就是l &#x3D;&#x3D; r的时候 这时候就直接返回nums[l] 表示只能取这一个</p><p>然后是递归 当前选手的赢面 意思是当前选手取的值 减去下一步对手取的值  每次都求最大的赢面 意为最优决策</p><p>然后分为取左的赢面和取右的赢面 选较大值即可</p><p>dfs(0, n - 1)就是我的赢面 因为是我先开始 所以答案就是dfs是否大于0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (l == r)<span class="hljs-keyword">return</span> nums[l];<br><br><span class="hljs-type">int</span> hl = nums[l] - <span class="hljs-built_in">dfs</span>(l + <span class="hljs-number">1</span>, r); <br><span class="hljs-type">int</span> hr = nums[r] - <span class="hljs-built_in">dfs</span>(l, r - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(hl, hr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (c != <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>, &amp;nums[k++], &amp;c);<br>&#125;<br><span class="hljs-comment">/*for (int i = 0; i &lt; k; i++)</span><br><span class="hljs-comment">cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;*/</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = k - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(l, r) &gt;= <span class="hljs-number">0</span>)<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;true&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>记忆化搜索  比直接dfs快了很多倍（因为xmuoj输入太抽象了 这里用力扣的题（ </p><h3 id="486-预测赢家-力扣（LeetCode）"><a href="#486-预测赢家-力扣（LeetCode）" class="headerlink" title="486. 预测赢家 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/predict-the-winner/description/">486. 预测赢家 - 力扣（LeetCode）</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">predictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">memo</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">-1</span>));<br>        <br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)-&gt;<span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (l == r)<br>            &#123;<br>                <span class="hljs-keyword">return</span> nums[l];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (memo[l][r] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> memo[l][r];<br><br>            <span class="hljs-type">int</span> hl = nums[l] - <span class="hljs-built_in">dfs</span>(l + <span class="hljs-number">1</span>, r); <br>            <span class="hljs-type">int</span> hr = nums[r] - <span class="hljs-built_in">dfs</span>(l, r - <span class="hljs-number">1</span>);<br>            memo[l][r] = <span class="hljs-built_in">max</span>(hl, hr);<br>            <span class="hljs-keyword">return</span> memo[l][r];<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-最短突破天数"><a href="#xmuoj-最短突破天数" class="headerlink" title="xmuoj | 最短突破天数"></a><a href="https://www.xmuoj.com/contest/215/problem/5">xmuoj | 最短突破天数</a></h2><p>思考回溯的方法 这个题是选哪个的问题</p><p>dfs(int u, int k) u表示当前枚举到哪个材料 k表示需要多少天</p><p>从第i天到第k天 每天都试一下能不能放上nums[u] 然后递归、回溯 </p><p>还要 增加新的一天 新一天可以放上当前的u 也可以不放（回溯）</p><p>递归出口就是u &#x3D;&#x3D; n的时候 记录答案 当前了多少天</p><p>由于要求最短的天数 可以用ans记录一下 当k &gt; ans 的时候说明已经不是最佳答案了 可以剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> nums[N], day[N]; <br><span class="hljs-type">int</span> n, w;<br><span class="hljs-type">int</span> ans = N;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt;= ans)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (u == n)<br>    &#123;<br>        ans = k;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 看这每一天哪一个还能再放的下nums[u] 其实是在枚举nums[u]放在di&#x27;ji</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (day[i] + nums[u] &lt;= w)<br>        &#123;<br>            day[i] += nums[u];<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, k);<br>            day[i] -= nums[u];<br>        &#125;<br>    &#125;<br>    <br>    day[k] = nums[u];<span class="hljs-comment">// 新的一天</span><br>    <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>);<br>    day[k] = <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cin &gt;&gt; n &gt;&gt; w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; nums[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(nums, nums + n, [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<span class="hljs-keyword">return</span> a &gt; b; &#125;);<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1941/problem/E">Problem - E - Codeforces</a></h2><ul><li>3&#x2F;11</li></ul><p>单调队列优化DP </p><p>学习了tllwtg的代码 发现multiset居然也可以发挥和priority_queue一样的功能 并且默认是最小堆（priority_queue默认最大堆）</p><p>最后选出k个最大的 原来都是排序 是$O(nlogn+k)$没想到居然可以$O(n)$ ：滑动窗口 维护长度为k的滑动窗口 ans取出最小</p><p>思路： 枚举每一条河 找出最便宜的k条 如果直接用动态规划会超时 因为m 和d范围都是1e6 所以要用单调队列优化</p><p>需要开最小堆  堆中存放【到当前坐标需要的花费，当前的坐标】 对于花费要从小到大排序 优先取出最小的花费 对坐标要从大到小排列 优先取出大的坐标（离对岸更近）tip：可以把坐标存负值 取出来的时候取正</p><p>到j点的时候 看要从前面哪个点更新过来，先循环去掉距离j超过d的点 然后选出距离合适的 花费最少的点   </p><p>记录当前的花费 并且存入优先队列中</p><p>如果当前的点距离对岸小于m 说明可以直接到对岸 用ans记录最小花费</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;ll, ll&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200001</span>;<br>ll nums[<span class="hljs-number">101</span>][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k, d;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            cin &gt;&gt; nums[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">res</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;); <span class="hljs-comment">// 到当前这个点的花费 和距离 按花费从小到大排序 高度相同的 按距离从大到小排序 因此距离存负 拿出来后取正</span><br>        ll ans = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= m - <span class="hljs-number">1</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> [cost, last] = q.<span class="hljs-built_in">top</span>();<br>                last = -last;<br>                <span class="hljs-keyword">if</span> (j - last &gt; d + <span class="hljs-number">1</span>)<br>                    q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> [cost, last] = q.<span class="hljs-built_in">top</span>();<br>            last = -last;<br>            cost += nums[i][j] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (m - j &lt;= d + <span class="hljs-number">1</span>)<br>            &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, cost);<br>            &#125;<br>            q.<span class="hljs-built_in">push</span>(&#123;cost, -j&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (d &gt;= m - <span class="hljs-number">2</span>)<br>            ans = <span class="hljs-number">0</span>;<br>        res[i] = ans + <span class="hljs-number">2</span>;<br>    &#125;<br>    ll ans = <span class="hljs-number">1e18</span>, cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)<br>        cur += res[i];<br>    ans = cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cur += res[i];<br>        cur -= res[i - k];<br>        ans = <span class="hljs-built_in">min</span>(ans, cur);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1360-有序分数-AcWing题库"><a href="#1360-有序分数-AcWing题库" class="headerlink" title="1360. 有序分数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1362/">1360. 有序分数 - AcWing题库</a></h2><ul><li>3&#x2F;13</li></ul><p>递归 可以发现 0&#x2F;1 和1&#x2F;1之间有 1&#x2F;2  </p><p>0&#x2F;1和1&#x2F;2之间有1&#x2F;3 0&#x2F;1和1&#x2F;3之间有1&#x2F;4 0&#x2F;1和1&#x2F;4之间有1&#x2F;5…</p><p>a&#x2F;b和c&#x2F;d之间存在a + c &#x2F; b + d</p><p>递归  dfs表示当前的两个分数a&#x2F;b 和c&#x2F;d算出他们两个中间的数 然后输出 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b + d &gt; n)<span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-built_in">dfs</span>(a, b, a + c, b + d);<br>    cout&lt;&lt;a + c&lt;&lt;<span class="hljs-string">&quot;/&quot;</span>&lt;&lt;b + d&lt;&lt;endl;<br>    <span class="hljs-built_in">dfs</span>(a + c, b + d, c, d);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class="hljs-string">&quot;0/1&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;1/1&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4645-选数异或-AcWing题库"><a href="#4645-选数异或-AcWing题库" class="headerlink" title="4645. 选数异或 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4648/">4645. 选数异或 - AcWing题库</a></h2><ul><li>3&#x2F;14</li></ul><p>动态规划+位运算</p><p>a^b &#x3D; x –&gt; a^x &#x3D; b</p><p>用last数组记录b出现的坐标 每次查询a^x 如果等于b 那么就 标记 dp[i] 为 b的坐标  </p><p>状态表示 dp[r] &#x3D; l 表示与这个r异或为x的最近的l </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>ll dp[N];<br>ll n, m, x;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>    ll a;<br>    unordered_map&lt;ll, ll&gt;last;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ;i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a;<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], last[a ^ x]);<br>        last[a] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        <span class="hljs-keyword">if</span> (dp[r] &gt;= l)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2312-卖木头块-力扣（LeetCode）"><a href="#2312-卖木头块-力扣（LeetCode）" class="headerlink" title="2312. 卖木头块 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/selling-pieces-of-wood/?envType=daily-question&envId=2024-03-15">2312. 卖木头块 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;15</li></ul><p>每次对木头横切或者竖切一刀 求出最后能卖出的最大价值  切完后木头还可以再切 那就是一个子问题 可以用递归来解决</p><p>设dp[i] [j] 为 长i 宽j的木块最多能卖多少钱  可以选择不切 也就是直接卖长i宽j的木块 </p><p>选择在长的k处 切一刀 那么长就变为了 i - k 和k 木块就变成dp[k] [j] + dp[i - k] [j]</p><p>竖切同理  所以就需要枚举切的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sellingWood</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prices)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pr</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p: prices) &#123;<br>            pr[p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]] = p[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(n + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            &#123;<br>                dp[i][j] = pr[i][j];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; j; k++)dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[i][j - k]);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; i; k++)dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[k][j] + dp[i - k][j]);<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2684-矩阵中移动的最大次数-力扣（LeetCode）"><a href="#2684-矩阵中移动的最大次数-力扣（LeetCode）" class="headerlink" title="2684. 矩阵中移动的最大次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/?envType=daily-question&envId=2024-03-16">2684. 矩阵中移动的最大次数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;16</li></ul><p>动态规划 矩阵型动态规划 但是状态计算的更新点是前一列的上中下</p><p>f[i] [j] 表示到f[i] [j] 最多能走几步  如果比当前数前面大的话就可以从前面更新过来</p><p>但是这个题 跟之前不一样 他必须要从最前面开始往后走 断掉了就不算  所以说要加判断 如果f[i] [j] !&#x3D; j 的话 就说明断了 直接赋为0</p><p>注意 要先枚举列 在枚举行 因为每次更新的时候 都必须从前一列更新过来  那就必须有前一列的数据 也就是说要先算前一列 所以先枚举列再枚举行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">f</span>(row + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col + <span class="hljs-number">1</span>)); <span class="hljs-comment">// f[i][j] 表示i j的最大移动次数</span><br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; col; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] &gt; grid[i][j - <span class="hljs-number">1</span>])f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, f[i][j]);<br>                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j] &gt; grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, f[i][j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[i][j] &gt; grid[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])f[i][j] = <span class="hljs-built_in">max</span>(f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, f[i][j]);<br>                <span class="hljs-keyword">if</span> (f[i][j] != j)f[i][j] = <span class="hljs-number">0</span>;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, f[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4997-更小的数-AcWing题库"><a href="#4997-更小的数-AcWing题库" class="headerlink" title="4997. 更小的数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5000/">4997. 更小的数 - AcWing题库</a></h2><ul><li>3&#x2F;16</li></ul><p>用dp[l] [r] 表示l r区间是否可以旋转 </p><p>如果s[l] &gt; s[r] 标记为可以</p><p>当s[l] &#x3D;&#x3D; s[r]的时候 就看dp[l + 1] [r - 1] 也就是他们里面的一个子数组</p><p>枚举长度len 和左端点l 计算出右端点 如果当前区间可以旋转就标记</p><p>由于是枚举len 从小到大 所以dp[l + 1] [r - 1] 必定是已经计算过的 可以直接使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">6000</span>][<span class="hljs-number">6000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l + len - <span class="hljs-number">1</span> &lt; n; l++)<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (s[l] &gt; s[r])dp[l][r] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[l] == s[r]) dp[l][r] = dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>];<br>            cnt += (dp[l][r] == <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P9242-蓝桥杯-2023-省-B-接龙数列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P9242-蓝桥杯-2023-省-B-接龙数列-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P9242 蓝桥杯 2023 省 B] 接龙数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P9242 <a href="https://www.luogu.com.cn/problem/P9242">蓝桥杯 2023 省 B] 接龙数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><ul><li>3&#x2F;18</li></ul><p>类似于最长上升子序列问题 最少的删除个数不好求  但是可以求最长的接龙的长度 然后用n减去 注意是<strong>子序列</strong>所以才会符合题目要求</p><p>把最长上升子序列的上升改为前后相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    dp[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>    &#123;<br>        <span class="hljs-comment">// 由于j &lt; i 所以j在前面 j就要是second</span><br>        <span class="hljs-keyword">if</span> (nums[j].second == nums[i].first)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意和最长公共子序列区分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>])<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样做会超时 所以还需要优化   可以令dp数组表示到i为止 以j结尾的最长的子序列 设b为起点 e为终点 </p><p>那么当$e_i &#x3D; j$的时候就可以更新 $dp[e_i] &#x3D; max(dp[b_{i}]+1, dp[e_i])$为什么再$b_i$的时候可以加1 因为$dp[b_i]$就是以$b_i$结尾的最长的子序列 然后$b_i$现在又是第i个数的开头 所以就可以更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        dp[s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-built_in">max</span>(dp[s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>], dp[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="P9241-蓝桥杯-2023-省-B-飞机降落-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P9241-蓝桥杯-2023-省-B-飞机降落-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P9241 蓝桥杯 2023 省 B] 飞机降落 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P9241 <a href="https://www.luogu.com.cn/problem/P9241">蓝桥杯 2023 省 B] 飞机降落 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><ul><li>3&#x2F;19</li></ul><p>没办法用贪心 数据只有20 可以用dfs暴力搜索</p><p>思路：枚举每个飞机下降的顺序 用vis记录是否降落</p><p>当p &#x3D;&#x3D; n的时候表示所有飞机都顺利下落 返回true 标记flag为true 剪枝</p><p>否则就开始循环 找到还每下落的飞机 开始下落 </p><p>用l表示当前的时间     如果s &lt; l表示当上一辆下降完成 的时候 我现在枚举到的这架飞机已经到达了 但是不能下降  要令s &#x3D; l （当时间到达t的时候 这架飞机开始下落）要这样做的原因是 后面递归的时候 当前时间为 飞机开始下落的时间加上下落时长 如果s &gt;&#x3D; l 说明上一辆完成时 当前枚举到的这架飞机还没到达 要等到他到达才能开始下降 然后计算时间  所以时间要用s + nums[i].l </p><p>既然时间要用s 前面就要修改s的值（s &lt; l的时候） </p><p>注意标注vis</p><p>主要是变量表示的意义不清楚 .</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">plane</span><br>&#123;<br>    <span class="hljs-type">int</span> t, d, l, e;<br>&#125; nums[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> flag, vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == n)<br>    &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l &lt;= nums[i].e)<br>            &#123;<br>                <span class="hljs-type">int</span> s = nums[i].t;<br>                <span class="hljs-keyword">if</span> (s &lt; l)<br>                &#123;<br>                    s = l;<br>                &#125;<br><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(p + <span class="hljs-number">1</span>, s + nums[i].l);<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i].t &gt;&gt; nums[i].d &gt;&gt; nums[i].l;<br>        nums[i].e = nums[i].t + nums[i].d;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (flag)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="377-组合总和-Ⅳ-力扣（LeetCode）"><a href="#377-组合总和-Ⅳ-力扣（LeetCode）" class="headerlink" title="377. 组合总和 Ⅳ - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;22</li></ul><p>爬楼梯变形 把原来每次爬1&#x2F;2阶台阶 换成每次爬nums[i]次台阶</p><p>本来dp[i] +&#x3D; dp[i - 1] + dp[i - 2] 换成枚举每一个nums[i]</p><p>dp[i] 表示到i共有多少种走法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;ll&gt;<span class="hljs-built_in">dp</span>(target + <span class="hljs-number">1</span>); <span class="hljs-comment">// dp[i] 表示到i有多少种走法 那就是加上 dp[i - nums[j]]</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                &#123;<br>                    dp[i] += dp[i - x];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2466-统计构造好字符串的方案数-力扣（LeetCode）"><a href="#2466-统计构造好字符串的方案数-力扣（LeetCode）" class="headerlink" title="2466. 统计构造好字符串的方案数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;22</li></ul><p>跟上题有点像 计算low到high的种数 其实只用一个个算 然后再循环加起来</p><p>还是求dp[i] </p><p>注意1:数太大了 每次加都需要mod</p><p>注意2:初始化zero和one可能相等要用+&#x3D;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countGoodStrings</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> zero, <span class="hljs-type">int</span> one)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// dp表示i共有多少种 </span><br>        vector&lt;ll&gt;<span class="hljs-built_in">dp</span>(high + <span class="hljs-number">1</span>);<br>        dp[zero] += <span class="hljs-number">1</span>;<br>        dp[one] += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= high; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= zero)<br>            dp[i] = (dp[i] + dp[i - zero]) % mod;<br>            <span class="hljs-keyword">if</span> (i &gt;= one)<br>            dp[i] = (dp[i] + dp[i - one]) % mod;<br>        &#125;<br>        ll ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low; i &lt;= high; i++)<br>        &#123;<br>            ans = (ans + dp[i]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="P9234-蓝桥杯-2023-省-A-买瓜-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P9234-蓝桥杯-2023-省-A-买瓜-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P9234 蓝桥杯 2023 省 A] 买瓜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P9234 <a href="https://www.luogu.com.cn/problem/P9234">蓝桥杯 2023 省 A] 买瓜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><ul><li>3&#x2F;21</li></ul><p>dfs的思路比较简单  但是剪枝优化比较难</p><p>dfs分为 买 不买 卖一半  </p><p>需要排序  先买大的 更快凑齐需要的重量 </p><p>递归出口：i&#x3D;&#x3D;n 和 sum&#x3D;&#x3D;m</p><p>剪枝1：当当前切分数大于最小切分数的时候 不需要再切分 已经不可能更小了 return</p><p>剪枝2：当当前重量大于所需的重量 </p><p>最重要的剪枝：suf  因为从小到大排序了  suf计算一个后缀和 当当前的总和sum 再加上后缀和（就是把后面全部选上）都不够所需的重量 直接返回  这一步可以减去非常多计算 预见后面很多步</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">100</span>), <span class="hljs-built_in">suf</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> mcnt = <span class="hljs-number">2e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> sum, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= m)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (sum == m)<br>    &#123;<br>        mcnt = <span class="hljs-built_in">min</span>(cnt, mcnt);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == n || sum &gt; m || suf[i] + sum &lt; m)<br>    &#123;<br>      <span class="hljs-comment">//  cout&lt;&lt;sum&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i], cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum, cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i] / <span class="hljs-number">2</span>, cnt + <span class="hljs-number">1</span>);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 请在此输入您的代码</span><br>    <br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)cin&gt;&gt;nums[i];<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)suf[i] = suf[i + <span class="hljs-number">1</span>] + nums[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    mcnt == <span class="hljs-number">2e9</span> ? cout&lt;&lt; <span class="hljs-number">-1</span> : cout&lt;&lt;mcnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2266-统计打字方案数-力扣（LeetCode）"><a href="#2266-统计打字方案数-力扣（LeetCode）" class="headerlink" title="2266. 统计打字方案数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-number-of-texts/">2266. 统计打字方案数 - 力扣（LeetCode）</a></h2><p>仍然是求dp[i] 但是这个题多了一步 连续相同的字母合在一起计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> f[N], g[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// dp[i] 表示到i共有多少种</span><br>        <br>        f[<span class="hljs-number">0</span>] = g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = g[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = g[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt; N; i++)<br>        &#123;<br>            f[i] = (<span class="hljs-type">int</span>)(((ll)f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>] + f[i - <span class="hljs-number">3</span>]) % mod);<br>            g[i] = (<span class="hljs-type">int</span>)(((ll)g[i - <span class="hljs-number">1</span>] + g[i - <span class="hljs-number">2</span>] + g[i - <span class="hljs-number">3</span>] + g[i - <span class="hljs-number">4</span>]) % mod);            <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countTexts</span><span class="hljs-params">(string pressedKeys)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = pressedKeys.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            cnt++;<br>            <span class="hljs-type">char</span> c = pressedKeys[i];<br>            <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> || c != pressedKeys[i + <span class="hljs-number">1</span>])<br>            &#123;<br>                ans = (<span class="hljs-type">int</span>)((ll)ans * (c != <span class="hljs-string">&#x27;7&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;9&#x27;</span> ? f[cnt]: g[cnt]) % mod);<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换-力扣（LeetCode）"><a href="#322-零钱兑换-力扣（LeetCode）" class="headerlink" title="322. 零钱兑换 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change/description/?envType=daily-question&envId=2024-03-24">322. 零钱兑换 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;24</li></ul><img src="../images/$%7Bfiilename%7D/image-20240325073006172.png" alt="image-20240325073006172" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//dp[i] 表示到i为止的最小硬币数</span><br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:coins)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= amount)<br>            dp[x] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i - x] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">1e9</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="518-零钱兑换-II-力扣（LeetCode）"><a href="#518-零钱兑换-II-力扣（LeetCode）" class="headerlink" title="518. 零钱兑换 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;25</li><li><img src="../images/$%7Bfiilename%7D/image-20240325075300423.png" alt="image-20240325075300423" style="zoom:25%;" /></li></ul><p>这个题目与上题有区别 一个是求排列数 一个是求组合数 </p><p>也就是说 上一题会把1 2 和2 1当成两种情况 但是这一题 视为同一种情况 如果按上面的写法 最后结果会偏大</p><p>本质原因是子问题的改变   我们需要加上对硬币的限制 1 2 和 2 1 是同种情况 因此可以枚举硬币而不是枚举总和  从小到大枚举硬币 就不会出现2 1这种情况</p><p>现在子问题变为 到第k个硬币 合成金额i的组合数</p><p>状态转移为dp[k] [i] &#x3D; dp[k - 1] [i] + dp[k] [i - coins[k]]  (i &gt; coins[k])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; coins.<span class="hljs-built_in">size</span>(); k++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= coins[k - <span class="hljs-number">1</span>])<br>            dp[k][i] = dp[k][i - coins[k - <span class="hljs-number">1</span>]] + dp[k - <span class="hljs-number">1</span>][i];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp[k][i] = dp[k - <span class="hljs-number">1</span>][i];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时就算交换两个for循环的顺序也不会影响结果 因为交换后子数组的状态转移方程不变 得到的结果也不变</p><p>如果要降成一维的数组 重新定义子问题为 必须选择第k个硬币的时候 凑成金额i的方案数  不能交换for循环的顺序 因为交换完之后 子问题的意义就是 对于金额i 有几种选择硬币的方案数（理解两个子问题的差别 一个是可重复一个不行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// dp[i] 表示必须选择第i个硬币时能凑成的金额的组合数</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                dp[i] += dp[i - x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            cout&lt;&lt;dp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍-力扣（LeetCode）"><a href="#198-打家劫舍-力扣（LeetCode）" class="headerlink" title="198. 打家劫舍 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;26</li></ul><p>打家劫舍例题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);<span class="hljs-comment">// dp[i] 表示到i为止 最大收益是多少</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-comment">// 状态计算 在第i位有选或不选两种方法 如果上一家劫了 这一家就不能劫 上一家没劫 为了达到最大 这一家必须劫</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还可以进行压缩 因为观察可以发现 当前的状态i 只和前一时刻的状态i - 1 和i - 2有关 所以可以只用记录三个变量 而不用一个数组 空间复杂度降为$O(1)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> f0 = <span class="hljs-number">0</span>, f1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; ++i) &#123;<br>            <span class="hljs-type">int</span> new_f = <span class="hljs-built_in">max</span>(f1, f0 + nums[i]);<br>            f0 = f1;<br>            f1 = new_f;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f1;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="740-删除并获得点数-力扣（LeetCode）"><a href="#740-删除并获得点数-力扣（LeetCode）" class="headerlink" title="740. 删除并获得点数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/delete-and-earn/description/">740. 删除并获得点数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;26</li></ul><p>打家劫舍变式  本来选一个之后 只需要跳过一个 就可以选下一个了</p><p>但是现在 每次可以选值为nums[i]的数 删除值为nums[i] - 1 和 nums[i] + 1的数</p><p>每次选择nums[i] 之后 肯定是要把所有的nums[i] 全部选上的 因为他不会被删除</p><p>因此可以把连续相同的nums[i]合并 成为now数组</p><p>接下来就是选不选的问题 更新到nums[i]的时候 只用考虑nums[i] - 1 即可  所以就在用一个数组记录now[i]和now[i - 1]所在的基础值是不是相差1 如果是的话 那就需要跳过nums[i] - 1</p><p>如果不是的话 就可以直接加上</p><p>比如nums&#x3D; 2 4 6那么最大值就是2+4+6&#x3D;12 全都可以选</p><p>状态定义与打家劫舍一样  关键是把原数组转换成适合使用这个定义的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> m = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">bj</span>(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">now</span>(m + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                sum += nums[i];<br>            <span class="hljs-keyword">else</span> <br>                &#123;<br>                    now[++k] = sum;<br>                    sum = nums[i];<br>                    <span class="hljs-keyword">if</span> (nums[i] - nums[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                    bj[k] = <span class="hljs-number">1</span>;<br>                &#125;<br>        &#125;<br>        <br>        now[++k] = sum;<br>        <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">1</span> &amp;&amp; nums[m - <span class="hljs-number">1</span>] - nums[m - <span class="hljs-number">2</span>] == <span class="hljs-number">1</span>)<br>       <br>        bj[k] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        &#123;<br>            cout&lt;&lt;now[i]&lt;&lt;endl;<br>            cout&lt;&lt;<span class="hljs-string">&quot;*&quot;</span>&lt;&lt;bj[i]&lt;&lt;endl;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = now[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= k; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (bj[i - <span class="hljs-number">1</span>])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>],now[i] + dp[i - <span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">else</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + now[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        cout&lt;&lt;dp[i]&lt;&lt;endl;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        &#123;<br>            a = <span class="hljs-built_in">max</span>(a, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="902-最短编辑距离-AcWing题库"><a href="#902-最短编辑距离-AcWing题库" class="headerlink" title="902. 最短编辑距离 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/904/">902. 最短编辑距离 - AcWing题库</a></h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span> == <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[j]</span>的时候 不用操作  <br>当<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span> == <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[j - 1]</span>的时候 要添加<br>    <span class="hljs-selector-tag">i</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>   <span class="hljs-number">4</span><br>   j-<span class="hljs-number">1</span><br>当<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i - 1]</span> == <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[j]</span>的时候 要删除<br>   i-<span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>   <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>  j<br>当<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i - 1]</span> == <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[j - 1]</span>的时候 可以选择替换<br>   i-<span class="hljs-number">1</span>  <span class="hljs-selector-tag">i</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>   <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>   <span class="hljs-number">4</span><br>   j-<span class="hljs-number">1</span>  j<br></code></pre></td></tr></table></figure><p>状态表示：dp[i] [j] 表示0<del>a[i] 和 0</del>b[j] 相等的最少操作次数（dp[i] [j]—–&gt;0<del>a[i] &#x3D;&#x3D; 0</del>b[j]）</p><p>状态计算：</p><p>如果a[i] &#x3D;&#x3D; b[j] （末位相等）那么可以直接从dp[i - 1] [j - 1]更新过来  也可以从dp[i - 1] [j] 或者dp[i] [j - 1]更新过来 （即通过添加或者删除操作 +1</p><p>否则 可以从dp[i - 1] [j - 1] 通过替换更新过来 也可以从dp[i - 1] [j] 或者dp[i] [j - 1]更新过来</p><p>初始化：当i&#x3D;0的时候 j每多一个 就要多一次添加操作  j&#x3D;0同理  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    string a, b;<br>    cin&gt;&gt;n&gt;&gt;a;<br>    cin&gt;&gt;m&gt;&gt;b;<br>    a = <span class="hljs-string">&#x27; &#x27;</span> + a;<br>    b = <span class="hljs-string">&#x27; &#x27;</span> + b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)dp[<span class="hljs-number">0</span>][i] = i;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i] == b[j])dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2320-统计放置房子的方式数-力扣（LeetCode）"><a href="#2320-统计放置房子的方式数-力扣（LeetCode）" class="headerlink" title="2320. 统计放置房子的方式数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">2320. 统计放置房子的方式数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;27</li></ul><img src="../images/$%7Bfiilename%7D/image-20240327084907628.png" alt="image-20240327084907628" style="zoom:25%;" /><p>dp[i] 为单独一侧 前i个的放置方案 </p><p>状态计算：如果i放了 那么i - 1不能放 只能从i - 2更新过来    如果i不放 那么i - 1可放可不放 f[i] &#x3D; f[i - 1]  则 f[i] &#x3D; f[i - 1] + f[i - 2]  因为算的是总方案数 所以两个都要加上（放和不放的方案）</p><p>初始化 f[0] &#x3D; 1 不放也是一种方案  f[1] &#x3D; 2  放和不放两种</p><p>两侧的房屋相互独立 由乘法原理 ans &#x3D; f[n] ^ 2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">10</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n] * dp[n] % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="213-打家劫舍-II-力扣（LeetCode）"><a href="#213-打家劫舍-II-力扣（LeetCode）" class="headerlink" title="213. 打家劫舍 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-ii/submissions/517072916/">213. 打家劫舍 II - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;27</li></ul><img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-27%20090620.png" style="zoom:25%;" /><p>先来看一波丑陋的代码  按照打家劫舍1的方法来写 由于头和尾相连 不能同时选 所以用两个数组表示选头和选尾 然后取最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp1</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        dp1[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp1[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            dp1[i] = <span class="hljs-built_in">max</span>(dp1[i - <span class="hljs-number">1</span>], dp1[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>], dp1[n - <span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这样写太复杂了 （不是优雅的代码 </p><p>可以考虑直接调用打家劫舍1的代码  写成函数之后清晰很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> f0 = <span class="hljs-number">0</span>, f1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; ++i) &#123;<br>            <span class="hljs-type">int</span> new_f = <span class="hljs-built_in">max</span>(f1, f0 + nums[i]);<br>            f0 = f1;<br>            f1 = new_f;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>] + <span class="hljs-built_in">rob1</span>(nums, <span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>), <span class="hljs-built_in">rob1</span>(nums, <span class="hljs-number">1</span>, n));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1388-3n-块披萨-力扣（LeetCode）"><a href="#1388-3n-块披萨-力扣（LeetCode）" class="headerlink" title="1388. 3n 块披萨 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n 块披萨 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;27</li></ul><img src="../images/$%7Bfiilename%7D/image-20240327190933284.png" alt="image-20240327190933284" style="zoom:25%;" /><p>这个题和打家劫舍2很类似  但是如果直接套用打家劫舍的代码就会出错  主要是因为 打家劫舍选的数量不止n &#x3D; m &#x2F; 3个 因此要增加一个条件限制 返回选择n个的时候的最大值 </p><p>状态表示dp[i] [j] 表示到数组的第i个的时候 选了j块披萨的最大值 </p><p>状态计算 dp[i] [j] 当不选第i块披萨的时候（不选nums[i - 1] nums和dp的下标差 1）可以直接从nums[i - 1] [j] 转移</p><p>当选择第i块披萨的时候 就可以从dp[i - 2] [j - 1] 更新过来 再加上nums[i - 1]</p><p>取最大值</p><p>最后返回dp[m] [n] 表示在m块披萨中选n块得到的最大值</p><p>然后分类  选头和选尾 取最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSizeSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; slices)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = slices.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">auto</span> g = [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums) -&gt;<span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-type">int</span> m = nums.<span class="hljs-built_in">size</span>();<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], (i &gt;= <span class="hljs-number">2</span> ? f[i - <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>]:<span class="hljs-number">0</span>) + nums[i - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> f[m][n];<br>        &#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">nums</span>(slices.<span class="hljs-built_in">begin</span>(), slices.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">g</span>(nums);<br>        nums = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(slices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, slices.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> b = <span class="hljs-built_in">g</span>(nums);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a, b);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2597-美丽子集的数目-力扣（LeetCode）"><a href="#2597-美丽子集的数目-力扣（LeetCode）" class="headerlink" title="2597. 美丽子集的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/the-number-of-beautiful-subsets/">2597. 美丽子集的数目 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;27</li></ul><img src="../images/$%7Bfiilename%7D/image-20240327191015040.png" alt="image-20240327191015040" style="zoom:25%;" /><h3 id="子集型回溯"><a href="#子集型回溯" class="headerlink" title="子集型回溯"></a>子集型回溯</h3><p>写法1</p><p>讨论选或者不选 </p><p>先看可不可以选 用map记录已经选了的数 如果map中有数和当前的nums[i] 差为k的话 就不能选 </p><p>否则就可以选 </p><p>不选就没有条件 直接dfs(i + 1) </p><p>递归出口为i &#x3D;&#x3D; nums.size() 只要到了i 就是一种可行的集合</p><p>最后减去空集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">beautifulSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;mp;<br><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                ans ++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp[nums[i] - k] == <span class="hljs-number">0</span> &amp;&amp; mp[nums[i] + k] == <span class="hljs-number">0</span>)<br>            &#123;<br>                mp[nums[i]]++;<br>                <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br>                mp[nums[i]]--;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br>        &#125;; <br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>写法2</p><p>枚举选哪个  dfs(i) 表示在i到n中选</p><p>查找每一个数 看是否选择 每一次选择都是一个可行的集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i)<br>&#123;<br>    ans++;<br>    <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mp[nums[j] - k] == <span class="hljs-number">0</span> &amp;&amp; mp[ nums[j] + k] == <span class="hljs-number">0</span>)<br>        &#123;<br>            mp[nums[j]]++;<br>            <span class="hljs-built_in">dfs</span>(j + <span class="hljs-number">1</span>);<br>            mp[nums[j]]--;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h1 id="枚举-模拟"><a href="#枚举-模拟" class="headerlink" title="枚举 &#x2F; 模拟"></a>枚举 &#x2F; 模拟</h1><h2 id="1210-连号区间数-AcWing题库"><a href="#1210-连号区间数-AcWing题库" class="headerlink" title="1210. 连号区间数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1212/">1210. 连号区间数 - AcWing题库</a></h2><ul><li>3&#x2F;1</li></ul><p>有点偏技巧 关键要找到规律 怎么样求出一个区间是否连号   只要一个区间的最大值和最小值的差 等于 区间的长度就是连号的区间   比如3 2 4    4 - 2 &#x3D; 2 区间长度（下标分别为0 1 2 ）为2 - 0 &#x3D; 2   </p><p>因为当排好序之后 连号数列为minn x1 x2… maxn 则 maxn - minn &#x3D; 区间长度</p><p>找到规律之后直接枚举 左右区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> maxn = nums[<span class="hljs-number">0</span>], minn = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; l++)<br>    &#123;<br>        maxn = minn = nums[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; n; r++)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, nums[r]);<br>            minn = <span class="hljs-built_in">min</span>(minn, nums[r]);<br>            <span class="hljs-keyword">if</span> (maxn - minn == r - l)cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1204-错误票据-AcWing题库"><a href="#1204-错误票据-AcWing题库" class="headerlink" title="1204. 错误票据 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1206/">1204. 错误票据 - AcWing题库</a></h2><ul><li>3&#x2F;2</li></ul><p>照题意模拟 用hash表存数 循环两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>], has[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, maxn = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF)<br>    &#123;<br>        has[x]++;<br>        maxn = <span class="hljs-built_in">max</span>(maxn, x);<br>        minn = <span class="hljs-built_in">min</span>(minn, x);<br>    &#125;<br>    <span class="hljs-type">int</span> d, c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minn; i &lt;= maxn; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (has[i] == <span class="hljs-number">0</span>)d = i;<br>        <span class="hljs-keyword">if</span> (has[i] == <span class="hljs-number">2</span>)c = i;<br>    &#125;<br>    cout&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="466-回文日期-AcWing题库"><a href="#466-回文日期-AcWing题库" class="headerlink" title="466. 回文日期 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/468/">466. 回文日期 - AcWing题库</a></h2><ul><li>3&#x2F;2</li></ul><p>枚举日期可能会超时 所以可以构造回文串然后判断是否是一个日期 是否在规定日期内 复杂度会降低很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> date)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = date / <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> month = date % <span class="hljs-number">10000</span> / <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> day = date % <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">if</span> (!month || month &gt;= <span class="hljs-number">13</span> || !day) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (month != <span class="hljs-number">2</span> &amp;&amp; day &gt; months[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> leap = year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (day &gt; <span class="hljs-number">28</span> + leap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> date1, date2;<br>    cin &gt;&gt; date1 &gt;&gt; date2;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x = i, r = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j ++ ) r = r * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">if</span> (r &gt;= date1 &amp;&amp; r &lt;= date2 &amp;&amp; <span class="hljs-built_in">check</span>(r)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1219-移动距离-AcWing题库"><a href="#1219-移动距离-AcWing题库" class="headerlink" title="1219. 移动距离 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1221/">1219. 移动距离 - AcWing题库</a></h2><ul><li>3&#x2F;2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w, m, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x % w == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> x / w;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> x / w + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> x % w;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (w - (x % w) + <span class="hljs-number">1</span>) % w;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;w&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-keyword">if</span> (m &gt; n)<span class="hljs-built_in">swap</span>(m, n);<br>    <span class="hljs-type">int</span> rn, rm;<br>    rn = <span class="hljs-built_in">r</span>(n), rm = <span class="hljs-built_in">r</span>(m);<br>    <span class="hljs-keyword">if</span> (rn == rm)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-built_in">abs</span>(m - n);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">abs</span>(rn - rm);<br>    <br>    <span class="hljs-type">int</span> fn = rn % <span class="hljs-number">2</span>, fm = rm % <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> cn = <span class="hljs-built_in">c</span>(n, fn), cm = <span class="hljs-built_in">c</span>(m, fm);<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">abs</span>(cn - cm);<br>    <br>    cout&lt;&lt;a + b;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1229-日期问题-AcWing题库"><a href="#1229-日期问题-AcWing题库" class="headerlink" title="1229. 日期问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1231/">1229. 日期问题 - AcWing题库</a></h2><ul><li>3&#x2F;2</li></ul><p>由于数比较小 可以枚举 从19600101到20591231 </p><p>直接模拟不好写 可以先判断一下当前的数字是不是日期</p><p>如果是一个日期的话 再去看他符不符合三种排列的其中一种 输出即可（直接按提议模拟判断太多 写不了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> mon[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) || (y % <span class="hljs-number">100</span> != <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m &gt;= <span class="hljs-number">1</span> &amp;&amp; m &lt;= <span class="hljs-number">12</span>)<br>    &#123;<br>        mon[<span class="hljs-number">2</span>] += <span class="hljs-built_in">run</span>(y);<br>        <span class="hljs-keyword">if</span> (d&gt;=<span class="hljs-number">1</span> &amp;&amp; d &lt;= mon[m])<br>            &#123;<br>                mon[<span class="hljs-number">2</span>] = <span class="hljs-number">28</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d/%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>    <br>    <span class="hljs-comment">//构造</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">19600101</span>; i &lt;= <span class="hljs-number">20591231</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> y = (i / <span class="hljs-number">10000</span>), m = (i % <span class="hljs-number">10000</span>) / <span class="hljs-number">100</span>, d = i % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(y, m, d))<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((y%<span class="hljs-number">100</span> == a &amp;&amp; m == b &amp;&amp; d == c)||<br>        (m == a &amp;&amp; d == b &amp;&amp; y%<span class="hljs-number">100</span> == c)||<br>        (d == a &amp;&amp; m == b &amp;&amp; y%<span class="hljs-number">100</span> == c))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%02d-%02d\n&quot;</span>, y, m, d);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1231-航班时间-AcWing题库"><a href="#1231-航班时间-AcWing题库" class="headerlink" title="1231. 航班时间 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1233/">1231. 航班时间 - AcWing题库</a></h2><ul><li>3&#x2F;1</li></ul><p>关键在于题目给的是<strong>往返</strong>的时间 去的时候 时间为B - A + H（时差）回来的时候时间为A - B + H  两趟的时间加起来刚好抵消了时差 所以可以不需要考虑时差 只用除以二即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gettime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> h1,h2,m1,m2,s1,s2,a=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>, &amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;a);<br>    <span class="hljs-type">int</span> t = a * <span class="hljs-number">24</span> * <span class="hljs-number">3600</span> + h2 * <span class="hljs-number">3600</span> + m2 * <span class="hljs-number">60</span> + s2 - (h1 * <span class="hljs-number">3600</span> + m1 * <span class="hljs-number">60</span> + s1);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-type">int</span> t1 = <span class="hljs-built_in">gettime</span>();<br>        <span class="hljs-type">int</span> t2 = <span class="hljs-built_in">gettime</span>();<br>        <span class="hljs-type">int</span> t = t1 + t2 &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d\n&quot;</span>, t / <span class="hljs-number">3600</span>, t % <span class="hljs-number">3600</span> / <span class="hljs-number">60</span>, t % <span class="hljs-number">60</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1241-外卖店优先级-AcWing题库"><a href="#1241-外卖店优先级-AcWing题库" class="headerlink" title="1241. 外卖店优先级 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1243/">1241. 外卖店优先级 - AcWing题库</a></h2><ul><li>3&#x2F;2</li></ul><p>1e5的规模 O(n2)的时间会超时 直接两层循环肯定是不行的 要降低复杂度 </p><p>不用枚举每分钟 每个商店的加减 而是枚举所有的<strong>操作</strong>记录上次操作的时间 分段地处理订单 这样处理就需要订单是有序的 所以要排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, t;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TD</span><br>&#123;<br>    <span class="hljs-type">int</span> t, d;  <br>&#125;td[<span class="hljs-number">100010</span>];<br><span class="hljs-type">bool</span> st[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> last[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t, d;<br>        cin&gt;&gt;t&gt;&gt;d;<br>        td[i].t = t, td[i].d = d;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(td, td + m, [&amp;](TD a, TD b)&#123;<br>        <span class="hljs-keyword">if</span> (a.t == b.t)<span class="hljs-keyword">return</span> a.d &lt; b.d;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.t &lt; b.t;<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m;)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-type">int</span> id = td[i].d, it = td[i].t;<br>        <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; td[j].d == id &amp;&amp; td[j].t == it)<br>        &#123;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> c = it - last[id] - <span class="hljs-number">1</span>;<br>        cnt[id] -= c;<br>        <span class="hljs-keyword">if</span> (cnt[id] &lt; <span class="hljs-number">0</span>)cnt[id] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cnt[id] &lt;= <span class="hljs-number">3</span>)st[id] = <span class="hljs-literal">false</span>;<br>        cnt[id] += <span class="hljs-number">2</span> * (j - i);<br>        <span class="hljs-keyword">if</span> (cnt[id] &gt; <span class="hljs-number">5</span>) st[id] = <span class="hljs-literal">true</span>;<br>        last[id] = it;<br>        <br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cnt[i] -= (t - last[i]);<br>        <span class="hljs-keyword">if</span> (cnt[i] &lt;= <span class="hljs-number">3</span>)st[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i])res++;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1238-日志统计-AcWing题库"><a href="#1238-日志统计-AcWing题库" class="headerlink" title="1238. 日志统计 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1240/">1238. 日志统计 - AcWing题库</a></h2><ul><li>3&#x2F;3</li></ul><p>这个题跟上一题有点像 但是又不一样  上一题是每个单位时间都在增减 这个题只用看当前这个博客他的上一次点赞  由于排好序了 所以博客点赞取消的时间也是有序的  用j来表示 当logs[i].x 也就是当前的时间 比j大超过d的时候 点赞取消 cnt要减少</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> cnt[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-type">int</span> n, k, d;<br>PII logs[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)cin&gt;&gt;logs[i].x&gt;&gt;logs[i].y;<br>    <br>    <span class="hljs-built_in">sort</span>(logs, logs + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> id = logs[i].y, t = logs[i].x;<br>        cnt[id]++;<br>        <span class="hljs-comment">// 时间超了</span><br>        <span class="hljs-keyword">while</span> (logs[i].x - logs[j].x &gt;= d)<br>        &#123;<br>            cnt[logs[j].y]--;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt[id] &gt;= k)st[id] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<span class="hljs-keyword">if</span> (st[i])cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-C-Codeforces"><a href="#Problem-C-Codeforces" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1933/problem/C">Problem - C - Codeforces</a></h2><ul><li>3&#x2F;1</li></ul><p>比赛的时候一直感觉有复杂度低的做法  结果没想到就是暴力（ 但是不是枚举k 这样会超时  而是枚举x y</p><p>因为x y是幂次 1e6的数据x y到30就已经超出很多了  这样来看复杂度也就是900*O(pow)肯定是够的。。。</p><p>然后再注意一点 用set会比map简单一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, l;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; l;<br>    set&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= <span class="hljs-number">30</span>; x++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= <span class="hljs-number">30</span>; y++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l % (<span class="hljs-type">int</span>)(<span class="hljs-built_in">pow</span>(a, x) * <span class="hljs-built_in">pow</span>(b, y)) == <span class="hljs-number">0</span>)<br>                s.<span class="hljs-built_in">insert</span>(l / (<span class="hljs-built_in">pow</span>(a, x) * <span class="hljs-built_in">pow</span>(b, y)));<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3066-超过阈值的最少操作数-II-力扣（LeetCode）"><a href="#3066-超过阈值的最少操作数-II-力扣（LeetCode）" class="headerlink" title="3066. 超过阈值的最少操作数 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/submissions/506853271/">3066. 超过阈值的最少操作数 II - 力扣（LeetCode）</a></h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/">3065. 超过阈值的最少操作数 I - 力扣（LeetCode）</a></p><ul><li>3&#x2F;2</li></ul><p>双周赛t1 t2 简单模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;q;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(-nums[i]);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &lt;= k &amp;&amp; !q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            x = -q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (x &gt;= k)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> y = -q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            q.<span class="hljs-built_in">push</span>(-(<span class="hljs-built_in">min</span>(x, y) * <span class="hljs-number">2</span> + <span class="hljs-built_in">max</span>(x, y)));<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3071-在矩阵上写出字母-Y-所需的最少操作次数-力扣（LeetCode）"><a href="#3071-在矩阵上写出字母-Y-所需的最少操作次数-力扣（LeetCode）" class="headerlink" title="3071. 在矩阵上写出字母 Y 所需的最少操作次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/submissions/506949217/">3071. 在矩阵上写出字母 Y 所需的最少操作次数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;3</li></ul><p>周赛t3 哈希表 记录Y上的0 1 2 的数量 最后进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperationsToWriteY</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = g.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> zx = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> cy[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; zx; i++)<br>        &#123;<br>            cy[g[i][n - i - <span class="hljs-number">1</span>]]++;<br>            cy[g[i][i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = zx; i &lt; n; i++)<br>        &#123;<br>            cy[g[i][zx]]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ny[<span class="hljs-number">3</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt; n; j++)<br>            &#123;<br>                ny[g[i][j]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span> ; i  &lt;<span class="hljs-number">3</span>; i++)<br>            ny[i] -= cy[i];<br>        <br>        <span class="hljs-type">int</span> sumy[<span class="hljs-number">3</span>], nsy[<span class="hljs-number">3</span>];<br>        sumy[<span class="hljs-number">0</span>] = sumy[<span class="hljs-number">1</span>] = sumy[<span class="hljs-number">2</span>] = (cy[<span class="hljs-number">0</span>] + cy[<span class="hljs-number">1</span>] + cy[<span class="hljs-number">2</span>]);<br>        nsy[<span class="hljs-number">0</span>] = nsy[<span class="hljs-number">1</span>] = nsy[<span class="hljs-number">2</span>] = (ny[<span class="hljs-number">0</span>] + ny[<span class="hljs-number">1</span>] + ny[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            sumy[i] -= cy[i];<br>            nsy[i] -= ny[i];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br>        <br>        res = <span class="hljs-built_in">min</span>(res, sumy[<span class="hljs-number">0</span>] + <span class="hljs-built_in">min</span>(nsy[<span class="hljs-number">1</span>], nsy[<span class="hljs-number">2</span>]));<br>        res = <span class="hljs-built_in">min</span>(res, sumy[<span class="hljs-number">1</span>] + <span class="hljs-built_in">min</span>(nsy[<span class="hljs-number">0</span>], nsy[<span class="hljs-number">2</span>]));<br>        res = <span class="hljs-built_in">min</span>(res, sumy[<span class="hljs-number">2</span>] + <span class="hljs-built_in">min</span>(nsy[<span class="hljs-number">0</span>], nsy[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="100251-数组中的最短非公共子字符串-力扣（LeetCode）"><a href="#100251-数组中的最短非公共子字符串-力扣（LeetCode）" class="headerlink" title="100251. 数组中的最短非公共子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-uncommon-substring-in-an-array/description/">100251. 数组中的最短非公共子字符串 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;10</li></ul><p>周赛t3</p><p>核心思路 ：哈希表记录前面出现过的子字符串 </p><p>先枚举所有字符串的子字符串 放入哈希表 </p><p>然后再枚举所有字符串的子字符串 检查哈希表中其他字符是否也有这个子字符串</p><img src="../images/$%7Bfiilename%7D/image-20240311091841329.png" alt="image-20240311091841329" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">shortestSubstrings</span><span class="hljs-params">(vector&lt;string&gt;&amp; arr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.<span class="hljs-built_in">size</span>(); k++)<br>        &#123;<br>            <span class="hljs-type">int</span> n = arr[k].<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) <br>                &#123;<br>                    string substring = arr[k].<span class="hljs-built_in">substr</span>(i, j - i);<br>                    mp[substring].<span class="hljs-built_in">push_back</span>(k);<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;string&gt;rets;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.<span class="hljs-built_in">size</span>(); k++)<br>        &#123;<br>            <span class="hljs-type">int</span> n = arr[k].<span class="hljs-built_in">size</span>();<br>            string ret = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) <br>                &#123;<br>                    string substring = arr[k].<span class="hljs-built_in">substr</span>(i, j - i);<br>                    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: mp[substring])<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (x != k)<br>                        &#123;<br>                            flag = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (ret == <span class="hljs-string">&quot;&quot;</span>)ret = substring;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (ret.<span class="hljs-built_in">size</span>() &gt; substring.<span class="hljs-built_in">size</span>())<br>                                ret = substring;<br>                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret.<span class="hljs-built_in">size</span>() == substring.<span class="hljs-built_in">size</span>() &amp;&amp; ret &gt; substring)<br>                                ret = substring;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            rets.<span class="hljs-built_in">push_back</span>(ret);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rets;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Problem-A-Codeforces"><a href="#Problem-A-Codeforces" class="headerlink" title="Problem - A - Codeforces"></a><a href="https://codeforces.com/contest/1941/problem/A">Problem - A - Codeforces</a></h2><ul><li>3&#x2F;12</li></ul><p>按题意模拟 左右各取硬币进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> l[N], r[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; l[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        cin &gt;&gt; r[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(l, l + n);<br>    <span class="hljs-built_in">sort</span>(r, r + m);<br>    ll cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l[i] + r[j] &lt;= k)<br>                cnt++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l[i] &gt;= k)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-C-Codeforces-1"><a href="#Problem-C-Codeforces-1" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1941/problem/C">Problem - C - Codeforces</a></h2><ul><li>3&#x2F;11</li></ul><p>字符串查找 关键是对每个子串进行分割 map 和pie都是只用破坏中间的字母就可以让他们变美 需要的最小代价为1</p><p>要注意mapie这样特殊的字符串 进行特判</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    string s;<br>    cin &gt;&gt; s;<br>    ll cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        string a = s.<span class="hljs-built_in">substr</span>(i, <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&quot;map&quot;</span> || a == <span class="hljs-string">&quot;pie&quot;</span>)<br>            cnt++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        string a = s.<span class="hljs-built_in">substr</span>(i, <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&quot;mapie&quot;</span>)<br>            cnt--;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1941/problem/D">Problem - D - Codeforces</a></h2><ul><li>3&#x2F;11</li></ul><p>记录每次传球可能传到的同学的下标 然后存入temp中 </p><p>当一轮全部传完再赋值给last </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> n, m, x;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    set&lt;<span class="hljs-type">int</span>&gt; last;<br>    last.<span class="hljs-built_in">insert</span>(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> d;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; d &gt;&gt; c;<br>        set&lt;<span class="hljs-type">int</span>&gt; temp;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : last)<br>        &#123;<br>            <span class="hljs-type">int</span> now1 = (a + d) % n;<br>            <span class="hljs-type">int</span> now2 = (a - d + n) % n;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                temp.<span class="hljs-built_in">insert</span>(now1);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>)<br>            &#123;<br>                temp.<span class="hljs-built_in">insert</span>(now2);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                temp.<span class="hljs-built_in">insert</span>(now1);<br>                temp.<span class="hljs-built_in">insert</span>(now2);<br>            &#125;<br>        &#125;<br>        last = temp;<br>    &#125;<br>    <span class="hljs-type">int</span> l = last.<span class="hljs-built_in">size</span>();<br>    cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : last)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-number">0</span>)<br>            cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag)<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="成为-K-特殊字符串需要删除的最少字符数-力扣-LeetCode-竞赛"><a href="#成为-K-特殊字符串需要删除的最少字符数-力扣-LeetCode-竞赛" class="headerlink" title="成为 K 特殊字符串需要删除的最少字符数 - 力扣 (LeetCode) 竞赛"></a><a href="https://leetcode.cn/contest/weekly-contest-389/problems/minimum-deletions-to-make-string-k-special/">成为 K 特殊字符串需要删除的最少字符数 - 力扣 (LeetCode) 竞赛</a></h2><ul><li>3&#x2F;17</li></ul><p>比赛的时候调了一个多小时都没调出来。。。</p><p>是类似于滑动窗口的思想，先计算全部减少最大的字母 直到满足条件</p><p>然后删除一个最小的字母 再减少后面大的字母  直到满足条件</p><p>然后删除两个最小的字母 再减少后面大的字母 直到满足条件</p><p>… 直到删除所有的小字母</p><p>暴力枚举</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumDeletions</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:word)<br>        &#123;<br>            cnt[x - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(cnt, cnt + <span class="hljs-number">26</span>);<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cnt[i] != <span class="hljs-number">0</span>)<br>                &#123;index = i;<br>                 <span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">25</span>] - cnt[index] &lt;= k)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">26</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; n; i++)<br>        &#123;<br>        <span class="hljs-type">int</span> now = pre;<br>            <span class="hljs-comment">// 全部删后面</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt; cnt[i] + k)<br>                now += cnt[j] - cnt[i] - k;<br>            &#125;<br>            res = <span class="hljs-built_in">min</span>(res, now);<br>            pre += cnt[i];<span class="hljs-comment">// 删一个最小的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2580-统计将重叠区间合并成组的方案数-力扣（LeetCode）"><a href="#2580-统计将重叠区间合并成组的方案数-力扣（LeetCode）" class="headerlink" title="2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/">2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;27</li></ul><img src="../images/$%7Bfiilename%7D/image-20240327081353922.png" alt="image-20240327081353922" style="zoom:25%;" /><p>区间合并 按左端点排序 之后维护一个最大右值maxr 如果下一个数的左端点小于maxr 就说明这是相连的区间 否则就是一个新的区间</p><p>由于相连的区间必须放在同一组 可以直接将相连的区间视为一个整体 算出区间的数量 然后利用排列 共有$2^n$种放法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countWays</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ranges)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">sort</span>(ranges.<span class="hljs-built_in">begin</span>(), ranges.<span class="hljs-built_in">end</span>(), [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;a, vector&lt;<span class="hljs-type">int</span>&gt;b)<br>        &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:ranges)<br>        &#123;<br>            cout&lt;&lt;x[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;x[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-type">int</span> n = ranges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxr = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ranges[i][<span class="hljs-number">0</span>] &gt; maxr)<br>                res = res * <span class="hljs-number">2</span> % mod;<br>                <br>            maxr = <span class="hljs-built_in">max</span>(maxr, ranges[i][<span class="hljs-number">1</span>]);<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数学-贪心"><a href="#数学-贪心" class="headerlink" title="数学 &#x2F; 贪心"></a>数学 &#x2F; 贪心</h1><h2 id="Problem-A-Codeforces-1"><a href="#Problem-A-Codeforces-1" class="headerlink" title="Problem - A - Codeforces"></a><a href="https://codeforces.com/contest/1933/problem/A">Problem - A - Codeforces</a></h2><ul><li>3&#x2F;1</li></ul><p>正数不需要换 负数需要换 全部变成整数即为最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>)<br>            res += x;<br>        <span class="hljs-keyword">else</span><br>            res -= x;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-B-Codeforces⁤"><a href="#Problem-B-Codeforces⁤" class="headerlink" title="Problem - B - Codeforces⁤"></a><a href="https://codeforces.com/contest/1933/problem/B">Problem - B - Codeforces⁤</a></h2><ul><li>3&#x2F;1</li></ul><p>由于要模3  sum % 3只有0 1 2三种情况 当减去某个数之后可能整除3   注意 减去1 和减去4 的效果是一样的 所以用哈希表记录是否有模3为1 或2的然后看加还是减 可以得到整除3的数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>        sum += nums[i];<br>        cnt[nums[i] % <span class="hljs-number">3</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sum + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || ((sum - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; cnt[<span class="hljs-number">1</span>] != <span class="hljs-number">0</span>) || ((sum - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; cnt[<span class="hljs-number">2</span>] != <span class="hljs-number">0</span>))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-D-Codeforces-1"><a href="#Problem-D-Codeforces-1" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1933/problem/D">Problem - D - Codeforces</a></h2><ul><li>3&#x2F;1</li></ul><p>尽量通过排列顺序凑出 <strong>不等于0</strong></p><p>所有的数都去取模 最终不为0输出YES 否则输出NO</p><ol><li><p>观察可以发现  1 % 2 &#x3D; 1   2 % 9 &#x3D; 2  小数模大数 必定不可能为0   </p></li><li><p>0 % x &#x3D; 0  只要有两数相模为0 那么结果就肯定为0 就为NO</p></li></ol><p>所以排序之后 把大数分别拿去模小数（模最小的nums[0]即可）如果不是0  那么说明可能出现不等于0 直接输出YES（只要一直用这个小数模大数就行）  2 2 3   可以3 % 2 &#x3D; 1 得到的数为1         1 % 2 &#x3D; 1 由于大数模小数可以得到比nums[0]更小的数  只要他大于0 小于nums[0] 那么就一定可以反复利用这个小数  最终结果不为0   [规则1]</p><p>最终如果nums[0] &#x3D;&#x3D; nums[1] 就是两个一样的数相模 为0  就为NO  因为比如3 3 6 9         9 % 3 &#x3D; 0 规则1失效 由于 [规则2]  虽然说3模6 3模9都不为0    但是3 % 3 &#x3D; 0 所以最后要特判一下是否有和最小数nums[0] 一样的数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] % nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>])<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1224-交换瓶子-AcWing题库"><a href="#1224-交换瓶子-AcWing题库" class="headerlink" title="1224. 交换瓶子 - AcWing题库"></a>1224. <a href="https://www.acwing.com/problem/content/1226/">交换瓶子 - AcWing题库</a></h2><p>3&#x2F;8</p><p>置换群</p><p>每个长k的环需要k - 1次交换 则求n中有多少个环即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> nums[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; <br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[nums[i]])<br>        &#123;<br>            cnt++;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (!vis[nums[j]])<br>            &#123;<br>                vis[nums[j]] = <span class="hljs-number">1</span>;<br>                j = nums[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;n - cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-货仓选址-AcWing题库"><a href="#104-货仓选址-AcWing题库" class="headerlink" title="104. 货仓选址 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/106/">104. 货仓选址 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>尽量选在中间位置 比如1  2   6 9</p><p>选择在2 6 中间   距离和为 2x - 3 + 15 - 2x &#x3D; 12</p><p>选在6 9中间为 9 - x - 9 + 3x 并且x &gt; 6  sum  &gt; 12</p><p>所以在中间是最好的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        left += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> + n % <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        right += nums[i];<br>    &#125;<br>    cout&lt;&lt;right - left&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0填充-蓝桥云课-lanqiao-cn"><a href="#0填充-蓝桥云课-lanqiao-cn" class="headerlink" title="0填充 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3519/learning/">0填充 - 蓝桥云课 (lanqiao.cn)</a></h2><ul><li>3&#x2F;6</li></ul><p>贪心的策略 从0到n 一旦遇到了两两凑成一对的 就直接计入结果并且跳过i + 1</p><p>如果遇到？ 大概有这几种情况 0??1   0?可以 ?1 可以</p><p>??11    ??可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>  string s;<br>  cin&gt;&gt;s;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>] || s[i] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>)<br>      &#123;<br>          ans++;<br>          i++;<br>      &#125;<br>  &#125;<br>  cout&lt;&lt;ans;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-糖果传递-AcWing题库"><a href="#122-糖果传递-AcWing题库" class="headerlink" title="122. 糖果传递 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/124/">122. 糖果传递 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>[环形]均分纸牌问题</p><img src="../images/$%7Bfiilename%7D/image-20240302163447063.png" alt="image-20240302163447063" style="zoom: 25%;" /><p>推公式：先设每个人要给左边的$x_i$个 从右边拿到$x_{i + 1}$个 （只需要给旁边的 因为就算跨着给 结果也是一样的 直接设只给旁边的好算） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], temp[N], c[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    ll sum = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>        sum += a[i];<br>    &#125;<br>    ll ave = sum / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        temp[i] = ave - a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>] = temp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        c[i] = c[i - <span class="hljs-number">1</span>] + temp[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(c, c + n);<br>    <span class="hljs-type">int</span> xn = c[n / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        ret += <span class="hljs-built_in">abs</span>(c[i] - xn);<br>    &#125;<br>    cout&lt;&lt;ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="112-雷达设备-AcWing题库"><a href="#112-雷达设备-AcWing题库" class="headerlink" title="112. 雷达设备 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/114/">112. 雷达设备 - AcWing题库</a></h2><ul><li>3&#x2F;11</li></ul><p>本来想这样贪心：先按x从小到大 相同x的y从大到小排序 不断选取最右边的值 但是有些情况不符合 <img src="../images/$%7Bfiilename%7D/image-20240302195003434.png" alt="image-20240302195003434" style="zoom:25%;" /></p><p>所以要先求出每个岛的探测区间 然后再按区间合并的方法来做</p><p>按右端点排序 排完序后如果一个区间的左端点小于last区间的右端点 那么就说明他们可以共用一个雷达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> r first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> l second</span><br>PII seg[<span class="hljs-number">100010</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> INF = <span class="hljs-number">1e10</span>, eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, d;<br>    cin &gt;&gt; n &gt;&gt; d;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span> (y &gt; d)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">sqrt</span>(d * d - y * y);<br>        seg[i] = &#123;x + len, x - len&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(seg, seg + n);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> last = -INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (seg[i].l &gt; last + eps)<br>        &#123;<br>            res++;<br>            last = seg[i].r;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1235-付账问题-AcWing题库"><a href="#1235-付账问题-AcWing题库" class="headerlink" title="1235. 付账问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1237/">1235. 付账问题 - AcWing题库</a></h2><p>求出平均值 当小于平均值的 时候  直接allin 当大于平均值的时候只需要给出平均值就行</p><p>关键在于不断地更新当前的平均值 </p><p>一开始想的贪心是 先把小于的全部给了 大于的把平均值给了 然后算差的钱的平均值 再从大的里面减 然后不够了再去… 这样要两层循环 是$O(n^2)$的 不行</p><p>可以对每一个数都更新一下当前的平均值 小于的全部给  但是由于小于平均值 这里要更新一下当前的平均值 因为这人给的不够 后面要多给   由于<strong>排序</strong>了 如果有人够了 就直接给平均值的钱就行 因为后面的必然够</p><p>注意同时计算sum</p><p>注意这题爆double了（哭   要用long double<img src="../images/$%7Bfiilename%7D/image-20240302205938546.png" alt="image-20240302205938546" style="zoom:25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">500010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> ave = s * <span class="hljs-number">1.0</span> / n ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> cur_ave = ave;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= cur_ave)<br>        &#123;<br>            s -= nums[i];<br>            sum += (ave - nums[i]) * (ave - nums[i]);<br>            cur_ave = s  * <span class="hljs-number">1.0</span> / (n - i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            sum += (cur_ave - ave) * (cur_ave - ave);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4llf&quot;</span>,<span class="hljs-built_in">sqrt</span>(sum / n));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1239-乘积最大-AcWing题库"><a href="#1239-乘积最大-AcWing题库" class="headerlink" title="1239. 乘积最大 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1241/">1239. 乘积最大 - AcWing题库</a></h2><ul><li>3&#x2F;7</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">k是奇数则 如果全是负数 结果为负</span><br><span class="hljs-comment">否则先选一个正数（最大的） 变为k是偶数的情况</span><br><span class="hljs-comment">k是偶数则答案必然是正的 看负数的个数 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span> , mod = <span class="hljs-number">1000000009</span> ;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n , k ;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br>    <span class="hljs-built_in">sort</span>(a,a + n);<br><br>    LL res = <span class="hljs-number">1</span> ; <span class="hljs-comment">//乘积初始化</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span> ;<span class="hljs-comment">//双指针初始化</span><br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span> ; <span class="hljs-comment">// 符号初始化</span><br><br>    <span class="hljs-comment">//由于4种情况除了 k 是奇数且 k &lt; n 的时候需要特判一下处理一下符号 ,其他的时候都可以转化为双指针做法</span><br>    <span class="hljs-comment">//k 是奇数是先选出最大的数, k-- 就是偶数,两边再同时取对,转化成相同的双指针做法</span><br>    <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> )<br>    &#123;<br>        res =  a[r]; <span class="hljs-comment">// 取出最大的一个数</span><br>        r -- ; <span class="hljs-comment">//右指针移动</span><br>        k -- ; <span class="hljs-comment">//个数减1</span><br><br>        <span class="hljs-keyword">if</span>(res &lt; <span class="hljs-number">0</span>) sign = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果最大值都是负数,就证明全是负数,那么符号要发生改变</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(k) <span class="hljs-comment">// 双指针做法</span><br>    &#123;<br>        LL x = (LL)a[l] * a[l + <span class="hljs-number">1</span>] , y = (LL)a[r] * a[r - <span class="hljs-number">1</span>];<span class="hljs-comment">//两边同时取对</span><br>        <span class="hljs-comment">//选择更大的一对,和归并排序思路相近</span><br>        <span class="hljs-keyword">if</span>(x * sign &gt; y * sign)<br>        &#123;<br>            res = x % mod * res % mod; <span class="hljs-comment">// 需要注意的是 :不可以写成(x * res) % mod ,也不可以写成是 res % mod * x % mod</span><br>                                       <span class="hljs-comment">// 因为x最大是 10^10，如果不先取模的话，和res相乘的结果最大是 10^19,会暴long long。            </span><br>            l += <span class="hljs-number">2</span>; <span class="hljs-comment">// 指针移动                                 </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            res = y % mod * res % mod; <br>            r -= <span class="hljs-number">2</span>; <br>        &#125;<br>        k -= <span class="hljs-number">2</span>; <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1247-后缀表达式-AcWing题库"><a href="#1247-后缀表达式-AcWing题库" class="headerlink" title="1247. 后缀表达式 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1249/">1247. 后缀表达式 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>一开始没读懂题意   后缀表达式关键在于他转换成中缀表达式 是可以随意添加括号的  所以说 根据负负得正的原则 我们可以将负数转化成正数 比如 -1 -2 -3   1 2 3   可以是1 +2+3-(-1-2-3)</p><p>贪心：先选最大的数作为基数 如果没有减号那就是全部相加 如果有一个减号 那就把所有负数变成正的  如果没有负的就要减去最小的正数   所以一开始直接减去最小的那个数 然后把1~n+m-1的数全部按绝对值加起来就可以</p><p>如果有多个减号  通过加括号 可以变成跟一个减号一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">300010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m + <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n + m + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = nums[n + m];<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        res -= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1248-灵能传输-AcWing题库"><a href="#1248-灵能传输-AcWing题库" class="headerlink" title="1248. 灵能传输 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1250/">1248. 灵能传输 - AcWing题库</a></h2><ul><li>3&#x2F;4</li></ul><p>太困难了 最后还是没看懂题解 但是学到了：</p><p>每次中间的给两边的能量 求最小的最大值  每次传输完能量后前缀和会由 s[i - 1] s[i] s[i + 1]变成s[i] s[i - 1] s[i + 1] 这就说明了所有的前缀和都可以任意排序 当顺序排序的时候差值最小 最大值就最小</p><h2 id="1246-等差数列-AcWing题库"><a href="#1246-等差数列-AcWing题库" class="headerlink" title="1246. 等差数列 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1248/">1246. 等差数列 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>gcd 求最大公约数 背住gcd公式就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-type">int</span> d = nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        d = <span class="hljs-built_in">gcd</span>(d, nums[i] - nums[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!d)cout&lt;&lt;n;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;(nums[n - <span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]) / d + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1295-X的因子链-AcWing题库"><a href="#1295-X的因子链-AcWing题库" class="headerlink" title="1295. X的因子链 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1297/">1295. X的因子链 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>几个数论中很重要的内容 </p><p>首先是欧拉筛（线性筛）模板要背下来 <a href="https://www.zhihu.com/column/c_1182444932760125440">算法学习笔记 - 知乎 (zhihu.com)</a>可以看pecco的讲解</p><p>然后是公理  任意的数都可以被表示成质数的积的形式 $N&#x3D;P_1^{a_1}<em>P_2^{a_2}</em>…P_n^{a_n}$其中p是质数  </p><p>补充：（所有约数的和为 $sum&#x3D;(1+p_1+p_1^{2}…+p_1^{a_1})*(1+p_2+p_2^{2}…+p_2^{a_2})…(1+p_n+p_n^{2}…+p_n^{a_n})$）</p><p>因此我们可以用线性筛求出质因数 然后再算出每个质数的次数  其中$total&#x3D;\sum_ia_i$就是最长的链（可以全部都乘上去） </p><p>最长链的条数是 排列问题 比如2 2 2 5 5 7 7 7 不同的排列方式 就是$\frac{total!}{a_1!*a_2!…a_i!}$</p><p>细节问题 primes这个数组 第一位不用 直接primes[1] &#x3D; 2 而不用primes[0]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">min_t</span>[N],primes[N];<br><span class="hljs-type">bool</span> in_primes[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!in_primes[i])<br>            &#123;<br>                primes[cnt++] = i;<br>                <span class="hljs-type">min_t</span>[i] = i;<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i * primes[j] &lt;= N; j++)<br>        &#123;<br>            in_primes[primes[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">min_t</span>[i * primes[j]] = primes[j];<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">get_primes</span>();<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF)<br>    &#123;<br>        <br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> p = <span class="hljs-type">min_t</span>[x];<br>            a[k] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % p == <span class="hljs-number">0</span>)<br>            &#123;<br>                <br>                a[k]++;<br>                total++;<br>                x /= p;<br>            &#125;<br>            k++;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= total; i++)res *= i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= a[i]; j++)<br>                res /= j;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %lld\n&quot;</span>, total, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1296-聪明的燕姿-AcWing题库"><a href="#1296-聪明的燕姿-AcWing题库" class="headerlink" title="1296. 聪明的燕姿 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1298/">1296. 聪明的燕姿 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>数学结论在上面 </p><p>主要是 直接枚举会超时</p><p>这个时候我们就可以观察我们的约数和的公式<br>S &#x3D; (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)</p><p>假设这个时候有一个约数和S满足(1+2)(1+2+2^2)(1+2+2^2+…+2^k)<br>3x5x9x17x33x65x129 &#x3D; 635037975 就已经接近1e9的量级了，可见符合条件的项不会很多</p><p>那么这个时候我们就可以用dfs进行搜索，看我们能不能得到符合条件的(1+pk+pk^2+…+pk^ak)能够使得<br>S能够整除，即S % (1+pk+pk^2+…+pk^ak) &#x3D;&#x3D; 0<br>然后S &#x2F;&#x3D; (1+pk+pk^2+…+pk^ak),再dfs到下一层</p><p>应该先从小到大枚举P</p><p>for(p : 2,3,5,7,…)<br>    for(a : 1,2,3,…)<br>        if(S mod (1+p1+p1^2+…+p1^a1) &#x3D;&#x3D; 0)<br>            dfs(下一层)<br>这个时候我们还需要继续思考特殊情况</p><p>如果ai &#x3D; 1的话，S &#x3D; (1+Pi)的时候，因为Pi为质数，那么S-1也一定为质数，那么这个时候只需要判断S-1是否为质数即可</p><p>又S只会有两种情况，就是一种情况包括一个因子里面有(1+Pi)，另一种情况不包括(1+Pi)<br>S &#x3D; (1+Pi)(1+Pj+Pj^2…..)<br>S &#x3D; (1+Pi+Pi^2)(1+…..)</p><p>但是这两种情况都可以看出来Pi ^2 &lt;&#x3D; S<br>所以我们dfs枚举Pi的上限就是S<br>所以dfs应该设置成三个参数dfs(last,product,S)</p><p>1.last参数<br>表示上一个枚举的质数是谁，我们这样枚举的目的就是先把前面符合条件的质数枚举完了再枚举后面的质数，这样不会带来重复，降低了时间复杂度</p><p>比如质数为P &#x3D; 2,3,5,7….</p><p>如果枚举2之后再dfs到下一层，那么这个时候就应该再从3开始进行枚举而不是再从头开始枚举</p><p>2.product参数<br>product表示 S &#x3D; (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)中</p><p>当前进行到哪一个括号里面的最高次项Pi^ai的乘积和<br>比如S &#x3D; (1+2+2^2)(1+3+3^2+3^3)(1+….)<br>则dfs到第三层的时候product &#x3D; 2^2<em>3^3 (product : 1 – &gt; 2^2 – &gt; 2^2</em>3^3)</p><p>又由算术基本定理可知<br>一个数N &#x3D; P1^a1 * P2^a2 * … * Pn^an</p><p>product &#x3D; P1^a1 * P2^a2*…..</p><p>如果product要从第一层(一开始product初始化为1)进到第二层，此时product(2) &#x3D; product(1) * P1^a1<br>S &#x3D; S’ &#x2F; (1+p1+p1^2+…+p1^a1)</p><p>然后再dfs(last,product(2),S) &#x3D;&#x3D;(等价于) dfs(last , product(1)*P1^a1 , S’&#x2F;(1+p1+p1^2+…+p1^a1))</p><p>3.S参数<br>从上面的分析可知S参数就代表着从一开始的S除以(1+pk+pk^2+…+pk^ak)后剩余的乘积</p><p>所以每一层我们都应当判断S-1是否为质数，如果S-1是质数的话,也需要记录，但是不需要返回上一层继续往下搜即可<br>就比如24<br>24 &#x3D; (1+23)<br>&#x3D; (1+2)(1+7)<br>&#x3D; (1+3)(1+5)<br>第一层的时候判断23是质数，所以记录res[len++] &#x3D; 1*23<br>同时也需要继续往下做然后依次判断2、7 或者3、5能不能满足条件<br>只要有S-1为质数，说明就有满足条件的数，这个时候就需要记录结果<br>为什么S-1一定要大于上一层的质数？<br>因为我们要保证质数是从小到大枚举的，只有剩下的S-1是大于上一层的质数的时候，(1+S)才有可能成为最初的那个S的一个因子</p><p>因为我们要表示S’ &#x3D; (1+ 2 + 2^2+…)(1 + 3 + 3^2 + …)…(1+S)<br>越往后枚举对应的那个Pi也越大，所以S-1一定要大于上一层的质数才能满足条件</p><p>S &#x3D;&#x3D; 1对应的是什么情况？<br>S &#x3D;&#x3D; 1对应的就是S’只由一个括号即只有一个P,S’ &#x3D; (1+p+p^2+…+p^k)组成的情况<br>比如 7 &#x3D; (1 + 2 + 2^2) —–&gt;对应4<br>13 &#x3D; (1 + 3 + 3^2) —–&gt;对应9<br>15 &#x3D; (1 + 2 + 2^2 + 2^3) —–&gt;对应8<br>这种情况表明，我从p &#x3D; primes[i]开始枚举，一个p得到的序列和就把一开始的S’给整除了或者说这个序列和与S’相等，即此时的p得到的序列和(1+p+p^2+…+p^k) &#x3D;&#x3D; S’</p><p>所以此时S’ &#x2F; (1+p+p^2+…) &#x3D;&#x3D; 1<br>dfs到下一层直接就是dfs(last,p^k,1)<br>那么dfs到下一层S &#x3D;&#x3D; 1的时候,product &#x3D; p^k就是对应我们要找的那个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50000</span>;<br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> s, res[N], len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>            primes[cnt++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i * primes[j] &lt;= N; j++)<br>        &#123;<br>            st[i * primes[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; N)<span class="hljs-keyword">return</span> !st[x];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; primes[i] &lt;= x / primes[i]; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x % primes[i] == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> last, <span class="hljs-type">int</span> product, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-number">1</span>)<br>    &#123;<br>        res[len++] = product;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (s - <span class="hljs-number">1</span> &gt; ((last &lt; <span class="hljs-number">0</span>)? <span class="hljs-number">0</span> :primes[last])&amp;&amp; <span class="hljs-built_in">is_prime</span>(s - <span class="hljs-number">1</span>))<br>        res[len++] = product * (s - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = last + <span class="hljs-number">1</span>; primes[i] &lt;= s / primes[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> p = primes[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> + p, t = p; j &lt;= s; t *= p, j += t)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s % j == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(i, product * t, s / j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">get_prime</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s) != EOF)<br>    &#123;<br>        len = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, s);<br>        cout&lt;&lt;len&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span> (len)<br>        &#123;<br>            <span class="hljs-built_in">sort</span>(res, res + len);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)cout&lt;&lt;res[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1299-五指山-AcWing题库"><a href="#1299-五指山-AcWing题库" class="headerlink" title="1299. 五指山 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1301/">1299. 五指山 - AcWing题库</a></h2><ul><li>3&#x2F;6</li></ul><p>扩展欧几里得 exgcd 返回值与gcd一样 是ab的最大公因数 可以求解ax+by&#x3D;m是否有解 求ax+by&#x3D;m的一组解 通解 最小整数解 (线性同余方程) 求逆元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= (a / b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过扩展欧几里得求出来 x y   首先判断ax+by&#x3D;m是否有解 </p><p>此时引入裴蜀定理:设a,b为正整数，则关于x,y的方程 ax+by&#x3D;m有整数解当且仅当m是 gcd(a,b) 的倍数。即m%gcd&#x3D;&#x3D;0</p><p> 判断有解后 开始求解  ax+by&#x3D;m的x 和 y是其中一组特解 将x，y扩大$\frac{m}{gcd}$ 倍后得到$x_0\ y_0$ 通解就是 </p><p>$x_k&#x3D;x_0+k*\frac{b}{gcd(a,b)}$</p><p> $y_k&#x3D;y_0-k*\frac{a}{gcd(a,b)}$</p><p>得到通解之后就可以求最小正整数解了</p><p>$y_{min}&#x3D;y_0$%$ \frac{a}{gcd}$</p><p>$a_1&#x3D;\frac{a}{gcd}$当有负数的时候要写成(y%a1+a1) % a1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= (a / b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        ll n, d, x, y, a, b;<br>        cin&gt;&gt;n&gt;&gt;d&gt;&gt;x&gt;&gt;y;<br>        <br>        ll gcd = <span class="hljs-built_in">exgcd</span>(n, d, a, b);<br>        <span class="hljs-keyword">if</span> ((y - x) % gcd)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Impossible&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            b *= (y - x) / gcd;<br>            n /= gcd;<br>            cout&lt;&lt;(b%n+n)%n&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xmuoj-寻找蒙德大陆最宝贵的宝藏"><a href="#xmuoj-寻找蒙德大陆最宝贵的宝藏" class="headerlink" title="xmuoj | 寻找蒙德大陆最宝贵的宝藏"></a><a href="https://www.xmuoj.com/contest/215/problem/1">xmuoj | 寻找蒙德大陆最宝贵的宝藏</a></h2><ul><li>3&#x2F;6</li></ul><p>贪心+记录下标 上机的时候一直调不出来 下标还有格式错了（哭、</p><p>规定下标从1到n</p><p>贪心思路 用sum记录当前的和 如果当前和大于maxn的话就令maxn &#x3D; sum同时ed&#x3D;i  注意此时st &#x3D; record   因为如果sum一直大于0的话 record是不会变的 只有当sum 小于0的时候record才会变成i+1（表示起点在当前点的下一个）所以没有影响 st不变  只有当刚开始 或者sum 小于0 才会使st变化</p><p>sum小于0的时候可以直接不选 让sum变成0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= T; p++)<br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100002</span>];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>&#125;<br><span class="hljs-type">int</span> maxn = <span class="hljs-number">-1001</span>, sum = <span class="hljs-number">0</span>, record = <span class="hljs-number">1</span>, st, ed;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>sum += a[i];<br><span class="hljs-keyword">if</span> (sum &gt; maxn) &#123;<br>st = record;<br>maxn = sum;<br>ed = i;<br>&#125;<br><span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>record = i + <span class="hljs-number">1</span>;<br>sum = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>, p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, maxn, st, ed);<br><span class="hljs-keyword">if</span> (p != T) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2575-找出字符串的可整除数组-力扣（LeetCode）"><a href="#2575-找出字符串的可整除数组-力扣（LeetCode）" class="headerlink" title="2575. 找出字符串的可整除数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">2575. 找出字符串的可整除数组 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;7</li></ul><p>(a + b) % mod &#x3D; a % mod + b % mod 不用把s具体值算出来 $10^5$位会爆 </p><p>但是可以算出来s是否能被mod整除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divisibilityArray</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> m)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ret</span>(n);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span>  s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            s = (s * <span class="hljs-number">10</span> + (word[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) % m;<br>            ret[i] = s==<span class="hljs-number">0</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1223-最大比例-AcWing题库"><a href="#1223-最大比例-AcWing题库" class="headerlink" title="1223. 最大比例 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1225/">1223. 最大比例 - AcWing题库</a></h2><ul><li>3&#x2F;7</li></ul><p>更相减损术</p><img src="../images/$%7Bfiilename%7D/image-20240307193114575.png" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll nums[N], a[N], b[N], cnt;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b, a % b): a;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd_sub</span><span class="hljs-params">(ll a, ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b)<span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd_sub</span>(b, a / b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] != nums[i])<br>        &#123;<br>            ll d = <span class="hljs-built_in">gcd</span>(nums[i], nums[<span class="hljs-number">0</span>]);<br>            a[cnt] = nums[i] / d;<br>            b[cnt] = nums[<span class="hljs-number">0</span>] / d;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    ll up = a[<span class="hljs-number">0</span>], down = b[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt; i++)<br>    &#123;<br>        up = <span class="hljs-built_in">gcd_sub</span>(a[i], up);<br>        down = <span class="hljs-built_in">gcd_sub</span>(b[i], down);<br>    &#125;<br>    cout&lt;&lt;up&lt;&lt;<span class="hljs-string">&quot;/&quot;</span>&lt;&lt;down&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-B-Codeforces"><a href="#Problem-B-Codeforces" class="headerlink" title="Problem - B - Codeforces"></a><a href="https://codeforces.com/contest/1941/problem/B">Problem - B - Codeforces</a></h2><ul><li>3&#x2F;12</li></ul><p>每次第i位减2 i - 1和i + 1位减1</p><p>可以发现减的顺序不影响答案 因此直接从前往后贪心地写 每次都先让前面的数为0 尽可能多的造出0 </p><p>当i - 1为0的时候 要让i 和i + 1减去i - 1的值 当有负数说明不可能全减为0 可以返回false 否则到最后还需要再检查一遍倒数前三个是否都为0 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        nums[i] -= (<span class="hljs-number">2</span> * nums[i - <span class="hljs-number">1</span>]);<br>        nums[i + <span class="hljs-number">1</span>] -= nums[i - <span class="hljs-number">1</span>];<br>        nums[i - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> || nums[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; nums[n - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span> &amp;&amp; nums[n - <span class="hljs-number">3</span>] == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="100249-替换字符串中的问号使分数最小-力扣（LeetCode）"><a href="#100249-替换字符串中的问号使分数最小-力扣（LeetCode）" class="headerlink" title="100249. 替换字符串中的问号使分数最小 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/replace-question-marks-in-string-to-minimize-its-value/">100249. 替换字符串中的问号使分数最小 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;18</li></ul><p>最终的分数为 比如 a…a…a 那么分数就为 0 + 1 + 2 不论a在哪里 a一定能为答案提供c * (c + 1) &#x2F; 2的分数</p><p>那么最终的分数 就只与字母出现的绝对次数有关 那就用堆 不断选择出现次数最少的字母  如果次数一样就选择字典序小的 然后再对选出来的 字母进行排序 填入？中 这样就可以保证字典序一定是最小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*只与字母最终出现的绝对次数有关*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minimizeStringValue</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> mp[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-string">&#x27;?&#x27;</span>)<br>            mp[x - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">else</span> cnt++;<br>        &#125;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt;q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;mp[i], i&#125;);<br>        &#125;<br>        vector&lt;<span class="hljs-type">char</span>&gt;c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>            c.<span class="hljs-built_in">push_back</span>(t.second + <span class="hljs-string">&#x27;a&#x27;</span>);<br>            q.<span class="hljs-built_in">pop</span>();<br>            q.<span class="hljs-built_in">push</span>(&#123;t.first + <span class="hljs-number">1</span>, t.second&#125;);<br>        &#125;<br>        string ret = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: s)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-string">&#x27;?&#x27;</span>)<br>            ret += x;<br>            <span class="hljs-keyword">else</span> <br>            ret += c[i++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1793-好子数组的最大分数-力扣（LeetCode）"><a href="#1793-好子数组的最大分数-力扣（LeetCode）" class="headerlink" title="1793. 好子数组的最大分数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/">1793. 好子数组的最大分数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;19</li></ul><img src="../images/$%7Bfiilename%7D/image-20240331114451084.png" alt="image-20240331114451084" style="zoom:25%;" /><p>贪心&#x2F;双指针</p><p>由于这个题目要求包含k  所以可以 用双指针 以k为中心向两边扩展 关键在于最小值怎么更新：让nums[k]逐渐减小 然后每次左右扩展到比nums[k]大 这样就可以保证每次扩展的最小值</p><p>因为i &#x3D; nums[k] 每次减小1 都是整数 所以左右两边的数 要么大于i 要么等于i 等于i就可以更新进去 并且每次更新完之后最小值就是i （比i小的进不来区间）而最大数是2e4 O(n)不会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = k, r = k;<br>        <span class="hljs-type">int</span> res = nums[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums[k]; i &gt; <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (r &lt; n &amp;&amp; nums[r] &gt;= i)<br>            &#123;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[l] &gt;= i)<br>            &#123;<br>                l--;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, (r - l - <span class="hljs-number">1</span>)*i);<br>            <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span> &amp;&amp; r == n)<span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以使用贪心的做法 以k为中心 优先向较大的一边进行更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = k, r = k;<br>        <span class="hljs-type">int</span> res = nums[k];<br>        <span class="hljs-type">int</span> minn = nums[k];<br>        <span class="hljs-keyword">while</span> (l &gt; <span class="hljs-number">0</span> || r &lt; n - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>)minn = <span class="hljs-built_in">min</span>(minn, nums[++r]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r == n - <span class="hljs-number">1</span>)minn = <span class="hljs-built_in">min</span>(minn, nums[--l]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[l - <span class="hljs-number">1</span>] &gt; nums[r + <span class="hljs-number">1</span>])minn = <span class="hljs-built_in">min</span>(minn, nums[--l]);<br>                <span class="hljs-keyword">else</span> minn = <span class="hljs-built_in">min</span>(minn, nums[++r]);<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, minn * (r - l + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="0数组分割-蓝桥云课-lanqiao-cn"><a href="#0数组分割-蓝桥云课-lanqiao-cn" class="headerlink" title="0数组分割 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3535/learning/">0数组分割 - 蓝桥云课 (lanqiao.cn)</a></h2><p>3&#x2F;18</p><p>数组分成两边 两边都是偶数  取一边为s1 另一边就是sum - s1</p><p>那么就需要sum为偶数  如果sum为奇数的话 那么绝对不可能分成两个偶数 就是0</p><p>我们可以数奇数的个数  奇数的个数如果为奇数  那说明sum为奇数</p><p>奇数的个数如果为0（全是偶数 ）那就随便组合 有2^n种</p><p>奇数的个数为偶数的时候 一边必须包含<strong>偶数个奇数</strong>相当于把两个奇数合成了一个偶数所以相当于少了一个数   所以就是 $2^{n-1}$</p><p>要边乘边mod</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        res = res * <span class="hljs-number">2</span> %mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, odd = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span>)odd++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (odd == <span class="hljs-number">0</span>)cout&lt;&lt;<span class="hljs-built_in">cal</span>(n)&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span> (odd % <span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">cal</span>(n - <span class="hljs-number">1</span>)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0矩形总面积-蓝桥云课-lanqiao-cn"><a href="#0矩形总面积-蓝桥云课-lanqiao-cn" class="headerlink" title="0矩形总面积 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3536/learning/">0矩形总面积 - 蓝桥云课 (lanqiao.cn)</a></h2><ul><li>3&#x2F;19</li></ul><p>要记得开ll 数组也要开  不然直接乘的时候会爆</p><img src="../images/$%7Bfiilename%7D/uid2314845-20231022-1697949902971.png" alt="图片描述" style="zoom:25%;" /><p>多画点图 就可以看出来 情况其实不多</p><p>没有交集的时候 就是左上角小于右下角的时候 由于两个都可能在下面 所以要做两个判断</p><p>剩下的就是有交集的时候</p><p>那么有交集必定是有至少一个角在另一个里面 就是上面四种情况（加上包含）所以可以排序 排完序之后 交集就是(x2-x1) * (y2-y1)</p><p>但是其实不用排序也可以 因为这个交集的小矩形的边长就是min(x2, x4) - max(x1,x3)  y同理 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll x[<span class="hljs-number">4</span>], y[<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        cin&gt;&gt;x[i]&gt;&gt;y[i];<br>    &#125;<br>    ll a = <span class="hljs-built_in">abs</span>(x[<span class="hljs-number">1</span>] - x[<span class="hljs-number">0</span>]) * <span class="hljs-built_in">abs</span>(y[<span class="hljs-number">1</span>] - y[<span class="hljs-number">0</span>]);<br>    ll b = <span class="hljs-built_in">abs</span>(x[<span class="hljs-number">3</span>] - x[<span class="hljs-number">2</span>]) * <span class="hljs-built_in">abs</span>(y[<span class="hljs-number">3</span>] - y[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] &gt; x[<span class="hljs-number">3</span>] || x[<span class="hljs-number">1</span>] &lt; x[<span class="hljs-number">2</span>] || y[<span class="hljs-number">0</span>] &gt; y[<span class="hljs-number">3</span>] || y[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">2</span>])<br>    &#123;<br>        cout&lt;&lt;a + b;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ll c = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">max</span>(x[<span class="hljs-number">0</span>], x[<span class="hljs-number">2</span>]) - <span class="hljs-built_in">min</span>(x[<span class="hljs-number">1</span>], x[<span class="hljs-number">3</span>]));<br>        ll d = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">max</span>(y[<span class="hljs-number">0</span>], y[<span class="hljs-number">2</span>]) - <span class="hljs-built_in">min</span>(y[<span class="hljs-number">1</span>], y[<span class="hljs-number">3</span>]));<br>        ll ans = c * d;<br>        ll n = a + b - ans;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1969-数组元素的最小非零乘积-力扣（LeetCode）"><a href="#1969-数组元素的最小非零乘积-力扣（LeetCode）" class="headerlink" title="1969. 数组元素的最小非零乘积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/">1969. 数组元素的最小非零乘积 - 力扣（LeetCode）</a></h2><ul><li>3.20</li></ul><img src="../images/$%7Bfiilename%7D/image-20240320090945094.png" alt="image-20240320090945094" style="zoom:25%;" /><p>位运算+快速幂</p><p>两个数的位交换 两两之间差距越大 乘积就越小 所以要尽量扩大差距  最后换出来 应该是$2^{n-1}-1$个1 $2^{n-1}-1$个$2^n-2$还有一个$2^n-1$最后的公式为$(2^{n}-1)*(2^{n}-2)^{2^{n-1}-1}$</p><p>由于数太大 需要用快速幂来求</p><p>快速幂:<a href="https://leetcode.cn/problems/powx-n/description/">50. Pow(x, n) - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0.0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-type">long</span> b = n;<br>        <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            x = <span class="hljs-number">1</span>/x;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (b)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)res *= x;<br>            x *= x;<br>            b &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-function">ll <span class="hljs-title">mpow</span><span class="hljs-params">(ll x, ll p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x %= mod;<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>)ans = ans * x % mod;<br>            x = x * x % mod;<br>            p &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNonZeroProduct</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll k = (<span class="hljs-number">1LL</span> &lt;&lt; p) - <span class="hljs-number">1</span>;<br>        ll n = (<span class="hljs-number">1LL</span> &lt;&lt; (p<span class="hljs-number">-1</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>  k % mod * <span class="hljs-built_in">mpow</span>(k - <span class="hljs-number">1</span>, n) % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="100245-每个字符最多出现两次的最长子字符串-力扣（LeetCode）"><a href="#100245-每个字符最多出现两次的最长子字符串-力扣（LeetCode）" class="headerlink" title="100245. 每个字符最多出现两次的最长子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/submissions/515848010/">100245. 每个字符最多出现两次的最长子字符串 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;24</li></ul><img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-25%20075414.png" style="zoom:25%;" /><p>滑动窗口  右移的同时观察当有三个相同字符的时候就开始收缩窗口（滑动左指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLengthSubstring</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;mp;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            mp[s[i]]++;<br>            <br>            <span class="hljs-keyword">while</span> (mp[s[i]] == <span class="hljs-number">3</span>)<br>            &#123;<br>                mp[s[j++]]--;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="100228-执行操作使数据元素之和大于等于-K-力扣（LeetCode）"><a href="#100228-执行操作使数据元素之和大于等于-K-力扣（LeetCode）" class="headerlink" title="100228. 执行操作使数据元素之和大于等于 K - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/submissions/515851624/">100228. 执行操作使数据元素之和大于等于 K - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;24</li></ul><img src="../images/$%7Bfiilename%7D/image-20240325075911567.png" alt="image-20240325075911567" style="zoom:25%;" /><p>数学题 找规律推公式 对数组中的数+1和复制数组中的数 要求最小操作数的话 根据贪心的策略 当然是先加再复制 收益更大 因为加每次只能加1 复制一次可以加很多</p><p>先加再复制的话 就枚举加的次数 复制的次数就是( target &#x2F; 当前值)上取整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(k); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> now = <span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)k / i) + i - <span class="hljs-number">2</span>;<br>            ans = <span class="hljs-built_in">min</span>(now,ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>3&#x2F;28 3&#x2F;29</li></ul><h2 id="Problem-D-Codeforces-2"><a href="#Problem-D-Codeforces-2" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1950/problem/D">Problem - D - Codeforces</a></h2><p>div4D 由于数据范围是1e5 所以最多就是六位的“类”二进制数 可以先预处理出二进制数 直接打表</p><p>接下来就是连续除 最后看能不能整除  由于循环的基数比较小 只有64 所以时间复杂度很小</p><p>明明不难 比赛的时候调了半天  没看清题意 以为是一个数的倍数(哭)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> nums[<span class="hljs-number">1000</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1010</span>, <span class="hljs-number">1011</span>, <span class="hljs-number">1100</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">1110</span>, <span class="hljs-number">1111</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10001</span>, <span class="hljs-number">10010</span>, <span class="hljs-number">10011</span>, <span class="hljs-number">10100</span>, <span class="hljs-number">10101</span>, <span class="hljs-number">10110</span>, <span class="hljs-number">10111</span>, <span class="hljs-number">11000</span>, <span class="hljs-number">11001</span>, <span class="hljs-number">11010</span>, <span class="hljs-number">11011</span>, <span class="hljs-number">11100</span>, <span class="hljs-number">11101</span>, <span class="hljs-number">11110</span>, <span class="hljs-number">11111</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100001</span>, <span class="hljs-number">100010</span>, <span class="hljs-number">100011</span>, <span class="hljs-number">100100</span>, <span class="hljs-number">100101</span>, <span class="hljs-number">100110</span>, <span class="hljs-number">100111</span>, <span class="hljs-number">101000</span>, <span class="hljs-number">101001</span>, <span class="hljs-number">101010</span>, <span class="hljs-number">101011</span>, <span class="hljs-number">101100</span>, <span class="hljs-number">101101</span>, <span class="hljs-number">101110</span>, <span class="hljs-number">101111</span>, <span class="hljs-number">110000</span>, <span class="hljs-number">110001</span>, <span class="hljs-number">110010</span>, <span class="hljs-number">110011</span>, <span class="hljs-number">110100</span>, <span class="hljs-number">110101</span>, <span class="hljs-number">110110</span>, <span class="hljs-number">110111</span>, <span class="hljs-number">111000</span>, <span class="hljs-number">111001</span>, <span class="hljs-number">111010</span>, <span class="hljs-number">111011</span>, <span class="hljs-number">111100</span>, <span class="hljs-number">111101</span>, <span class="hljs-number">111110</span>, <span class="hljs-number">111111</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == n)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (n % nums[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-E-Codeforces-1"><a href="#Problem-E-Codeforces-1" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1950/problem/E">Problem - E - Codeforces</a></h2><p>div4E…调了2个小时都没调出来 </p><p>首先枚举长度 要判断是否可以分成整份 也就是求因子</p><p>然后枚举每一个长len的数组 作为基准数组 去和其他所有长len的数组比较 只要有一个符合就可以</p><p>主要是错在这一步 没有调出来。。写cf老是觉得会超时 时间复杂度太高 但是这里完全可以直接枚举所有的 我当时是准备找到第一个不相等的 将这个数组作为基准 也去做一遍比较 如果这两个都不行 那么这个长度就不符合 因为这两个不符合就说明至少有三个不一样的</p><p>其实思路没问题 关键是合在一个循环里面太乱了 要是当时能写两个循环 说不定都过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; s;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n % len != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; i &lt;= len; i += len)<br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (s[j] != s[i + j % len])<br>                    cnt++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= <span class="hljs-number">1</span>)<br>            &#123;<br>                cout &lt;&lt; len &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Problem-F-Codeforces"><a href="#Problem-F-Codeforces" class="headerlink" title="Problem - F - Codeforces"></a><a href="https://codeforces.com/contest/1950/problem/F">Problem - F - Codeforces</a></h2><p>树形 但是数学题 </p><p>首先 要判断合不合格 由于0个结点的 上面可以接无限个1个结点的 所以重点是0 2结点</p><p>2个结点的 一定要比0个结点的少一个（二叉树的规律）</p><p>当2个结点的个数为0 那高度就是1个节点的个数 （下面接0）</p><p>当三个结点加起来为1的时候高度就是0</p><p>接下来就是考虑度为1 的结点的位置  尽量减少树的高度（因为度为2和0的结点位置固定）</p><img src="../images/$%7Bfiilename%7D/image-20240329210439572.png" alt="image-20240329210439572" style="zoom:25%;" /><p>这张图是已经放上了全部 度为2的结点 其中rem 可能是度为1 或0  优先放在rem处可减小高度</p><p>rem放不下就一排排往下放 一排放满再放下一排  </p><p>主要就是用到log函数求当前的层</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x2, x1, x0;<br>    cin &gt;&gt; x2 &gt;&gt; x1 &gt;&gt; x0;<br><br>    <span class="hljs-keyword">if</span> (x2 + <span class="hljs-number">1</span> != x0)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x2 + x1 + x0 == <span class="hljs-number">1</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; x1 &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(x2 + <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> rem = (<span class="hljs-number">1</span> &lt;&lt; d) - x2 - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x1 &lt;= rem)<br>    &#123;<br>        cout &lt;&lt; d &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    x1 -= rem;<br>    <span class="hljs-type">int</span> c = (x2 - (<span class="hljs-number">1</span> &lt;&lt; (d - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> + rem;<br>    <span class="hljs-type">int</span> add = <span class="hljs-built_in">ceil</span>(x1 * <span class="hljs-number">1.0</span> / c);<br>    cout &lt;&lt; add + d &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2952-需要添加的硬币的最小数量-力扣（LeetCode）"><a href="#2952-需要添加的硬币的最小数量-力扣（LeetCode）" class="headerlink" title="2952. 需要添加的硬币的最小数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/">2952. 需要添加的硬币的最小数量 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;30</li></ul><img src="../images/$%7Bfiilename%7D/image-20240330214051238.png" alt="image-20240330214051238" style="zoom:25%;" /><p>贪心的做法 要得到1~target的所有数</p><p>要得到1 2 必须有1  2 然后通过1 2 可以合成3</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">添加/最大<br>1   / 1<br>2   / 3<br>4   / 7<br>8   / 15<br></code></pre></td></tr></table></figure><p>贪心主要体现在 每次加上当前可以加的最大值 比如1 2 4数组 应该加上8 可以达到最大值15 如果加9的话 8就凑不出来 因此最大是8</p><p>对coins排序</p><p>设s为当前最大值 s如果比coins小的话 说明当前能凑到的最大值 距离下一次增加中间还有空挡 需要添加硬币（也就是加当前最大值） 否则就直接加上coins[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumAddedCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(coins.<span class="hljs-built_in">begin</span>(), coins.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (s &lt;= target)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; coins[i] &lt;= s)<br>            &#123;<br>                s += coins[i++];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ans ++;<br>                s *= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="1236-递增三元组-AcWing题库"><a href="#1236-递增三元组-AcWing题库" class="headerlink" title="1236. 递增三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></h2><ul><li>3&#x2F;1</li></ul><p>找这个三元组 主要是看中间一行 比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>就看B的5能和A结合几个 能和C结合几个</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">4</span> <br><span class="hljs-attribute">5</span> <br>  <span class="hljs-attribute">6</span> <span class="hljs-number">7</span>  <br></code></pre></td></tr></table></figure><p>结果为2 * 2 &#x3D; 4  </p><p>所以只需要对B的每一个数在A   C两个数组内进行二分 求出比他小的第一个数 和比他大的第一个数即可</p><p>然后注意一些下标的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums[i], nums[i] + n);<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> key = nums[<span class="hljs-number">1</span>][i];<br>        <span class="hljs-type">int</span> pos1 = <span class="hljs-built_in">lower_bound</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">0</span>] + n, key) - nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 在A中找到第一个小于key的数</span><br>        <span class="hljs-type">int</span> pos2 = <span class="hljs-built_in">upper_bound</span>(nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">2</span>] + n, key) - nums[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在C中找到第一个大于key的数</span><br>        <br>        res += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(n - pos2 + <span class="hljs-number">1</span>) * pos1;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-E-Codeforces-2"><a href="#Problem-E-Codeforces-2" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1933/problem/E">Problem - E - Codeforces</a></h2><ul><li>3&#x2F;1</li></ul><p>二分前缀和</p><p>首先预处理 求前缀和 二分前缀和 二分是前缀和 和u比较 </p><p>和以前的二分不一样的 最终结果不能直接输出 而是需要和ans - 1比较</p><p>因为可能超出 导致减少   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], qzh[N];<br><span class="hljs-type">int</span> l, u, le;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        cin &gt;&gt; l &gt;&gt; u;<br>        <span class="hljs-type">int</span> le = l;<br>        <span class="hljs-type">int</span> r = n;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k = qzh[mid] - qzh[le - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span> (k &gt;= u)<br>                r = mid;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> f = [&amp;](ll len, ll a1)<br>        &#123;<br>            ll an = a1 - len + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (a1 + an) * len / <span class="hljs-number">2</span>;<br>        &#125;;<br>        <span class="hljs-keyword">if</span> (r - <span class="hljs-number">1</span> &gt;= le &amp;&amp; <span class="hljs-built_in">f</span>(qzh[r - <span class="hljs-number">1</span>] - qzh[le - <span class="hljs-number">1</span>], u) &gt;= <span class="hljs-built_in">f</span>(qzh[r] - qzh[le - <span class="hljs-number">1</span>], u))<br>            r--;<br>        cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4647-青蛙过河-AcWing题库"><a href="#4647-青蛙过河-AcWing题库" class="headerlink" title="4647. 青蛙过河 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4650/">4647. 青蛙过河 - AcWing题库</a></h2><ul><li>3&#x2F;14</li></ul><p>经典二分题 关键是check函数怎么写</p><p>可以发现 走过去和走过来是一样的 因此可以看作过去2x次</p><p>当跳跃一次能跳mid的时候  每个长度为mid的<strong>区间的和</strong>都需要大于2x</p><p>因为每个长为mid的区间都会被走到2x次 当有一个长为mid的区间少于2x的时候 就说明无法走过去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n, x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>ll nums[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - mid - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>       <span class="hljs-keyword">if</span> (s[i + mid - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>] &lt; x)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    x *= <span class="hljs-number">2</span>;<br>    s[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        s[i] = s[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>            r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;l&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><ul><li>3&#x2F;1</li></ul><p>除了二分也可以用前缀和  比如b中的5  可以求出a中所有比5小的数 这时候就可以用哈希表＋前缀和 哈希表记录1 2 3 4 出现的次数 然后加起来 就可以得到比5小的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], b[N], c[N], cnt1[N], cnt2[N], qzh1[N], qzh2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>        cnt1[++a[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;b[i];<br>        b[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;c[i];<br>        cnt2[++c[i]]++;<br>    &#125;<br>    qzh1[<span class="hljs-number">0</span>] = cnt1[<span class="hljs-number">0</span>];<br>    qzh2[<span class="hljs-number">0</span>] = cnt2[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        qzh1[i] = qzh1[i - <span class="hljs-number">1</span>] + cnt1[i];<br>        qzh2[i] = qzh2[i - <span class="hljs-number">1</span>] + cnt2[i];<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> k = b[i];<br>        ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(qzh2[N - <span class="hljs-number">1</span>] - qzh2[k]) * qzh1[k - <span class="hljs-number">1</span>];<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3070-元素和小于等于-k-的子矩阵的数目-力扣（LeetCode）"><a href="#3070-元素和小于等于-k-的子矩阵的数目-力扣（LeetCode）" class="headerlink" title="3070. 元素和小于等于 k 的子矩阵的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/submissions/506940450/">3070. 元素和小于等于 k 的子矩阵的数目 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;3</li></ul><p>二维前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubmatrices</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">qzh</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(cols, <span class="hljs-number">0</span>));<br>        <br>        qzh[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; cols; ++j) &#123;<br>            qzh[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + qzh[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; ++i) &#123;<br>            qzh[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + qzh[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; ++j) &#123;<br>                qzh[i][j] = grid[i][j] + qzh[i - <span class="hljs-number">1</span>][j] + qzh[i][j - <span class="hljs-number">1</span>] - qzh[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <br>        <br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (qzh[i][j] &lt;= k)cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4644-求和-AcWing题库⁤"><a href="#4644-求和-AcWing题库⁤" class="headerlink" title="4644. 求和 - AcWing题库⁤"></a><a href="https://www.acwing.com/problem/content/4647/">4644. 求和 - AcWing题库⁤</a></h2><ul><li>3&#x2F;14</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;ll&gt;<span class="hljs-built_in">nums</span>(n + <span class="hljs-number">10</span>);<br>    vector&lt;ll&gt;<span class="hljs-built_in">qzh</span>(n + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;n ;i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    qzh[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        res += nums[i] * (qzh[n - <span class="hljs-number">1</span>] - qzh[i]);<br>    &#125;<br>    cout&lt;&lt;res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2909-元素和最小的山形三元组-II-力扣（LeetCode）"><a href="#2909-元素和最小的山形三元组-II-力扣（LeetCode）" class="headerlink" title="2909. 元素和最小的山形三元组 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/submissions/518117391/">2909. 元素和最小的山形三元组 II - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;29</li></ul><img src="../images/$%7Bfiilename%7D/image-20240329200706728.png" alt="image-20240329200706728" style="zoom:25%;" /><ul><li>三重循环暴力</li><li>前后缀分解</li></ul><p>对于这种三个三个的 一般是枚举中间的值 然后看两边是否有小于他的数 </p><p>因此可以分别求出前缀和后缀的数组 数组的意义为：到i为止 前&#x2F;后 最小的数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">nums 8 6 1 5 3<br>pre  8 6 1 1 1  <br>suf  1 1 1 3 3 <br>枚举到第i位就看pre和suf  分别代表前面/后面是否有比他小的  选最小的<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">2e9</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">pre</span>(n), <span class="hljs-built_in">sub</span>(n);<br>        pre[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        sub[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            pre[i] = <span class="hljs-built_in">min</span>(pre[i - <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            sub[i] = <span class="hljs-built_in">min</span>(sub[i + <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (pre[i] &lt; nums[i] &amp;&amp; sub[i] &lt; nums[i])<br>            res = <span class="hljs-built_in">min</span>(res, nums[i] + pre[i] + sub[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res == <span class="hljs-number">2e9</span>?<span class="hljs-number">-1</span>:res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="2673-使二叉树所有路径值相等的最小代价-力扣（LeetCode）"><a href="#2673-使二叉树所有路径值相等的最小代价-力扣（LeetCode）" class="headerlink" title="2673. 使二叉树所有路径值相等的最小代价 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/">2673. 使二叉树所有路径值相等的最小代价 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;3</li></ul><img src="../images/$%7Bfiilename%7D/image-20240228173918182.png" alt="image-20240228173918182" style="zoom:25%;" /><p>最开始没读懂题目 后来发现中间节点也可以加 越上面的结点产生的效果越好 可以减小操作次数（原来用的BFS 会很麻烦</p><p>题目的二叉树是<strong>满二叉树</strong> 可以从兄弟节点两两一组来计算 兄弟节点 只需要加上两者的差 这样两个数就相等了 </p><p>又由于兄弟节点 从根节点到两兄弟的值是相同的 两者的差值就是 他们俩的子节点 因此可以从下往上计算  （每次把孩子结点更新为较大值 然后加到当前结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minIncrements</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 完全二叉树 倒数第二层即n / 2</span><br>        &#123;<br>            ans += <span class="hljs-built_in">abs</span>(cost[i * <span class="hljs-number">2</span>] - cost[i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]);<br>            cost[i - <span class="hljs-number">1</span>] += <span class="hljs-built_in">max</span>(cost[i * <span class="hljs-number">2</span>], cost[i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2368-受限条件下可到达节点的数目-力扣（LeetCode）"><a href="#2368-受限条件下可到达节点的数目-力扣（LeetCode）" class="headerlink" title="2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/">2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;4</li></ul><img src="../images/$%7Bfiilename%7D/image-20240331115003018.png" alt="image-20240331115003018" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reachableNodes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-type">int</span>&gt;&amp; restricted)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;g[n];<br>        vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">re</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: edges)<br>        &#123;<br>            g[x[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">1</span>]);<br>            g[x[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: restricted)<br>        &#123;<br>            re[x] = <span class="hljs-number">0</span>;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        re[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y: g[x])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (re[y])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                    re[y] = <span class="hljs-number">0</span>;<br>                    ans ++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1976-到达目的地的方案数-力扣（LeetCode）"><a href="#1976-到达目的地的方案数-力扣（LeetCode）" class="headerlink" title="1976. 到达目的地的方案数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/">1976. 到达目的地的方案数 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;4</li></ul><img src="../images/$%7Bfiilename%7D/image-20240305083325908.png" alt="image-20240305083325908" style="zoom:25%;" /><p>最短路+DP 首先要打出最短路的模板（ </p><p>然后就是分析DP  状态表示 f[i] 表示0<del>i的最短路径的数量  状态计算就是  x y  当从0到x 再从x到y 的路径比直接从0到y更短的时候 此时最短路就是0-x-y 那么0</del>y的最短路的数量就是0~x的最短路的数量（当前x-y只有一条）  如果路径长度相等的话  那说明 0-x-y 和 0-y都是最短路 那么从0-y的最短路数量就是两者相加 </p><p>最终返回0-n - 1的数量           f[0] &#x3D; 1  自己到自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; roads)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;<span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;r: roads)<br>        &#123;<br>            <span class="hljs-type">int</span> x = r[<span class="hljs-number">0</span>], y = r[<span class="hljs-number">1</span>], z = r[<span class="hljs-number">2</span>];<br>            g[x].<span class="hljs-built_in">emplace_back</span>(y, z);<br>            g[y].<span class="hljs-built_in">emplace_back</span>(x, z);<br>        &#125;<br><span class="hljs-comment">//用堆优化的dijkstra</span><br>        vector&lt;ll&gt;<span class="hljs-built_in">dis</span>(n, LLONG_MAX);<br>        priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt;q;<br>        vector&lt;ll&gt;<span class="hljs-built_in">f</span>(n);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [dx, x] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, d]: g[x])<br>            &#123;<br>                ll new_dis = dx + d;<br>                <span class="hljs-keyword">if</span> (new_dis &lt; dis[y])<br>                &#123;<br>                    dis[y] = new_dis;<br>                    f[y] = f[x];<br>                    q.<span class="hljs-built_in">emplace</span>(new_dis, y);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_dis == dis[y])<br>                &#123;<br>                    f[y] = (f[y] + f[x]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1261-在受污染的二叉树中查找元素-力扣（LeetCode）"><a href="#1261-在受污染的二叉树中查找元素-力扣（LeetCode）" class="headerlink" title="1261. 在受污染的二叉树中查找元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/submissions/511125292/">1261. 在受污染的二叉树中查找元素 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;12</li></ul><img src="../images/$%7Bfiilename%7D/image-20240313001702069.png" alt="image-20240313001702069" style="zoom:25%;" /><p>主要是检查的数据如何保存 </p><p>用一个全局的set来保存 方便后续查找 而不需要再写一个dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FindElements</span> &#123;<br><span class="hljs-keyword">public</span>:<br>set&lt;<span class="hljs-type">int</span>&gt;s;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode*root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root -&gt; left != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        root-&gt;left-&gt;val = root-&gt;val * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        s.<span class="hljs-built_in">insert</span>(root-&gt;left-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root -&gt; right != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        root-&gt;right-&gt;val = root-&gt;val * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        s.<span class="hljs-built_in">insert</span>(root-&gt;right-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;<br>    <span class="hljs-built_in">FindElements</span>(TreeNode* root) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> ;<br>        root-&gt;val = <span class="hljs-number">0</span>;<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">find</span>(target) != s.<span class="hljs-built_in">end</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your FindElements object will be instantiated and called as such:</span><br><span class="hljs-comment"> * FindElements* obj = new FindElements(root);</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;find(target);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="310-最小高度树-力扣（LeetCode）"><a href="#310-最小高度树-力扣（LeetCode）" class="headerlink" title="310. 最小高度树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;18</li></ul><p>拓扑排序解法：因为要选出一个根 使得整棵树的高度最小 那就可以反向思考 从度为1的结点（最外面的一圈）出发 进行拓扑排序 向内BFS寻找 每次消除一层  根节点到这一层的每个点的距离都是相同的  最后消掉的一层就是可以作为根节点的一层 </p><p>tips ：map可以用来做邻接表！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">degree</span>(n);<br>        map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;m;<br>        vector&lt;<span class="hljs-type">int</span>&gt;res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: edges)<br>        &#123;<br>            degree[x[<span class="hljs-number">0</span>]]++;<br>            degree[x[<span class="hljs-number">1</span>]]++;<br>            m[x[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">1</span>]);<br>            m[x[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">0</span>]);<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-comment">// 度为一的结点入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(degree[i] == <span class="hljs-number">1</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++)<br>            &#123;<br>                <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(t);<br>                degree[t]--;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j: m[t])<br>                &#123;<br>                    degree[j]--;<br>                    <span class="hljs-keyword">if</span>(degree[j] == <span class="hljs-number">1</span>)<br>                        q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2642-设计可以求最短路径的图类-力扣（LeetCode）"><a href="#2642-设计可以求最短路径的图类-力扣（LeetCode）" class="headerlink" title="2642. 设计可以求最短路径的图类 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/">2642. 设计可以求最短路径的图类 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;26</li></ul><p>堆优化的dijkstra算法 注意用最小堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;PII&gt;&gt; g;<br><br><span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> m, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges) <br>    &#123;<br>        n = m;<br>        g.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: edges)<br>        &#123;<br>            <span class="hljs-built_in">addEdge</span>(&#123;x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; edge)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        g[edge[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPath</span><span class="hljs-params">(<span class="hljs-type">int</span> node1, <span class="hljs-type">int</span> node2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n, <span class="hljs-number">0</span>), <span class="hljs-built_in">dis</span>(n, <span class="hljs-number">2e9</span>);<br><br>        dis[node1] = <span class="hljs-number">0</span>;<br>        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt;q;<br>        q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,node1&#125;);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [d, x] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (vis[x])<span class="hljs-keyword">continue</span>;<br>            vis[x] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w]: g[x])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (d + w &lt; dis[y])<br>                &#123;<br>                    dis[y] = d + w;<br>                    q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dis[node2] == <span class="hljs-number">2e9</span> ? <span class="hljs-number">-1</span>: dis[node2];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Graph object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Graph* obj = new Graph(n, edges);</span><br><span class="hljs-comment"> * obj-&gt;addEdge(edge);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;shortestPath(node1,node2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS&#x2F;DFS"></a>BFS&#x2F;DFS</h1><h2 id="1096-地牢大师-AcWing题库"><a href="#1096-地牢大师-AcWing题库" class="headerlink" title="1096. 地牢大师 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1098/">1096. 地牢大师 - AcWing题库</a></h2><ul><li>3&#x2F;4</li></ul><p>三维BFS 注意下标的对应关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> l, r, c;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">char</span> g[N][N][N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pos</span><br>&#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>&#125;;<br><span class="hljs-type">int</span> step[N][N][N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dz[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dx[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> si, <span class="hljs-type">int</span> sj, <span class="hljs-type">int</span> sk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    step[si][sj][sk] = <span class="hljs-number">1</span>;<br>    queue&lt;pos&gt;q;<br>    q.<span class="hljs-built_in">push</span>(&#123;si, sj, sk&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        pos t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> x = t.x, y = t.y, z = t.z;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; l &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; r &amp;&amp; nz &gt;= <span class="hljs-number">0</span> &amp;&amp; nz &lt; c &amp;&amp; g[nx][ny][nz] != <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; step[nx][ny][nz] == <span class="hljs-number">0</span>)<br>            &#123;<br>                step[nx][ny][nz] = step[x][y][z] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (g[nx][ny][nz] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">return</span> step[nx][ny][nz];<br>                q.<span class="hljs-built_in">push</span>(&#123;nx, ny, nz&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-keyword">if</span> (l == r &amp;&amp; r == c &amp;&amp; c == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">memset</span>(step, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(step));<br>        <span class="hljs-type">int</span> si, sj, sk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; c; k++)<br>                    &#123;<br>                        cin&gt;&gt;g[i][j][k];<br>                        <span class="hljs-keyword">if</span> (g[i][j][k] == <span class="hljs-string">&#x27;S&#x27;</span>)<br>                            si = i, sj = j, sk = k;<br>                    &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(si, sj, sk);<br>        <br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)cout&lt;&lt;<span class="hljs-string">&quot;Trapped!&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Escaped in %d minute(s).\n&quot;</span>, res - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1233-全球变暖-AcWing题库"><a href="#1233-全球变暖-AcWing题库" class="headerlink" title="1233. 全球变暖 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1235/">1233. 全球变暖 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>这题求的是 完全被淹没的岛屿的数量 可以先求所有的岛的数量 再求淹水后岛的数量 再相减</p><p>但是也可以直接求  如果一个岛屿被完全淹没了  说明他所有的陆地都与水相邻 <strong>在dfs中判断是否有一块陆地不与水相连</strong> 如果是 不会被淹 否则会</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> v[N][N];<br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> vis[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[x][y] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (g[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx = dx[i] + x, ny = dy[i] + y;<br>        <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !vis[nx][ny] &amp;&amp; g[nx][ny] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>        &#123;<br>            <br>            <span class="hljs-built_in">dfs</span>(nx, ny);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            cin&gt;&gt;g[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i][j] &amp;&amp; g[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    flag = <span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">dfs</span>(i, j);<br>                    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)ans ++;<br>                &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1207-大臣的旅费-AcWing题库-https-www-acwing-com-problem-content-description-1209"><a href="#1207-大臣的旅费-AcWing题库-https-www-acwing-com-problem-content-description-1209" class="headerlink" title="1207. 大臣的旅费 - AcWing题库](https://www.acwing.com/problem/content/description/1209/)"></a>1207. 大臣的旅费 - AcWing题库](<a href="https://www.acwing.com/problem/content/description/1209/">https://www.acwing.com/problem/content/description/1209/</a>)</h2><ul><li>3&#x2F;8</li></ul><p>求树的直径问题</p><p>要求相距最远的两个城市 也就是求树的直径 </p><p>先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径</p><p>用dis记录任意点到i点的最远距离</p><p>复习了存图的方法和树的dfs的方法  dfs中需要添加father 防止回头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ;<br><span class="hljs-type">int</span> w[N] , e[N] , ne[N] , h[N] , idx ;<br><span class="hljs-type">int</span> maxu , maxd ;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b , <span class="hljs-type">int</span> c )</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> fa , <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    dis[u] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i != <span class="hljs-number">-1</span> ; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j != fa)<br>            <span class="hljs-built_in">dfs</span>(j,u,d + w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a , b , c ;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxd * <span class="hljs-number">10</span> + (maxd + <span class="hljs-number">1ll</span>) * maxd / <span class="hljs-number">2</span> &lt;&lt; endl ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3067-在带权树网络中统计可连接服务器对数目-力扣（LeetCode）"><a href="#3067-在带权树网络中统计可连接服务器对数目-力扣（LeetCode）" class="headerlink" title="3067. 在带权树网络中统计可连接服务器对数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/">3067. 在带权树网络中统计可连接服务器对数目 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;2</li></ul><p>双周赛t3 枚举根DFS+乘法原理</p><p>由题意分析知道 要满足三个条件 </p><p>1不能用重复路径  那么枚举每一个根 如果两个数不在这个根的同一个子树上 那么就不会有重复路径</p><p>2 3  ac 和 bc路径和都能整除sig 这个可以在DFS的时候算出来</p><p>思路就是 枚举每个根的每条路径  dfs算路径和 如果能整除就加入ok数组中  最后把这个根的每条路径的ok数 两两相乘 即可得到答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countPairsOfConnectableServers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> sig)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        vector&lt;PII&gt;g[<span class="hljs-number">1010</span>];<br>        <span class="hljs-comment">// 图论题常用的记录方式</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: edges)<br>        &#123;<br>            g[x[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(&#123;x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>]&#125;);<br>            g[x[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(&#123;x[<span class="hljs-number">0</span>], x[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">count</span>(n);<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ok</span>(<span class="hljs-number">1010</span>);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&amp;, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp;ok, <span class="hljs-type">int</span> d) -&gt;<span class="hljs-type">void</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (d % sig == <span class="hljs-number">0</span>)<br>                ok[depth]++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p: g[x])<br>            &#123;<br>                <span class="hljs-type">int</span> y = p.first, w = p.second;<br>                <span class="hljs-keyword">if</span> (y != fa)<br>                    <span class="hljs-built_in">dfs</span>(y, x, i, ok, d + w);<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            depth = <span class="hljs-number">0</span>;<br>            ok.<span class="hljs-built_in">clear</span>();<br>            ok.<span class="hljs-built_in">resize</span>(n);<br>            <span class="hljs-keyword">if</span> (g[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            &#123;<br>                count[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p: g[i])<br>            &#123;<br>                <span class="hljs-type">int</span> y = p.first, w = p.second;<br>                <span class="hljs-built_in">dfs</span>(y, i, i, ok, w);<br>                depth++;<br>            &#125;<br>           <br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; depth; j++)<br>                &#123;<br>                    ans += ok[i] * ok[j];<br>                &#125;<br>            &#125;<br>            count[i] = ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2386-找出数组的第-K-大和-力扣（LeetCode）"><a href="#2386-找出数组的第-K-大和-力扣（LeetCode）" class="headerlink" title="2386. 找出数组的第 K 大和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">2386. 找出数组的第 K 大和 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;9</li></ul><p>sum是所有非负数之和 因为减去非负数和加上负数都是减去nums[i] 所以可以把负数转换成非负数 后面全部用减法 </p><p>要找出第k大的子序列 由于是子序列可以先排序 排完序之后再求第k小的子序列 用sum 减去这个子序列 就是第k大的子序列</p><p>用最小堆来生成所有子序列   以[1,2,3]为例</p><p>从[]开始</p><p>在 [][][] 末尾添加 111 得到 [1]。<br>在 [1] 末尾添加 222 得到 [1,2] 也可以把末尾的 111 替换成 222 得到 [2]<br>在 [2] 末尾添加 333 得到 [2,3] 也可以把末尾的 222 替换成 333 得到 [3]<br>在 [1,2] 末尾添加 333 得到 [1,2,3] 也可以把末尾的 222 替换成 333 得到 [1,3]</p><p>因为结合了最小堆 会自动排序 每次都取出当前最小的 然后由于数组也已经排序 每次取最小的 替换&#x2F;加上nums[i] 就是由小到大的 </p><p>所以k次操作之后 最小的值就是 q.top()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">kSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>)<br>                sum += x;<br>            <span class="hljs-keyword">else</span> x = -x;<br>        &#125;<br>        <br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt;,greater&lt;&gt;&gt;q;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (--k)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [s, i] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (i &lt; nums.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                q.<span class="hljs-built_in">emplace</span>(s + nums[i], i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (i)<br>                &#123;<br>                    q.<span class="hljs-built_in">emplace</span>(s + nums[i] - nums[i - <span class="hljs-number">1</span>], i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - q.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="331-验证二叉树的前序序列化-力扣（LeetCode）⁤"><a href="#331-验证二叉树的前序序列化-力扣（LeetCode）⁤" class="headerlink" title="331. 验证二叉树的前序序列化 - 力扣（LeetCode）⁤"></a><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化 - 力扣（LeetCode）⁤</a></h2><ul><li>3&#x2F;31</li></ul><p>栈+二叉树</p><p>遇到#结点直接放入 当累计两个的时候 就可以弹出#结点以及他的父节点 然后再放上一个#结点 表示这个结点已经到达空 接下来会访问右节点</p><p>最后 根节点左右都会是# 然后把根节点pop  如果最后剩下一个#说明是树的前序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(string preorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;st;<br>        <br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    num = <span class="hljs-number">-1</span>;<br>                    i++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                num = num * <span class="hljs-number">10</span> + preorder[i++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&quot;num&quot;</span>&lt;&lt;num&lt;&lt;endl;<br>            <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>)<br>                st.<span class="hljs-built_in">push_back</span>(num);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                st.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span> &amp;&amp; st[st.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span> &amp;&amp; st[st.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] == <span class="hljs-number">-1</span> &amp;&amp; st[st.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>] != <span class="hljs-number">-1</span>)<br>                &#123;<br>                    st.<span class="hljs-built_in">pop_back</span>();<br>                    st.<span class="hljs-built_in">pop_back</span>();<br>                    st.<span class="hljs-built_in">pop_back</span>();<br>                    st.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; st[st.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="树状数组-线段树"><a href="#树状数组-线段树" class="headerlink" title="树状数组&#x2F;线段树"></a>树状数组&#x2F;线段树</h1><h2 id="3072-将元素分配到两个数组中-II-力扣（LeetCode）"><a href="#3072-将元素分配到两个数组中-II-力扣（LeetCode）" class="headerlink" title="3072. 将元素分配到两个数组中 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/submissions/507364590/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;3</li></ul><p>周赛t4 python的SortedList排序 可以在$O(logn)$完成 然后再加上二分查找的$O(logn)$ 可以在时间复杂度$O(nlogn)$内完成</p><p>因为数据范围为1e5 $O({n^2})$会超时 所以要用$O(nlogn)$的算法 当时最后想到了要多加两个数组 来记录有序的序列 再用二分 但是写C++的二分的时候好像出问题了 最后没写出来</p><p>用python自带的排序和二分库函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resultArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">greatCount</span>(<span class="hljs-params">arr, k</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr) - arr.bisect_right(k)<br><br>        arr1, arr2 = SortedList([nums[<span class="hljs-number">0</span>]]), SortedList([nums[<span class="hljs-number">1</span>]])<br>        res1, res2 = [nums[<span class="hljs-number">0</span>]], [nums[<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>            c1, c2 = greatCount(arr1, nums[i]), greatCount(arr2, nums[i])<br>            <span class="hljs-keyword">if</span> c1 &gt; c2 <span class="hljs-keyword">or</span> (c1 == c2 <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(arr1) &lt;= <span class="hljs-built_in">len</span>(arr2)):<br>                arr1.add(nums[i])<br>                res1.append(nums[i])<br>            <span class="hljs-keyword">else</span>:<br>                arr2.add(nums[i])<br>                res2.append(nums[i])<br>        <span class="hljs-keyword">return</span> res1 + res2<br></code></pre></td></tr></table></figure><p>树状数组板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="307-区域和检索-数组可修改-力扣（LeetCode）"><a href="#307-区域和检索-数组可修改-力扣（LeetCode）" class="headerlink" title="307. 区域和检索 - 数组可修改 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;9</li></ul><p>树状数组模板题 求不断修改数组的情况下的区间和 </p><p>主要是add函数 for循环结束条件是i &lt; tree.size()</p><p>然后修改了数组元素 要把数组变为val 然后tree里面的值也相应地要修改  修改了<strong>delta</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i ; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums):<span class="hljs-built_in">nums</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">tree</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-built_in">add</span>(i, nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> delta = val - nums[index];<br>        nums[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>; i &lt; tree.<span class="hljs-built_in">size</span>(); i += <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += delta;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(right + <span class="hljs-number">1</span>) - <span class="hljs-built_in">pre</span>(left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3072-将元素分配到两个数组中-II-力扣（LeetCode）-1"><a href="#3072-将元素分配到两个数组中-II-力扣（LeetCode）-1" class="headerlink" title="3072. 将元素分配到两个数组中 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></h2><p>离散化+树状数组</p><p>由于数的范围在1e9 太大了 数组开不下 所以要用离散化 为什么可以离散化  因为他只是为了比大小 那把数去重排序后映射到1~n的区间就行了  由于树状数组从1开始 建议映射也从1开始</p><p>用unordered_map把每个数映射</p><p>树状数组的部分 首先把板子打上</p><p>树状数组 存什么呢？ 别的题树状数组（如上题）可能是存前缀和 但是这个题目不一样 他主要是看前面有几个数比他大 我们又已经把数映射了 所以每次add的时候就加1表示index这个地方多了一个数 那么算出来的前缀和就是到1~n这个地方共有几个数 那就是比他小的数的个数  再用size减一下就得到比他大的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">int</span> MAXN;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tree;<br>    <span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BiTree</span>(<span class="hljs-type">int</span> _MAXN = <span class="hljs-number">100010</span>):<span class="hljs-built_in">MAXN</span>(_MAXN)<br>    &#123;<br>        tree.<span class="hljs-built_in">resize</span>(MAXN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            tree[i] += x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            sum += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-comment">// (l, r]</span><br>    <span class="hljs-function">ll <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pre</span>(r) - <span class="hljs-built_in">pre</span>(l);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">resultArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">tmp</span>(nums);<br>        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>        tmp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()), tmp.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> m = tmp.<span class="hljs-built_in">size</span>(), n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)mp[tmp[i]] = i + <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt;a&#123;nums[<span class="hljs-number">0</span>]&#125;,b&#123;nums[<span class="hljs-number">1</span>]&#125;;<br>        <span class="hljs-function">BiTree <span class="hljs-title">t1</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>        t1.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">0</span>]], <span class="hljs-number">1</span>);<br>        t2.<span class="hljs-built_in">add</span>(mp[nums[<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-type">int</span> v = mp[nums[i]];<br>            <span class="hljs-type">int</span> gc1 = a.<span class="hljs-built_in">size</span>() - t1.<span class="hljs-built_in">pre</span>(v);<br>            <span class="hljs-type">int</span> gc2 = b.<span class="hljs-built_in">size</span>() - t2.<span class="hljs-built_in">pre</span>(v);<br><br>            <span class="hljs-keyword">if</span> (gc1 &gt; gc2 || (gc2 == gc1 &amp;&amp; a.<span class="hljs-built_in">size</span>() &lt;= b.<span class="hljs-built_in">size</span>()))<br>            &#123;<br>                a.<span class="hljs-built_in">push_back</span>(x);<br>                t1.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                b.<span class="hljs-built_in">push_back</span>(x);<br>                t2.<span class="hljs-built_in">add</span>(v, <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br>        a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1215-小朋友排队-AcWing题库"><a href="#1215-小朋友排队-AcWing题库" class="headerlink" title="1215. 小朋友排队 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1217/">1215. 小朋友排队 - AcWing题库</a></h2><ul><li>3&#x2F;11</li></ul><p>记录每个小朋友前面有多少个比他高的 后面有多少个比他矮的</p><p>树状数组里面存放数字出现的次数 而不是数字本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>ll nums[N], ret[N];<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1000010</span>;<br>ll tree[MAXN];<br><span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; MAXN; i+=<span class="hljs-built_in">lowbit</span>(i))<br>    &#123;<br>        tree[i] += x;<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -= <span class="hljs-built_in">lowbit</span>(i))<br>    &#123;<br>        sum += tree[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>        nums[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">add</span>(nums[i], <span class="hljs-number">1</span>);<br>        ret[i] += (i - <span class="hljs-built_in">query</span>(nums[i]));<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(tree, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(tree));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">add</span>(nums[i], <span class="hljs-number">1</span>);<br>        ret[i] += <span class="hljs-built_in">query</span>(nums[i] - <span class="hljs-number">1</span>);<br>        <br>        ans += (ll)ret[i] * (ret[i] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="797-差分-AcWing题库"><a href="#797-差分-AcWing题库" class="headerlink" title="797. 差分 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/799/">797. 差分 - AcWing题库</a></h2><ul><li>3&#x2F;11</li></ul><p>差分前缀和 用一个差分数组 在区间起点记录加数 在终点减去这个数 最后求前缀和 就可以把整个区间的数都加上 只用$O(n)$的时间  如果是每次都把整个区间直接加到数组上 就要$O(n^{2})$时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], diff[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r, c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        diff[l] += c;<br>        diff[r + <span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        diff[i] += diff[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cout&lt;&lt;nums[i] + diff[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="798-差分矩阵-AcWing题库"><a href="#798-差分矩阵-AcWing题库" class="headerlink" title="798. 差分矩阵 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵 - AcWing题库</a></h2><ul><li>3&#x2F;13</li></ul><p>二维差分与一位差分不同 也需要前缀和 但是需要对原矩阵进行处理 求得原矩阵的差值矩阵 然后再用差分</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">diff<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> + nums<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> - nums<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> - nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>是由<br>nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = nums<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> - nums<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> - nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> + diff<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;得到的<br></code></pre></td></tr></table></figure><p>然后还要注意差分数组加的地方 [x2 + 1] [y1]  [x1] [y2 + 1]  [x2 + 1] [y2 + 1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, q;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> nums[N][N], diff[N][N], qzh[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cin&gt;&gt;nums[i][j];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            diff[i][j] = nums[i][j] + nums[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - nums[i - <span class="hljs-number">1</span>][j] - nums[i][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x1, x2, y1, y2, c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        diff[x1][y1]+=c;<br>        diff[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>]+=c;<br>        diff[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>        diff[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            diff[i][j] += -diff[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + diff[i][j - <span class="hljs-number">1</span>] + diff[i - <span class="hljs-number">1</span>][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            cout&lt;&lt;diff[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="2917-找出数组中的-K-or-值-力扣（LeetCode）"><a href="#2917-找出数组中的-K-or-值-力扣（LeetCode）" class="headerlink" title="2917. 找出数组中的 K-or 值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-k-or-of-an-array/">2917. 找出数组中的 K-or 值 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;6</li></ul><p>简单模拟</p><img src="../images/$%7Bfiilename%7D/image-20240306083318322.png" alt="image-20240306083318322" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKOr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">33</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">31</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: nums)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (x &gt;&gt; i &amp; <span class="hljs-number">1</span>)cnt[i]++; <br>            &#125;<br>        &#125;    <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">32</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cnt[i] &gt;= k)res += <span class="hljs-number">1</span> &lt;&lt; i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5001-异或和之和-AcWing题库"><a href="#5001-异或和之和-AcWing题库" class="headerlink" title="5001. 异或和之和 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5004/">5001. 异或和之和 - AcWing题库</a></h2><ul><li>3&#x2F;16</li></ul><p>直接暴力循环会超时（1e5数据 On2</p><p>贡献法 分别计算每一位的贡献 可以达到On 的复杂度</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs txt">0        1 2 3 4 5<br>0000     0001 0010 0011 0100 0101  nums<br>0000     0001 0011 0000 0100 0001  qzh<br><br>看第0位的贡献 <br>对于R为2 只有2个 1~2和2~2 分别为 <br>0~2 qzh[2] ^ qzh[0] = 1 （相当于1~2）<br>1~2 qzh[2] ^ qzh[1] = 0 <br>对于R为3  第0位<br>0~3 qzh[3] ^ qzh[0] = 0   0^0=0<br>1~3 qzh[3] ^ qzh[1] = 1   0^1=1<br>2~3 qzh[3] ^ qzh[2] = 1   0^1=1<br>**那我要看第0位的贡献 不就是第0位是0   前面有2个1  贡献就是2 &lt;&lt; 0**<br>qzh[b] ^ qzh[a] 表示 a到b区间的异或 所以只需要b这一位 分别和前面的 0~b-1分别异或一次就可以得到区间异或 <br>但是这样还是n^2复杂度<br>观察可以发现 现在只需要计算第j位这一位与前面每个数的异或 那 如果这一位是1 这一位前面有多少个0 那就是多少 所以可以在n的复杂度解决  只要记录每一位是0 还是1<br>就是把前面的0~3 1~3 2~3的计算 直接换成当前位0/1前面有多少个1/0 <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll nums[<span class="hljs-number">100010</span>], qzh[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        qzh[i] = qzh[i - <span class="hljs-number">1</span>] ^ nums[i];<br>    <br>    ll res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">21</span>; j++)<br>    &#123;<br>        <span class="hljs-type">int</span> c0 = <span class="hljs-number">1</span>, c1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// j这一位0和1的个数</span><br>        ll now = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (qzh[i] &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>            &#123;<br>                c1++;<br>                now += c0;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                c0++;<br>                now += c1;<br>            &#125;<br>        &#125;<br>        res += now * (<span class="hljs-number">1</span> &lt;&lt; j);<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>结点由两个集合组成 两个集合内部没有边的图</p><p>也就是 存在一种方案 将结点划分成满足以上两个性质的集合</p><p>就是集合中的点都染成黑白 可以发现二分图中每条边都链接一个白点一个黑点</p><p>二分图不存在长为奇数的环（每条边都从一个集合走到另一个集合 偶数次才能回到同一个集合）</p><p>判断二分图：遍历：发现奇环就不是 否则是</p><h2 id="二分图最大匹配P3386-【模板】二分图最大匹配-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#二分图最大匹配P3386-【模板】二分图最大匹配-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="二分图最大匹配P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>二分图最大匹配<a href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><ul><li>3&#x2F;20</li></ul><p>匈牙利算法（ntr算法哈哈</p><p>就是每次先配对 然后下一个人来配对的时候 遍历她所有可以访问的点 如果没被访问过并且没有配对 就配对 如果有配对了 就看看上一个人能不能让出来 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n, m, e;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> vis[N], match[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, ne;<br>&#125; edge[N];<br><span class="hljs-type">int</span> head[N], idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[++idx] = &#123;b, head[a]&#125;;<br>    head[a] = idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = edge[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = edge[i].v;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">dfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i))<br>            ans++;<br>    &#125;<br>    cout &lt;&lt; ans;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xmuoj-AI2024春《算法设计与分析》第三次上机"><a href="#xmuoj-AI2024春《算法设计与分析》第三次上机" class="headerlink" title="xmuoj | AI2024春《算法设计与分析》第三次上机"></a><a href="https://www.xmuoj.com/contest/221/problem/6">xmuoj | AI2024春《算法设计与分析》第三次上机</a></h2><ul><li>3&#x2F;20</li></ul><p>棋盘覆盖问题  可以当作二分图来写：</p><p>这样思考 每个块都把他当作是两个点合在一起 假设中间是一个白点 （2，2）那么（1，2）（2，1）（3，2）（2，3）都是黑点 然后建边 这样就类似与上面的二分图了  对白点或者黑点进行二分图查找就可以找到最大匹配（一个匹配就相当于是放了一块木板）</p><p>难点在于想到用二分图的做法来做这个题 还有怎样去建边 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-comment">//N开太大会超时</span><br><span class="hljs-type">int</span> b[N][N], vis[N * N], match[N * N];<span class="hljs-comment">// N*N才能过 不然数组太小</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N * N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 匈牙利算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vis[v])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!match[v] || <span class="hljs-built_in">bfs</span>(match[v]))<br>        &#123;<br>            match[v] = u;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n, t;<br>    cin &gt;&gt; n &gt;&gt; t;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        b[x][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!b[i][j])<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<br>                &#123;<br>                    <span class="hljs-type">int</span> x = dx[k] + i, y = dy[k] + j;<br>                    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= n &amp;&amp; !b[x][y])<br>                    &#123;<br>                        <span class="hljs-comment">// 建边</span><br>                        e[i * n + j].<span class="hljs-built_in">push_back</span>(x * n + y);<br>                        e[x * n + y].<span class="hljs-built_in">push_back</span>(i * n + j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((i ^ j) &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 枚举奇数结点</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-comment">//清空</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bfs</span>(i * n + j))<br>                ans++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h1><h2 id="100258-最高频率的-ID-力扣（LeetCode）"><a href="#100258-最高频率的-ID-力扣（LeetCode）" class="headerlink" title="100258. 最高频率的 ID - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/most-frequent-ids/submissions/515906308/">100258. 最高频率的 ID - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;24</li></ul><img src="../images/$%7Bfiilename%7D/image-20240325082019545.png" alt="image-20240325082019545" style="zoom:25%;" /><p>一个感觉见过很多次的题。。周赛的时候大脑宕机了(哭</p><h3 id="方法一-两个map"><a href="#方法一-两个map" class="headerlink" title="方法一 两个map"></a>方法一 两个map</h3><p>题目要求每次操作之后 最高的频率是多少  需要有一个map记录每个id的频率 还需要有一个 map 记录这个频率有多少个数  因为不同id的频率可能是一样的 但是答案只需要最大的频率 所以记录一下每个频率有几个数 最后返回最大频率即可  对id增加的时候直接加 减的时候只需要看是否减为0  减为0后需要让这个频率的数量减少 如果当前频率的数为0 要记得删除 否则map还会保存这个频率只不过数量为0 就无法直接取到最大的频率</p><p>关键是不需要求最大的id是哪个 只需要看最大频率 记录频率个数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">mostFrequentIDs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; fr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>, ll&gt;cnt; <span class="hljs-comment">// 记录这个id的频率</span><br>        map&lt;ll, <span class="hljs-type">int</span>&gt;num; <span class="hljs-comment">// 记录这个频率有多少个id</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>       &#123;<br>           <span class="hljs-type">int</span> x = nums[i], f = fr[i];<br>           <span class="hljs-comment">// 减去旧的频率</span><br>           <span class="hljs-keyword">if</span> (cnt.<span class="hljs-built_in">count</span>(x)) <span class="hljs-comment">// map的count只有0 或1两种 其实就是检查x是否是cnt的键 </span><br>           &#123;<br>               <span class="hljs-keyword">if</span> (--num[cnt[x]] == <span class="hljs-number">0</span>)num.<span class="hljs-built_in">erase</span>(cnt[x]);<br>           &#125;<br>           <span class="hljs-comment">// 添加新的频率</span><br>           cnt[x] += f;<br>           num[cnt[x]]++;<br>           <span class="hljs-keyword">if</span> (num.<span class="hljs-built_in">empty</span>())<br>           &#123;<br>               ans[i] = <span class="hljs-number">0</span>;<br>           &#125;<br>           <span class="hljs-keyword">else</span><br>               ans[i] = num.<span class="hljs-built_in">rbegin</span>() -&gt; first;<span class="hljs-comment">// 通过rbegin取得最大值</span><br>       &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法二-懒删除堆"><a href="#方法二-懒删除堆" class="headerlink" title="方法二 懒删除堆"></a>方法二 懒删除堆</h3><p>每次都直接插入堆中 用map记录当前每个id的频率</p><p>在取出最大频率的时候 开始判断 如果id的频率和map中相同 那说明这就是最大频率</p><p>否则就说明这是id变化之后 没有删掉的 现在把他删掉 直到频率、id 和map中匹配  就是真实的最大频率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++">![屏幕截图 <span class="hljs-number">2024</span><span class="hljs-number">-03</span><span class="hljs-number">-25</span> <span class="hljs-number">092730</span>](../../../../Pictures/Screenshots/%E5%B1%<span class="hljs-number">8F</span>%E5%B9%<span class="hljs-number">95</span>%E6%<span class="hljs-number">88</span>%AA%E5%<span class="hljs-number">9B</span>%BE%<span class="hljs-number">202024</span><span class="hljs-number">-03</span><span class="hljs-number">-25</span>%<span class="hljs-number">20092730.</span>png)<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">mostFrequentIDs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; fr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt;q; <span class="hljs-comment">// &lt;频率, id&gt;</span><br>        map&lt;<span class="hljs-type">int</span>, ll&gt;mp;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;ll&gt;<span class="hljs-built_in">ans</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x = nums[i], f = fr[i];<br>            mp[x] += f;<br>            q.<span class="hljs-built_in">push</span>(&#123;mp[x], x&#125;);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span> (mp[t.second] != t.first)<br>                &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans[i] = q.<span class="hljs-built_in">top</span>().first;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-25%20092730.png" style="zoom:25%;" /><p>懒删除堆的效率更高</p><h1 id="前缀树（Trie）"><a href="#前缀树（Trie）" class="headerlink" title="前缀树（Trie）"></a>前缀树（Trie）</h1><h2 id="208-实现-Trie-前缀树-力扣（LeetCode）"><a href="#208-实现-Trie-前缀树-力扣（LeetCode）" class="headerlink" title="208. 实现 Trie (前缀树) - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;25</li></ul><img src="../images/$%7Bfiilename%7D/image-20240326075542565.png" alt="image-20240326075542565" style="zoom:25%;" /><p>前缀树 多叉树 一般将单词等拆分成根到叶子的形式，每个结点一个字母。</p><p>通常用于判断前后缀</p><p>最重要的是Trie*next[26] 每个结点都有一个Trie *的数组分别表示26个字母（视情况而定）</p><p>然后就是isEnd 这个也是视题目而定 判断单词前缀的题 一般就是用isEnd判断这个单词是否结束 结束了的话就标记 后面一题 不需要判断是否结束 只需要判断是不是后缀 所以不用isEnd 改用别的参数</p><p>其余函数 整体的操作流程跟<strong>链表</strong>差不多（其实就是用链表实现的..）</p><p>插入函数 不断下移到字母对应位置 如果为空就创建结点 否则就继续往下 直到单词结束 打上End标记</p><p>查找函数 记得要用end判断</p><p>判前缀和查找一样  不过判断前缀不需要用End</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(next));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c: word)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)<br>                node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            <br>            node = node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node -&gt; isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c: word)<br>        &#123;<br>            node = node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c: prefix)<br>        &#123;<br>            node = node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="3093-最长公共后缀查询-力扣（LeetCode）"><a href="#3093-最长公共后缀查询-力扣（LeetCode）" class="headerlink" title="3093. 最长公共后缀查询 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-common-suffix-queries/submissions/516608165/">3093. 最长公共后缀查询 - 力扣（LeetCode）</a></h2><ul><li>3&#x2F;25</li></ul><p>周赛t4 没来得及写(被动态找点整破防了</p><img src="../images/$%7Bfiilename%7D/image-20240326080744268.png" alt="image-20240326080744268" style="zoom:25%;" /><p>（不写成类的形式 更像是链表操作了）</p><p>题目要求在WordsContainer数组里面 找wordsQuery里每个单词的最长公共后缀 然后返回这个WordsContainer里面的拥有最长公共后缀的单词的下标</p><p>因为单词非常多 而每个wordsQuery又是在WordsContainer的全部里面去找  所以可以先用Trie树预处理所有的WordsContainer里面的单词（Trie树中倒着存WordsContainer的每个单词 因为要后缀）</p><p>然后再拿wordsQuery的每个单词去Trie树中匹配后缀</p><p>匹配原则：1最长公共后缀 2后缀长度相同优先单词长度短的 3前两个都相同 优先先出现的</p><p>这个判后缀就不需要isEnd标记了   但是可以存放这个后缀的答案（也就是这个后缀的长度和如果这个后缀匹配了 应该返回的下标）</p><p>比如abcd 和 bcd   Trie树为</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">NULL (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>  \<br>   d (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>    \<br>     c (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>      \<br>       <span class="hljs-selector-tag">b</span> (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>        \<br>         <span class="hljs-selector-tag">a</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>这样假设cd 去匹配 后缀 最终会在c处返回 (1,3)  1就是bcd的下标1  3就是bcd的长度3  </p><p>如果是abcd去匹配后缀 就会在a处返回(0,4) 因为abcd后缀更长</p><p>根节点为NULL也需要存 因为题目中包含了空结点 </p><p>存下标 便于访问答案  存长度便于更新下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    Node* son[<span class="hljs-number">26</span>]&#123;&#125;;<br>    <span class="hljs-type">int</span> min_l = INT_MAX, i;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stringIndices</span><span class="hljs-params">(vector&lt;string&gt;&amp; wordsContainer, vector&lt;string&gt;&amp; wordsQuery)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Node*root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        <span class="hljs-comment">// 存入全部的后缀</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; wordsContainer.<span class="hljs-built_in">size</span>(); idx++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> &amp;s = wordsContainer[idx];<br>            <span class="hljs-type">int</span> l = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">auto</span> cur = root;<br>            <span class="hljs-comment">// 空结点（根节点）的更新操作</span><br>            <span class="hljs-keyword">if</span> (l &lt; cur-&gt;min_l)<br>            &#123;<br>                cur-&gt;min_l = l;<br>                cur-&gt;i = idx;<br>            &#125;<br>            <span class="hljs-comment">// 每个单词的后缀</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            &#123;<br>                <span class="hljs-type">int</span> b = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (cur-&gt;son[b] == <span class="hljs-literal">nullptr</span>)<br>                    cur-&gt;son[b] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>                cur = cur-&gt;son[b];<br>                <span class="hljs-keyword">if</span> (l &lt; cur-&gt;min_l)<br>                &#123;<br>                    cur-&gt;min_l = l;<br>                    cur-&gt;i = idx;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt;ans;<br>        <span class="hljs-comment">// 开始cha</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;s: wordsQuery)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> cur = root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;son[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">break</span>;<br>                cur = cur-&gt;son[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>课程报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2024/02/21/%E9%80%92%E5%BD%92/"/>
    <url>/2024/02/21/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="92-递归实现指数型枚举-AcWing题库"><a href="#92-递归实现指数型枚举-AcWing题库" class="headerlink" title="92. 递归实现指数型枚举 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/94/">92. 递归实现指数型枚举 - AcWing题库</a></h1><p><img src="/../images/$%7Bfiilename%7D/image-20240221101137855.png" alt="image-20240221101137855"></p><p>每个位置 选或不选  不选的话就直接dfs(u + 1)过去 选的话 就标记一下vis</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 边界 枚举到最后一个</span><br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[i])<br>                cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!vis[u])<br>    &#123;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>); <span class="hljs-comment">// 当前位置选</span><br>        vis[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<span class="hljs-comment">// 当前位置不选</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)a[i] = i;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="94-递归实现排列型枚举-AcWing题库"><a href="#94-递归实现排列型枚举-AcWing题库" class="headerlink" title="94. 递归实现排列型枚举 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/96/">94. 递归实现排列型枚举 - AcWing题库</a></h1><p><img src="/../images/$%7Bfiilename%7D/image-20240221112328817.png" alt="image-20240221112328817"></p><p>每个位置都需要填东西  关键是填什么 </p><p>那就是 每个位置选一个填 选过的就标记 下次从没标记的里面选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> used[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cout&lt;&lt;nums[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!used[i])<br>        &#123;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            nums[u] = i;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// </span><br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lqb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯&amp;分支限界(剪枝)</title>
    <link href="/2024/02/06/%E5%9B%9E%E6%BA%AF&amp;%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C(%E5%89%AA%E6%9E%9D)/"/>
    <url>/2024/02/06/%E5%9B%9E%E6%BA%AF&amp;%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C(%E5%89%AA%E6%9E%9D)/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="子集型（选或不选）"><a href="#子集型（选或不选）" class="headerlink" title="子集型（选或不选）"></a>子集型（选或不选）</h2><h3 id="6-买瓜-蓝桥云课-lanqiao-cn"><a href="#6-买瓜-蓝桥云课-lanqiao-cn" class="headerlink" title="6.买瓜 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3505/learning/?subject_code=1&group_code=5&match_num=14&match_flow=1&origin=cup">6.买瓜 - 蓝桥云课 (lanqiao.cn)</a></h3><p>DFS+剪枝 主要有几种情况 不需要继续进行搜索</p><p>当sum &gt; m的时候 必定不相等 当cnt &gt; mcnt的时候 不会是最小</p><p>比较难想的是 对所有的瓜进行排序 当买到第i个的时候 如果后面所有瓜加起来都不能到m 那也是必定不相等的 这个就相当于往后多看了一步 就不用去走了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">100</span>), <span class="hljs-built_in">suf</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> mcnt = <span class="hljs-number">2e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> sum, <span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= m)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (sum == m)<br>    &#123;<br>        mcnt = <span class="hljs-built_in">min</span>(cnt, mcnt);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == n || sum &gt; m || suf[i] + sum &lt; m)<br>    &#123;<br>      <span class="hljs-comment">//  cout&lt;&lt;sum&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i], cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum, cnt);<br>    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, sum + nums[i] / <span class="hljs-number">2</span>, cnt + <span class="hljs-number">1</span>);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 请在此输入您的代码</span><br>    <br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)cin&gt;&gt;nums[i];<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)suf[i] = suf[i + <span class="hljs-number">1</span>] + nums[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    mcnt == <span class="hljs-number">2e9</span> ? cout&lt;&lt; <span class="hljs-number">-1</span> : cout&lt;&lt;mcnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列型（选哪个）"><a href="#排列型（选哪个）" class="headerlink" title="排列型（选哪个）"></a>排列型（选哪个）</h2>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lqb</title>
    <link href="/2024/02/06/lqb/"/>
    <url>/2024/02/06/lqb/</url>
    
    <content type="html"><![CDATA[<h1 id="1-平方差-蓝桥云课-lanqiao-cn"><a href="#1-平方差-蓝桥云课-lanqiao-cn" class="headerlink" title="1.平方差 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3213/learning/?subject_code=1&group_code=5&match_num=14&match_flow=1&origin=cup">1.平方差 - 蓝桥云课 (lanqiao.cn)</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] != B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size())</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++) <br>            C[i + j] += A[i] * B[j];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t += C[i];<br>        C[i] = t % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<br>    string aa, bb, a, b;<br><br>    cin&gt;&gt;aa&gt;&gt;bb;<br><br>    <span class="hljs-keyword">if</span>(aa[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; aa.<span class="hljs-built_in">size</span>(); i++) a += aa[i];<br>    <span class="hljs-keyword">else</span> a = aa;<br>    <span class="hljs-keyword">if</span>(bb[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; bb.<span class="hljs-built_in">size</span>(); i++) b += bb[i];<br>    <span class="hljs-keyword">else</span> b = bb;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    A = <span class="hljs-built_in">mul</span>(A, A);<br>    B = <span class="hljs-built_in">mul</span>(B, B);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B)) C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>;<br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cout&lt;&lt;C[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1210-连号区间数-AcWing题库"><a href="#1210-连号区间数-AcWing题库" class="headerlink" title="1210. 连号区间数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1212/">1210. 连号区间数 - AcWing题库</a></h1><p>有点偏技巧 关键要找到规律 怎么样求出一个区间是否连号   只要一个区间的最大值和最小值的差 等于 区间的长度就是连号的区间   比如3 2 4    4 - 2 &#x3D; 2 区间长度（下标分别为0 1 2 ）为2 - 0 &#x3D; 2   </p><p>因为当排好序之后 连号数列为minn x1 x2… maxn 则 maxn - minn &#x3D; 区间长度</p><p>找到规律之后直接枚举 左右区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> maxn = nums[<span class="hljs-number">0</span>], minn = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; l++)<br>    &#123;<br>        maxn = minn = nums[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; n; r++)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, nums[r]);<br>            minn = <span class="hljs-built_in">min</span>(minn, nums[r]);<br>            <span class="hljs-keyword">if</span> (maxn - minn == r - l)cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反悔贪心</title>
    <link href="/2024/02/06/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/"/>
    <url>/2024/02/06/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>反悔贪心 就是 贪心 + 优先队列 </p><p>重点是找到 把什么放进优先队列中</p><h1 id="LCP-30-魔塔游戏-力扣（LeetCode）"><a href="#LCP-30-魔塔游戏-力扣（LeetCode）" class="headerlink" title="LCP 30. 魔塔游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/p0NxJO/description/">LCP 30. 魔塔游戏 - 力扣（LeetCode）</a></h1><p>每次都把扣的血直接扣掉 加的血直接加上 扣的血加入优先队列中（因为最好我只用移动扣血量最大的 移动一个就可以少移几个血量小的）</p><p>直到扣的血超过当前血量的时候 <strong>反悔</strong> 此时把 扣血最多的移动到最后（不用真的移动）然后把血加上 继续向后</p><p>本题放入优先队列的就是 扣血量 因为一个扣血大的可以抵很多个扣血少的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">magicTower</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll hp = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: nums)<br>        &#123;<br>            hp += x;<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(-x);<br>            <span class="hljs-keyword">if</span> (hp &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                cnt ++;<br>                hp += q.<span class="hljs-built_in">top</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h1 id="630-课程表-III-力扣（LeetCode）"><a href="#630-课程表-III-力扣（LeetCode）" class="headerlink" title="630. 课程表 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iii/description/">630. 课程表 III - 力扣（LeetCode）</a></h1><p>课程有两个衡量标准 第一是 持续时间  第二是结束时间 </p><p>结束时间早的应该先上  所以对结束时间进行排序 </p><p>而持续时间应该放入优先队列  因为 一个持续时间长的可以抵很多持续时间短的 所以尽量要上时间短的课  </p><p>当当前时间大于这节课的结束时间的时候 就可以考虑要不要<strong>反悔</strong> 去掉之前上的时间最长的课 改为上这节课（如果这节课的时长较短）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scheduleCourse</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; courses)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(courses.<span class="hljs-built_in">begin</span>(), courses.<span class="hljs-built_in">end</span>(), [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;a, vector&lt;<span class="hljs-type">int</span>&gt;b)<br>        &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;);<br><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: courses)<br>        &#123;<br>            <span class="hljs-type">int</span> dur = x[<span class="hljs-number">0</span>], last = x[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (now + dur &lt;= last)<br>            &#123;<br>                now += dur;<br>                q.<span class="hljs-built_in">push</span>(dur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; dur &lt; q.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                now -= q.<span class="hljs-built_in">top</span>() - dur;<br>                q.<span class="hljs-built_in">pop</span>();<br>                q.<span class="hljs-built_in">push</span>(dur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1642-可以到达的最远建筑-力扣（LeetCode）"><a href="#1642-可以到达的最远建筑-力扣（LeetCode）" class="headerlink" title="1642. 可以到达的最远建筑 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/furthest-building-you-can-reach/description/">1642. 可以到达的最远建筑 - 力扣（LeetCode）</a></h1><p>这题放入优先队列的是高度差 因为高度差高的地方用梯子可以省下很多砖头</p><p>梯子相当于是一次性无限量砖块 那么就要把梯子放在差距最高的几个地方 维护长为[梯子的数量]的优先队列 表示这几个要用梯子  后面一旦遇到比top大的高度差 就pop出来 换上这个 然后pop出来的就要用砖头 砖头不够的时候就退出 表示最后只能到这里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights, <span class="hljs-type">int</span> bricks, <span class="hljs-type">int</span> ladders)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>        <br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-type">int</span> sumH = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> deltaH = heights[i] - heights[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (deltaH &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(deltaH);<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &gt; ladders)<br>                &#123;<br>                    sumH += q.<span class="hljs-built_in">top</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sumH &gt; bricks)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2024/02/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/02/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z_function</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>      z[i] = z[i - l];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      z[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) l = i, r = i + z[i] - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>石子游戏</title>
    <link href="/2024/02/03/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/02/03/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><p>石子游戏（每次只能选择 前端或者后端的那一堆）的主要思想是 计算当前局面先手的人选择的那一堆 和 他留给另一个人的局面 从中选出最优解</p><p>f[i] [j]考虑区间 [l, r]之间双方都做最优选择  先手后手的最大分差是多少</p><h1 id="877-石子游戏-力扣（LeetCode）"><a href="#877-石子游戏-力扣（LeetCode）" class="headerlink" title="877. 石子游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏 - 力扣（LeetCode）</a></h1><p>dfs(i, j) 双指针表示当前可以取的前端和后端 然后每次取的时候 的好处为  <strong>当前先手取得的值减去留给对手的局面所能获得的值</strong>  </p><p>取i和取j两种选择 选较大的</p><p>注意当i&#x3D;&#x3D;j的时候为退出条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            dfs(i, j) 表示到当前局面先手的人 与另一个的差值</span><br><span class="hljs-comment">            当i==j的时候不用选 直接返回</span><br><span class="hljs-comment">            否则选择</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// int n = piles.size();</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;memo(n, vector&lt;int&gt;(n, -1));</span><br>        <span class="hljs-comment">// function&lt;int(int, int)&gt;dfs=[&amp;](int i, int j)-&gt;int</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     if (i == j)</span><br>        <span class="hljs-comment">//         return piles[i];</span><br>        <span class="hljs-comment">//     if (memo[i][j] != -1)</span><br>        <span class="hljs-comment">//         return memo[i][j];</span><br>            <br>        <span class="hljs-comment">//     memo[i][j] = max(piles[i] - dfs(i + 1, j), piles[j] - dfs(i, j - 1));</span><br>        <span class="hljs-comment">//     return memo[i][j];</span><br>        <span class="hljs-comment">// &#125;;</span><br>        <span class="hljs-comment">// return dfs(0, n - 1);</span><br><br>        <span class="hljs-type">int</span> n = piles.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            dp[i][i] = piles[i];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(piles[i] - dp[i + <span class="hljs-number">1</span>][j], piles[j] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1690-石子游戏-VII-力扣（LeetCode）"><a href="#1690-石子游戏-VII-力扣（LeetCode）" class="headerlink" title="1690. 石子游戏 VII - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/stone-game-vii/?envType=daily-question&envId=2024-02-03">1690. 石子游戏 VII - 力扣（LeetCode）</a></h1><p>这个和上一个有不同的地方 这个题每次是把剩余的全部加起来 所以dfs的时候要先计算出sum （注意每次加之前要先减去当前取的值）相当于dfs多出来一个变量sum</p><p>而动态规划写法不能这样  就只能先计算出<strong>区间和</strong> 每次加上区间和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoneGameVII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">/* dfs(i, j) 表示当前局面先手得分和后手的差距</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// int sum = 0;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     sum += nums[i];</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;memo(n, vector&lt;int&gt;(n, -1));</span><br>        <span class="hljs-comment">// function&lt;int(int, int, int)&gt;dfs=[&amp;](int i, int j, int now)-&gt;int</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     if(i == j)</span><br>        <span class="hljs-comment">//         return 0;</span><br>        <span class="hljs-comment">//     if (memo[i][j] != -1)</span><br>        <span class="hljs-comment">//         return memo[i][j];</span><br>            <br>        <span class="hljs-comment">//     memo[i][j] = max(now - nums[i] - dfs(i + 1, j, now - nums[i]), now - nums[j] - dfs(i, j - 1, now - nums[j]));</span><br>        <span class="hljs-comment">//     return memo[i][j];</span><br>        <span class="hljs-comment">// &#125;;</span><br>        <span class="hljs-comment">// return dfs(0, n - 1, sum);</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">sum</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 记录i到j的区间和  和前面的题目不一样的地方 区间和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == j)sum[i][j] = nums[i];<br>                <span class="hljs-keyword">else</span> sum[i][j] = sum[i][j - <span class="hljs-number">1</span>] + nums[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(sum[i + <span class="hljs-number">1</span>][j] - dp[i + <span class="hljs-number">1</span>][j], sum[i][j - <span class="hljs-number">1</span>] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2024/02/03/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/02/03/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="2055-蜡烛之间的盘子-力扣（LeetCode）"><a href="#2055-蜡烛之间的盘子-力扣（LeetCode）" class="headerlink" title="2055. 蜡烛之间的盘子 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/plates-between-candles/">2055. 蜡烛之间的盘子 - 力扣（LeetCode）</a></h1><p>其实只需要计算 每次查询的最前面的蜡烛和最后面的蜡烛 中间的盘子的数量 盘子的数量可以用前缀和来处理 （因为要频繁地查询 不能每次都数一遍 要直接用前缀和来求）</p><p>蜡烛的位置可以用二分查找来计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">platesBetweenCandles</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">qzh</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(q.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt;lz;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;|&#x27;</span>)lz.<span class="hljs-built_in">push_back</span>(i);<br>            qzh[i + <span class="hljs-number">1</span>] = qzh[i] + (s[i] == <span class="hljs-string">&#x27;*&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lz.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = q[i][<span class="hljs-number">0</span>], b = q[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = <span class="hljs-number">-1</span>, d = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = lz.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (mid &gt;= a) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(lz[r] &gt;= a)c = lz[r];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>            l = <span class="hljs-number">0</span>, r = lz.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (lz[mid] &lt;= b) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lz[r] &lt;= b) d = lz[r];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (c &lt;= d) ans[i] = qzh[d + <span class="hljs-number">1</span>] - qzh[c];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1236-递增三元组-AcWing题库"><a href="#1236-递增三元组-AcWing题库" class="headerlink" title="1236. 递增三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></h1><p>除了二分也可以用前缀和  比如b中的5  可以求出a中所有比5小的数 这时候就可以用哈希表＋前缀和 哈希表记录1 2 3 4 出现的次数 然后加起来 就可以得到比5小的数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], b[N], c[N], cnt1[N], cnt2[N], qzh1[N], qzh2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>        cnt1[++a[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;b[i];<br>        b[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;c[i];<br>        cnt2[++c[i]]++;<br>    &#125;<br>    qzh1[<span class="hljs-number">0</span>] = cnt1[<span class="hljs-number">0</span>];<br>    qzh2[<span class="hljs-number">0</span>] = cnt2[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        qzh1[i] = qzh1[i - <span class="hljs-number">1</span>] + cnt1[i];<br>        qzh2[i] = qzh2[i - <span class="hljs-number">1</span>] + cnt2[i];<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> k = b[i];<br>        ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(qzh2[N - <span class="hljs-number">1</span>] - qzh2[k]) * qzh1[k - <span class="hljs-number">1</span>];<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2024/01/22/%E8%B4%AA%E5%BF%83/"/>
    <url>/2024/01/22/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1953-你可以工作的最大周数-力扣（LeetCode）"><a href="#1953-你可以工作的最大周数-力扣（LeetCode）" class="headerlink" title="1953. 你可以工作的最大周数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/description/">1953. 你可以工作的最大周数 - 力扣（LeetCode）</a></h2><p>假设按顺序排列 C1，C2… Cn</p><p>那么Cn &gt;&#x3D; Cn - 1 则Cn - 1 必定可以插在Cn的空里面 那Cn - 2就一定可以插在Cn - 1的空里（也可以插在别的数的空里） 所以前面的数是一定可以插入的</p><p>关键就在最后一个数 如果前面所有数都去插他的空 还不够的话 那后面的就不能用了</p><p>所以分两种情况 前n - 1个数的sum &gt; 最大数Cn则所有数都可以插入 答案为sum + Cn</p><p>否则 只有sum * 2 + 1个数可以（拿Cn去插 sum的空）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">numberOfWeeks</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; milestones)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> m = *<span class="hljs-built_in">max_element</span>(milestones.<span class="hljs-built_in">begin</span>(), milestones.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> rest = <span class="hljs-built_in">accumulate</span>(milestones.<span class="hljs-built_in">begin</span>(), milestones.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) - m;<br>        <span class="hljs-keyword">if</span> (m &gt; rest + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> rest * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> rest + m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="104-货仓选址-AcWing题库"><a href="#104-货仓选址-AcWing题库" class="headerlink" title="104. 货仓选址 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/106/">104. 货仓选址 - AcWing题库</a></h2><ul><li>3&#x2F;5</li></ul><p>尽量选在中间位置 比如1  2   6 9</p><p>选择在2 6 中间   距离和为 2x - 3 + 15 - 2x &#x3D; 12</p><p>选在6 9中间为 9 - x - 9 + 3x 并且x &gt; 6  sum  &gt; 12</p><p>所以在中间是最好的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        left += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> + n % <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        right += nums[i];<br>    &#125;<br>    cout&lt;&lt;right - left&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0填充-蓝桥云课-lanqiao-cn"><a href="#0填充-蓝桥云课-lanqiao-cn" class="headerlink" title="0填充 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/3519/learning/">0填充 - 蓝桥云课 (lanqiao.cn)</a></h2><ul><li>3&#x2F;6</li></ul><p>贪心的策略 从0到n 一旦遇到了两两凑成一对的 就直接计入结果并且跳过i + 1</p><p>如果遇到？ 大概有这几种情况 0??1   0?可以 ?1 可以</p><p>??11    ??可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>  string s;<br>  cin&gt;&gt;s;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>] || s[i] == <span class="hljs-string">&#x27;?&#x27;</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>)<br>      &#123;<br>          ans++;<br>          i++;<br>      &#125;<br>  &#125;<br>  cout&lt;&lt;ans;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-糖果传递-AcWing题库"><a href="#122-糖果传递-AcWing题库" class="headerlink" title="122. 糖果传递 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/124/">122. 糖果传递 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>[环形]均分纸牌问题</p><img src="../images/$%7Bfiilename%7D/image-20240302163447063.png" alt="image-20240302163447063" style="zoom:67%;" /><p>推公式：先设每个人要给左边的$x_i$个 从右边拿到$x_{i + 1}$个 （只需要给旁边的 因为就算跨着给 结果也是一样的 直接设只给旁边的好算） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], temp[N], c[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    ll sum = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>        sum += a[i];<br>    &#125;<br>    ll ave = sum / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        temp[i] = ave - a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>] = temp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        c[i] = c[i - <span class="hljs-number">1</span>] + temp[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(c, c + n);<br>    <span class="hljs-type">int</span> xn = c[n / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        ret += <span class="hljs-built_in">abs</span>(c[i] - xn);<br>    &#125;<br>    cout&lt;&lt;ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="112-雷达设备-AcWing题库"><a href="#112-雷达设备-AcWing题库" class="headerlink" title="112. 雷达设备 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/114/">112. 雷达设备 - AcWing题库</a></h2><ul><li>3&#x2F;11</li></ul><p>本来想这样贪心：先按x从小到大 相同x的y从大到小排序 不断选取最右边的值 但是有些情况不符合 <img src="../images/$%7Bfiilename%7D/image-20240302195003434.png" alt="image-20240302195003434" style="zoom:25%;" /></p><p>所以要先求出每个岛的探测区间 然后再按区间合并的方法来做</p><p>按右端点排序 排完序后如果一个区间的左端点小于last区间的右端点 那么就说明他们可以共用一个雷达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; PII;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> r first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> l second</span><br>PII seg[<span class="hljs-number">100010</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> INF = <span class="hljs-number">1e10</span>, eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, d;<br>    cin &gt;&gt; n &gt;&gt; d;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span> (y &gt; d)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">sqrt</span>(d * d - y * y);<br>        seg[i] = &#123;x + len, x - len&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(seg, seg + n);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> last = -INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (seg[i].l &gt; last + eps)<br>        &#123;<br>            res++;<br>            last = seg[i].r;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1235-付账问题-AcWing题库"><a href="#1235-付账问题-AcWing题库" class="headerlink" title="1235. 付账问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1237/">1235. 付账问题 - AcWing题库</a></h2><p>求出平均值 当小于平均值的 时候  直接allin 当大于平均值的时候只需要给出平均值就行</p><p>关键在于不断地更新当前的平均值 </p><p>一开始想的贪心是 先把小于的全部给了 大于的把平均值给了 然后算差的钱的平均值 再从大的里面减 然后不够了再去… 这样要两层循环 是$O(n^2)$的 不行</p><p>可以对每一个数都更新一下当前的平均值 小于的全部给  但是由于小于平均值 这里要更新一下当前的平均值 因为这人给的不够 后面要多给   由于<strong>排序</strong>了 如果有人够了 就直接给平均值的钱就行 因为后面的必然够</p><p>注意同时计算sum</p><p>注意这题爆double了（哭   要用long double<img src="../images/$%7Bfiilename%7D/image-20240302205938546.png" alt="image-20240302205938546" style="zoom:25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">500010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> ave = s * <span class="hljs-number">1.0</span> / n ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> cur_ave = ave;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(nums, nums + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= cur_ave)<br>        &#123;<br>            s -= nums[i];<br>            sum += (ave - nums[i]) * (ave - nums[i]);<br>            cur_ave = s  * <span class="hljs-number">1.0</span> / (n - i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            sum += (cur_ave - ave) * (cur_ave - ave);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4llf&quot;</span>,<span class="hljs-built_in">sqrt</span>(sum / n));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1239-乘积最大-AcWing题库"><a href="#1239-乘积最大-AcWing题库" class="headerlink" title="1239. 乘积最大 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1241/">1239. 乘积最大 - AcWing题库</a></h2><ul><li>3&#x2F;7</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">k是奇数则 如果全是负数 结果为负</span><br><span class="hljs-comment">否则先选一个正数（最大的） 变为k是偶数的情况</span><br><span class="hljs-comment">k是偶数则答案必然是正的 看负数的个数 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL ;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span> , mod = <span class="hljs-number">1000000009</span> ;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n , k ;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br>    <span class="hljs-built_in">sort</span>(a,a + n);<br><br>    LL res = <span class="hljs-number">1</span> ; <span class="hljs-comment">//乘积初始化</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span> ;<span class="hljs-comment">//双指针初始化</span><br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span> ; <span class="hljs-comment">// 符号初始化</span><br><br>    <span class="hljs-comment">//由于4种情况除了 k 是奇数且 k &lt; n 的时候需要特判一下处理一下符号 ,其他的时候都可以转化为双指针做法</span><br>    <span class="hljs-comment">//k 是奇数是先选出最大的数, k-- 就是偶数,两边再同时取对,转化成相同的双指针做法</span><br>    <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> )<br>    &#123;<br>        res =  a[r]; <span class="hljs-comment">// 取出最大的一个数</span><br>        r -- ; <span class="hljs-comment">//右指针移动</span><br>        k -- ; <span class="hljs-comment">//个数减1</span><br><br>        <span class="hljs-keyword">if</span>(res &lt; <span class="hljs-number">0</span>) sign = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果最大值都是负数,就证明全是负数,那么符号要发生改变</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(k) <span class="hljs-comment">// 双指针做法</span><br>    &#123;<br>        LL x = (LL)a[l] * a[l + <span class="hljs-number">1</span>] , y = (LL)a[r] * a[r - <span class="hljs-number">1</span>];<span class="hljs-comment">//两边同时取对</span><br>        <span class="hljs-comment">//选择更大的一对,和归并排序思路相近</span><br>        <span class="hljs-keyword">if</span>(x * sign &gt; y * sign)<br>        &#123;<br>            res = x % mod * res % mod; <span class="hljs-comment">// 需要注意的是 :不可以写成(x * res) % mod ,也不可以写成是 res % mod * x % mod</span><br>                                       <span class="hljs-comment">// 因为x最大是 10^10，如果不先取模的话，和res相乘的结果最大是 10^19,会暴long long。            </span><br>            l += <span class="hljs-number">2</span>; <span class="hljs-comment">// 指针移动                                 </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            res = y % mod * res % mod; <br>            r -= <span class="hljs-number">2</span>; <br>        &#125;<br>        k -= <span class="hljs-number">2</span>; <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1247-后缀表达式-AcWing题库"><a href="#1247-后缀表达式-AcWing题库" class="headerlink" title="1247. 后缀表达式 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1249/">1247. 后缀表达式 - AcWing题库</a></h2><ul><li>3&#x2F;12</li></ul><p>一开始没读懂题意   后缀表达式关键在于他转换成中缀表达式 是可以随意添加括号的  所以说 根据负负得正的原则 我们可以将负数转化成正数 比如 -1 -2 -3   1 2 3   可以是1 +2+3-(-1-2-3)</p><p>贪心：先选最大的数作为基数 如果没有减号那就是全部相加 如果有一个减号 那就把所有负数变成正的  如果没有负的就要减去最小的正数   所以一开始直接减去最小的那个数 然后把1~n+m-1的数全部按绝对值加起来就可以</p><p>如果有多个减号  通过加括号 可以变成跟一个减号一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">300010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m + <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(nums, nums + n + m + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = nums[n + m];<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        res -= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + m; i++)<br>        &#123;<br>            res += <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1248-灵能传输-AcWing题库"><a href="#1248-灵能传输-AcWing题库" class="headerlink" title="1248. 灵能传输 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1250/">1248. 灵能传输 - AcWing题库</a></h2><ul><li>3&#x2F;4</li></ul><p>太困难了 最后还是没看懂题解 但是学到了：</p><p>每次中间的给两边的能量 求最小的最大值  每次传输完能量后前缀和会由 s[i - 1] s[i] s[i + 1]变成s[i] s[i - 1] s[i + 1] 这就说明了所有的前缀和都可以任意排序 当顺序排序的时候差值最小 最大值就最小</p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2024/01/18/%E4%BA%8C%E5%88%86/"/>
    <url>/2024/01/18/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="0求阶乘-蓝桥云课-lanqiao-cn"><a href="#0求阶乘-蓝桥云课-lanqiao-cn" class="headerlink" title="0求阶乘 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2145/learning/">0求阶乘 - 蓝桥云课 (lanqiao.cn)</a></h1><p>只有5 * 2 才能&#x3D;10 才可能出现0  由于2 必定比5多  只需要求5 的个数</p><p>二分法求到mid的时候前面有多少5 不断除以5就可以算出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll x;<br><span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (mid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret += mid / <span class="hljs-number">5</span>;<br>        mid /= <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin&gt;&gt;x;<br>    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">6e18</span>;<br>    ll res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        ll s = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (s &lt; x)<br>            l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(r) == x)<br>    cout&lt;&lt;r;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1236-递增三元组-AcWing题库"><a href="#1236-递增三元组-AcWing题库" class="headerlink" title="1236. 递增三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></h1><p>找这个三元组 主要是看中间一行 比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>就看B的5能和A结合几个 能和C结合几个</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">4</span> <br><span class="hljs-attribute">5</span> <br>  <span class="hljs-attribute">6</span> <span class="hljs-number">7</span>  <br></code></pre></td></tr></table></figure><p>结果为2 * 2 &#x3D; 4  </p><p>所以只需要对B的每一个数在A   C两个数组内进行二分 求出比他小的第一个数 和比他大的第一个数即可</p><p>然后注意一些下标的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums[i], nums[i] + n);<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> key = nums[<span class="hljs-number">1</span>][i];<br>        <span class="hljs-type">int</span> pos1 = <span class="hljs-built_in">lower_bound</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">0</span>] + n, key) - nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 在A中找到第一个小于key的数</span><br>        <span class="hljs-type">int</span> pos2 = <span class="hljs-built_in">upper_bound</span>(nums[<span class="hljs-number">2</span>], nums[<span class="hljs-number">2</span>] + n, key) - nums[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在C中找到第一个大于key的数</span><br>        <br>        res += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(n - pos2 + <span class="hljs-number">1</span>) * pos1;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位DP</title>
    <link href="/2024/01/17/%E6%95%B0%E4%BD%8DDP/"/>
    <url>/2024/01/17/%E6%95%B0%E4%BD%8DDP/</url>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">以第一题为例比如n = <span class="hljs-number">1234</span> 要找<span class="hljs-number">1</span>~<span class="hljs-number">1234</span>的数<br>数位DP是 一位一位地去填 看能不能填上这个数<br>比如<span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> 第一位填<span class="hljs-number">1</span> 那么第二位就只能填 <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> 中的数 （否则就会超出<span class="hljs-number">1234</span>）<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> 第二位填<span class="hljs-number">1</span> 那么第三位 第四位都可以随意地填<span class="hljs-number">0</span>~<span class="hljs-number">9</span>的任何值 因为不论怎么填都不会超过<span class="hljs-number">1234</span> <br></code></pre></td></tr></table></figure><h1 id="数位DP模板"><a href="#数位DP模板" class="headerlink" title="数位DP模板"></a>数位DP模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">bool</span> isLimit, <span class="hljs-type">bool</span> isNum) -&gt; <span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h2><p>i代表现在走到第几位数</p><p>mask 根据题目而定 也可能没有 也可能是cnt等 主要用于记录题目的条件 比如第一题 用cnt 记录1的个数 第二题是用mask记录是否有重复的数字</p><p>isLimit 看是否有受到限制 这涉及到<a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">数位DP的思想</a>：</p><p>则isLimit就是判断这一位能填写的上下界（主要是上界up）如果不受限制 那就是9 受限制就是 n在这一位的值s[i]</p><p>isNum 主要是用来判断前导0的情况 如果前面有0 就不是一个数了 如果题目不含前导0则不需要</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先把n转换为字符串 然后求出长度m 初始化记忆化数组</p><p>写function函数</p><p>退出条件 一般是i &#x3D;&#x3D; m 返回 什么？</p><p>记忆化 一般是！isLimit &amp;&amp; dp[i] [cnt&#x2F;mask] !&#x3D; 0&#x2F;-1 &amp;&amp; isNum 直接return</p><p>res &#x3D; 0 用于记录答案</p><p>求出最大最小值 up 和 low</p><p>循环for d in range(low, up) 在循环内递归</p><p>if (d &#x3D;&#x3D; 1 &#x2F;&#x2F; mask&gt;&gt;d&amp;1 &#x3D;&#x3D; 0) 选择的这个d 如果满足题目条件</p><p>​就递归 res +&#x3D; f(i + 1, ???, isLimit &amp;&amp; d &#x3D;&#x3D; up, ???) 注意更新状态 </p><p>最后 还需要写入记忆化 if(!isLimit &amp;&amp; isNum)dp[i] [cnt&#x2F; mask] &#x3D; res</p><p>return res</p><p>注意初始条件</p><h1 id="233-数字-1-的个数-力扣（LeetCode）"><a href="#233-数字-1-的个数-力扣（LeetCode）" class="headerlink" title="233. 数字 1 的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-digit-one/solutions/1750339/by-endlesscheng-h9ua/">233. 数字 1 的个数 - 力扣（LeetCode）</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">to_string</span>(n);<br>    <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), dp[m][m];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> cnt, <span class="hljs-type">bool</span> isLimit) -&gt; <span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == m)<br>                <span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[i][cnt] &gt;= <span class="hljs-number">0</span>) <br>                <span class="hljs-keyword">return</span> dp[i][cnt];<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br>            <span class="hljs-type">int</span> up = isLimit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= up; d++)<br>            &#123;<br>                res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, cnt + (d == <span class="hljs-number">1</span>), isLimit &amp;&amp; d == up);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit) dp[i][cnt] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 一开始需要限制</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="2376-统计特殊整数-力扣（LeetCode）"><a href="#2376-统计特殊整数-力扣（LeetCode）" class="headerlink" title="2376. 统计特殊整数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-special-integers/description/">2376. 统计特殊整数 - 力扣（LeetCode）</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>     string s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), dp[m][<span class="hljs-number">1</span>&lt;&lt;m];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">int</span> isLimit, <span class="hljs-type">int</span> isNum) -&gt; <span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == m)<br>                <span class="hljs-keyword">return</span> isNum;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> dp[i][mask];<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!isNum)<br>                res = <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            <span class="hljs-type">int</span> up = isLimit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">9</span>;<br>            <span class="hljs-type">int</span> low = isNum ? <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = low; d &lt;= up; d++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> ((mask&gt;&gt;d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>                    res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask | (<span class="hljs-number">1</span>&lt;&lt;d), isLimit &amp;&amp; up == d, <span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum)<br>                dp[i][mask] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3007-价值和小于等于-K-的最大数字-力扣（LeetCode）"><a href="#3007-价值和小于等于-K-的最大数字-力扣（LeetCode）" class="headerlink" title="3007. 价值和小于等于 K 的最大数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/">3007. 价值和小于等于 K 的最大数字 - 力扣（LeetCode）</a></h1><p>二分+数位DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ll <span class="hljs-title">CntDigitOne</span><span class="hljs-params">(ll n, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">64</span> - __builtin_clzll(n);<br>        ll dp[m][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><br>        function&lt;ll(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt;f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> isLimit) -&gt; ll<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[i][cnt] &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> dp[i][cnt];<br>            ll res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> up = isLimit? n&gt;&gt;i &amp; <span class="hljs-number">1</span>: <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= up; d++)<br>            &#123;<br>                res += <span class="hljs-built_in">f</span>(i - <span class="hljs-number">1</span>, cnt + (d == <span class="hljs-number">1</span> &amp;&amp; ((i + <span class="hljs-number">1</span>) % x == <span class="hljs-number">0</span>)), isLimit &amp;&amp; up == d);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isLimit)dp[i][cnt] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(m - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findMaximumNumber</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ll left = <span class="hljs-number">1</span>, right = (k + <span class="hljs-number">1</span>) &lt;&lt; x;<br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            ll mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            ll s = <span class="hljs-built_in">CntDigitOne</span>(mid, x);<br>            <span class="hljs-keyword">if</span> (s &lt;= k)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                res = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贡献法</title>
    <link href="/2023/11/27/%E8%B4%A1%E7%8C%AE%E6%B3%95/"/>
    <url>/2023/11/27/%E8%B4%A1%E7%8C%AE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="828-统计子串中的唯一字符-力扣（LeetCode）"><a href="#828-统计子串中的唯一字符-力扣（LeetCode）" class="headerlink" title="828. 统计子串中的唯一字符 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/?envType=daily-question&envId=2023-11-26">828. 统计子串中的唯一字符 - 力扣（LeetCode）</a></h1><p>贡献法  一个字符 能贡献1 代表他在这个子数组里 是唯一的 那就求这样的子数组有多少个 那就在前后找 他上一个和下一个相同元素 这中间的所有数的子数组个数 就是贡献度</p><p>预处理这个字符的前后的相同的字符的位置 然后再用乘法原理算出来相同子数组的个数  注意这里的子数组是类子串而不是类子序列</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniqueLetterString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        res = <span class="hljs-number">0</span><br>        m = &#123;&#125;<br>        l = [<span class="hljs-number">0</span>] * n<br>        r = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            x = s[i]<br>            l[i] = m.get(x, -<span class="hljs-number">1</span>)<br>            m[x] = i<br>        m.clear()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            x = s[i]<br>            r[i] = m.get(x, n)<br>            m[x] = i<br>        <br>        res = <span class="hljs-built_in">sum</span>((i - a) * (b - i) <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(l, r)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="907-子数组的最小值之和-力扣（LeetCode）"><a href="#907-子数组的最小值之和-力扣（LeetCode）" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h1><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="2477-到达首都的最少油耗-力扣（LeetCode）"><a href="#2477-到达首都的最少油耗-力扣（LeetCode）" class="headerlink" title="2477. 到达首都的最少油耗 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">2477. 到达首都的最少油耗 - 力扣（LeetCode）</a></h1><p>计算每条边的贡献 到首都的人数是固定的 每个人要走的边也是固定的 因此可以用贡献法直接计算出每条边会有多少人经过 然后再把这个贡献 &#x2F;&#x2F; 车载数 就可以得到这条边上要消耗的油量 然后把所有边加起来就行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumFuelCost</span>(<span class="hljs-params">self, roads: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], seats: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    g = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> roads:<br>        g[a].append(b)<br>        g[b].append(a)<br>    <br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 令dfs返回这条路的人数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, fa</span>):<br>        <span class="hljs-comment"># 每条路至少有端点这一个人走</span><br>        ret = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>            <span class="hljs-keyword">if</span> y != fa:<br>                <span class="hljs-keyword">nonlocal</span> ans<br>                t = dfs(y, x)<br>                ans += (t - <span class="hljs-number">1</span>) // seats + <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 现在ret 就是这个点到终点的人数 （注意一个点可通向多个点 有多个终点 这些终点是不算在这个ret里的 而是算在fa的ret里）</span><br>            ret += t<br>        <span class="hljs-keyword">return</span> ret<br>dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> ans<br>                <br></code></pre></td></tr></table></figure><h1 id="979-在二叉树中分配硬币-力扣（LeetCode）"><a href="#979-在二叉树中分配硬币-力扣（LeetCode）" class="headerlink" title="979. 在二叉树中分配硬币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/">979. 在二叉树中分配硬币 - 力扣（LeetCode）</a></h1><p>类似于贡献法 算出棵子树的硬币总数 和结点数 就可以算出 有多少硬币要移出这棵子树  然后就可以算出 有多少硬币要移出这个子树的边<img src="/../images/$%7Bfiilename%7D/image-20231206230837411.png" alt="image-20231206230837411"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCoins</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 返回硬币数和结点数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root:TreeNode</span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            l_c, l_n = dfs(root.left)<br>            r_c, r_n = dfs(root.right)<br>          coin = l_c + r_c + root.val<br>            node = l_n + r_n + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">nonlocal</span> ans<br>            ans += <span class="hljs-built_in">abs</span>(coin - node)<br>            <span class="hljs-keyword">return</span> (coin, node)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/11/27/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2023/11/27/%E5%8D%95%E8%B0%83%E6%A0%88&amp;%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="907-子数组的最小值之和-力扣（LeetCode）"><a href="#907-子数组的最小值之和-力扣（LeetCode）" class="headerlink" title="907. 子数组的最小值之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27">907. 子数组的最小值之和 - 力扣（LeetCode）</a></h2><p>贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 </p><p>一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n</p><p>要找这样的数 每个数的前后比他更小的  就用单调栈</p><p>从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 </p><p>此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left, right = [-<span class="hljs-number">1</span>] * n, [n] * n<br>        st = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> arr[st[-<span class="hljs-number">1</span>]] &lt;= x:<br>                right[st.pop()] = i<br>            <span class="hljs-keyword">if</span> st:<br>                left[i] = st[-<span class="hljs-number">1</span>]<br>            st.append(x)<br>        res = <span class="hljs-built_in">sum</span>(a * (i - l) * (r - i) <span class="hljs-keyword">for</span> i, (l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(left, right)))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="2454-下一个更大元素-IV-力扣（LeetCode）"><a href="#2454-下一个更大元素-IV-力扣（LeetCode）" class="headerlink" title="2454. 下一个更大元素 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-iv/description/">2454. 下一个更大元素 IV - 力扣（LeetCode）</a></h2><p>要找到下下个更大的元素   其实就是用单调栈  一个单调栈用于找下一个更大的元素  两个单调栈就可以找下下个更大的元素</p><p>st1存放 (暂时没找到比他大的)元素   st2存放(已经有一个比他大)的元素</p><p>每次先判断当前元素x 是否大于st2中的元素 如果是  就直接更新ans</p><p>然后判断有多少个st1中的数可以被更新到st2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">secondGreaterElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        st1 = []<br>        st2 = []<br>        ans = [-<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">while</span> st2 <span class="hljs-keyword">and</span> nums[st2[-<span class="hljs-number">1</span>]] &lt; x:<br>                ans[st2.pop()] = x<br>            j = <span class="hljs-built_in">len</span>(st1) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[st1[j]] &lt; x:<br>                j -= <span class="hljs-number">1</span><br>            st2 += st1[j + <span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">del</span> st1[j + <span class="hljs-number">1</span>:]<br>            st1.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="1673-找出最具竞争力的子序列-力扣（LeetCode）"><a href="#1673-找出最具竞争力的子序列-力扣（LeetCode）" class="headerlink" title="1673. 找出最具竞争力的子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/">1673. 找出最具竞争力的子序列 - 力扣（LeetCode）</a></h2><p>主要是没看出来是用单调栈的题目 </p><p>一般来说需要从小到大（比如每日温度那个题）就是用单调栈</p><p>这个题目就满足 为了取最小的数 需要小数放前面 大数放后面 而且要按照数组中出现的顺序 所以可以考虑用单调栈</p><p>特别的是 这个题还有数量要求 必须是k个数字</p><p><strong>那就设置last &#x3D; n - k 表示pop的次数</strong> 在单调栈循环内 如果pop超过了last次 后面就不再pop了 否则数量不够k个  在单调栈循环结束后 如果last大于0 表示超过了k个数 需要再pop掉last次 由于小的数字放越前面越好 所以pop肯定是越早越好 所以就是遇到可以pop的就pop 后面的次数不够了就直接push进来</p><p>然后注意这题单调栈里面放的是数 不是下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mostCompetitive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> last = n - k;<br>        vector&lt;<span class="hljs-type">int</span>&gt;st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; last &gt; <span class="hljs-number">0</span> &amp;&amp; st.<span class="hljs-built_in">back</span>() &gt; nums[i])<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                last--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(last--)<br>            st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> st;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2302-统计得分小于-K-的子数组数目-力扣（LeetCode）"><a href="#2302-统计得分小于-K-的子数组数目-力扣（LeetCode）" class="headerlink" title="2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）</a></h2><p>这题首先是个数学问题  当出现连续的子数组的时候 每次答案增加的数量是 <strong>r - l + 1</strong> 知道这个之后就好想到滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0L</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++)<br>        &#123;<br>            sum += nums[r];<br>            <span class="hljs-keyword">while</span> (sum * (r - l + <span class="hljs-number">1</span>) &gt;= k) <span class="hljs-comment">// zhu&#x27;yi&#x27;shi</span><br>            &#123;<br>                sum -= nums[l++];<br>            &#125;<br>            ans += r - l + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2023/11/25/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2023/11/25/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="P4779-【模板】单源最短路径（标准版）-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4779-【模板】单源最短路径（标准版）-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>板子题 注意几个点 </p><p>1.dis数组的初始化   dis[s] &#x3D; 0</p><p>2.整体的思路 最小堆的创建  尤其注意cmp函数 里面是<strong>大于</strong>不是小于</p><p>3.vis数组 在哪里更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;edge[N];<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> head[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].w = w;<br>edge[idx].to = to;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br><span class="hljs-type">int</span> dist, id;<br><span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dist, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">dist</span>(dist), <span class="hljs-built_in">id</span>(id) &#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.dist &gt; b.dist;<br>&#125;<br>&#125;;<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt; q;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dis[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(<span class="hljs-number">0</span>, s));<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (vis[p])<br><span class="hljs-keyword">continue</span>;<br>vis[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to, w = edge[e].w;<br><br>dis[to] = <span class="hljs-built_in">min</span>(dis[to], dis[p] + w);<br><span class="hljs-keyword">if</span> (!vis[to])<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(dis[to], to));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m, s;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)dis[i] = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-built_in">dijkstra</span>(s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P3385-【模板】负环-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3385-【模板】负环-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3385 【模板】负环 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3385">P3385 【模板】负环 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>spfa板子 用spfa判负环</p><p>注意</p><p>1.一定一定一定非常注意 spfa函数的初始化 q.push 、dis  inq  inqc有没有初始化  </p><p>2.每次如何更新inq inqc dis q </p><p>3.判负环 就是看inqc有没有&gt;&#x3D;n （同一个点的松弛次数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;;<br>edges edge[N];<br><span class="hljs-type">int</span> idx, head[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].to = to;<br>edge[idx].w = w;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> inq[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(s);<br>inq[s] = <span class="hljs-number">1</span>;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> inqc[N] = &#123; <span class="hljs-number">0</span> &#125;;<br>inqc[s] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>inq[p] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to;<br><span class="hljs-keyword">if</span> (dist[to] &gt; dist[p] + edge[e].w)<br>&#123;<br>dist[to] = dist[p] + edge[e].w;<br><span class="hljs-keyword">if</span> (!inq[to])<br>&#123;<br>inqc[to]++;<br><span class="hljs-keyword">if</span> (inqc[to] &gt;= n)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>inq[to] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T = <span class="hljs-number">0</span>;<br>cin &gt;&gt; T;<br><span class="hljs-keyword">while</span> (T--)<br>&#123;<br><br>cin &gt;&gt; n &gt;&gt; m;<br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>edge[i].to = <span class="hljs-number">0</span>;<br>edge[i].next = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br><span class="hljs-keyword">if</span> (w &gt;= <span class="hljs-number">0</span>)<span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P5960-【模板】差分约束-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5960-【模板】差分约束-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5960 【模板】差分约束 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>差分约束<br>$$<br>\begin{cases} x_{c_1}-x_{c’<em>1}\leq y_1 \x</em>{c_2}-x_{c’<em>2} \leq y_2 \ \cdots\ x</em>{c_m} - x_{c’_m}\leq y_m\end{cases}<br>$$</p><p>类似于三角不等式 跟最短路的优化形式相近 考虑用最短路</p><p>变形 $x_{c1}\leq x_{c1}’ + y_1$ 即可以求最短路 </p><p>添加一个超级源点 0 求出0 到每个点的最短路 </p><p>如果不存在负环 就是有解 有负环则无解 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> v, w, next;<br>&#125;edge[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> head[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].v = v;<br>edge[idx].w = w;<br>edge[idx].next = head[u];<br>head[u] = idx;<br>&#125;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">5005</span>], tot[<span class="hljs-number">5005</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><br>vis[s] = <span class="hljs-number">1</span>;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(s);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[p] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].v, w = edge[e].w;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + w)<br>&#123;<br>dis[to] = dis[p] + w;<br><span class="hljs-keyword">if</span> (!vis[to])<br>&#123;<br><br>vis[to] = <span class="hljs-number">1</span>;<br>tot[to]++;<br><span class="hljs-keyword">if</span> (tot[to] == n + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b, c;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><span class="hljs-built_in">add</span>(a, b, c);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>))cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P1993-小-K-的农场-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1993-小-K-的农场-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1993 小 K 的农场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1993">P1993 小 K 的农场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h2><p>差分约束变形</p><p>超级源点要初始化 连接0 到所有的点 权值为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> m, n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> w, v, next;<br>&#125;edge[N];<br><br><span class="hljs-type">int</span> head[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].v = v;<br>edge[idx].w = w;<br>edge[idx].next = head[u];<br>head[u] = idx;<br>&#125;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5005</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">5005</span>], tot[<span class="hljs-number">5005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>vis[s] = <span class="hljs-literal">true</span>;<br>dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(s);<br>tot[s]++;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[p] = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].v, w = edge[e].w;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + w)<br>&#123;<br>dis[to] = dis[p] + w;<br><span class="hljs-keyword">if</span> (!vis[to])<br>&#123;<br>vis[to] = <span class="hljs-literal">true</span>;<br>tot[to]++;<br><span class="hljs-keyword">if</span> (tot[to] == n + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(to);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> c, u, v, w;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, -w);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">2</span>) <br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">3</span>)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v;<br><span class="hljs-built_in">add</span>(u, v, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">add</span>(v, u, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 超级源点0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>))cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B3611-【模板】传递闭包-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#B3611-【模板】传递闭包-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="B3611 【模板】传递闭包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/B3611">B3611 【模板】传递闭包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>传递闭包  就和离散的传递闭包一个意思 如果存在a-&gt;b b-&gt;c 那就必须有a-&gt;c 就这样加上   注意这个题要用邻接矩阵存储</p><p>用Floyd算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> g[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br>cin &gt;&gt; g[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[k][j] &amp;&amp; g[i][k])g[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br>cout &lt;&lt; g[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1144-最短路计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1144-最短路计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1144">P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>无权图 可以用BFS  先到达的必定是最短的  用deg记录这个点dfs的层数  如果这个点的层数比上一个相邻结点多1 说明找到了一条最短路 更新条数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><span class="hljs-type">int</span> deg[N], cnt[N], vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>cnt[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>deg[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : g[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[e])<br>&#123;<br>vis[e] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(e);<br>deg[e] = deg[p] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (deg[e] == deg[p] + <span class="hljs-number">1</span>)<br>cnt[e] = (cnt[e] + cnt[p]) % <span class="hljs-number">100003</span>;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; cnt[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><br><span class="hljs-built_in">bfs</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1462-通往奥格瑞玛的道路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1462-通往奥格瑞玛的道路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1462 通往奥格瑞玛的道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1462">P1462 通往奥格瑞玛的道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>神奇的二分+最短路</p><p>一开始题目看不懂  求可以到达的情况下 他所经过的所有城市中 收费最多的一次 收取的费用的最小值是多少</p><p>就是要最小化 （经过城市收费的最大值）</p><p>最大（小）化 最小（大）值 就用二分</p><p>二分钱数   check就找可以通过并且通过的钱数小于mid 的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, b;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br><span class="hljs-type">int</span> to, w, next;<br>&#125;edge[N];<br><span class="hljs-type">int</span> idx, head[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++idx].w = w;<br>edge[idx].to = to;<br>edge[idx].next = head[from];<br>head[from] = idx;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br><span class="hljs-type">int</span> id, dis;<br><span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dis, <span class="hljs-type">int</span> id) :<span class="hljs-built_in">dis</span>(dis), <span class="hljs-built_in">id</span>(id) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.dis &gt; b.dis;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt;q;<br>q.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;);<br>dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (f[<span class="hljs-number">1</span>] &gt; mid)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (vis[p])<span class="hljs-keyword">continue</span>;<br>vis[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e; e = edge[e].next)<br>&#123;<br><span class="hljs-type">int</span> to = edge[e].to;<br><span class="hljs-keyword">if</span> (f[to] &gt; mid)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (dis[to] &gt; dis[p] + edge[e].w)<br>&#123;<br>dis[to] = dis[p] + edge[e].w;<br>q.<span class="hljs-built_in">push</span>(&#123; dis[to], to &#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (dis[n] &gt; b)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; b;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; f[i];<br>r = <span class="hljs-built_in">max</span>(f[i], r);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">add</span>(u, v, w);<br><span class="hljs-built_in">add</span>(v, u, w);<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dij</span>(INT_MAX))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;AFK&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dij</span>(mid))<br>&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; l &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P6464-传智杯-2-决赛-传送门-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P6464-传智杯-2-决赛-传送门-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P6464 传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P6464 <a href="https://www.luogu.com.cn/problem/P6464">传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>思考优化策略  从$O(n^5)$优化到$O(n^4)$</p><p>最初的想法应该是 每两个点为0都单独($O(n^2)$)再跑一遍Floyd($O(n^3)$)</p><p>但是其实不需要   而是只需要更新{加入传送门之后 距离改变了 }会影响到的那几条边   假设与l—b加上传送门  只用更新 需要中介l的点和需要中介b 的点即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> g[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>f[u][v] = f[v][u] = w;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k][j]);<br>g[i][j] = f[i][j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; l++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt; l; b++)<br>&#123;<br><br>g[l][b] = g[b][l] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 关键优化步骤</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][l] + g[l][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>&#123;<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][b] + g[b][j]);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>&#123;<br>ret += g[i][j];<br>&#125;<br>&#125;<br>ans = <span class="hljs-built_in">min</span>(ans, ret);<br><span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-built_in">sizeof</span>(f));<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P2419-USACO08JAN-Cow-Contest-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2419-USACO08JAN-Cow-Contest-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2419 USACO08JAN] Cow Contest S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2419 <a href="https://www.luogu.com.cn/problem/P2419">USACO08JAN] Cow Contest S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>关键在于 能够确定排名的牛  是怎么看的</p><p>能确定排名 就是直到有几只牛比他高 有几只牛比他低 用有向图表示 弧尾表示赢的牛 弧头表示输的牛 </p><p>那么入度就是输给几头牛的数  出度就是赢了几头牛 当入度+出度&#x3D;n-1的时候  代表他已经确定和其他n - 1头牛的关系了 说明可以排名</p><p>入度和出度 可以用bfs 正反图+dfs（因为间接赢也是赢）来求</p><p>也可以用floyd再计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 胜利者指向失败者</span><br><span class="hljs-comment">* 入度是被多少牛打败</span><br><span class="hljs-comment">* 出度是打败了多少牛</span><br><span class="hljs-comment">* 能确定排名就是 入度 + 出度 = n - 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N], rg[N];<br><span class="hljs-type">int</span> win[N], lose[N];<br><span class="hljs-type">int</span> win_c, lose_c;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_win</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : g[i])<br><span class="hljs-keyword">if</span> (!win[y])<br>&#123;<br>win[y] = <span class="hljs-number">1</span>;<br>win_c++;<br><span class="hljs-built_in">dfs_win</span>(y);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_lose</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : rg[i])<br><span class="hljs-keyword">if</span> (!lose[y])<br>&#123;<br>lose[y] = <span class="hljs-number">1</span>;<br>lose_c++;<br><span class="hljs-built_in">dfs_lose</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>rg[v].<span class="hljs-built_in">push_back</span>(u);<br><br>&#125;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>win_c = lose_c = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(win, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(win));<br><span class="hljs-built_in">memset</span>(lose, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(lose));<br><span class="hljs-built_in">dfs_win</span>(i);<br><span class="hljs-built_in">dfs_lose</span>(i);<br><span class="hljs-comment">//cout &lt;&lt; win_c &lt;&lt; lose_c &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (win_c + lose_c == n - <span class="hljs-number">1</span>)ret++;<br>&#125;<br>cout &lt;&lt; ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1073-NOIP2009-提高组-最优贸易-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1073-NOIP2009-提高组-最优贸易-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1073 NOIP2009 提高组] 最优贸易 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1073 <a href="https://www.luogu.com.cn/problem/P1073">NOIP2009 提高组] 最优贸易 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>由于边权为1 考虑BFS  </p><p>权值在点上  可以预处理出一个中转点i i满足通路 1~i  i ~ n （即首先需要能够到达n才行）</p><p>然后再1<del>i上找一个点买入  i</del>n找一个点卖出 则可以用<strong>两次bfs</strong>求出1<del>i的每个点的最小值 i</del>n的每个点的最大值 （求i<del>n可以存反图 求n</del>i的点 然后求与1~i 的交集）</p><p>最后遍历1~n 即令每个点都为中转点 求出哪个点作为中转时最大</p><p>注意 1 和n 作为中转也可以  要给1和n赋初值 当<strong>重复</strong>经过的时候也必须算上 就是说BFS的vis即使已经为1 maxn和minn也要进行比较赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> mon[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;G[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;rg[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> maxn[N], minn[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[v])<br>&#123;<br>q.<span class="hljs-built_in">push</span>(v);<br>vis[v] = <span class="hljs-number">1</span>;<br><br>&#125;<br>minn[v] = <span class="hljs-built_in">min</span>(minn[p], mon[v]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : rg[p])<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[v])<br>&#123;<br>q.<span class="hljs-built_in">push</span>(v);<br>vis[v] = <span class="hljs-number">1</span>;<br><br>&#125;<br>maxn[v] = <span class="hljs-built_in">max</span>(maxn[p], mon[v]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">memset</span>(maxn, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(maxn));<br><span class="hljs-built_in">memset</span>(minn, <span class="hljs-number">10</span>, <span class="hljs-built_in">sizeof</span>(minn));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; mon[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> u, v, t;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;<br>rg[v].<span class="hljs-built_in">push_back</span>(u);<br>G[u].<span class="hljs-built_in">push_back</span>(v);<br><br><span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">1</span>)<br>&#123;<br>G[v].<span class="hljs-built_in">push_back</span>(u);<br>rg[u].<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br>&#125;<br>minn[<span class="hljs-number">1</span>] = maxn[<span class="hljs-number">1</span>] = mon[<span class="hljs-number">1</span>];<br>maxn[n] = minn[n] = mon[n];<br><span class="hljs-built_in">bfs1</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">bfs2</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; minn[i] &lt;&lt; &quot; &quot; &lt;&lt; maxn[i] &lt;&lt; endl;</span><br>ret = <span class="hljs-built_in">max</span>(ret, maxn[i] - minn[i]);<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2023/11/16/Trie%E6%A0%91/"/>
    <url>/2023/11/16/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="2935-找出强数对的最大异或值-II-力扣（LeetCode）"><a href="#2935-找出强数对的最大异或值-II-力扣（LeetCode）" class="headerlink" title="2935. 找出强数对的最大异或值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/submissions/482713400/">2935. 找出强数对的最大异或值 II - 力扣（LeetCode）</a></h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>():<br>    __slots__ = <span class="hljs-string">&#x27;children&#x27;</span>, <span class="hljs-string">&#x27;cnt&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.children = [<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]<br>        self.cnt = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>():<br>    HIGH_BIT = <span class="hljs-number">19</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = Node()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cur.children[bit] = Node()<br>            cur = cur.children[bit]<br>            cur.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = self.root<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            cur = cur.children[(val &gt;&gt; i) &amp; <span class="hljs-number">1</span>]<br>            cur.cnt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cur<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_xor</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cur = self.root<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Trie.HIGH_BIT, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            bit = (val &gt;&gt; i) &amp; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur.children[bit ^ <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> cur.children[bit ^ <span class="hljs-number">1</span>].cnt:<br>                ans |= <span class="hljs-number">1</span> &lt;&lt; i<br>                bit ^= <span class="hljs-number">1</span><br>            cur = cur.children[bit]<br>        <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumStrongPairXor</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        root = Trie()        <br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ret = left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> nums:<br>            root.insert(y)<br>            <span class="hljs-keyword">while</span> nums[left] * <span class="hljs-number">2</span> &lt; y:<br>                root.remove(nums[left])<br>                left += <span class="hljs-number">1</span><br>            ret = <span class="hljs-built_in">max</span>(ret, root.max_xor(y))            <br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/10/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/10/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="斐波那契型"><a href="#斐波那契型" class="headerlink" title="斐波那契型"></a>斐波那契型</h1><h2 id="一般是直观的状态转移-选或不选的问题"><a href="#一般是直观的状态转移-选或不选的问题" class="headerlink" title="一般是直观的状态转移  选或不选的问题"></a>一般是直观的状态转移  选或不选的问题</h2><p>dp[i] 表示前i个最多能有多少钱   每个选还是不选？因为选了这个 就不能选下一个 由此得出状态转移方程 dp[i] &#x3D; max(dp[i - 2] + cost[i], dp[i - 1])  选了这个 就需要加上这个的值（并且不能选i - 1） 不选这个 就直接从i - 1转移</p><p>初始化 视情况而定 一般初始化 dp[0] 、dp[1] 等 前几个元素</p><h3 id="198-打家劫舍-力扣（LeetCode）"><a href="#198-打家劫舍-力扣（LeetCode）" class="headerlink" title="198. 打家劫舍 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=dynamic-programming">198. 打家劫舍 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i])<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="740-删除并获得点数-力扣（LeetCode）-https-leetcode-cn-problems-delete-and-earn-envType-study-plan-v2-envId-dynamic-programming"><a href="#740-删除并获得点数-力扣（LeetCode）-https-leetcode-cn-problems-delete-and-earn-envType-study-plan-v2-envId-dynamic-programming" class="headerlink" title="740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&amp;envId=dynamic-programming)"></a>740. 删除并获得点数 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&envId=dynamic-programming">https://leetcode.cn/problems/delete-and-earn/?envType=study-plan-v2&amp;envId=dynamic-programming</a>)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAndEarn</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">max</span>(nums)<br>        cost = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            cost[x] += x<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>     <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + cost[i], dp[i - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h1 id="矩阵型"><a href="#矩阵型" class="headerlink" title="矩阵型"></a>矩阵型</h1><h2 id="一般是类似于走迷宫-用二维的-dp-i-j"><a href="#一般是类似于走迷宫-用二维的-dp-i-j" class="headerlink" title="一般是类似于走迷宫 用二维的 dp[i] [j]"></a>一般是类似于走迷宫 用二维的 dp[i] [j]</h2><p>i，j表示坐标   状态从上一坐标 转移而来  一般是相邻的位置 比如i - 1 j - 1 等</p><p>注意 这类问题 一般需要判断该位置是否已经走过？  比如求最大值可以设初值为0 判断为0即未访问 求最小值设为inf等</p><p>得到状态转移方程为  dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]) + cost[]</p><p>初始化一般是用于转移的前几个数</p><p>由于数组的原因 下标经常从1开始 到n+1结束 相应的cost数组的下标也需要改变</p><h3 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths/?envType=study-plan-v2&envId=dynamic-programming">62. 不同路径 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">0</span>:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h3 id="64-最小路径和-力扣（LeetCode）"><a href="#64-最小路径和-力扣（LeetCode）" class="headerlink" title="64. 最小路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&envId=dynamic-programming">64. 最小路径和 - 力扣（LeetCode）</a></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">10</span> ** <span class="hljs-number">9</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h3 id="221-最大正方形-力扣（LeetCode）"><a href="#221-最大正方形-力扣（LeetCode）" class="headerlink" title="221. 最大正方形 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=dynamic-programming">221. 最大正方形 - 力扣（LeetCode）</a></h3><p>这题同样是矩阵型 </p><p>dp[i] [j] 表示以i j 为右下角的最大正方形的 边长 每次看他的上、左和上左 三个格子的最大边长  + 1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">len</span>(matrix)<br>        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                ret = <span class="hljs-built_in">max</span>(ret, dp[i][j])<br>        <span class="hljs-keyword">return</span> ret ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2304-网格中的最小路径代价-力扣（LeetCode）"><a href="#2304-网格中的最小路径代价-力扣（LeetCode）" class="headerlink" title="2304. 网格中的最小路径代价 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">2304. 网格中的最小路径代价 - 力扣（LeetCode）</a></h2><p>想到 从第一行开始取数 然后向下转移 </p><p>比如g[0] [0] 就可以到 g[1] [0]….g[1] [m - 1]这样</p><p>于是用dfs(i, j) 来表示状态  在第i行第j列的最小值 </p><p>然后就要考虑怎么递增 从i j 递增到下一行的第k个 那么下一行第k个的值 就是dfs(i + 1, k) + moveCost[grid[i] [j]] [k] </p><p>然后考虑退出条件  不断向下 那肯定就是到第n - 1行结束 </p><p>结束的时候要返回什么？ 这和存的东西 有关  dfs（i, j）表示i j 的最小值 然后往下转移 最后一行不再往下转移 最小值就是它本身</p><p>然后通过这个转移的过程 可以发现 i j处的最小值  其实是i j 加上 从i j往下 的所有的（也就是  我们最后会把所有的都加到第0行 返回第0行的最小值）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], moveCost: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> grid[i][j]<br>           ret = inf<br>            <span class="hljs-comment"># 注意 这里算的是 i j 的最小值 那就是i j 往下转移到下一行每一个 求最小</span><br>            <span class="hljs-keyword">for</span> k, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moveCost):<br>                res = <span class="hljs-built_in">min</span>(res, dfs(i + <span class="hljs-number">1</span>, k) + c)<br>            <span class="hljs-keyword">return</span> res + grid[i][j] <span class="hljs-comment"># 记得加上grid</span><br>        <span class="hljs-comment"># 由dfs函数 就可以计算出 i j的最小值 -》算出0 j 的最小值 所以 还需要遍历0~m-1找第0行的最小值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(<span class="hljs-number">0</span>, j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m))<br></code></pre></td></tr></table></figure><p>然后翻译成递推</p><ul><li>dfs改dp</li><li>递归改循环</li><li>递归边界改为dp初始值</li><li>递归入口即为答案</li></ul><p>dfs(i, j) -&gt; dp[i] [j]  几个参数 就是几维</p><p>dp[-1] &#x3D; grid[-1] 递归的边界 最后一行 就是初始值 因为我们算i j 的时候 其实是必须先算出来 i + 1 k 的值 然后再往上转移的</p><p>所以i要从下往上遍历  最后dp[0]  的最小值就是答案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], moveCost: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[inf] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[-<span class="hljs-number">1</span>] = grid[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">for</span> k, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(moveCost):<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i + <span class="hljs-number">1</span>][k] + c, dp[i][j])<br>             dp[i][j] += grid[i][j]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h2 id="1212-地宫取宝-AcWing题库"><a href="#1212-地宫取宝-AcWing题库" class="headerlink" title="1212. 地宫取宝 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝 - AcWing题库</a></h2><p>这个题目与上一个题有点像 都是矩阵型 状态转移方程也是由左(j  - 1)上(i - 1)转移到[i, j]</p><p>四维DP      状态表示 dp[i] [j] [cnt] [d] 表示i到j中 拿到cnt个物品且最大价值为d的情况</p><p>状态计算 有选或不选两种 （只有当拿的东西不多于k并且价值大于当前最大价值才可以拿）</p><p>不选就直接转移   dp[i] [j] [c] [d] &#x3D; (dp[i] [j] [c] [d] + dp[i - 1] [j] [c] [d]) % mod;</p><p>选的话 需要从c - 1转移过来 并且要加上所有价值小于d的情况</p><p>最后需要加上所有的最大价值的情况 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>, mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>, M = <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> nums[N][N], dp[N][N][M][M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;row&gt;&gt;col&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            cin&gt;&gt;nums[i][j];<br>            nums[i][j]++;<br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= k; c++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; M; d++)<br>                &#123;<br>                    <span class="hljs-comment">// 不选</span><br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c][d]) % mod;<br>                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c][d]) % mod;<br>                    <span class="hljs-comment">// 选</span><br>                    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d == nums[i][j])<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; d; s++)<br>                        &#123;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - <span class="hljs-number">1</span>][j][c - <span class="hljs-number">1</span>][s]) % mod;<br>                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - <span class="hljs-number">1</span>][c - <span class="hljs-number">1</span>][s]) % mod;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; M; i++)<br>    &#123;<br>        res = (res + dp[row][col][k][i])%mod;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单字符串型"><a href="#单字符串型" class="headerlink" title="单字符串型"></a>单字符串型</h1><p>在单个字符串上进行操作  一般状态表示也是两个变量 i， j 然后取出一个区间   j 一般表示端点 s[i:j]或s[j: i]</p><p>初始化 一般需要初始化大量的字符串  比如 回文串 需要初始化每个s[i:i] 为1 </p><h3 id="5-最长回文子串-力扣（LeetCode）"><a href="#5-最长回文子串-力扣（LeetCode）" class="headerlink" title="5. 最长回文子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/?envType=study-plan-v2&envId=dynamic-programming">5. 最长回文子串 - 力扣（LeetCode）</a></h3><p>dp[i] [j] 表示i到j是否为回文串   状态转移为  看12…..21 比如 1 &#x3D;&#x3D; 1 那就看前面 一段2…..2是不是回文 </p><p>如果1 !&#x3D; 1 那就直接false</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> s<br>       begin = <span class="hljs-number">0</span><br>     max_len = <span class="hljs-number">1</span><br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 枚举长度L</span><br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                j = i + L - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> j &gt;= n:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> s[i] != s[j]:<br>                    dp[i][j] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<span class="hljs-comment"># s[i] = s[j]  那就看前一段是不是回文 </span><br>                    <span class="hljs-keyword">if</span> L &lt; <span class="hljs-number">3</span>:<br>                        dp[i][j] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> j - i + <span class="hljs-number">1</span> &gt; max_len:<br>                    max_len = j - i + <span class="hljs-number">1</span><br>                    begin = i<br>        <span class="hljs-keyword">return</span> s[begin:begin + max_len]<br>                <br></code></pre></td></tr></table></figure><h3 id="139-单词拆分-力扣（LeetCode）"><a href="#139-单词拆分-力扣（LeetCode）" class="headerlink" title="139. 单词拆分 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=dynamic-programming">139. 单词拆分 - 力扣（LeetCode）</a></h3><p>跟前一题很像 用dp[i]表示 前i个能不能被word拼接  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> dp[i] == <span class="hljs-literal">True</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> dp[j] == <span class="hljs-literal">False</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 当前i个是False 并且前j个事True的时候  就要从j转移到i </span><br>                <span class="hljs-keyword">if</span> s[j:i] <span class="hljs-keyword">in</span> wordDict:<br>                    s[i] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">break</span><br>         <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>                   <br></code></pre></td></tr></table></figure><h3 id="516-最长回文子序列-力扣（LeetCode）"><a href="#516-最长回文子序列-力扣（LeetCode）" class="headerlink" title="516. 最长回文子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">516. 最长回文子序列 - 力扣（LeetCode）</a></h3><p>子序列问题 不连续 一般就要用i 和 j </p><p>dp[i] [j] 表示i 到j 最长是多少</p><p>当s[i] &#x3D;&#x3D; s[j]的时候 dp[i] [j] 就可以从dp[i + 1] [j - 1]更新来</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindromeSubseq</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            ret = <span class="hljs-built_in">max</span>(ret, dp[i][j])<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="双字符串型"><a href="#双字符串型" class="headerlink" title="双字符串型"></a>双字符串型</h1><p>双字符串的题一般要用dp[i] [j] 一个用来表示第一个字符串的 第i个 一个用来表示第2个字符串的前j个</p><h3 id="72-编辑距离-力扣（LeetCode）"><a href="#72-编辑距离-力扣（LeetCode）" class="headerlink" title="72. 编辑距离 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&envId=dynamic-programming">72. 编辑距离 - 力扣（LeetCode）</a></h3><p>dp[i] [j] 表示第一个到i 第二个到j 相同的最小编辑次数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;def dfs(i, j):</span><br><span class="hljs-string">            if i &lt; 0:</span><br><span class="hljs-string">                return j + 1</span><br><span class="hljs-string">           if j &lt; 0:</span><br><span class="hljs-string">                return i + 1</span><br><span class="hljs-string">           if word1[i] == word2[j]:</span><br><span class="hljs-string">                return dfs(i - 1, j - 1)</span><br><span class="hljs-string">            return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># dfs 转 dp</span><br>        n, m = <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> word1[i] == word2[j]:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][j + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n][m]<br>        <br></code></pre></td></tr></table></figure><h3 id="115-不同的子序列-力扣（LeetCode）"><a href="#115-不同的子序列-力扣（LeetCode）" class="headerlink" title="115. 不同的子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/distinct-subsequences/description/?envType=study-plan-v2&envId=dynamic-programming">115. 不同的子序列 - 力扣（LeetCode）</a></h3><p>这题与上一题不同 在于 上一题是修改s使其与 t相等  所以 不相等的时候只需要修改 就可以相等  然后位移指针</p><p>但是这个题 是求t在x中出现的次数 也就是说t 必须全部匹配  所以t的指针j 只有在匹配的时候才能位移</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numDistinct</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;def dfs(i, j):</span><br><span class="hljs-string">            if i &lt; 0:</span><br><span class="hljs-string">                return 0</span><br><span class="hljs-string">            if j &lt; 0:</span><br><span class="hljs-string">                return 1 # 表示已经匹配</span><br><span class="hljs-string">           if s[i] == t[j]:</span><br><span class="hljs-string">                return dfs(i - 1, j - 1) + dfs(i - 1, j)  # 选或不选两种情况</span><br><span class="hljs-string">            return dfs(i - 1, j)</span><br><span class="hljs-string">       &quot;&quot;&quot;</span><br>        n, m = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s[i] == t[j]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[n][m]<br>                <br></code></pre></td></tr></table></figure><h3 id="712-两个字符串的最小ASCII删除和-力扣（LeetCode）"><a href="#712-两个字符串的最小ASCII删除和-力扣（LeetCode）" class="headerlink" title="712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/?envType=study-plan-v2&envId=dynamic-programming">712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）</a></h3><p>由于直接求最小不好求  可以选择 先求出两个字符串的ascll总和  然后求<strong>最长子序列</strong> 最后再减去最长子序列的ascll * 2 就是删除的最小和</p><p>dp[i] [j] 表示最长子序列的ascll和  （即 到s1[i] s2[j]的ascll和）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>: <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumDeleteSum</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        s = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(s1[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>        s += <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">ord</span>(s2[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-built_in">ord</span>(s1[i])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> s - dp[n][m] * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="673-最长递增子序列的个数-力扣（LeetCode）"><a href="#673-最长递增子序列的个数-力扣（LeetCode）" class="headerlink" title="673. 最长递增子序列的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/?envType=study-plan-v2&envId=dynamic-programming">673. 最长递增子序列的个数 - 力扣（LeetCode）</a></h3><p>先是找最长的递增子序列 用maxn记录最长的长度 dp[i] 记录到i的最长子序列长度 （最长递增子序列） </p><p>由于本题求得是个数 需要增加cnt[i] 表示 到i 的最长递增子序列的个数 </p><p>对于每个i  遍历0 ~ i的每个j 如果nums[i] &gt; nums[j] 说明i 可以接在j后面形成递增子序列 </p><p>如果dp[i] &lt; dp[j] + 1那么说明到i的最长递增子序列的长度需要更新  那么到i 的最长子序列的数量 可以直接更新(到j的数量 直接转移到 到i的数量 )</p><p>如果dp[i] &#x3D;&#x3D; dp[j] + 1 那么说明到i这个地方 他的最长递增子序列（并非整个数组最长而是0~i最长）的数量+&#x3D; 到j的数量</p><p>最后把到每个i 的等于maxn的数量加起来</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNumberOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        cnt = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        maxn = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i] = <span class="hljs-number">1</span><br>            cnt[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    <span class="hljs-keyword">if</span> dp[i] &lt; dp[j] + <span class="hljs-number">1</span>:<br>                        dp[i] = dp[j] + <span class="hljs-number">1</span><br>                        cnt[i] = cnt[j]<br>                    <span class="hljs-keyword">elif</span> dp[i] == dp[j] + <span class="hljs-number">1</span>:<br>                        cnt[i] += cnt[j]<br>            maxn = <span class="hljs-built_in">max</span>(maxn, dp[i])<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> dp[i] == maxn:<br>                ret += cnt[i]<br>        <span class="hljs-keyword">return</span> ret<br>                        <br></code></pre></td></tr></table></figure><h2 id="646-最长数对链-力扣（LeetCode）"><a href="#646-最长数对链-力扣（LeetCode）" class="headerlink" title="646. 最长数对链 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/description/?envType=study-plan-v2&envId=dynamic-programming">646. 最长数对链 - 力扣（LeetCode）</a></h2><p>模板题 最长上升子序列</p><p>状态表示dp[i] 表示到i 到j 的最长链 </p><p>状态转移 i + 1的l如果大于i的r</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLongestChain</span>(<span class="hljs-params">self, pairs: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(pairs)<br>        pairs.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> pairs[j][<span class="hljs-number">1</span>] &lt; pairs[i][<span class="hljs-number">0</span>]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i])<br>                <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h1 id="公共子序列型"><a href="#公共子序列型" class="headerlink" title="公共子序列型"></a>公共子序列型</h1><p>一般需要二维 i用来表示到text1   j表示到text2 的时候最长公共子序列为多长</p><p>更新状态一般是当text1[i - 1] &#x3D;&#x3D; text2[i - 1]的时候就是dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1 意思是到i j 公共子序列长度增加</p><p>否则就是选出dp[i - 1] [j] 和dp[i] [j - 1] 中较大的</p><h2 id="1143-最长公共子序列-力扣（LeetCode）"><a href="#1143-最长公共子序列-力扣（LeetCode）" class="headerlink" title="1143. 最长公共子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">1143. 最长公共子序列 - 力扣（LeetCode）</a></h2><p>dp[i] [j] </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>        dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h1 id="0数组切分-蓝桥云课-lanqiao-cn"><a href="#0数组切分-蓝桥云课-lanqiao-cn" class="headerlink" title="0数组切分 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2148/learning/">0数组切分 - 蓝桥云课 (lanqiao.cn)</a></h1><p>类似最长子串的问题 判断条件变为 连续数字</p><p>判断连续的数字 就用i - j &#x3D;&#x3D; max - min 从i到j中的最大值与最小值的差等于i - j的话 那么这个范围内的数字就是连续的</p><p>dp[i] 表示前i个数共有多少种表示方法</p><p>二重循环从i到0 倒着找 如果找到了一个范围j~i使得里面的数字连续的话  (原来前i个数 共有dp[i] 种表示方法  前j - 1个数共有dp[j - 1]种)  那么现在dp[i] &#x3D; dp[i] + dp[j - 1] 因为前j - 1的方案数 现在j ~i也可以了 就可以接上 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>], dp[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> ma = a[i], mi = a[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i - j == ma - mi)<br>            &#123;<br>                dp[i] = (dp[i] + dp[j - <span class="hljs-number">1</span>]) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n];<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1035-不相交的线-力扣（LeetCode）"><a href="#1035-不相交的线-力扣（LeetCode）" class="headerlink" title="1035. 不相交的线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/uncrossed-lines/description/?envType=study-plan-v2&envId=dynamic-programming">1035. 不相交的线 - 力扣（LeetCode）</a></h2><p>最长公共子序列  同时要满足线不能相交（也就是要有序 ）其实跟最长公共子序列一样</p><h2 id="1312-让字符串成为回文串的最少插入次数-力扣（LeetCode）"><a href="#1312-让字符串成为回文串的最少插入次数-力扣（LeetCode）" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/?envType=study-plan-v2&envId=dynamic-programming">1312. 让字符串成为回文串的最少插入次数 - 力扣（LeetCode）</a></h2><p>也是最长公共子序列 只不过不是两个字符串  而是一个字符串 从前往后 一个字符串从后往前 来比较</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minInsertions</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j  - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> n - dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="树上DP"><a href="#树上DP" class="headerlink" title="树上DP"></a>树上DP</h1><h2 id="96-不同的二叉搜索树-力扣（LeetCode）"><a href="#96-不同的二叉搜索树-力扣（LeetCode）" class="headerlink" title="96. 不同的二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/?envType=study-plan-v2&envId=dynamic-programming">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></h2><p>求二叉搜索树的种数  就是G[0] &#x3D; 1 G[1] &#x3D; 1 G[2] &#x3D; 2</p><p><img src="/../images/$%7Bfiilename%7D/image-20231125183323873.png" alt="image-20231125183323873"></p><p>卡特兰数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numTrees</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        g[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>           <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>):<br>                g[i] += g[j - <span class="hljs-number">1</span>] * g[i - j]<br>        <span class="hljs-keyword">return</span> g[n]<br></code></pre></td></tr></table></figure><h2 id="95-不同的二叉搜索树-II-力扣（LeetCode）"><a href="#95-不同的二叉搜索树-II-力扣（LeetCode）" class="headerlink" title="95. 不同的二叉搜索树 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/?envType=study-plan-v2&envId=dynamic-programming">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></h2><p>搜索 首先想要递归什么？递归start和end 就是每棵树包含start到end的元素</p><p>递归出口条件 就是当start &lt; end 的时候 说明没有元素 return None</p><p>然后思考如何去递归  既然是递归start和end中间的元素  那么就可以想到  左子树是start到i  右子树是i+1到end  然后再去把这两个树加上根节点拼起来  存入答案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateTrees</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[TreeNode]]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">start, end</span>):<br>            <span class="hljs-keyword">if</span> start &gt; end:<br>                <span class="hljs-keyword">return</span> [<span class="hljs-literal">None</span>, ]<br>            alltrees = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end + <span class="hljs-number">1</span>):<br>                leftTree = generate(start, i)<br>                rightTree = generate(i + <span class="hljs-number">1</span>, end)<br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> leftTree:<br>                <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rightTree:<br>                    curTree = TreeNode(i)<br>                    curTree.left = l<br>                    curTree.right = r<br>                   allTree.append(curTree)<br>            <span class="hljs-keyword">return</span> allTrees<br>        <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> n <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure><h2 id="337-打家劫舍-III-力扣（LeetCode）"><a href="#337-打家劫舍-III-力扣（LeetCode）" class="headerlink" title="337. 打家劫舍 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iii/description/?envType=study-plan-v2&envId=dynamic-programming">337. 打家劫舍 III - 力扣（LeetCode）</a></h2><p>首先思考怎么表示状态 偷或不偷  返回值表示 左边偷的钱 和右边偷的钱  如果左边或右边偷了  那么根就不能偷 否则偷根 </p><p>递归出口 当root is None的时候 就返回0，0 表示</p><p>然后是每个  当dfs(root.left) 表示偷左不偷右  right同理</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>            l_rob, r_not_rob = dfs(root.left)<br>            l_not_rob, r_rob = dfs(root.right)<br>            rob = root.val + l_not_rob + r_not_rob<br>            <span class="hljs-comment"># not_rob = l_rob + r_rob不偷根 也不一定必须偷左右  而是可以偷左右</span><br>            not_rob = <span class="hljs-built_in">max</span>(l_rob, l_not_rob) + <span class="hljs-built_in">max</span>(r_rob, r_not_rob)<br>            <span class="hljs-keyword">return</span> rob, not_rob<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(root))<br></code></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和-力扣（LeetCode）"><a href="#124-二叉树中的最大路径和-力扣（LeetCode）" class="headerlink" title="124. 二叉树中的最大路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=dynamic-programming">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></h2><p>首先思考递归表示 root</p><p>然后是递归出口 当root is None的时候 返回0</p><p>然后是算出左边的结点 右边的结点  再加上中间的  求最大值</p><p>返回最大值   注意最后的返回值要和0比较 因为有负数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = -inf<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <br>            l_val = dfs(root.left)<br>            r_val = dfs(root.right)<br>            <span class="hljs-keyword">nonlocal</span> ans <br>            ans = <span class="hljs-built_in">max</span>(l_val + r_val + root.val, ans)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l_val, r_val) + root.val, <span class="hljs-number">0</span>)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="1155-掷骰子等于目标和的方法数-力扣（LeetCode）"><a href="#1155-掷骰子等于目标和的方法数-力扣（LeetCode）" class="headerlink" title="1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）</a></h2><p>分组背包 总和为n 每个骰子只能有一个点数 选哪个的问题</p><p>并且不是分组背包求最大值的问题  而是分组背包求固定和的问题  用的转移方程是  j - ds</p><p>第三重循环枚举点数 即 从dp[i - 1] 转移到dp[i] 的情况  有dp[i - 1] [j - 1] + 1；dp[i -  1] [j - 2] + 2 ……dp[i - 1] [j - k] + k </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRollsToTarget</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span>, target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><span class="hljs-comment"># 注意数组的范围 由于可能遍历计算的最大值是超过target的 所以这里不能开target</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">max</span>(target + <span class="hljs-number">1</span>, n * k + <span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-comment"># 注意初始化 j = 0 的时候不可能 即种数为0 大于k的时候也为0 因为一个骰子最多是k（大于target不用算了 所以为0）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(target, k) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 算到n * k因为n * k 可能小于target 这时候为0</span><br>        maxn = n * k<br>        <span class="hljs-comment"># 前两个循环 是枚举dp[i][j] 前i个骰子 和为j有几种情况</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, maxn + <span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 第三个循环 状态转移 枚举第n - 1个骰子的点数 转移到i</span><br>                ds = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span>  j - ds &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ds &lt;= k:<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - ds]<br>                    dp[i][j] %= mod<br>                    ds += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> dp[n][target]<br></code></pre></td></tr></table></figure><h1 id="组合型背包"><a href="#组合型背包" class="headerlink" title="组合型背包"></a>组合型背包</h1><h2 id="518-零钱兑换-II-力扣（LeetCode）"><a href="#518-零钱兑换-II-力扣（LeetCode）" class="headerlink" title="518. 零钱兑换 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></h2><p>这个题目与上题有区别 一个是求排列数 一个是求组合数 </p><p>也就是说 上一题会把1 2 和2 1当成两种情况 但是这一题 视为同一种情况 如果按上面的写法 最后结果会偏大</p><p>本质原因是子问题的改变   我们需要加上对硬币的限制 1 2 和 2 1 是同种情况 因此可以枚举硬币而不是枚举总和  从小到大枚举硬币 就不会出现2 1这种情况</p><p>现在子问题变为 到第k个硬币 合成金额i的组合数</p><p>状态转移为dp[k] [i] &#x3D; dp[k - 1] [i] + dp[k] [i - coins[k]]  (i &gt; coins[k])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; coins.<span class="hljs-built_in">size</span>(); k++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= coins[k - <span class="hljs-number">1</span>])<br>            dp[k][i] = dp[k][i - coins[k - <span class="hljs-number">1</span>]] + dp[k - <span class="hljs-number">1</span>][i];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp[k][i] = dp[k - <span class="hljs-number">1</span>][i];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时就算交换两个for循环的顺序也不会影响结果 因为交换后子数组的状态转移方程不变 得到的结果也不变</p><p>如果要降成一维的数组 重新定义子问题为 必须选择第k个硬币的时候 凑成金额i的方案数  不能交换for循环的顺序 因为交换完之后 子问题的意义就是 对于金额i 有几种选择硬币的方案数（理解两个子问题的差别 一个是可重复一个不行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// dp[i] 表示必须选择第i个硬币时能凑成的金额的组合数</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                dp[i] += dp[i - x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            cout&lt;&lt;dp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="排列型背包"><a href="#排列型背包" class="headerlink" title="排列型背包"></a>排列型背包</h1><h2 id="322-零钱兑换-力扣（LeetCode）"><a href="#322-零钱兑换-力扣（LeetCode）" class="headerlink" title="322. 零钱兑换 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change/description/?envType=daily-question&envId=2024-03-24">322. 零钱兑换 - 力扣（LeetCode）</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//dp[i] 表示到i为止的最小硬币数</span><br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x:coins)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= amount)<br>            dp[x] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: coins)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= x)<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i - x] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">1e9</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="279-完全平方数-力扣（LeetCode）"><a href="#279-完全平方数-力扣（LeetCode）" class="headerlink" title="279. 完全平方数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=dynamic-programming">279. 完全平方数 - 力扣（LeetCode）</a></h2><p>背包问题 i 表示到i要多少数 </p><p>当i  &gt; j ^2 的时候i 就可以更新   找到最少的次数  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> num ** <span class="hljs-number">2</span> &gt; n:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> num ** <span class="hljs-number">2</span> == n:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            minn = inf<br>            j = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j ** <span class="hljs-number">2</span> &lt;= i:<br>                minn = <span class="hljs-built_in">min</span>(minn, dp[i - j ** <span class="hljs-number">2</span>])<br>                j += <span class="hljs-number">1</span><br>            dp[i] = minn + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="518-零钱兑换-II-力扣（LeetCode）-1"><a href="#518-零钱兑换-II-力扣（LeetCode）-1" class="headerlink" title="518. 零钱兑换 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/?envType=study-plan-v2&envId=dynamic-programming">518. 零钱兑换 II - 力扣（LeetCode）</a></h2><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>k 表示前k个硬币  i 表示凑成i 元</p><p>前k个硬币凑成i元的种类为 前k - 1个凑成i 元  加上 前k个硬币凑成了i - k元  就差k了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, amount: <span class="hljs-built_in">int</span>, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(coins)<br>        dp = [[<span class="hljs-number">0</span>] * (amount + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> i &gt;= coins[k - <span class="hljs-number">1</span>]:<br>                    dp[k][i] = dp[k][i - coins[k - <span class="hljs-number">1</span>]] + dp[k - <span class="hljs-number">1</span>][i]<br></code></pre></td></tr></table></figure><h1 id="定差型"><a href="#定差型" class="headerlink" title="定差型"></a>定差型</h1><p>不是 i - 1 和i 的关系 而是 每次比较 i 和i - nums[i] 这样的 某个差值nums[i] 之间的关系</p><h2 id="1218-最长定差子序列-力扣（LeetCode）"><a href="#1218-最长定差子序列-力扣（LeetCode）" class="headerlink" title="1218. 最长定差子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/description/?envType=study-plan-v2&envId=dynamic-programming">1218. 最长定差子序列 - 力扣（LeetCode）</a></h2><p>每次到达dp[i] 的时候 就去 dp[i - difference] 找上一个相差difference的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], difference: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = defaultdict(<span class="hljs-built_in">int</span>)<br><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>            dp[x] = dp[x - difference] + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp.values())<br></code></pre></td></tr></table></figure><h2 id="1027-最长等差数列-力扣（LeetCode）"><a href="#1027-最长等差数列-力扣（LeetCode）" class="headerlink" title="1027. 最长等差数列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming">1027. 最长等差数列 - 力扣（LeetCode）</a></h2><p>与上题相同 但是difference需要自己找</p><p>每个dp[i] 存储一个哈希表</p><p>每个哈希表存储 i - 1 ~ 0 的所有数 和nums[i] 的差值（key）和这个差值d 的出现的次数</p><p>比如9 4 7 2 10  到10 的时候 就往前找 2与10 差8 公差为8 的就是1个 再在2中找 公差为8的次数 0 ＋1&#x3D;1</p><p>7 与10 差3 公差为3 在7中找公差为3的 为1 （7 和4） 总次数为2</p><p>最后个数是次数+1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestArithSeqLength</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [&#123;&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>               d = nums[i] - nums[j]<br>                <span class="hljs-keyword">if</span> d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dp[i]:<br>                    dp[i][d] = dp[j].get(d, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>                    <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(d.values()) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dp[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h2 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/E">Problem - E - Codeforces</a></h2><p>从n向前寻找  当i + nums[i] &lt;&#x3D; n的时候  是可以形成 [长度+数组]的形式的  这时候就要检查这个地方是否需要选（可以选 也可以不选）</p><p>就要判断选这个点的代价（因为选这个可能影响其他代价更小的点）选了就是 dp[i + nums[i] + 1] 就是 这个点清除掉之后 比如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 2 3 4 5 6 7<br>3 3 4 5 2 6 1<br></code></pre></td></tr></table></figure><p>选了nums[1]的话 从1到n的代价就为 nums[5]的代价 因为1~4都被消除了</p><p>如果不选i 的话  那就是dp[i + 1] + 1(即直接删除这个点)</p><p>如果i + nums[i] &gt; n 不能形成 数组 那就需要删除 删除的话就是dp[i] &#x3D; dp[i + 1] + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(N)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br><br>    dp[n] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + i &gt; n)<br>            dp[i] = dp[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i + nums[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="100133-购买水果需要的最少金币数-力扣（LeetCode）"><a href="#100133-购买水果需要的最少金币数-力扣（LeetCode）" class="headerlink" title="100133. 购买水果需要的最少金币数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/description/">100133. 购买水果需要的最少金币数 - 力扣（LeetCode）</a></h2><p>跟上面那题有点像。。但是也不一样</p><p>找买水果的最少的钱数  首先写递归 </p><p>这个水果买或不买 怎么看 哪些水果是免费的？ 从1开始递归往后找</p><p>能够不花钱的水果就是i + 1, i + 2 …, 2 * i</p><p>那我下一个要买的水果 就是从i + 1 i + 2… 2 * i + 1 因为2 * i + 1必定是要买的  而前面i个是可以选择买的  那么下一个买的肯定就在这中间 </p><p>那么dfs（i）的意义就是 从1到后面需要花的最少的钱</p><p>那么从i开始 后面要花的最少的钱 就是 我现在买了i的钱 再加上下一个要买的 j 的最小值 （从j 到后面需要花的最少的钱）就是 i买的覆盖了i到2 * i 然后加上 dfs（j） 的最小值就是dfs(i)</p><p>然后递归出口 大于n的时候就是 0 就是不用在花钱了</p><p>细节地方是 prices 下标从1开始 我们dfs也定义从1开始 但是本质上prices是个数组 下标从0开始  所以每次加的时候 加prices[i - 1]</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> i &gt; n:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            res = <span class="hljs-built_in">min</span>(dfs(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>))<br>            <span class="hljs-keyword">return</span> res + prices[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>优化可以是 2 * i &gt; n的时候 return prices[i - 1] 因为这时候只用花一次钱就行了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * i &gt;= n:<br>                <span class="hljs-keyword">return</span> prices[i - <span class="hljs-number">1</span>]<br>            res = <span class="hljs-built_in">min</span>(dfs(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>))<br>            <span class="hljs-keyword">return</span> res + prices[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>然后翻译成递推 因为我们是从1开始到n的  那么变成递推就要改成从n 开始 因为从1 开始 递归到n 说明我实际上是从n算到1的  就是 我算前面的时候  后面是已经先算出来的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCoins</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(prices)<br>        f = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * i &gt;= n:<br>                f[i] = prices[i - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                f[i] = prices[i - <span class="hljs-number">1</span>] + <span class="hljs-built_in">min</span>(f[i + <span class="hljs-number">1</span>: <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1214-波动数列-AcWing题库"><a href="#1214-波动数列-AcWing题库" class="headerlink" title="1214. 波动数列 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1216/">1214. 波动数列 - AcWing题库</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, s, a, b;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">100000007</span>;<br><span class="hljs-type">int</span> f[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmod</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x % y + y) % y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            f[i][j] = ((f[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(j - a * (n - i), n)] + f[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(j + b * (n - i), n)]))%mod;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n - <span class="hljs-number">1</span>][<span class="hljs-built_in">getmod</span>(s, n)];<br>&#125;<br></code></pre></td></tr></table></figure><p>[d]: </p>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/10/11/KMP/"/>
    <url>/2023/10/11/KMP/</url>
    
    <content type="html"><![CDATA[<p>j</p><p>将模式串指针j的回溯 看作整个模式串向后移动来匹配主串</p><p>当i j不匹配的时候有两种做法，第一是模式串移动到当前串的后面（对应的其实是next数组移动到0的位置的时候 也就是全不匹配的时候）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>          <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>第二种 移动到下一个公共子串的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span> <br>移动后<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <br>    <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>即主串的后缀集合与模式串的前缀集合有交集的时候</p><p>j指针回溯的位置是A后缀和B前缀交集里最长的元素（这样不会遗漏）最长元素的长度就是j回溯的位置</p><p>匹配失败 但是A和B串存在一段相同的子串 j回溯的位置只与B有关（A、B相同子串的前后缀 其实就是B子串的前后缀） 因此可以先求出B放入next数组</p><p>next[i]表示B[1]~B[i]最长公共前后缀的长度</p><p>匹配步骤</p><p>i, j初始化为0</p><p>1.如果A[i + 1] &#x3D;&#x3D; B[j + 1] i++,j++</p><p>2.如果不相等 不断回溯j到next[j] 直到A[i + 1] &#x3D;&#x3D; B[j + 1]   或者j回溯到next[0] &#x3D; -1了 此时直接让i++（）意思是B移到A后面</p><p>3.j &#x3D; m 匹配成功输出位置 </p><p>构建next数组  </p><p>求B[1]~B[i]最长公共后缀长度</p><p>如果匹配 next[i] &#x3D; j + 1  (j 表示B串前缀的指针 也就是当前字符匹配之前的最长公共前后缀长度 匹配成功就+1)</p><p>匹配不成功 回溯j指针j &#x3D; next[j]直到成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(string p, <span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i] = j<br>&#125;<br>        <span class="hljs-keyword">else</span><br>           j = next[j]<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">KMP</span>(string s, string p, <span class="hljs-type">int</span> next[])<br>&#123;<br>    <span class="hljs-built_in">getnext</span>(p,next);<br>    <br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> p_len = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j = next[j]<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == p_len)<span class="hljs-keyword">return</span> i - j;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课题组学习</title>
    <link href="/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/11/%E8%AF%BE%E9%A2%98%E7%BB%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/10/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）"><a href="#分享｜从集合论到位运算，常见位运算技巧分类总结！-力扣（LeetCode）" class="headerlink" title="分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></h1><h2 id="压缩表示"><a href="#压缩表示" class="headerlink" title="压缩表示"></a>压缩表示</h2><p>集合用二进制表示，从高到低第i位为1表示i在集合中。如{0,2,3}可以表示为1101，压缩成一个数字 13</p><h2 id="集合与集合"><a href="#集合与集合" class="headerlink" title="集合与集合"></a>集合与集合</h2><p>集合的交并补差</p><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><p>“&lt;&lt;”代表左移，相当于乘2 ^ i</p><p>“&gt;&gt;”代表右移， 相当于除2 ^ i</p><p>补集~s</p><p>全集 (1&lt;&lt;n) - 1</p><p>属于  (s &gt;&gt; i) &amp; 1 &#x3D; 1</p><p>不属于 (s &gt;&gt; i) &amp; 1 &#x3D; 0</p><p>添加元素 s | (1 &lt;&lt; i)</p><p>删除元素 s &amp; ~ (1 &lt;&lt; i)  (比如i &#x3D; 2 变成0100 取反变成 1011 然后和s并起来  这样才可以保证 只删除目标位而不影响其他位)</p><p>删除最小元素 s &amp; (s - 1) ((s - 1)可以使得最低位的1变为0 并且其右边的所有0变为1  然后&amp;s 使得 最低位的1以及后面的所有0全部变成0)</p><p>lowbit  &#x3D; s &amp; (-s)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">     s = <span class="hljs-number">101100</span><br>    ~s = <span class="hljs-number">010011</span><br>(~s)+<span class="hljs-number">1</span> = <span class="hljs-number">010100</span> <span class="hljs-regexp">//</span> 根据补码的定义，这就是 -s   最低 <span class="hljs-number">1</span> 左侧取反，右侧不变<br>s &amp; -s = <span class="hljs-number">000100</span> <span class="hljs-regexp">//</span> lowbit<br></code></pre></td></tr></table></figure><h3 id="部分库函数"><a href="#部分库函数" class="headerlink" title="部分库函数"></a>部分库函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">s.bit_count() <span class="hljs-comment"># 集合大小</span><br>s.bit_length() <span class="hljs-comment"># 二进制长度</span><br>(s&amp;-s).bit_length()-<span class="hljs-number">1</span> <span class="hljs-comment"># 集合中的最小元素</span><br></code></pre></td></tr></table></figure><h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-comment"># 如果i在s中</span><br>    <span class="hljs-keyword">if</span> (s &gt;&gt; i) &amp; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="枚举集合"><a href="#枚举集合" class="headerlink" title="枚举集合"></a>枚举集合</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 从空集枚举到全集U</span><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 设集合为s 从大到小枚举s的所有非空子集sub</span><br>sub = s<br><span class="hljs-keyword">while</span> sub:<br>    <span class="hljs-comment"># pass</span><br>    <br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s <span class="hljs-comment"># （如何证明？）</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">跳过非子集的集合！</span><br><span class="hljs-string">意思是，把10100 的最低位1变0，它的后面有两位 00， 都是0。这时候按照普通二进制，会把这两个 00 都变成 11，如果按照压缩版，就只把原来集合里有的 1 变成 1 （因为求的是子集），其余的还是 0，原有的集合是 10101，最后两位是 01，所以只保留 01。综合起来就是 10100 先变 10000，然后保留 01，变成 10001。</span><br><span class="hljs-string"></span><br><span class="hljs-string">这样做的效果是从 10100 直接跳到 10001，把中间的 10011 和10010 忽略掉了（普通减法顺序是 10100 - 10011 - 10010 - 10001），因为10011 和 10010不是有效的子集。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 所有子集</span><br><span class="hljs-keyword">while</span> sub:<br>    sub = (sub - <span class="hljs-number">1</span>) &amp; s<br>    <span class="hljs-keyword">if</span> sub == s:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h1 id="136-只出现一次的数字-力扣（LeetCode）"><a href="#136-只出现一次的数字-力扣（LeetCode）" class="headerlink" title="136. 只出现一次的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></h1><p>一个数字出现一次 其他数字出现两次   用异或操作 因为a^0 &#x3D; a a ^ a &#x3D; 0 所以两个一样的数异或就为0 </p><p>并且a ^ b ^ c 满足交换律  </p><p>即所有的数都是相同的凑成一对 变为0   然后剩下的目标数字^0 &#x3D; 目标  输出即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            ret ^= x<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="137-只出现一次的数字-II-力扣（LeetCode）"><a href="#137-只出现一次的数字-II-力扣（LeetCode）" class="headerlink" title="137. 只出现一次的数字 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-ii/description/">137. 只出现一次的数字 II - 力扣（LeetCode）</a></h1><p>一个数字出现三次  目标数字出现三次</p><p>所以每个比特位的1的数量必定是3的倍数  不是3的倍数的 就是ans的比特位 </p><p>注意python这种对有符号整型和无符号整型不区分的语言 需要特判最高位</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = [<span class="hljs-number">0</span>] * <span class="hljs-number">33</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>                ret[i] += ((x&gt;&gt;i) &amp; <span class="hljs-number">1</span>)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>            <span class="hljs-keyword">if</span> ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">31</span>:<br>                    ans -= (<span class="hljs-number">1</span> &lt;&lt; i)<br>                <span class="hljs-keyword">else</span>:<br>                    ans |= (<span class="hljs-number">1</span> &lt;&lt; i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            &#123;<br>                ret[i] += ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ret[i] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>)<br>                ans += (<span class="hljs-number">1</span> &lt;&lt; i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="260-只出现一次的数字-III-力扣（LeetCode）"><a href="#260-只出现一次的数字-III-力扣（LeetCode）" class="headerlink" title="260. 只出现一次的数字 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/single-number-iii/description/">260. 只出现一次的数字 III - 力扣（LeetCode）</a></h1><p>每个元素只出现两次  有两个只出现一次的数 要找出这两个数 </p><p>由于这两个数不同  必然有一个(以上)的比特位不同  那么就求这个比特位 </p><p>然后把所有在这个比特位上 是1 的 异或到一起 （包含所有 这个比特位上是1 的两个两个的数  和 这个比特位上是1 的目标数）  把所有这个比特位上是0 的异或到一起…</p><p>注意取  lowbit   lowbit &#x3D;  a &amp; (-a)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        xorsum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            xorsum ^= x<br>        ans1 = ans2 = <span class="hljs-number">0</span><br>        lb = xorsum &amp; (-xorsum)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> lb &amp; x:<br>                ans1 ^= x<br>            <span class="hljs-keyword">else</span>:<br>                ans2 ^= x<br><br>        <span class="hljs-keyword">return</span> [ans1, ans2]<br></code></pre></td></tr></table></figure><h1 id="78-子集-力扣（LeetCode）"><a href="#78-子集-力扣（LeetCode）" class="headerlink" title="78. 子集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></h1><p>子集的形式与二进制数非常相似 可以考虑用二进制来写</p><p>1 &lt; (1 &lt;&lt; n)就是小于2的n次方</p><p>i&gt;&gt;j 就是把i这个二进制数往右移动j位</p><p>比如0001  移动0位是1  移动1位是0 移动两位是0 三位是0</p><p>就是用这种方式 代表每个位置上的数选或不选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        rets = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; (<span class="hljs-number">1</span>&lt;&lt;n):<br>            ret = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:<br>                    ret.append(nums[j])<br>            rets.append(ret)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> rets<br></code></pre></td></tr></table></figure><h1 id="421-数组中两个数的最大异或值-力扣（LeetCode）"><a href="#421-数组中两个数的最大异或值-力扣（LeetCode）" class="headerlink" title="421. 数组中两个数的最大异或值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></h1><h2 id="前缀哈希表"><a href="#前缀哈希表" class="headerlink" title="前缀哈希表"></a>前缀哈希表</h2><p>mask每次是00000-10000-11000-11100-11110-11111 每次让他第i位变成1  则其前i位都为1  后i + 1位都为0</p><p>new_ans &#x3D; ans|&#x3D;(1  &lt;&lt; i) 就是假设ans的第i位为1 其余位不变</p><p>然后对每个x 先和mask与 得到 <strong>前缀</strong> 重点  这里是得到前缀  因为mask前i位为1 后为0 则与后 x前i位不变 后i+1位为0 实现取前缀的操作</p><p>假设此时进行到了第 k个x (即nums[k]) seen里面有nums的前k - 1个数的前缀（后缀为0）如果x ^ new_ans 在seen里找到了  说明ans的这一位为1是可以的  因为：</p><p>x ^ new_ans 如果在seen里找到了   说明seen里一定有一个数 y 满足 x ^ y &#x3D;&#x3D; new_ans   （因为a ^ b &#x3D; c  &lt;&#x3D;&gt; a ^ c &#x3D; b &lt;，&#x3D;&gt; b ^ c &#x3D; a）那就说明 有两个数的异或值 可以为new_ans （也即在保留前i - 1位的情况下  第i位可以为1）   如果没有找到的话 就说明不存在两个数异或为new_ans 那ans就不变 （即该位为0不变）否则ans &#x3D; new_ans   这样 每一位都尽量取1  最后就是最大值</p><p>主要用了 用mask与 取前缀排除后缀的影响  不是只比较第i位  而是比较前i位   </p><p>设new_ans 去异或  然后在set里查找</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaximumXOR</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = mask = <span class="hljs-number">0</span><br>        high_bit = <span class="hljs-built_in">max</span>(nums).bit_length() - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            mask = <span class="hljs-number">1</span> |= (<span class="hljs-number">1</span> &lt;&lt; i) <br>            seen = <span class="hljs-built_in">set</span>()<br>           new_ans = ans |= (<span class="hljs-number">1</span> &lt;&lt; i)<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>                x &amp;= mask<br>                <span class="hljs-keyword">if</span> (x ^ new_ans) <span class="hljs-keyword">in</span> seen():<br>                    ans = new_ans<br>                    <span class="hljs-keyword">break</span><br>                seen.add(x)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>建前缀树  要尽量往相反方向走</p><p>每个数进入add函数 建树  扩展树的枝叶</p><p>每个数进入check函数 如果当前位是1 则尽量往0的枝叶走（left）如果左边走不了再走右  如果当前位是0 尽量往1走（right）</p><p>每次走到相反位   x &#x3D; x * 2 + 1 相同位 x &#x3D; x * 2 因为是从高往低位走的（从根往叶子走） </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaximumXOR</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        root = Trie()<br>        high_bit = <span class="hljs-built_in">max</span>(nums).bit_length() - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>            cut = root<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> bit == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> cur.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                        cur.left = Trie()<br>                    cur = cur.left<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> cur.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                        cur.right = Trie()<br>                    cur = cur.right<br>       <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>            cur = root<br>            x = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(high_bit, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> bit == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> cur.right:<br>                        cur = cur.right<br>                        x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        cur = cur.left<br>                        x = x * <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> cur.left:<br>                        cur = cur.left<br>                        x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        cur = cur.right<br>                        x = x * <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> x<br>         <br>        x = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            add(nums[i - <span class="hljs-number">1</span>])<br>            x = <span class="hljs-built_in">max</span>(x, check(nums[i]))<br>        <span class="hljs-keyword">return</span> x<br>            <br></code></pre></td></tr></table></figure><h1 id="2939-最大异或乘积-力扣（LeetCode）"><a href="#2939-最大异或乘积-力扣（LeetCode）" class="headerlink" title="2939. 最大异或乘积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-xor-product/description/">2939. 最大异或乘积 - 力扣（LeetCode）</a></h1><p>aa</p><p>两个位相同的话 x的该位就直接取反</p><p>两个位不同的话 总有一位为0 一位为1 如何取</p><p>注意到a &#x3D; 12 和 b &#x3D; 5 即 1100 和 0101 x第二位为0第三位为1 那么x如果是0010 即让x异或完a变成 0100 &#x3D; 8 b变成1101 &#x3D; 13 总和为21  如果x是1010 a &#x3D; 0110 6 b &#x3D; 1111 15 总和为21   其实也很好想 每个地方放1 不管放在哪 都会被加进去 在a第0位 放1 变成a + 1 + b   在b的第0位放1 也是a + b + 1 所以a + b 总和是不变的  这也是位运算的特殊之处</p><p>基本不等式 a + b &gt; 2 sqrt(a * b)  要让a b尽量接近</p><p>如何让a b 尽量接近呢  由上分析 已经知道了 只需要考虑a 和b中 不相等的位 那这几位1是固定的 关键在于如何把1分配给a 和b 要让a b 尽量接近 如果a &gt; b 就把最高位分配给a 剩余位 分配给b （因为最高的一位大于剩下最低位的和</p><p>然后考虑分配 a b 都小于2 ^ n 直接分  a b有一个 大于等于 2 ^ n的时候  那前面的部分是不可修改的 如果a b前面的位都相同 那就跟上面一样 分配后面的  否则 a &gt; b 的话 那就把所有的1都分配给b</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumXorProduct</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> a &lt; b:<br>            a, b = b, a<br>        mask = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> <span class="hljs-comment"># 全为1的掩码</span><br>        <span class="hljs-comment"># 取出第n位及其左边的数 不被x影响</span><br>        ax = a &amp; ~mask<br>        bx = b &amp; ~mask<br>        <span class="hljs-comment"># 再来算右边的</span><br>        a &amp;= mask<br>        b &amp;= mask<br>        <br>        left = a ^ b <span class="hljs-comment"># 可分配的位 （a^b 就是a和b的不同位）</span><br>        one = mask ^ left <span class="hljs-comment"># 不用分配的位</span><br>        <span class="hljs-comment"># 把右边的 无需分配的 先加到左边</span><br>        ax |= one<br>        bx |= one<br>        <br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ax == bx:<br>            high_bit = <span class="hljs-number">1</span> &lt;&lt; (left.bit_length() - <span class="hljs-number">1</span>)<br>            ax |= high_bit <span class="hljs-comment"># 最高位给a</span><br>            left ^= high_bit <span class="hljs-comment"># 除了最高位以外的其他位</span><br>        bx |= left <span class="hljs-comment"># 给b （因为当left &gt; 0 ax == bx的时候才需要把最高位给a  但是 其他的不管什么情况都是给b）</span><br>    <span class="hljs-keyword">return</span> ax * bx % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch环境</title>
    <link href="/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/10/07/pytorch%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="配个环境配了一天-人麻了"><a href="#配个环境配了一天-人麻了" class="headerlink" title="配个环境配了一天 人麻了"></a>配个环境配了一天 人麻了</h1><p>不知道为什么只有这个版本可以用 下次重建conda虚拟环境的时候要用这个下载 </p><p>并且在下载之前记得</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> cpuonly<br>conda uninstall cpuonly<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">1</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> cudatoolkit=<span class="hljs-number">11</span>.<span class="hljs-number">3</span> -c pytorch<br></code></pre></td></tr></table></figure><h1 id="艹-在conda虚拟环境要用conda-install"><a href="#艹-在conda虚拟环境要用conda-install" class="headerlink" title="艹 在conda虚拟环境要用conda install"></a>艹 在conda虚拟环境要用conda install</h1><p>为什么我疯狂用pip install啊啊啊</p><h1 id="pip开代理可能会出现路径错误"><a href="#pip开代理可能会出现路径错误" class="headerlink" title="pip开代理可能会出现路径错误"></a>pip开代理可能会出现路径错误</h1><p>到底还有多少离谱的问题啊</p><h1 id="下不下来的包-居然可以直接复制粘贴文件夹吗？（😀"><a href="#下不下来的包-居然可以直接复制粘贴文件夹吗？（😀" class="headerlink" title="下不下来的包 居然可以直接复制粘贴文件夹吗？（😀"></a>下不下来的包 居然可以直接复制粘贴文件夹吗？（😀</h1><p>vscode终端出问题。。一直以为是pytorch环境错了</p><p>把终端换成（pytorch1）也就是conda的虚拟环境就可以了 而不能用PS的终端</p>]]></content>
    
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基环树</title>
    <link href="/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    <url>/2023/10/03/%E5%9F%BA%E7%8E%AF%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>一般来说就是先存反图 算入度 </p><p>然后拓扑排序 剩下的就是基环</p><p>第三步 分别对每个基环进行操作 找基环的方式为模板（如下题）</p><h1 id="2127-参加会议的最多员工数-力扣（LeetCode）"><a href="#2127-参加会议的最多员工数-力扣（LeetCode）" class="headerlink" title="2127. 参加会议的最多员工数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/">2127. 参加会议的最多员工数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumInvitations</span>(<span class="hljs-params">self, favorite: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(favorite)<br>        deg = [<span class="hljs-number">0</span>] * n<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(favorite):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br><br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = favorite[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            m_depth = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    m_depth = <span class="hljs-built_in">max</span>(m_depth, rdfs(y) + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> m_depth<br><br>        <br>        max_ring_size = sum_chine_size = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 找基环的套路</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            res = <span class="hljs-number">0</span><br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                res += <span class="hljs-number">1</span><br>                deg[x] = -<span class="hljs-number">1</span><br>                x = favorite[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> res == <span class="hljs-number">2</span>:<br>                sum_chine_size += rdfs(i) + rdfs(favorite[i])<br>            <span class="hljs-keyword">else</span>:<br>                max_ring_size = <span class="hljs-built_in">max</span>(max_ring_size, res)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_ring_size, sum_chine_size)<br></code></pre></td></tr></table></figure><h1 id="2876-有向图访问计数-力扣（LeetCode）"><a href="#2876-有向图访问计数-力扣（LeetCode）" class="headerlink" title="2876. 有向图访问计数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/description/">2876. 有向图访问计数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countVisitedNodes</span>(<span class="hljs-params">self, g: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(g)<br>        rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        deg = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(g):<br>            rg[y].append(x)<br>            deg[y] += <span class="hljs-number">1</span><br>        <br>        q = deque(i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            y = g[x]<br>            deg[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                q.append(y)<br>        <br>        ans = [<span class="hljs-number">0</span>] * n<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">rdfs</span>(<span class="hljs-params">x, depth</span>):<br>            ans[x] = depth<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rg[x]:<br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">0</span>:<br>                    rdfs(y, depth + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 找基环的操作</span><br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(deg):<br>            <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            ring = []<br>            x = i<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ring.append(x)<br>                deg[x] = -<span class="hljs-number">1</span><br>                x = g[x]<br>                <span class="hljs-keyword">if</span> x == i:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ring:<br>                rdfs(x, <span class="hljs-built_in">len</span>(ring))<br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/10/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="股票问题系列通解（转载翻译）-力扣（LeetCode）"><a href="#股票问题系列通解（转载翻译）-力扣（LeetCode）" class="headerlink" title="股票问题系列通解（转载翻译） - 力扣（LeetCode）"></a><a href="https://leetcode.cn/circle/discuss/qiAgHn/">股票问题系列通解（转载翻译） - 力扣（LeetCode）</a></h1><p>首先，通用状态表示是dp[i] [k] [0]和dp[i] [k] [1]表示第i天时 交易k次 手上有0&#x2F;1只股票的时候的最大利润 </p><p>状态计算，dp[i] [k] [0] &#x3D; max(dp[i - 1] [k] [0], dp[i - 1] [k] [1] + price[i]])</p><p>第i天手上有0只股票的最大收益为 第i - 1天手上有0只股票 和 第i - 1天手上有1只股票并且卖掉的最大收益 </p><p>dp[i] [k] [1] &#x3D; max(dp[i - 1] [k] [1], dp[i - 1] [k - 1] [0] - price[i]])</p><p>第i天手上有1只股票的最大收益为 第i - 1天手上有1只股票 和 第i - 1天手上有0只股票并且买入的最大收益 注意 要减掉一次交易次数</p><p>当k &gt;&#x3D; n &#x2F;&#x2F; 2时 就相当于k无限 因为买入卖出算一次交易 那么最多前面一半全买入 后面一半全卖出</p><p>手续费直接减掉</p><p>冷冻期就跳过一天  加入i - 2天这个变量 买入的时候要从第i - 2天转移过来</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
      <tag>algorithm</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合题解</title>
    <link href="/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/30/%E9%9B%86%E5%90%88%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1551-亲戚-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>并查集模板</p><p>看两个数是不是在一个集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, p  = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> fa[x] == x:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    union(a, b)<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> find(a) == find(b):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Loading-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#Loading-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1536">Loading - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>不是看两个数是不是在一个集合 而是计算一共有多少个集合</p><p>计算还需要修几条路才能把所有村子连接起来 其实就是求现在的集合数 连起来的村子当同一个村子 当fa[i] &#x3D;&#x3D; i 的时候 cnt + 1  因为每个集合有且仅有一个 fa[i] &#x3D;&#x3D; i 因此可以用来计数 最后 村子数减一就是道路数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    n = l[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    m = l[<span class="hljs-number">1</span>]<br>    fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        union(a, b)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> fa[i] == i:<br>            cnt += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(cnt - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3370-【模板】字符串哈希-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>为每个字符串求一个hash值 直接放入列表中 排序列表 然后看相邻的两个数的值是否一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">base = <span class="hljs-number">131</span><br>prime = <span class="hljs-number">233317</span><br>mod = <span class="hljs-number">212370440130137957</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hashe</span>(<span class="hljs-params">s</span>):<br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>        ans = (ans * base + <span class="hljs-built_in">ord</span>(char)) % mod + prime<br>    <span class="hljs-keyword">return</span> ans<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    s = <span class="hljs-built_in">input</span>()<br>    a.append(hashe(s))<br><br>a.sort()<br>ans = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> a[i] != a[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3405-USACO16DEC-Cities-and-States-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P3405 USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P3405 <a href="https://www.luogu.com.cn/problem/P3405">USACO16DEC] Cities and States S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求城市对数 算出每个城市的hash值（只需要看前两位） 如果AB不是同一座城市  那么A B就是一个城市对 先放入mp中存起来  而B A可以直接加到答案里（题目要求有两个城市互为对的时候才算一个 比如MIAMT FL  和 FLINT 和 MI 算一对）所以每次遇到A B都先存着  知道遇到B  A再一次取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>ans = <span class="hljs-number">0</span><br>mp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">676</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">676</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a, b = <span class="hljs-built_in">input</span>().split()<br>    A = (<span class="hljs-built_in">ord</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    B = (<span class="hljs-built_in">ord</span>(b[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) * <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(b[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> A != B:<br>        mp[A][B] += <span class="hljs-number">1</span>  <br>        ans += mp[B][A]<br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1102-A-B-数对-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>计数 然后看mp中有没有A - k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>mp = &#123;&#125;<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> mp:<br>        mp[x] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        mp[x] = <span class="hljs-number">1</span><br><br>ans = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mp.items():<br>    <span class="hljs-keyword">if</span> key - k <span class="hljs-keyword">in</span> mp:<br>       ans += mp[key - k] * value<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1525-NOIP2010-提高组-关押罪犯-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1525 NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1525 <a href="https://www.luogu.com.cn/problem/P1525">NOIP2010 提高组] 关押罪犯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>带权并查集   并且一共只有两个集合  判断每个集合里面要放哪些</p><p>首先定义fa数组和Enemy（空数组） 对所有囚犯的怒气值从大到小排序 把最大的分别放到不同的集合 直到出现冲突（比如有个人A 和B   前面有一个在1监狱已经放好 而且B被放到2监狱（因为1和B的仇恨更大）这个人没办法 只能被放到1 和B仇恨较小的那个监狱）由于排序了 这个值就是最大值  带权值的并查集 只要用结构体加上w就行</p><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fo,to,w</span>):<br>        self.fo = fo<br>        self.to = to<br>        self.w = w<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-keyword">if</span> fa[k] == k:<br>        <span class="hljs-keyword">return</span> k<br>    fa[k] = find(fa[k])<br>    <span class="hljs-keyword">return</span> fa[k]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>p = [node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    p[i].fo = u<br>    p[i].to = v<br>    p[i].w = w<br><br>p.sort(key=<span class="hljs-keyword">lambda</span> x: -x.w)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    <span class="hljs-comment"># 如果已经在同一监狱</span><br>    t1, t2 = find(p[i].fo), find(p[i].to)<br>    <span class="hljs-keyword">if</span> t1 == t2:<br>        <span class="hljs-built_in">print</span>(p[i].w)<br>        sys.exit()<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].fo] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].fo] = p[i].to<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].fo], p[i].to)<br><br>    <span class="hljs-keyword">if</span> Enemy[p[i].to] == <span class="hljs-number">0</span>:<br>        Enemy[p[i].to] = p[i].fo<br>    <span class="hljs-keyword">else</span>:<br>        union(Enemy[p[i].to], p[i].fo)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><h1 id="P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1621-集合-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1621">P1621 集合 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最终的集合数其实就是算素数的个数  因为非素数都会被合并  每次合并总集合都减去一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br><br>a, b, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>ans = b - a + <span class="hljs-number">1</span><br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>prime = [<span class="hljs-number">0</span>] * (b + <span class="hljs-number">1</span>)<br>prime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> prime[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> i &gt;= p:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> j - i &gt;= a <span class="hljs-keyword">and</span> find(j) != find(j - i):<br>                    union(j, j - i)<br>                    ans -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, b + <span class="hljs-number">1</span>, i):<br>                prime[j] = <span class="hljs-literal">True</span><br><br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1892-BOI2003-团伙-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1892 BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1892 <a href="https://www.luogu.com.cn/problem/P1892">BOI2003] 团伙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>记住只有两个集合里面放的操作  如果Enemy[A] 为0 那就把Enemy[A]赋值为B  不为0则合并Enemy[A] 和B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == fa[x]:<br>        <span class="hljs-keyword">return</span> x<br>    fa[x] = find(fa[x])<br>    <span class="hljs-keyword">return</span> fa[x]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    fa[find(x)] = find(y)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100010</span>)]<br>Enemy = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    op, a, b = <span class="hljs-built_in">input</span>().split()<br>    a = <span class="hljs-built_in">int</span>(a)<br>    b = <span class="hljs-built_in">int</span>(b)<br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;E&#x27;</span>:<br>        <span class="hljs-keyword">if</span> Enemy[a] == <span class="hljs-number">0</span>:<br>            Enemy[a] = find(b)<br>        <span class="hljs-keyword">else</span>:<br>            union(Enemy[a], b)<br>        <span class="hljs-keyword">if</span> Enemy[b] == <span class="hljs-number">0</span>:<br>            Enemy[b] = find(a)<br>        <span class="hljs-keyword">else</span>:<br>            union(a, Enemy[b])<br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;F&#x27;</span>:<br>        union(a,b)<br><br>count = [<span class="hljs-number">0</span>] * <span class="hljs-number">1001</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    count[find(i)] = <span class="hljs-number">1</span><br><br>cnt= <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt += count[i]<br><br><span class="hljs-built_in">print</span>(cnt)<br></code></pre></td></tr></table></figure><h1 id="765-情侣牵手-力扣（LeetCode）"><a href="#765-情侣牵手-力扣（LeetCode）" class="headerlink" title="765. 情侣牵手 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/couples-holding-hands/description/?envType=daily-question&envId=2023-11-11">765. 情侣牵手 - 力扣（LeetCode）</a></h1><p>n对情侣要相邻 (0, 1)(2, 3)(4, 5)… 从 因此可以分组 01为第0组 23为第1组 45 为第2组… 恰好0 1 &#x2F; 2 &#x3D; 0  2 3 &#x2F; 2 &#x3D; 1  4 5 &#x2F; 2 &#x3D; 2 这样来分组   </p><p>如果两组情侣坐错了 那只需要其中两个人互换一次就可以  三组情侣坐错 只需要互换两次就可以 即k对错误的情侣 需要k - 1次交换就可以</p><p>注意 三个互相坐错 2次   若是两组 3个互相坐错就是 4次…（称为一个环）</p><p>就寻找有几个相互坐错的环  每个环 求环的大小减1就行</p><p>用并查集来写 坐错的就加到一个集合里 最后统计每个集合要交换的个数相加</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSwapsCouples</span>(<span class="hljs-params">self, row: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">if</span> x == fa[x]:<br>                <span class="hljs-keyword">return</span> x<br>           fa[x] = find(fa[x])<br>            <span class="hljs-keyword">return</span> fa[x]<br>      <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>            fa[find(x)] = find(y)<br>        <br>        <br>        n = <span class="hljs-built_in">len</span>(row)<br>        m = n // <span class="hljs-number">2</span><br>        fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n, <span class="hljs-number">2</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            0 1 union(0, 0) 就是把0 合到 0 不变 下面去比的时候 0 == find(0) 就是集合0 </span><br><span class="hljs-string">            若是0 3 union(0, 1) 即 集合1 合到集合1 那么find(1) = 0下面找 1 != find(1)那就不是</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            union(row[i] // <span class="hljs-number">2</span>, row[i + <span class="hljs-number">1</span>] // <span class="hljs-number">2</span>)<br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> find(i) == i:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> m - cnt    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赛题题解</title>
    <link href="/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/24/%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-C-Codeforces"><a href="#Problem-C-Codeforces" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/C">Problem - C - Codeforces</a></h1><p>先给每一圈赋一个权重dis</p><p>算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> dis[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; nums;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        nums.<span class="hljs-built_in">emplace_back</span>(s);<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res += dis[<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i, j), <span class="hljs-built_in">min</span>(<span class="hljs-number">9</span> - i, <span class="hljs-number">9</span> - j))];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces"><a href="#Problem-E-Codeforces" class="headerlink" title="Problem - E - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/E">Problem - E - Codeforces</a></h1><p>赛时调了半天没调出来，寄，害的F也没调出来&#x2F;kk </p><p>二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mid - nums[i] &gt;= <span class="hljs-number">0</span>)<br>            res += (mid - nums[i]);<br>        <span class="hljs-keyword">if</span> (res &gt; m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(nums));<br>    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>, mid;<br><br>    <span class="hljs-keyword">while</span> (l &lt;= r)<br>    &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>        &#123;<br>            res = mid;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br><br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-G-Codeforces"><a href="#Problem-G-Codeforces" class="headerlink" title="Problem - G - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/G">Problem - G - Codeforces</a></h1><p>AB-&gt;BC BA-&gt;CB</p><p>那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 </p><p>如果有两个B连在一起的话只可能是B..BB…B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B </p><p>如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span> || s[n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;A&#x27;</span>)<br>                sum++, cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>            &#123;<br>                minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>                    flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        minn = <span class="hljs-built_in">min</span>(minn, cnt);<br>        <span class="hljs-keyword">if</span> (flag)<br>        &#123;<br>            cout &lt;&lt; sum &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (minn != <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>                cout &lt;&lt; sum - minn &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/contest/1873/problem/H">Problem - H - Codeforces</a></h1><p>寻找基环树（套路）因为这个题不仅要判断环 而且需要储存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, a, b; <span class="hljs-comment">// a is M b is V</span><br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 存无向图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        graph[u].<span class="hljs-built_in">pb</span>(v);<br>        graph[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a == b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">incircle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>    <br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (v == fa)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-comment">// 第二次经过代表有环</span><br>            &#123;<br>                ok = <span class="hljs-literal">true</span>;<br>                incircle[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记在环上</span><br>                <span class="hljs-type">int</span> x = u;<br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    incircle[x] = <span class="hljs-number">1</span>;<br>                    x = pre[x];<br>                &#125; <span class="hljs-keyword">while</span> (x != v); <span class="hljs-comment">// 标记环上的所有点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                vis[v] = <span class="hljs-number">1</span>;<br>                pre[v] = u;<br>                <span class="hljs-built_in">dfs</span>(v, u);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 如果已经在环上了</span><br>    <span class="hljs-keyword">if</span> (incircle[b]) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> goal = <span class="hljs-number">-1</span>, gdis = <span class="hljs-number">-1</span>;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-comment">// 清空vis数组</span><br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;b, <span class="hljs-number">0</span>&#125;);<br>    vis[b] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (incircle[v])<br>            &#123;<br>                goal = v;<br>                gdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">goto</span> end;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>end:;<br>    <span class="hljs-keyword">if</span> (goal == a)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> tdis = <span class="hljs-number">-1</span>;<br>    vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(&#123;a, <span class="hljs-number">0</span>&#125;);<br>    vis[a] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> dis = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[v])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (v == goal)<br>            &#123;<br>                tdis = dis + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (tdis &lt;= gdis)<br>                    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dis + <span class="hljs-number">1</span>&#125;);<br>                vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="5153-删除-AcWing题库"><a href="#5153-删除-AcWing题库" class="headerlink" title="5153. 删除 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5156/">5153. 删除 - AcWing题库</a></h1><p>一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除<br>而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推<br>所以只需要枚举1 2 3 位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;8&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;8&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                cout &lt;&lt; a &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; k++)<br><br>            &#123;<br>                <span class="hljs-type">int</span> a = ((s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">100</span> + (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (a % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                    cout &lt;&lt; a &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1878/problem/D">Problem - D - Codeforces</a></h1><p>给出区间 然后反转 可以用差分 当这个下标被旋转奇数次的时候就需要旋转 被旋转偶数次的时候 就相当于没动 不用旋转 </p><p>每次旋转要找到唯一一个i 使得a[i] &lt;&#x3D; x &amp;&amp; b[i] &gt;&#x3D; x 然后旋转a[i] b[i] 的元素 </p><p>可以用cnt（类似差分数组）记录x出现的次数   并且不需要根据x寻找第二行所说的那个区间 而是遍历区间 找到这个区间的x</p><p>遍历区间 然后取出子串 从left到mid依次与right到mid交换 （根据sum的奇偶来判断）sum就是当前位置和对称位被交换次数之和（累计   因为是差分）然后输出子串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br><br>using namespace std;<br><br>using ll = long long;<br>using PII = pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;;<br><br><span class="hljs-comment">#define pb push_back</span><br><span class="hljs-comment">#define all(x) (x).begin(), (x).end()</span><br><span class="hljs-comment">#define fi first</span><br><span class="hljs-comment">#define se second</span><br><span class="hljs-comment">#define endl &#x27;\n&#x27;</span><br><br><span class="hljs-comment">#define debug(x)                          \</span><br>    &#123;                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; \</span><br>    &#125;<br><span class="hljs-comment">#define debugfull(x)                                                      \</span><br>    &#123;                                                                     \<br>        cerr &lt;&lt; <span class="hljs-comment">#x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; (line &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; endl; \</span><br>    &#125;<br><br>/*-------------------------------------------*/<br><br>void solve()<br>&#123;<br>    <span class="hljs-built_in">int</span> n, k;<br>    string s;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    cin &gt;&gt; s;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; a(k), b(k);<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; cnt(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; a[i], a[i]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        cin &gt;&gt; b[i], b[i]--;<br>    <span class="hljs-built_in">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> x;<br>        cin &gt;&gt; x;<br>        cnt[x - <span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    &#123;<br>        string s1 = s.substr(a[i], b[i] - a[i] + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l = a[i];<br>        <span class="hljs-built_in">int</span> r = b[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = l; j &lt;= (l + r) / <span class="hljs-number">2</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">sum</span> += cnt[j] + cnt[r - j + l];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> % <span class="hljs-number">2</span>)<br>                swap(s1[j - l], s1[r - j]);<br>        &#125;<br>        cout &lt;&lt; s1;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    // clock_t st = clock(), ed;<br>    ios::sync_with_stdio(<span class="hljs-number">0</span>);<br>    cin.tie(<span class="hljs-number">0</span>);<br>    // cout &lt;&lt; setprecision(<span class="hljs-number">15</span>) &lt;&lt; fixed;<br>    <span class="hljs-built_in">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        solve();<br><br>    // ed = clock();<br>    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;<br>    // cout &lt;&lt; <span class="hljs-string">&quot;Total time: &quot;</span> &lt;&lt; endtime &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100019-将数组分割成最多数目的子数组-力扣（LeetCode）"><a href="#100019-将数组分割成最多数目的子数组-力扣（LeetCode）" class="headerlink" title="100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/description/">100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）</a></h1><p>按位与的结果只能越来越小 因此要求最小的按位与的子数组的和 就是全部与在一起的和 就是最小的 但是又特殊情况 就是 当全部的与为0时 可能中间有一部分已经为0了  这样就可以拆成很多个与为0的子数组   如果不为0  那必然整个数组的与就是最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarrays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        t = nums[<span class="hljs-number">0</span>]<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>                cnt += <span class="hljs-number">1</span><br>                t = nums[i]<br>            t&amp;=nums[i]<br>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span>:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cnt <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）"><a href="#2872-可以被-K-整除连通块的最大数目-力扣（LeetCode）" class="headerlink" title="2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/2464559/javapython3cshen-du-you-xian-sou-suo-tan-3r78/">2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）</a></h1><p>由于题目说了 整棵树所有结点的和一定为k的倍数 那么从中取出一棵节点和为k的倍速的子树  剩下的部分的结点和一定也为k的倍数  </p><p>因此可以自底向上递归  每次找到一棵节点和为k的倍数的子树 就直接加入答案 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxKDivisibleComponents</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 建树</span><br>        self.link = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> edges:<br>            self.link[s].append(e)<br>            self.link[e].append(s)<br>        self.res = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 递归</span><br>        self.dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, values, k)<br>        <span class="hljs-keyword">return</span> self.res<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, node, parent, values, k</span>):<br>            node_sum = values[node]<br>            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.link[node]:<br>                <span class="hljs-comment"># 因为建的是无向图 要去掉父节点</span><br>                <span class="hljs-keyword">if</span> child == parent:<br>                    <span class="hljs-keyword">continue</span><br>                child_sum = dfs(child, node, values, k)<br>                <span class="hljs-keyword">if</span> child_sum % k == <span class="hljs-number">0</span>:<br>                    self.res += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    node_sum += child_sum<br>            <span class="hljs-keyword">return</span> node_sum<br></code></pre></td></tr></table></figure><h1 id="100086-有序三元组中的最大值-II-力扣（LeetCode）"><a href="#100086-有序三元组中的最大值-II-力扣（LeetCode）" class="headerlink" title="100086. 有序三元组中的最大值 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">100086. 有序三元组中的最大值 II - 力扣（LeetCode）</a></h1><p>遍历j 算出j的前缀的最大值和j的后缀的最大值 因为求得是(nums[i] - nums[j]) * nums[k] 所以i k要尽量大</p><p>后缀就是从n - 1往前 求出每一个j值所对应的最大后缀  前缀同理</p><p>最后直接计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumTripletValue</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        surmax = [-<span class="hljs-number">1</span>] * (n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            surmax[i] = <span class="hljs-built_in">max</span>(surmax[i + <span class="hljs-number">1</span>], nums[i])<br>        premax = nums[<span class="hljs-number">0</span>]<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">max</span>(ans, (surmax[i + <span class="hljs-number">1</span>] * (premax - nums[i])))<br>            premax = <span class="hljs-built_in">max</span>(premax, nums[i])<br>        <span class="hljs-keyword">return</span> ans <br></code></pre></td></tr></table></figure><h1 id="100076-无限数组的最短子数组-力扣（LeetCode）"><a href="#100076-无限数组的最短子数组-力扣（LeetCode）" class="headerlink" title="100076. 无限数组的最短子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">100076. 无限数组的最短子数组 - 力扣（LeetCode）</a></h1><p>滑动窗口</p><p>子数组是连续的 要求最短的就是先看看 能凑成几个完整的原序列  然后再两个序列间 凑出剩余的</p><p>剩余的就用滑动窗口来算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSizeSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        total = <span class="hljs-built_in">sum</span>(nums)<br>        nums = nums + nums<br>        x = target // total<br>        target %= total<br>        s = l = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * <span class="hljs-number">2</span>):<br>            s += nums[i]<br>            <span class="hljs-keyword">while</span> s &gt; target:<br>                s -= nums[l]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s == target:<br>                ret = <span class="hljs-built_in">min</span>(ret, i - l + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ret + x * n<br>        <br></code></pre></td></tr></table></figure><h1 id="8028-执行操作使两个字符串相等-力扣（LeetCode）"><a href="#8028-执行操作使两个字符串相等-力扣（LeetCode）" class="headerlink" title="8028. 执行操作使两个字符串相等 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/">8028. 执行操作使两个字符串相等 - 力扣（LeetCode）</a></h1><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><p>首先 1的个数的奇偶不同就不能变成一样的 返回-1</p><p>用dfs计算加上@cache变为记忆化搜索</p><p>每次变都是两个一起变 操作1 第一个变的时候就记录这次变化的消耗  然后另一个就相当于可以免费变化  记录免费变化的次数</p><p>操作2 不能像操作1那样在任意位置变  而是 只要用了操作2 必定是连续的两个变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span> != s2.count(<span class="hljs-string">&#x27;1&#x27;</span>) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>        n = <span class="hljs-built_in">len</span>(s1)<br>        <span class="hljs-comment"># 从前往后遍历 </span><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, pre_rever: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 到头了</span><br>            <span class="hljs-keyword">if</span> i == n:<br>                <span class="hljs-keyword">return</span> inf <span class="hljs-keyword">if</span> j <span class="hljs-keyword">or</span> pre_rever <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 不需要反转</span><br>            <span class="hljs-comment"># 当前不相等 但是前面有反转了 导致这两个相等</span><br>            <span class="hljs-keyword">if</span> s1[i] != s2[i] <span class="hljs-keyword">and</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <span class="hljs-comment"># 当前相等 并且前面没反转 这两个仍然相等</span><br>            <span class="hljs-keyword">if</span> s1[i] == s2[i] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> pre_rever:<br>                <span class="hljs-keyword">return</span> dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">False</span>)<br>            <br>            <span class="hljs-comment"># 需要反转 分别用操作1 和 操作2 取最小值 记得加上反转的代价 操作1为x 操作2为1</span><br>            res = <span class="hljs-built_in">min</span>(dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-literal">False</span>) + x, dfs(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">True</span>) + <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment"># 操作1的免费反转（操作2的免费反转在上面）</span><br>            <span class="hljs-keyword">if</span> j:<br>                res = <span class="hljs-built_in">min</span>(res, dfs(i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, pre_rever))<br>            <br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>dp做法</p><p>把所有需要变的位置先写出来 然后每次消除  通过操作1 每次消除一个 消耗x&#x2F;2（最后必定是可以消完的因为不行的情况已经返回-1了）或者用操作2 每次消除两个 比如1，4位置需要变化 那就需要3次操作12 23 34 这样  需要消耗 p[i] - p[i - 1]</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> s1 == s2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = [i <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(s1, s2)) <span class="hljs-keyword">if</span> x != y]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p) % <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(p)<br><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-comment"># 递归出口  到-1 说明是正常退出 （操作1 的0 - 1  操作2 的1 - 2）</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 到-2说明有问题 返回inf代表这个答案不能用</span><br>            <span class="hljs-keyword">if</span> i == -<span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> inf<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(i - <span class="hljs-number">1</span>) + x, dfs(i - <span class="hljs-number">2</span>) + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>再翻译成递推 dfs(i) -&gt; f[i]   注意翻译的时候 i - 1和i - 2  如果是f[i - 1] 和 f[i - 2] 会导致最后 i &#x3D;&#x3D; -1 和i &#x3D;&#x3D; -2 无法表示  所以 每个下标加上2</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        f = [<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>)<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        f[<span class="hljs-number">1</span>] = x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            new_f = <span class="hljs-built_in">min</span>(f[i] + x, f[i - <span class="hljs-number">1</span>] + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>           f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>]<br>            f[<span class="hljs-number">1</span>] = new_f<br>        <span class="hljs-keyword">return</span> f[m] // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>​     然后空间优化  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    f0, f1 = <span class="hljs-number">0</span>, x<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            f0, f1 = f1, <span class="hljs-built_in">min</span>(f1 + x, f0 + (p[i] - p[i - <span class="hljs-number">1</span>]) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> f1 // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="2897-对数组执行操作使平方和最大-力扣（LeetCode）"><a href="#2897-对数组执行操作使平方和最大-力扣（LeetCode）" class="headerlink" title="2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/">2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）</a></h1><p>与 越与越小 或越或越大   而x^y + y ^ 2 &lt; (x - d)^2 + (y + d)^2  所以 要尽量做或操作 直到最大</p><p>用位运算思考 先记录所有数每个比特位上有多少个1  然后构造尽量大的数 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m = <span class="hljs-built_in">max</span>(nums).bit_length()<br>        cnt = [<span class="hljs-number">0</span>] * m<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                cnt[i] += x &gt;&gt; i &amp; <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 构造出k个尽可能大的数</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            x = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> cnt[i]:<br>                    <span class="hljs-comment"># 消耗该比特位上的一个1</span><br>                    cnt[i] -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># x |= 就是直接把该位变成1 而1&lt;&lt;i就是对应位</span><br>                    x |= <span class="hljs-number">1</span> &lt;&lt; i <br>            ans += x * x<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="8026-构造乘积矩阵-力扣（LeetCode）"><a href="#8026-构造乘积矩阵-力扣（LeetCode）" class="headerlink" title="8026. 构造乘积矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/construct-product-matrix/description/">8026. 构造乘积矩阵 - 力扣（LeetCode）</a></h1><p>前后缀优化</p><p>类似的还有<a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><p>不能用乘积全部乘起来再除的方法 因为首先可能有0的情况 会导致错误 然后就是复杂度太高了</p><p>虽然说没有写循环 但是 乘积是高精度乘法 复杂度非常高所以会超时</p><p>同理  在每次计算前后缀的时候也需要取模防止数据过大超时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructProductMatrix</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        pre = suf = <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        ans = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        mod = <span class="hljs-number">12345</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans[i][j] = pre % mod<br>                pre = pre * grid[i][j] % mod<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                ans[i][j] = ans[i][j] * suf % mod<br>                suf = suf * grid[i][j] % mod<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="100101-找出满足差值条件的下标-II-力扣（LeetCode）"><a href="#100101-找出满足差值条件的下标-II-力扣（LeetCode）" class="headerlink" title="100101. 找出满足差值条件的下标 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">100101. 找出满足差值条件的下标 II - 力扣（LeetCode）</a></h1><p>这种题目 下标差 然后再找满足另一个条件的 就需要 储存前缀（或后缀）的最大值和最小值</p><p>类似于股票的第一题</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findIndices</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], indexDifference: <span class="hljs-built_in">int</span>, valueDifference: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        max_idx = <span class="hljs-number">0</span><br>        min_idx = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(indexDifference, n):<br>            j = i - indexDifference<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[max_idx]:<br>                max_idx = j<br>            <span class="hljs-keyword">elif</span> nums[j] &lt; nums[min_idx]:<br>                min_idx = j<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[max_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, max_idx]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(nums[i] - nums[min_idx]) &gt;= valueDifference:<br>                <span class="hljs-keyword">return</span> [i, min_idx]<br>        <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><h1 id="100077-最长相邻不相等子序列-II-力扣（LeetCode）"><a href="#100077-最长相邻不相等子序列-II-力扣（LeetCode）" class="headerlink" title="100077. 最长相邻不相等子序列 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/description/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></h1><p><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/solutions/2484023/python3zhu-ju-fen-xi-dong-tai-gui-hua-qi-gdss/">100077. 最长相邻不相等子序列 II - 力扣（LeetCode）</a></p><h1 id="100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）"><a href="#100084-最短且字典序最小的美丽子字符串-力扣（LeetCode）" class="headerlink" title="100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）</a></h1><p>滑动窗口 </p><p>一开始写的时候 出了好多错ww 下标什么的 while循环的条件带不带等号 还有最后更新忘记判断字典序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBeautifulSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        l = <span class="hljs-number">0</span><br>        cnt = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> cnt &gt; k:<br>                <span class="hljs-keyword">if</span> s[l] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    cnt -= <span class="hljs-number">1</span><br>                    l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; n <span class="hljs-keyword">and</span> s[l] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == k:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ans) == <span class="hljs-number">0</span>:<br>                    ans = s[l:i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> i - l + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(ans):<br>                    ans = s[l: i + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">elif</span> i - l + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(ans):<br>                    <span class="hljs-keyword">if</span> s[l: i + <span class="hljs-number">1</span>] &lt; ans:<br>                        ans = s[l:i + <span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="6920-得到-K-个半回文串的最少修改次数-力扣（LeetCode）"><a href="#6920-得到-K-个半回文串的最少修改次数-力扣（LeetCode）" class="headerlink" title="6920. 得到 K 个半回文串的最少修改次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/description/">6920. 得到 K 个半回文串的最少修改次数 - 力扣（LeetCode）</a></h1><p>思路是枚举每一个串看他们是否可以分成符合要求的子串</p><p>主要分成三个部分  首先就是求   一个子字符串变成半回文串的最小修改次数 </p><p>需要先预处理出每个长度n的真因子  </p><p>然后用modify数组来存储每个子字符串的最少修改次数</p><p>最后用划分DP来求整个串需要的最少修改次数</p><p>dfs(i, j ) 表示把s[0]到s[j] 的字符串划分成i + 1 个子字符串  </p><p>i 表示还需要分割的次数   i + 1 表示切出来i + 1段</p><p> j表示 s[0] ~ s[j]为当前需要切割的部分 （右端点）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 预处理n的所有的真因子(类似于埃式筛的做法 先求出i是那几个数的真因子)</span><br>MX = <span class="hljs-number">201</span><br>divisors = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(MX)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, MX):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, MX, i):<br>        divisors[j].append(i)<br><br><span class="hljs-comment"># 先求单个字串s变成半回文串的最少修改次数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_modify</span>(<span class="hljs-params">s:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <br>    n = <span class="hljs-built_in">len</span>(s)<br>    ans = inf<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> divisors[n]:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i0 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(d):<br>            i, j = i0, n - d + i0<br>            <span class="hljs-keyword">while</span> i &lt; j:<br>                ret += s[i] != s[j]<br>                i += d<br>                j -= d<br>        ans = <span class="hljs-built_in">min</span>(ans, ret)<br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumChanges</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        划分型DP</span><br><span class="hljs-string">        dfs(i, j)</span><br><span class="hljs-string">        i 为 剩余需要分割的个数</span><br><span class="hljs-string">        那么i + 1 就是切出来的子串的个数</span><br><span class="hljs-string">        j s[0] ~ s[j] 为当前需要切割的部分</span><br><span class="hljs-string">        返回修改最少的次数</span><br><span class="hljs-string">        枚举当前这一段的左端点</span><br><span class="hljs-string">        L的最小值就是2i 因为 剩下i段要切 每段至少是2（因为1&lt;=d&lt;=len len至少是2）</span><br><span class="hljs-string">        L的最大值为j - 1</span><br><span class="hljs-string">        设modify[i][j] 为s[i] ~ s[j]最小修改次数</span><br><span class="hljs-string">        dfs(i, j) = dfs(i - 1, L - 1) + modify[i][j]</span><br><span class="hljs-string">        终点 i = 0 return modify[0][j]</span><br><span class="hljs-string">        入口dfs(k - 1, n - 1)</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-comment"># 预处理出每个子串 成为半回文串的最小修改次数</span><br>        modify = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left + <span class="hljs-number">1</span>, n):<br>                modify[left][right] = get_modify(s[left:right + <span class="hljs-number">1</span>])<br><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-comment"># i为0 的时候 即 不需要再划分了</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> modify[<span class="hljs-number">0</span>][j]<br>            ret = inf<br>            <span class="hljs-comment"># 枚举左端点 左端点从i* 2开始 最大为j - 1 右端点为j</span><br>            <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i * <span class="hljs-number">2</span>, j):<br>                ret = <span class="hljs-built_in">min</span>(ret, dfs(i - <span class="hljs-number">1</span>, L - <span class="hljs-number">1</span>) + modify[L][j])<br>            <span class="hljs-keyword">return</span> ret<br>        <span class="hljs-keyword">return</span> dfs(k - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="100097-合法分组的最少组数-力扣（LeetCode）"><a href="#100097-合法分组的最少组数-力扣（LeetCode）" class="headerlink" title="100097. 合法分组的最少组数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/">100097. 合法分组的最少组数 - 力扣（LeetCode）</a></h1><p>首先思路就错了。。其实是从大（最少出现次数）到小（1） 枚举最小分割的k  一旦满足要求就可以直接返回  而不是先从最小出现次数 计算不对之后 再去拆分每一个数。。因为只要不是k 和k + 1 就不行  k - 1 会与k + 1 冲突</p><p>为什么q &lt; r 的时候不行呢   因为 k &#x3D; 10的时候 比如30分成3个10 可以31 分成10 10 11 ；32 分成10 11 11 ；33分成11 11 11 ；但是到了34   r &#x3D; 4  q &#x3D; 3  此时不能把r均摊到q上   所以说这种分法是不行的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minGroupsForValidAssignment</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums = Counter(nums)<br>        m = <span class="hljs-built_in">min</span>(nums.values())<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            ans = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> nums.values():<br>                q, r = <span class="hljs-built_in">divmod</span>(v, i)<br>                <span class="hljs-keyword">if</span> q &lt; r:<br>                    ans = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    ans += math.ceil(v / (i + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># for else 结构  没有break运行 （也可以 if ans:）</span><br>                <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="100114-元素和最小的山形三元组-II-力扣（LeetCode）"><a href="#100114-元素和最小的山形三元组-II-力扣（LeetCode）" class="headerlink" title="100114. 元素和最小的山形三元组 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/submissions/476195772/">100114. 元素和最小的山形三元组 II - 力扣（LeetCode）</a></h1><p>求出前缀的最小值 后缀的最小值</p><p>然后遍历每个i 如果是山状的  取i  i-1的最小值  i + 1 的最小值即可 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        left_min = [<span class="hljs-number">0</span>] * n<br>        left_min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        right_min = [<span class="hljs-number">0</span>] * n<br>        right_min[-<span class="hljs-number">1</span>] = nums[-<span class="hljs-number">1</span>]<br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            left_min[i] = <span class="hljs-built_in">min</span>(left_min[i - <span class="hljs-number">1</span>], nums[i])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            right_min[i] = <span class="hljs-built_in">min</span>(right_min[i + <span class="hljs-number">1</span>], nums[i])<br>        <br>        ret = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; left_min[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i] &gt; right_min[i + <span class="hljs-number">1</span>]:<br>                ret = <span class="hljs-built_in">min</span>(ret, nums[i] + left_min[i - <span class="hljs-number">1</span>] + right_min[i + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ret == inf <span class="hljs-keyword">else</span> ret<br></code></pre></td></tr></table></figure><h1 id="容器multiset"><a href="#容器multiset" class="headerlink" title="容器multiset"></a>容器multiset</h1><p><a href="https://codeforces.com/contest/1883/problem/D">Problem - D - Codeforces</a></p><p>用multiset可以自动排序 并且存储多个重复的数</p><p>注意erase的时候 要用s.erase(s.lower_bound(x))不然会删掉所有的x</p><p>本题只需要有一个不相交就行  那也就是 最大的left 和最小的right比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br>multiset&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">char</span> c;<br>    cin &gt;&gt; c &gt;&gt; l &gt;&gt; r;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>)<br>    &#123;<br>        s1.<span class="hljs-built_in">insert</span>(l);<br>        s2.<span class="hljs-built_in">insert</span>(r);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">lower_bound</span>(l));<br>        s2.<span class="hljs-built_in">erase</span>(s2.<span class="hljs-built_in">lower_bound</span>(r));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> s = s1.<span class="hljs-built_in">end</span>(), e = s2.<span class="hljs-built_in">begin</span>();<br>    s--;<br>    <span class="hljs-keyword">if</span> (*s &gt; *e)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-C-Codeforces-1"><a href="#Problem-C-Codeforces-1" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/C">Problem - C - Codeforces</a></h1><p>模拟  每次循环比较两个位置的值 然后把小的数变成大的数（题目要求只能增大）计算出差值就是一共要走的步数  并且直接将两个位置的值都修改为较大的值（表示变换了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">v</span>(n + <span class="hljs-number">5</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(n + <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            cin &gt;&gt; v[i][j];<br>        &#125;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        ll ii = <span class="hljs-number">1</span>, jj = <span class="hljs-number">1</span>;<br>        ll tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = n; col &gt;= <span class="hljs-number">1</span>; col--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">1</span>; row &lt;= n; row++)<br>            &#123;<br>                tot += <span class="hljs-built_in">abs</span>(v[ii][jj] - v[row][col]);<br>                ans += <span class="hljs-built_in">abs</span>(v[ii][jj] - v[row][col]);<br>                v[row][col] = <span class="hljs-built_in">max</span>(v[ii][jj], v[row][col]);<br>                v[ii][jj] = <span class="hljs-built_in">max</span>(v[ii][jj], v[row][col]);<br>                jj++;<br>            &#125;<br>            ii++;<br>            jj = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!tot)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces-1"><a href="#Problem-D-Codeforces-1" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1881/problem/D">Problem - D - Codeforces</a></h1><p>n个数 能不能最后变成相同的n个数  注意到 <em>x &#x2F; x 最终的乘积是不变的 所以可以算出每个数的因子  这些因子乘起来 就是总乘积  然后除了1以外  看看这些因子是否能被n整除  比如 3个5  6个8 肯定是能被分成3个一样的数的 5 * (2</em> 8) 用哈希表记录每个因数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j&lt;=x/j; j++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % j == <span class="hljs-number">0</span>)<br>            &#123;<br>                mp[j]++;<br>                x /= j;<br>            &#125;<br>        &#125;<br>        mp[x]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : mp)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x.first == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (x.second % n != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-B-Codeforces"><a href="#Problem-B-Codeforces" class="headerlink" title="Problem - B - Codeforces"></a><a href="https://codeforces.com/contest/1899/problem/B">Problem - B - Codeforces</a></h1><p>CF–记录傻逼瞬间</p><p>简单的暴力 maxnum范围开小了 从头WA到尾。。</p><p>前缀和 的范围 是远超过1e9的单个数字的范围的。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">qzh</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br>    ll minn = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>, maxn = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, nums[i]);<br>        minn = <span class="hljs-built_in">min</span>(minn, nums[i]);<br>        qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>    ll ret = maxn - minn;<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">if</span> (n % i != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j += i)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, qzh[j] - qzh[j - i]);<br>            minn = <span class="hljs-built_in">min</span>(minn, qzh[j] - qzh[j - i]);<br>        &#125;<br>        ret = <span class="hljs-built_in">max</span>(ret, maxn - minn);<br>    &#125;<br>    cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Problem-C-Codeforces-2"><a href="#Problem-C-Codeforces-2" class="headerlink" title="Problem - C - Codeforces"></a><a href="https://codeforces.com/contest/1899/problem/C">Problem - C - Codeforces</a></h1><p>C也是懒得喷。。我艹 vector开在局部 还每次都开2e5赋值0的是什么傻逼 T了一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> nums[N] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    ll ret = nums[<span class="hljs-number">0</span>];<br>    ll l = <span class="hljs-number">0</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[l] &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret = nums[l];<br>        sum = nums[l];<br>    &#125;<br>    l++;<br>    <span class="hljs-keyword">while</span> (l &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(nums[l] % <span class="hljs-number">2</span>) != <span class="hljs-built_in">abs</span>(nums[l - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>))<br>        &#123;<br>            sum += nums[l];<br>            <span class="hljs-keyword">while</span> (sum &lt; <span class="hljs-number">0</span> &amp;&amp; l &lt; n)<br>            &#123;<br>                l++;<br>                sum = nums[l];<br>                ret = <span class="hljs-built_in">max</span>(ret, sum);<br>            &#125;<br>            ret = <span class="hljs-built_in">max</span>(ret, sum);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                sum = nums[l];<br>                ret = <span class="hljs-built_in">max</span>(sum, ret);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        l++;<br>    &#125;<br>    cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100138-最大化网格图中正方形空洞的面积-力扣（LeetCode）"><a href="#100138-最大化网格图中正方形空洞的面积-力扣（LeetCode）" class="headerlink" title="100138. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/">100138. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）</a></h1><p>emm 感觉这两场状态都很差，题目没看明白 浪费了很多时间。</p><p>其实求最大的正方形  不是去整个里面删除  而是在可以删除的线（vBars和hBars）里面找 最长的连续的是多少   画个图 就能看出来 (最后要加一，，也是画图)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximizeSquareHoleArea</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, hBars: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], vBars: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>):<br>            l = <span class="hljs-built_in">len</span>(a)<br>            cnt = <span class="hljs-number">1</span><br>            ret = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l):<br>                <span class="hljs-keyword">if</span> a[i] == a[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    ret = <span class="hljs-built_in">max</span>(ret, cnt)<br>                    cnt = <span class="hljs-number">1</span><br>            ret = <span class="hljs-built_in">max</span>(ret, cnt)<br>            <span class="hljs-keyword">return</span> ret<br><br>        hBars.sort()<br>        vBars.sort()<br>        x = <span class="hljs-built_in">min</span>(f(hBars), f(vBars)) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure><h1 id="100139-循环移位后的矩阵相似检查-力扣（LeetCode）"><a href="#100139-循环移位后的矩阵相似检查-力扣（LeetCode）" class="headerlink" title="100139. 循环移位后的矩阵相似检查 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/matrix-similarity-after-cyclic-shifts/description/">100139. 循环移位后的矩阵相似检查 - 力扣（LeetCode）</a></h1><p>看清题目！其实就是直接比较两列是否相等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areSimilar</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        row = <span class="hljs-built_in">len</span>(mat)<br>        col = <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">if</span> k % col == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        k %= col<br>        <br>        now = [[<span class="hljs-number">0</span>] * col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br>        <span class="hljs-built_in">print</span>(mat)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>                now[j][i] = mat[j][(i + k) % col]<br>                <br>        <span class="hljs-built_in">print</span>(now, mat)<br>        <span class="hljs-keyword">if</span> now == mat:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1 id="100142-交换得到字典序最小的数组-力扣（LeetCode）"><a href="#100142-交换得到字典序最小的数组-力扣（LeetCode）" class="headerlink" title="100142. 交换得到字典序最小的数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/">100142. 交换得到字典序最小的数组 - 力扣（LeetCode）</a></h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lexicographicallySmallestArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        3 1 2 limit = 1 那么1 3 的差大于limit 是不是就不能换了呢？</span><br><span class="hljs-string">        不是 可以借助2来换 2 1 3 -&gt; 1 2 3 </span><br><span class="hljs-string">        3 5 1 7 limit = 2 可以换到1 3 5 7 </span><br><span class="hljs-string">        这说明limit限制内的所有数 都可以被换成从小到大的数</span><br><span class="hljs-string">        这被称为一个连通块（类似图论的概念）</span><br><span class="hljs-string">        再看 2 4 22 20 3 21 1 </span><br><span class="hljs-string">        这组数有两个连通块 1 2 3 4 可以按顺序 20 21 22 可以按顺序 但是 他们只能在各自的块内交换 即 1 2 20 21 3 22 4</span><br><span class="hljs-string">        用 排序+分组循环</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 注意排序不能直接排  会丢失下标</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        a = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(nums, <span class="hljs-built_in">range</span>(n)))<br>        <span class="hljs-comment"># 现在a 是带下标的 排序的nums值 如(6,1)(0,2)(4,3)(1,4)(3,20)(5,21)(2,22) 需要把他们分别放到各自的空里</span><br>        <span class="hljs-comment"># 分组循环 每次排一个连通块</span><br>        i = <span class="hljs-number">0</span><br>        ans = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            st = i<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> a[i][<span class="hljs-number">0</span>] &lt;= a[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + limit:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 出来的这个i 就是下一组的了</span><br>            <span class="hljs-comment"># 现在要把前面这几个 按下标排序 排完之后把a分别放到这些下标里（因为a是数从小到大 刚好放到下标的从小到大）</span><br>            sub = a[st:i]<br>            sub_idx = <span class="hljs-built_in">sorted</span>(i <span class="hljs-keyword">for</span> _, i <span class="hljs-keyword">in</span> sub)<br>            <span class="hljs-comment"># 排好了 放回去</span><br>            <span class="hljs-keyword">for</span> j, (x, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(sub_idx, sub):<br>                ans[j] = x<br>            <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习</title>
    <link href="/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- This is explanation--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to write<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is Heading1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is Heading2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>MAX Heading is 6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is strong<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>single tag:next paragraph<br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>single tag:divider<br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>ATTENTION:single tag:next paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> This<br>    is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is paragraph This is<br>    paragraph This is paragraph This is paragraph This is paragraph <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>same as strong<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>This is underline<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This is italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>This is delete<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You must have find that even if you wrap in vscode, it won&#x27;t wrap in Webpage<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert some medium<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to insert a photo<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 只写宽或高会等比例变换 两个都写可能变形 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./MD5.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;加载失败（替换文本示例）&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;This is title&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 下级目录 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;in/MD5.png&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 上级目录 就用../--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play music<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;刻在我心底的名字.mp3&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Now we study how to play video<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;a.mp4&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Now we study how to insert hyperlink<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/?tn=15007414_8_dg&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;study1.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>study1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>空连接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><p>app.json </p><p>pages记录当前小程序所有页面的路径</p><p>window 全局定义小程序背景文字颜色</p><p>style 组件样式</p>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>js</tag>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Math</title>
    <link href="/2023/09/11/Math/"/>
    <url>/2023/09/11/Math/</url>
    
    <content type="html"><![CDATA[<h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">如果i是primes[j]的倍数，跳出循环是因为在线性筛的过程中，我们的目标是找到小于等于n的所有素数，并且要保证每个合数只被标记一次。因此，在内层循环中，当i是primes[j]的倍数时，我们不需要再继续考虑primes[j] * i及其之后的倍数了，因为它们已经在之前的迭代中被标记过了。</span><br><span class="hljs-string"></span><br><span class="hljs-string">举个例子来说明：</span><br><span class="hljs-string"></span><br><span class="hljs-string">假设我们正在处理i=10，而primes[j]=2，也就是说10是2的倍数。那么在这一轮迭代中，我们会标记10、20、30、40、...等等所有10的倍数为非素数。但实际上，这些数在之前已经被标记过了，因为它们分别是2、4、6、8、...等等的倍数，而这些倍数在处理2的时候已经被标记过了。所以，为了避免重复标记，当i是primes[j]的倍数时，我们可以直接跳出内层循环，不再处理这个数及其后续的倍数。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_sieve</span>(<span class="hljs-params">n</span>):<br>    is_prime = [<span class="hljs-literal">True</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 初始化一个布尔数组，标记每个数是否为素数</span><br>    primes = []  <span class="hljs-comment"># 存储素数的列表</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i]:<br>            primes.append(i)  <span class="hljs-comment"># i是素数</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(primes)):<br>            <span class="hljs-comment"># 将已知素数primes[j]与当前数i相乘，标记其倍数为非素数</span><br>            <span class="hljs-keyword">if</span> primes[j] * i &gt; n:<br>                <span class="hljs-keyword">break</span><br>            is_prime[primes[j] * i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % primes[j] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果i是primes[j]的倍数，跳出循环</span><br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> primes<br><br>n = <span class="hljs-number">30</span>  <span class="hljs-comment"># 你可以设置需要查找素数的上限</span><br>primes = linear_sieve(n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小于等于&quot;</span>, n, <span class="hljs-string">&quot;的素数：&quot;</span>, primes)<br><br></code></pre></td></tr></table></figure><h1 id="0质因数个数-蓝桥云课-lanqiao-cn"><a href="#0质因数个数-蓝桥云课-lanqiao-cn" class="headerlink" title="0质因数个数 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2155/learning/">0质因数个数 - 蓝桥云课 (lanqiao.cn)</a></h1><p>n最大为10^16   </p><p>时间复杂度要在O(sqrt(n))</p><p>主要是 中间的while循环会直接处理掉所有当前质数的合数 比如i &#x3D; 2 会一直除以2 直到不能再被2除 使得2 4 6 8 10等合数在后面都不重复计算 而质数就会被留下 比如5 7 等 不会因为除以2而消失 最后会留下来 所以不会漏算 </p><p>然后 i &lt; n &#x2F; i 有效减低了复杂度 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>)res++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)res++;<br>    cout&lt;&lt;res;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="365-水壶问题-力扣（LeetCode）"><a href="#365-水壶问题-力扣（LeetCode）" class="headerlink" title="365. 水壶问题 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/water-and-jug-problem/?envType=daily-question&envId=2024-01-28">365. 水壶问题 - 力扣（LeetCode）</a></h1><p>每次水壶只会增加或者减少x 或y的水 只要x + y &gt;&#x3D; z 找出一对a， b使得<strong>ax+by&#x3D;z</strong>就可以 那么就需要找出xy的最大公约数</p><p>贝祖定理告诉我们，ax+by&#x3D;z ax+by&#x3D;z $a<em>x+b</em>y&#x3D;z$ 有解当且仅当 z 是 x y 的最大公约数的倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canMeasureWater</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x + y &lt; z)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> z == <span class="hljs-number">0</span> || x + y == z;<br>        <span class="hljs-keyword">return</span> z % <span class="hljs-built_in">gcd</span>(x, y) == <span class="hljs-number">0</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span>: a? <span class="hljs-built_in">gcd</span>(b, a) <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1792-最大平均通过率-力扣（LeetCode）"><a href="#1792-最大平均通过率-力扣（LeetCode）" class="headerlink" title="1792. 最大平均通过率 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-average-pass-ratio/">1792. 最大平均通过率 - 力扣（LeetCode）</a></h1><p>优秀的学生要加入那个班级？ 这个就要看 这个学生加入那个班级最好（使得平均通过率增加最多）</p><p>就要算平均通过率的增量 按照增量排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxAverageRatio</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; classes, <span class="hljs-type">int</span> extraStudents)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        priority_queue&lt;tuple&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: classes)<br>        &#123;<br>            <span class="hljs-type">int</span> a = x[<span class="hljs-number">0</span>], b = x[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">double</span> zl = (<span class="hljs-type">double</span>) (a + <span class="hljs-number">1</span>) / (b + <span class="hljs-number">1</span>) - (<span class="hljs-type">double</span>) a / b;<br>            q.<span class="hljs-built_in">push</span>(&#123;zl, a, b&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (extraStudents--)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [_, a, b] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            a++, b++;<br>            <span class="hljs-type">double</span> zl = (<span class="hljs-type">double</span>)(a + <span class="hljs-number">1</span>) / (b + <span class="hljs-number">1</span>) - (<span class="hljs-type">double</span>)a / b;<span class="hljs-comment">// 如果再次加到这个班 增量的大小</span><br>            q.<span class="hljs-built_in">push</span>(&#123;zl, a, b&#125;);<br>        &#125;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [_, a, b] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ans += (<span class="hljs-type">double</span>) a / b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans / classes.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1205-买不到的数目-AcWing题库"><a href="#1205-买不到的数目-AcWing题库" class="headerlink" title="1205. 买不到的数目 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1207/">1205. 买不到的数目 - AcWing题库</a></h1><h2 id="寻找数学规律的方法"><a href="#寻找数学规律的方法" class="headerlink" title="寻找数学规律的方法"></a>寻找数学规律的方法</h2><p>可以把题目先模拟出来找规律 不用手写</p><p>找规律可以固定a不变 换b  然后再固定b不变换a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (m &gt;= p &amp;&amp; <span class="hljs-built_in">dfs</span>(m - p, p, q))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (m &gt;= q &amp;&amp; <span class="hljs-built_in">dfs</span>(m - q, p, q))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p, q;<br>    cin&gt;&gt;p &gt;&gt; q;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, p, q))res = i;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个数不能凑出的 最大数 要求 两个正整数必须互质才可能有最大不能凑出的数</p><p>即当gcd(a, b)&gt;1 的时候无解   互质的时候 两个数最大不能凑出的数为 (a - 1) * (b - 1) - 1</p><h1 id="1216-饮料换购-AcWing题库"><a href="#1216-饮料换购-AcWing题库" class="headerlink" title="1216. 饮料换购 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1218/">1216. 饮料换购 - AcWing题库</a></h1><p>当还有剩余的瓶盖或者完整的饮料的时候 就要继续循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> ys = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        ans += n;<br>        ys += n % <span class="hljs-number">3</span>;<br>        n /= <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//cout&lt;&lt; n&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;ys&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (n || ys &gt;= <span class="hljs-number">3</span>)<br>    &#123;<br>        n = ys / <span class="hljs-number">3</span>;<br>        ys = ys % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (n)<br>        &#123;<br>            ans += n;<br>            ys += n % <span class="hljs-number">3</span>;<br>            n /= <span class="hljs-number">3</span>;<br>            <span class="hljs-comment">//cout&lt;&lt; n&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;ys&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br>        &#125;<br>        <br>    &#125;<br>    <br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1224-交换瓶子-AcWing题库"><a href="#1224-交换瓶子-AcWing题库" class="headerlink" title="1224. 交换瓶子 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/1226/">1224. 交换瓶子 - AcWing题库</a></h1><p>置换群</p><p>每个长k的环需要k - 1次交换 则求n中有多少个环即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> nums[<span class="hljs-number">10010</span>];<br><span class="hljs-type">int</span> vis[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; <br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[nums[i]])<br>        &#123;<br>            cnt++;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (!vis[nums[j]])<br>            &#123;<br>                vis[nums[j]] = <span class="hljs-number">1</span>;<br>                j = nums[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;n - cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论入门题解</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5318-【深基18-例3】查找文献-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P5318">P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>用vector<int>graph[N]存图 类似于defaultdict(list)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>vis[x] = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[x][i]])<br>&#123;<br><span class="hljs-built_in">dfs</span>(graph[x][i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(x);<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[a].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!vis[graph[a][i]])<br>&#123;<br>vis[graph[a][i]] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(graph[a][i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">emplace_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">sort</span>(graph[i].<span class="hljs-built_in">begin</span>(), graph[i].<span class="hljs-built_in">end</span>());<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br><br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3916-图的遍历-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>有向图求每个点能到达的编号最大的点</p><p>图论的经典做法  存反图然后从最大的点开始遍历他能到达的所有点 更新  后续如果这个点已经更新过了 就不再更新了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;fgraph[N];<br><span class="hljs-type">int</span> dis[N] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>dis[x] = d;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fgraph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(fgraph[x][i], d);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br>fgraph[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">dfs</span>(i, i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1113-杂务-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1113">P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>经典拓扑+动态规划</p><p>把前面的杂物干完才能干后面的事  拓扑排序</p><p>并且加上了动态规划（有点类似dijkstra）   完成所有杂物的最短时间 每次循环更新 到u这个任务需要的最短时间 （即f[u] &#x3D; max(f[u], f[x] + t[u]）到u的最短 即到源点到x的最短加上到x到u的最短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">500500</span>;<br><br>vector&lt;<span class="hljs-built_in">int</span>&gt;graph[N];<br><span class="hljs-built_in">int</span> deg[N];<br><span class="hljs-built_in">int</span> f[N];<br><span class="hljs-built_in">int</span> t[N];<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; t[i];<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v &amp;&amp; v)<br>&#123;<br>graph[v].push_back(u);<br>deg[u]++;<br>&#125;<br>&#125;<br>queue&lt;<span class="hljs-built_in">int</span>&gt;q;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(i);<br>f[i] = t[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.empty())<br>&#123;<br><span class="hljs-built_in">int</span> x = q.front();<br>q.pop();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].size(); i++)<br>&#123;<br><span class="hljs-built_in">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.push(u);<br>&#125;<br>f[u] = <span class="hljs-built_in">max</span>(f[u], f[x] + t[u]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4017-最大食物链计数-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求食物链的数量（食物链必须到最高消费者 即不被捕食的动物 即出度为0的）</p><p>拓扑排序+动态规划 </p><p>比如a-&gt;b-&gt;c   每次更新时 nums[b] &#x3D; nums[b] + nums[a] 把到第a的食物链条数全部累加到b中  最后把出度为0的点的条数加上 即为答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">80112002</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><span class="hljs-type">int</span> deg[N], out[N], nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>deg[b]++;<br>out[a]++;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>nums[i] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> u = graph[x][i];<br>deg[u]--;<br><span class="hljs-keyword">if</span> (deg[u] == <span class="hljs-number">0</span>)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(u);<br>&#125;<br>nums[u] = (nums[u] + nums[x]) % mod;<br>&#125;<br><br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>)<br>&#123;<br>ans = (nums[i] + ans)%mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1807-最长路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1807">P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>最长路问题   还是动态规划  d[i] &#x3D; max(d[x]  + mp[x ] [ i ], d[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000</span>, M = <span class="hljs-number">55000</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> d[N], mp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> u, v, w;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>mp[u][v] = <span class="hljs-built_in">max</span>(mp[u][v], w);<br>&#125;<br><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (mp[x][i] &amp;&amp; d[i] &lt; d[x] + mp[x][i])<br>&#123;<br>d[i] = d[x] + mp[x][i];<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>&#125;<br>&#125;<br><br>cout &lt;&lt; d[n] &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2853-USACO06DEC-Cow-Picnic-S-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P2853 USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P2853 <a href="https://www.luogu.com.cn/problem/P2853">USACO06DEC] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>求有几个地方 是所有的奶牛都可以的到达的</p><p>那每次走过的时候次数+1  当all[x] &#x3D;&#x3D; k 的时候就代表这个点都可以到达</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> a[N], vis[N], all[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;graph[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[x] != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>vis[x] = <span class="hljs-number">1</span>;<br>all[x] += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">int</span> y = graph[x][i];<br><span class="hljs-keyword">if</span> (vis[y] == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">dfs</span>(y);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>&#123;<br><span class="hljs-built_in">dfs</span>(a[i]);<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (all[i] == k)<br>ans += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1363-幻象迷宫-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1363">P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h1><p>无线的地图 那么只要它能够回到原点 就说明可以从一个点到另一个点  就可以无限走 就符合题意</p><p>用vis储存横纵坐标和是否访问  </p><p>每次进入先判断该点（是取模过的点 ***）是否已经访问过  如果访问过 并且x， y跟之前的不一样（只要有一个不一样就行）那就说明走到了另一个地图的原点 说明可以无限</p><p>如果访问过 并且是回到了原点 那就退回</p><p>标记该点为已访问 像四个方向拓展  lx和ly用来记录是否走出  要取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m, n, sx, sy, dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span> &#125;, dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span> &#125;, ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">bool</span> graph[N][N] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">int</span> vis[N][N][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> ly)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; (vis[lx][ly][<span class="hljs-number">0</span>] != x || vis[lx][ly][<span class="hljs-number">1</span>] != y))<br>&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vis[lx][ly][<span class="hljs-number">2</span>] &amp;&amp; vis[lx][ly][<span class="hljs-number">0</span>] == x &amp;&amp; vis[lx][ly][<span class="hljs-number">1</span>] == y)<span class="hljs-keyword">return</span>;<br>vis[lx][ly][<span class="hljs-number">0</span>] = x; vis[lx][ly][<span class="hljs-number">1</span>] = y; vis[lx][ly][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nx, ny;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">4</span>; w++)<br>&#123;<br>nx = (lx + dx[w] + n) % n;<br>ny = (ly + dy[w] + m) % m;<br><span class="hljs-keyword">if</span> (graph[nx][ny])<span class="hljs-built_in">dfs</span>(x + dx[w], y + dy[w], nx, ny);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(graph, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(graph));<br>ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>)graph[i][j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;S&#x27;</span>)<br>&#123;<br>sx = i, sy = j;<br>graph[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> graph[i][j] = <span class="hljs-literal">false</span>;<br>&#125; <br>&#125;<br><span class="hljs-built_in">dfs</span>(sx, sy, sx, sy);<br><span class="hljs-keyword">if</span> (ans)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="省份数量-547-省份数量-力扣（LeetCode）"><a href="#省份数量-547-省份数量-力扣（LeetCode）" class="headerlink" title="[省份数量](547. 省份数量 - 力扣（LeetCode）)"></a>[省份数量](<a href="https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory">547. 省份数量 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findCircleNum</span>(<span class="hljs-params">self, isConnected: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>cities = <span class="hljs-built_in">len</span>(isConnected)<br>        province = <span class="hljs-number">0</span><br>        vis = [<span class="hljs-number">0</span>] * cities<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[j] <span class="hljs-keyword">and</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    vis[j] = <span class="hljs-number">1</span><br>                    dfs(j)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cities):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                vis[i] = <span class="hljs-number">1</span><br>                province += <span class="hljs-number">1</span><br>                dfs(i)<br><br>        <span class="hljs-keyword">return</span> province<br>    <br>   <span class="hljs-comment"># 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 </span><br><span class="hljs-comment"># 重点在并查集的写法</span><br>uf = UnionFind()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(isConnected)):<br>            uf.add(i)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    uf.merge(i,j)<br>        <span class="hljs-keyword">return</span> uf.num_of_sets<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.father = &#123;&#125;<br>        self.num_of_sets = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self,x</span>):<br>        root = x<br>        <span class="hljs-keyword">while</span> self.father[root] != <span class="hljs-literal">None</span>:<br>            root = self.father[root]<br><span class="hljs-comment"># 让并查集更宽 减少时间复杂度</span><br>        <span class="hljs-keyword">while</span> x != root:<br>            original_father = self.father[x]<br>            self.father[x] = root<br>            x = original_father<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self,x,y</span>):<br>        root_x, root_y = self.find(x),self.find(y)<br><br>        <span class="hljs-keyword">if</span> root_x != root_y:<br>            self.father[root_x] = root_y<br>            self.num_of_sets -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.father:<br>            self.father[x] = <span class="hljs-literal">None</span><br>            self.num_of_sets += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）"><a href="#找到最终的安全状态-802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="[找到最终的安全状态](802. 找到最终的安全状态 - 力扣（LeetCode）)"></a>[找到最终的安全状态](<a href="https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory">802. 找到最终的安全状态 - 力扣（LeetCode）</a>)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2</span><br><span class="hljs-string">一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全</span><br><span class="hljs-string">&quot;&quot;&quot;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>n = <span class="hljs-built_in">len</span>(graph)<br>        color = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>            <span class="hljs-comment"># 访问已经搜过的结点 1为有环 2为无环</span><br>            <span class="hljs-keyword">if</span> color[x] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span><br>            <span class="hljs-comment"># 如果是0</span><br>            color[x] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-comment"># 快速退出</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> safe(y):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True</span><br>            color[x] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>       <br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> safe(i)]<br>    <br>    <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的</span><br><span class="hljs-string">    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序</span><br><span class="hljs-string">    循环结束后 所有入度为0的结点都是安全的</span><br><span class="hljs-string">    意思是，原图的出度为0的结点，和指向出度为0的结点的结点</span><br><span class="hljs-string">    （由于存了反图并拓扑排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eventualSafeNodes</span>(<span class="hljs-params">self, graph: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>rg = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> graph]<br>        <span class="hljs-comment"># 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0</span><br>        <span class="hljs-keyword">for</span>  x, ys <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:<br>rg[y].append(x)<br>        <span class="hljs-comment"># in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）</span><br>        in_deg = [<span class="hljs-built_in">len</span>(ys) <span class="hljs-keyword">for</span> ys <span class="hljs-keyword">in</span> graph]<br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>])<br><span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rg[q.popleft()]:<br>                in_deg[x] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[x] == <span class="hljs-number">0</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i, d  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="颜色交替的最短路径"><a href="#颜色交替的最短路径" class="headerlink" title=" 颜色交替的最短路径 "></a><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory"> 颜色交替的最短路径 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestAlternatingPaths</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, redEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], blueEdges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> redEdges:<br>            g[x].append((y,<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> blueEdges:<br>            g[x].append((y,<span class="hljs-number">1</span>))<br>        <br><br>        dis = [-<span class="hljs-number">1</span>] * n<br>        vis = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        q = &#123;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&#125;<br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> x, color <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">if</span> dis[x] == -<span class="hljs-number">1</span>:<br>                    dis[x] = level<br>                <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-keyword">if</span> p[<span class="hljs-number">1</span>] != color <span class="hljs-keyword">and</span> p <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        vis.add(p)<br>                        q.append(p)<br>            level += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dis<br></code></pre></td></tr></table></figure><h1 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间 "></a><a href="https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/">通知所有员工所需的时间 </a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numOfMinutes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, headID: <span class="hljs-built_in">int</span>, manager: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], informTime: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            g[manager[i]].append(i)<br><br>        q = collections.deque()<br>        q.append((headID, <span class="hljs-number">0</span>))<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q:<br>            tid, val = q.popleft()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g[tid]) == <span class="hljs-number">0</span>:<br>                res = <span class="hljs-built_in">max</span>(res, val)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> ne <span class="hljs-keyword">in</span> g[tid]:<br>                    q.append((ne, val + informTime[tid]))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="1466-重新规划路线-力扣（LeetCode）"><a href="#1466-重新规划路线-力扣（LeetCode）" class="headerlink" title="1466. 重新规划路线 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory">1466. 重新规划路线 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> connections:<br>            g[a].append((b, <span class="hljs-number">1</span>))<br>            g[b].append((a, <span class="hljs-number">0</span>))<br>        <br>        q = deque([<span class="hljs-number">0</span>])<br>        vis = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">while</span> q:<br>            cur = q.popleft()<br>            <span class="hljs-comment"># 遍历所有和cur相邻的边</span><br>            <span class="hljs-keyword">for</span> end, dirction <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(g[cur]):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[end]:<br>                    vis[end] = <span class="hljs-literal">True</span><br>                    <span class="hljs-comment"># 如果方向不对就反转</span><br>                    res += dirction<br>                    q.append(end)<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <br><span class="hljs-comment"># 或者 用set一次遍历  有点问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minReorder</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = &#123;<span class="hljs-number">0</span>&#125;<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> connection:<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> s:<br>                s.add(l)<br>            <span class="hljs-comment"># 右边不通向0 并且左边通向0 （左边通向右边） 那就让r-&gt;l r就可以到0</span><br>            <span class="hljs-keyword">elif</span> l <span class="hljs-keyword">in</span> s:<br>                s.add(r)<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>                <br>        <br></code></pre></td></tr></table></figure><h1 id="1192-查找集群内的关键连接-力扣（LeetCode）"><a href="#1192-查找集群内的关键连接-力扣（LeetCode）" class="headerlink" title="1192. 查找集群内的关键连接 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory">1192. 查找集群内的关键连接 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环 （此时的curnode为入口结点）</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="934-最短的桥-力扣（LeetCode）"><a href="#934-最短的桥-力扣（LeetCode）" class="headerlink" title="934. 最短的桥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory">934. 最短的桥 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两座相同的岛 先找到第一个不为0的数然后dfs标记这个岛的全部，然后用bfs搜索当第一次搜到第二个岛的step即是答案，注意dfs的时候要把第一个岛全部放入q（因为每个点都可能是距离第二个岛最近的点）搜完上下左右一圈后step + 1 （不需要vis数组记录 直接把走过的设为-1即可）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBridge</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = -<span class="hljs-number">1</span><br>            q.append((x, y))<br>            <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                    dfs(nx, ny)<br><br>        n = <span class="hljs-built_in">len</span>(grid)<br>        q = deque()<br>        i, j = <span class="hljs-built_in">next</span>((i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> grid[i][j])<br>        dfs(i, j)<br>        step = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x, y = q.popleft()<br>                <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> (x + <span class="hljs-number">1</span>, y), (x - <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>), (x, y - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n :<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">return</span> step<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">0</span>:<br>                            grid[nx][ny] = -<span class="hljs-number">1</span><br>                            q.append((nx, ny))<br>            step += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="127-单词接龙-力扣（LeetCode）"><a href="#127-单词接龙-力扣（LeetCode）" class="headerlink" title="127. 单词接龙 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=graph-theory">127. 单词接龙 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 每次枚举26个字母 一一替换单词 直到找到wordList的单词 如果是end的话就直接返回 否则step+1放入q继续bfs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> beginWord == endWord:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        word = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)]<br>        q = deque([(beginWord, <span class="hljs-number">1</span>)])<br>        <span class="hljs-keyword">while</span> q:<br>            cur, step = q.popleft()<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cur):<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> word:<br>                    <span class="hljs-keyword">if</span> x != y:<br>                        nxt = cur[:i] + y + cur[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">in</span> wordList:<br>                            <span class="hljs-keyword">if</span> nxt == endWord:<br>                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                            q.append((nxt, step + <span class="hljs-number">1</span>))<br>                            wordList.remove(nxt)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="126-单词接龙-II-力扣（LeetCode）"><a href="#126-单词接龙-II-力扣（LeetCode）" class="headerlink" title="126. 单词接龙 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个方法相当于是每次把step=1的所有数都找出来并且加进去 把所有step=2的都找出来加进去这样（&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot; and &quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;）     当q（内层）取完之后表示当前步数可以链接的下一个单词已经全部找到 可以step+1 然后把s中暂存的给q 再次循环    直到end 加入答案 （当内层q为0的时候表示所有路径都已经加进去 就直接return） 当q（外层）取完（也就是sq交换的时候s为[]）之后表示所有路径都已经走过 但是还没有遇到end 这时返回[]</span><br><span class="hljs-comment"># 首先 建图方面 建立这个单词可以变的其他单词 变化处用* 表示 用defaultdict后面可以快速访问 </span><br><span class="hljs-comment"># 然后q用来存储当前值和当前路径 s与q相同 但是s是用来存储每轮的数据 每次开始时s都为[] （保证数据 相当于temp）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLadders</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        wordList = <span class="hljs-built_in">set</span>(wordList)<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> []<br>        dic = defaultdict(<span class="hljs-built_in">list</span>)<br>        n = <span class="hljs-built_in">len</span>(beginWord)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]].append(w)<br>        <br>        q, s = [(beginWord, [beginWord])], []<br>        res = []<br>        vis = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> q:<br>            <span class="hljs-keyword">while</span> q:<br>                w, path = q.pop()<br>                vis.add(w)<br>                <span class="hljs-keyword">if</span> w == endWord:<br>                    res.append(path)<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> dic[w[:i] + <span class="hljs-string">&#x27;*&#x27;</span> + w[i + <span class="hljs-number">1</span>:]]:<br>                        <span class="hljs-keyword">if</span> nxt <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                            s.append((nxt, path + [nxt]))<br>            <span class="hljs-keyword">if</span> res:<br>                <span class="hljs-keyword">return</span> res<br>            q, s = s, q<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="542-01-矩阵-力扣（LeetCode）"><a href="#542-01-矩阵-力扣（LeetCode）" class="headerlink" title="542. 01 矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/01-matrix/description/?envType=study-plan-v2&envId=graph-theory">542. 01 矩阵 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多起点的最短路问题 可以将所有的0 看成同一个源点 然后使用bfs 因为每次扩散一轮 所有的都加一时候再扩散下一轮（队列 先进先出）每次只需要搜索四个方向 然后再原来的ret的基础上加一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">updateMatrix</span>(<span class="hljs-params">self, mat: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n, m = <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])<br>        ret = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        q = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> mat[i][j] == <span class="hljs-number">0</span>:<br>                    ret[i][j] = <span class="hljs-number">0</span><br>                    q.append([i,j])<br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j = q.popleft()<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> ret[ni][nj] == -<span class="hljs-number">1</span>:<br>                    ret[ni][nj] = ret[i][j] + <span class="hljs-number">1</span><br>                    q.append([ni, nj])<br><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="863-二叉树中所有距离为-K-的结点-力扣（LeetCode）"><a href="#863-二叉树中所有距离为-K-的结点-力扣（LeetCode）" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/?envType=study-plan-v2&envId=graph-theory">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distanceK</span>(<span class="hljs-params">self, root: TreeNode, target: TreeNode, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 首先用字典node_parent存储每个结点的父节点</span><br>        node_parent = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_find_parent</span>(<span class="hljs-params">node: TreeNode</span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">if</span> node.left:<br>                node_parent[node.left] = node<br>            <span class="hljs-keyword">if</span> node.right:<br>                node_parent[node.right] = node<br>            dfs_find_parent(node.left)<br>            dfs_find_parent(node.right)<br><br><br>        dfs_find_parent(root)<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [target.val]<br>        res = []<br><br>        q = deque()<br>        vis = <span class="hljs-built_in">set</span>()<br>        q.append(target)<br>        vis.add(target)<br>        <span class="hljs-comment"># 现在依次遍历和target距离为level的结点（波纹法 一层层搜索）</span><br>        level = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> level &lt; k:<br>            level += <span class="hljs-number">1</span> <span class="hljs-comment"># 先加还是后加取决于level初值</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [node_parent[x] <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> node_parent <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, x.left, x.right]: <span class="hljs-comment"># 遍历和当前点相邻的所有结点（每次搜索一层 注意要用set判重）</span><br>                    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">and</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis:<br>                        <span class="hljs-keyword">if</span> level == k:<br>                            res.append(y.val)<br>                        q.append(y)<br>                        vis.add(y)<br>        <span class="hljs-keyword">return</span> res<br><br>                <br></code></pre></td></tr></table></figure><h1 id="864-获取所有钥匙的最短路径-力扣（LeetCode）"><a href="#864-获取所有钥匙的最短路径-力扣（LeetCode）" class="headerlink" title="864. 获取所有钥匙的最短路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/?envType=study-plan-v2&envId=graph-theory">864. 获取所有钥匙的最短路径 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不同之处在于 并不是一个点只能走一次 而是可以多次走 找到最短的路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestPathAllKeys</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dis 用于记录每个点走的距离 不同的是 现在有3个状态 多了一个钥匙数的状态 </span><br>        dis = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0x3f3f3f3f</span>)<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>:<br>                    q = deque([(i, j, <span class="hljs-number">0</span>)])<br>                    dis[(i, j, <span class="hljs-number">0</span>)] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> grid[i][j].islower():<br>                    cnt += <span class="hljs-number">1</span><br><br><br>        dx = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>        <br>        <br>        <span class="hljs-keyword">while</span> q:<br>            i, j, cur = q.popleft()<br>            step = dis[(i,  j, cur)]<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                ni, nj = i + dx[k], j + dy[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m:<br>                    c = grid[ni][nj]<br>                    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># 先将cur右移c位然后&amp;1判断是否为1</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> <span class="hljs-keyword">and</span> (cur &gt;&gt; (<span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    ncur = cur<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:<br>                        <span class="hljs-comment"># 标记为已有</span><br>                        ncur |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-keyword">if</span> ncur == (<span class="hljs-number">1</span> &lt;&lt; cnt) - <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 如果曾经走到过这里 并且步数更少的话 更新 （如果没有走到过的话 那就是0x3f3f3f3f 必定更新）</span><br>                    <span class="hljs-keyword">if</span> step + <span class="hljs-number">1</span> &lt; dis[(ni, nj, ncur)]:<br>                        dis[(ni, nj, ncur)] = step + <span class="hljs-number">1</span><br>                        q.append((ni, nj, ncur))<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="1334-阈值距离内邻居最少的城市-力扣（LeetCode）"><a href="#1334-阈值距离内邻居最少的城市-力扣（LeetCode）" class="headerlink" title="1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></h1><p>题目要求一个城市在距离小于distanceThreshold下能够到达的城市</p><p>可以直接求 对每个城市进行搜索 也可以直接用Floyd 算法求出每两个城市之间的距离 再找距离小于dis的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTheCity</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], distanceThreshold: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        graph = [[inf] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b, w <span class="hljs-keyword">in</span> edges:<br>            graph[a][b] = graph[b][a] = w<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])<br>        <br>        ans = min_cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> j != i <span class="hljs-keyword">and</span> graph[i][j] &lt;= distanceThreshold:<br>                    cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt &lt;= min_cnt:<br>                min_cnt = cnt<br>                ans = i<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="2646-最小化旅行的价格总和-力扣（LeetCode）"><a href="#2646-最小化旅行的价格总和-力扣（LeetCode）" class="headerlink" title="2646. 最小化旅行的价格总和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/">2646. 最小化旅行的价格总和 - 力扣（LeetCode）</a></h1><p>树形DP  要算所有的路径  的总和可以先暴力DFS算出所有的路径的<strong>贡献</strong>：也就是比如0-1-2中求(0,2)(1,2) 那么1-2 算了两次 这样求出所有边走的次数cnt[x]</p><p>遍历(start, end) 求cnt</p><p>然后知道每个边的 次数之后再用树形DP（打家劫舍3）求出最小值   每个点减或不减</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotalPrice</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], price: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], trips: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            g[a].append(b)<br>            g[b].append(a)<br>        cnt = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> trips:<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>                <span class="hljs-keyword">if</span> x == end:<br>                    cnt[x] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                    <span class="hljs-comment"># dfs(y) 是为了说明这是可以到end的路(到end之后再往回更新cnt)</span><br>                    <span class="hljs-keyword">if</span> y != fa <span class="hljs-keyword">and</span> dfs(y):<br>                        cnt[x] += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dfs(start, -<span class="hljs-number">1</span>)<br>        <br>       <span class="hljs-comment"># 现在就得到了走的边的次数 再加上已知点的权值 用树形DP求</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, fa:<span class="hljs-built_in">int</span></span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            now_not_halve = price[x] * cnt[x]<br>            now_halve = price[x] * cnt[x] // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> g[x]:<br>                <span class="hljs-keyword">if</span> y != fa:<br>                    kid_not_halve, kid_halve = dfs(y, x)<br>                    now_not_halve += <span class="hljs-built_in">min</span>(kid_not_halve, kid_halve)<br>                    now_halve += kid_not_halve<br>            <span class="hljs-keyword">return</span> now_not_halve, now_halve<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))<br>        <br>                        <br></code></pre></td></tr></table></figure><h1 id="1631-最小体力消耗路径-力扣（LeetCode）"><a href="#1631-最小体力消耗路径-力扣（LeetCode）" class="headerlink" title="1631. 最小体力消耗路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径 - 力扣（LeetCode）</a></h1><p>看起来像DP但是其实是图论的题  为什么呢  因为dp只能向一个方向更新 比如只能一直向下 选择 [i + 1] [j - 1] 、[i + 1] [j] 、[i + 1] [j + 1] 这三种 但是这个题明显就是有4个方向 类似BFS</p><h2 id="方法一、-二分-BFS"><a href="#方法一、-二分-BFS" class="headerlink" title="方法一、 二分+BFS"></a>方法一、 二分+BFS</h2><p>二分可能的最大差异值 用bfs计算 如果最大差异大于x则…</p><p>注意这里维护的是最大差异  每次当更新的时候如果差异值小于x才更新 最终如果能到达右下角说明这个x可以</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        l, r = <span class="hljs-number">0</span>, <span class="hljs-number">10</span>**<span class="hljs-number">6</span>+<span class="hljs-number">10</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">mid</span>):<br>            dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>            dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>            q = deque()<br>            q.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            minn = maxn = heights[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>            vis = [[<span class="hljs-literal">False</span>] * m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> q:<br>                x, y = q.popleft()<br><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                    nx = x + dx[i]<br>                    ny = y + dy[i]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> vis[nx][ny] <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]) &lt;= mid:<br>                        vis[nx][ny] = <span class="hljs-number">1</span><br>                        q.append((nx, ny))<br><br>            <span class="hljs-keyword">return</span> vis[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="方法二、并查集"><a href="#方法二、并查集" class="headerlink" title="方法二、并查集"></a>方法二、并查集</h2><p>其实是Kruskal算法  对所有边排序之后 不断添加边 同时维护最大差异值 直到左上角和右下角联通 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">if</span> fa[x] == x:<br>                <span class="hljs-keyword">return</span> x<br>            fa[x] = find(fa[x])<br>            <span class="hljs-keyword">return</span> fa[x]<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>            fa[find(x)] = find(y)<br><br>        edgelen = []<br>        fa = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                pos = i * m + j<br>                <span class="hljs-keyword">if</span> i &lt; n - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i + <span class="hljs-number">1</span>][j] - heights[i][j]), pos, pos + m])<br>                <span class="hljs-keyword">if</span> j &lt; m - <span class="hljs-number">1</span>:<br>                    edgelen.append([<span class="hljs-built_in">abs</span>(heights[i][j + <span class="hljs-number">1</span>] - heights[i][j]), pos, pos + <span class="hljs-number">1</span>])<br>        <br>        edgelen.sort()<br>        <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edgelen:<br>            union(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">if</span> find(<span class="hljs-number">0</span>) == find(m * n - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> e[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="方法三、最短路"><a href="#方法三、最短路" class="headerlink" title="方法三、最短路"></a>方法三、最短路</h2><p>Dijikstra算法  只不过本来维护最短距离  现在维护最大差异 本来是存边  现在不需要存边 直接用BFS</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumEffortPath</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, m = <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>        q = [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]<br>        dis = [inf] * (m * n)<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        vis = <span class="hljs-built_in">set</span>()<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> q:<br>            d, x, y = heapq.heappop(q)<br>            pos = x * m + y<br>            <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> vis:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> (x, y) == (n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">break</span><br>            vis.add(pos)<br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = dx[i] + x<br>                ny = dy[i] + y<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; m <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny])) &lt;= dis[nx * m + ny]:<br>                    dis[nx * m + ny] = <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">abs</span>(heights[x][y] - heights[nx][ny]))<br>                    heapq.heappush(q, (dis[nx * m + ny], nx, ny))<br>        <span class="hljs-keyword">return</span> dis[m * n - <span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><h1 id="1345-跳跃游戏-IV-力扣（LeetCode）"><a href="#1345-跳跃游戏-IV-力扣（LeetCode）" class="headerlink" title="1345. 跳跃游戏 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game-iv/">1345. 跳跃游戏 IV - 力扣（LeetCode）</a></h1><p>BFS 但是要分情况 主要是存图要用map存 map[arr[i]].push_back(i);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            mp[arr[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dist</span>(n, inf);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(), step = dist[x];<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; n &amp;&amp; dist[x + <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x + <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dist[x - <span class="hljs-number">1</span>] == inf)<br>            &#123;<br>                dist[x - <span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(x - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : mp[arr[x]])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dist[y] == inf)<br>                &#123;<br>                    dist[y] = step + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125;<br>            &#125;<br>            mp[arr[x]].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1207-大臣的旅费-AcWing题库"><a href="#1207-大臣的旅费-AcWing题库" class="headerlink" title="1207. 大臣的旅费 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/1209/">1207. 大臣的旅费 - AcWing题库</a></h1><p>求树的直径问题</p><p>要求相距最远的两个城市 也就是求树的直径 </p><p>先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径</p><p>用dis记录任意点到i点的最远距离</p><p>dfs中需要添加father 防止回头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ;<br><span class="hljs-type">int</span> w[N] , e[N] , ne[N] , h[N] , idx ;<br><span class="hljs-type">int</span> maxu , maxd ;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b , <span class="hljs-type">int</span> c )</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> fa , <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    dis[u] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i != <span class="hljs-number">-1</span> ; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j != fa)<br>            <span class="hljs-built_in">dfs</span>(j,u,d + w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a , b , c ;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(maxu,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dis[maxu] &lt; dis[i]) <br>        &#123;   <br>            maxu = i;<br>            maxd = dis[maxu];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxd * <span class="hljs-number">10</span> + (maxd + <span class="hljs-number">1ll</span>) * maxd / <span class="hljs-number">2</span> &lt;&lt; endl ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一题题解</title>
    <link href="/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5166-对称山脉-AcWing题库"><a href="#5166-对称山脉-AcWing题库" class="headerlink" title="5166. 对称山脉 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5169/">5166. 对称山脉 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])</span><br><span class="hljs-comment"># 用ans记录每个长度j下的最小值</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>s = [[<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5010</span>)]<br>ans = [<span class="hljs-number">0x3f3f3f3f</span>] * <span class="hljs-number">5010</span><br>h = [<span class="hljs-number">0</span>] * <span class="hljs-number">5010</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    h[i+<span class="hljs-number">1</span>] =  nums[i]   <br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n-j+<span class="hljs-number">2</span>):<br>        s[i][i + j - <span class="hljs-number">1</span>] = s[i + <span class="hljs-number">1</span>][i + j - <span class="hljs-number">2</span>] + <span class="hljs-built_in">abs</span>(h[i] - h[i + j - <span class="hljs-number">1</span>])<br>        ans[j] = <span class="hljs-built_in">min</span>(ans[j], s[i][i + j - <span class="hljs-number">1</span>])<br><br>ans[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[j],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="5180-正方形泳池-AcWing题库"><a href="#5180-正方形泳池-AcWing题库" class="headerlink" title="5180. 正方形泳池 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5183/">5180. 正方形泳池 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>tree = []<br>tree.append([-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 占位</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,t + <span class="hljs-number">1</span>):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    tree.append([a, b])<br><br>tree.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>tree.append([<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>])<br>tree.append([n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>tree.append([n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>])<br>t += <span class="hljs-number">4</span> <span class="hljs-comment"># 四个顶点插入树 树的个数要加上</span><br><br>ans = -<span class="hljs-number">1</span><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]) <span class="hljs-comment">#  对x排序</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]</span><br><span class="hljs-string">不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）</span><br><span class="hljs-string">更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    d, u = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> x - a - <span class="hljs-number">1</span> &gt; u - d - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, x - a - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> y &gt;= b:<br>            u = <span class="hljs-built_in">min</span>(u, y)<br>        <span class="hljs-keyword">if</span> y &lt;= b:<br>            d = <span class="hljs-built_in">max</span>(d, y)<br><br>tree.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>    l, r = <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):<br>        x, y = tree[j]<br>        a, b = tree[i]<br>        <span class="hljs-keyword">if</span> y - b - <span class="hljs-number">1</span> &gt; r - l - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        ans = <span class="hljs-built_in">max</span>(ans, y - b - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x &gt;= a:<br>            r = <span class="hljs-built_in">min</span>(r, x)<br>        <span class="hljs-keyword">if</span> x &lt;= a:<br>            l = <span class="hljs-built_in">max</span>(l, x)<br><br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h1 id="1654-到家的最少跳跃次数-力扣（LeetCode）"><a href="#1654-到家的最少跳跃次数-力扣（LeetCode）" class="headerlink" title="1654. 到家的最少跳跃次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BFS 搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumJumps</span>(<span class="hljs-params">self, forbidden: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span>, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    q,vis = deque([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]), <span class="hljs-built_in">set</span>([<span class="hljs-number">0</span>])<br>        lower, upper = <span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(forbidden) + a, x) + b<br>        forbiddenSet = <span class="hljs-built_in">set</span>(forbidden)<br>        <span class="hljs-keyword">while</span> q:<br>            position, direction, step = q.popleft()<br>            <span class="hljs-keyword">if</span> x == position:<br>                <span class="hljs-keyword">return</span> step<br>            nextposition = position + a<br>            nextdirection = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                vis.add(nextposition * nextdirection)<br>                q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 不能两次退后</span><br>            <span class="hljs-keyword">if</span> direction == <span class="hljs-number">1</span>:<br>                nextposition = position - b<br>                nextdirection = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> lower &lt;= nextposition &lt;= upper <span class="hljs-keyword">and</span> nextposition * nextdirection <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">and</span> nextposition <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> forbiddenSet:<br>                    vis.add(nextposition * nextdirection)<br>                    q.append([nextposition, nextdirection, step + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="823-带因子的二叉树-力扣（LeetCode）"><a href="#823-带因子的二叉树-力扣（LeetCode）" class="headerlink" title="823. 带因子的二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-trees-with-factors/">823. 带因子的二叉树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s = <span class="hljs-built_in">set</span>(arr)<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">val</span>):<br>            ans = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> s:<br>                    ans += dfs(x) * dfs(val // x)<br>            <span class="hljs-keyword">return</span> ans<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(dfs(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br>    <br><span class="hljs-comment"># 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numFactoredBinaryTrees</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        idx = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr)&#125;<br>        f = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                val = arr[i]<br>                x = arr[j]<br>                <span class="hljs-keyword">if</span> val % x == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> val // x <span class="hljs-keyword">in</span> idx:<br>                    f[i] += f[j] * f[idx[val // x]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(f) % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br><br></code></pre></td></tr></table></figure><h1 id="1761-一个图中连通三元组的最小度数-力扣（LeetCode）"><a href="#1761-一个图中连通三元组的最小度数-力扣（LeetCode）" class="headerlink" title="1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/">1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次</span><br><span class="hljs-comment"># 用邻接矩阵来储存 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minTrioDegree</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        g = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        degree = [<span class="hljs-number">0</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> edges:<br>            x, y = x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span><br>            g[x][y] = g[y][x] = <span class="hljs-number">1</span><br>            degree[x] += <span class="hljs-number">1</span><br>            degree[y] += <span class="hljs-number">1</span><br>        <br>        ans = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                <span class="hljs-keyword">if</span> g[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, n):<br>                        <span class="hljs-keyword">if</span> g[i][k] == g[j][k] == <span class="hljs-number">1</span>:<br>                            ans = <span class="hljs-built_in">min</span>(ans, degree[i] + degree[j] + degree[k] - <span class="hljs-number">6</span>)<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ans == inf <span class="hljs-keyword">else</span> ans<br><br></code></pre></td></tr></table></figure><h1 id="5183-好三元组-AcWing题库"><a href="#5183-好三元组-AcWing题库" class="headerlink" title="5183. 好三元组 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5186/">5183. 好三元组 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。</span><br><span class="hljs-string">所有情况为n * (n - 1) * (n - 2) // 6</span><br><span class="hljs-string">当三个数在同一点上时 不合规</span><br><span class="hljs-string">两个点在同一点上 不合规</span><br><span class="hljs-string">三个点在同一个半圆内时 不合规</span><br><span class="hljs-string">同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规</span><br><span class="hljs-string">所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1</span><br><span class="hljs-string">最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>N = <span class="hljs-number">2000100</span><br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>p = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>cnt = [<span class="hljs-number">0</span>] * N<br>s = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    cnt[p[i - <span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    cnt[p[i - <span class="hljs-number">1</span>] + c] += <span class="hljs-number">1</span><br><br>res = n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br><br>s[<span class="hljs-number">0</span>] = cnt[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * c):<br>    s[i] = s[i - <span class="hljs-number">1</span>] + cnt[i]<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c):<br>    <span class="hljs-keyword">if</span> cnt[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">continue</span><br>    t = cnt[i]<br>    d = s[i + c // <span class="hljs-number">2</span>] - s[i]<br>    <br>    <span class="hljs-comment"># 其实不需要判断也行</span><br>    <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">3</span>:<br>            res -= t * (t - <span class="hljs-number">1</span>) * (t - <span class="hljs-number">2</span>) // <span class="hljs-number">6</span><br>        res -= t * (t - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * d<br>    res -= t * d * (d - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c // <span class="hljs-number">2</span>):<br>        u, v = cnt[i], cnt[i + c // <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">2</span>:<br>            res += u * (u - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * v<br>        <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">2</span>:<br>            res += v * (v - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> * u<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="5145-同色环-AcWing题库"><a href="#5145-同色环-AcWing题库" class="headerlink" title="5145. 同色环 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/5148/">5145. 同色环 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> nums[N][N];<br><span class="hljs-type">bool</span> vis[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> ox, <span class="hljs-type">int</span> oy)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx = x + dx[i];<br>        <span class="hljs-type">int</span> ny = y + dy[i];<br><br>        <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m<br>            <span class="hljs-comment">// 这一句的意思是 不能退回</span><br>            &amp;&amp; !(nx == ox &amp;&amp; ny == oy)<br>            <span class="hljs-comment">// 颜色相同</span><br>            &amp;&amp; nums[nx][ny] == nums[x][y])<br>        &#123;<br>            <span class="hljs-comment">// 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况</span><br>            <span class="hljs-keyword">if</span> (vis[nx][ny] || <span class="hljs-built_in">dfs</span>(nx, ny, x, y))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            cin &gt;&gt; nums[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i][j])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1921-消灭怪物的最大数量-力扣（LeetCode）"><a href="#1921-消灭怪物的最大数量-力扣（LeetCode）" class="headerlink" title="1921. 消灭怪物的最大数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03">1921. 消灭怪物的最大数量 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eliminateMaximum</span>(<span class="hljs-params">self, dist: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(dist)<br>        <span class="hljs-comment"># 上取整</span><br>        arrivetime = [math.ceil(dist[i] / speed[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>        arrivetime.sort()<br>        <span class="hljs-keyword">for</span> attacktime, arrivetime <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arrivetime):<br>            <span class="hljs-keyword">if</span> attacktime &gt;= arrivetime:<br>                <span class="hljs-keyword">return</span> attacktime<br>        <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure><h1 id="统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛"><a href="#统计一个字符串的-k-子序列美丽值最大的数目-力扣-LeetCode-竞赛" class="headerlink" title="统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛"></a><a href="https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/">统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Counter 返回字典 每个元素是键 出现次数为值</span><br><span class="hljs-comment"># dfs</span><br><span class="hljs-comment"># 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        mx = -<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        keys = <span class="hljs-built_in">list</span>(c.keys())<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, count, add, mul</span>):<br>            <span class="hljs-keyword">nonlocal</span> mx, ans<br>            <span class="hljs-keyword">if</span> count == k:<br>                <span class="hljs-keyword">if</span> add &gt; mx:<br>                    mx = add<br>                    ans = mul<br>                <span class="hljs-keyword">elif</span> add == mx:<br>                    ans += mul<br>                ans %= Mod<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> i + k - count &gt; <span class="hljs-built_in">len</span>(keys):<br>                <span class="hljs-keyword">return</span><br>            dfs(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, add + c[keys[i]], mul * c[keys[i]] % Mod)<br>            dfs(i + <span class="hljs-number">1</span>, count, add, mul)<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-comment"># 数学</span><br><span class="hljs-comment"># 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        c = Counter(s)<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span>(c):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> comb<br>            Mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>            values = <span class="hljs-built_in">sorted</span>(c.values(), reverse=<span class="hljs-literal">True</span>)<br>            ans = <span class="hljs-number">1</span><br>            c = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                <span class="hljs-keyword">if</span> values[i] &gt; values[k - <span class="hljs-number">1</span>]:<br>                    ans *= values[i]<br>                    ans %= Mod<br>                <span class="hljs-keyword">elif</span> values[i] == values[k - <span class="hljs-number">1</span>]:<br>                    c += <span class="hljs-number">1</span><br>                    ans *= values[i]<br>                    ans %= Mod<br>            <span class="hljs-keyword">return</span> ans * comb(values.count(values[k - <span class="hljs-number">1</span>]),c) % Mod<br><br></code></pre></td></tr></table></figure><h1 id="2605-从两个数字数组里生成最小数字-力扣（LeetCode）"><a href="#2605-从两个数字数组里生成最小数字-力扣（LeetCode）" class="headerlink" title="2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/">2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是看一下这个写法 s = set(nums1) &amp; set(nums2) 直接取出1 2 中的相同的数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minNumber</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        a = <span class="hljs-built_in">min</span>(nums1)<br>        b = <span class="hljs-built_in">min</span>(nums2)<br>        <span class="hljs-keyword">if</span> a &gt; b:<br>            a, b = b, a<br>        ret = a * <span class="hljs-number">10</span> + b<br><br>        s = <span class="hljs-built_in">set</span>(nums1) &amp; <span class="hljs-built_in">set</span>(nums2)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> ret <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(s)<br></code></pre></td></tr></table></figure><h1 id="5198-整理书籍-AcWing题库"><a href="#5198-整理书籍-AcWing题库" class="headerlink" title="5198. 整理书籍 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5201/">5198. 整理书籍 - AcWing题库</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算有几个L几个M 然后算有几个L不在前面 有几个M不在中间 然后至多需要交换这么多次 才能换好 但是当错位的L和M互换时 两次就只需要一次了 所以说取min(l,m)(这就是LM相互错位的个数)减掉就行</span><br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())<br>n = <span class="hljs-built_in">len</span>(nums)<br>cl, cm, cs = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        cl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        cm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;S&#x27;</span>:<br>        cs += <span class="hljs-number">1</span><br><br><br>wl, wm, lm, ml = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;L&#x27;</span>:<br>        wl += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>        lm += <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cl, cl + cm):<br>    <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-string">&#x27;M&#x27;</span>:<br>        wm += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>        ml += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(wl + wm - <span class="hljs-built_in">min</span>(lm, ml))<br><br></code></pre></td></tr></table></figure><h1 id="2594-修车的最少时间-力扣（LeetCode）"><a href="#2594-修车的最少时间-力扣（LeetCode）" class="headerlink" title="2594. 修车的最少时间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/">2594. 修车的最少时间 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分最长的时间 计算这个时间每个人可以修的车的数量 和 cars比较 （并不需要实际地去算 应该给每个人安排多少车 而是求最大修车数 看能不能修完）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repairCars</span>(<span class="hljs-params">self, ranks: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], cars: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        right = cars * cars * <span class="hljs-built_in">min</span>(ranks)<br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(isqrt(mid // r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> ranks) &gt;= cars:<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><h1 id="Problem-F-Codeforces"><a href="#Problem-F-Codeforces" class="headerlink" title="Problem - F - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/F">Problem - F - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求一个数，他的约数的个数（同一个约数可能出现很多次）最多，遍历1~n，ans[j] += len(cs[i])。因为i的所有倍数上的点，都满足条件。所以把每个ans[j] 都加上i的个数。遍历到n的时候，就把所有的数都加上了</span><br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <br>    cs = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>        cs[x].append(i)<br>    ans = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    m = <span class="hljs-built_in">len</span>(cs)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        j = i<br>        <span class="hljs-keyword">while</span> j &lt;= n:<br>            ans[j] += <span class="hljs-built_in">len</span>(cs[i])<br>            j += i<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(ans))<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="210-课程表-II-力扣（LeetCode）"><a href="#210-课程表-II-力扣（LeetCode）" class="headerlink" title="210. 课程表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-ii/?envType=daily-question&envId=2023-09-10">210. 课程表 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拓扑排序(注意拓扑排序 是看是不是所有的都进入过q 或者说 最后是不是所有入度都为0) 首先建图 同时增加入度 然后把入度为0的都加入q 不断循环 每次pop的同时 numCourse-1 记录进入q的个数 如果全部进了代表没有环 那么就可以返回 而上课顺序 恰好是从q pop的顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        <br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        how = []<br>        <span class="hljs-keyword">while</span> q:<br>            pre = q.popleft()<br>            numCourses -= <span class="hljs-number">1</span><br>            how.append(pre)<br>            <span class="hljs-keyword">for</span> cur <span class="hljs-keyword">in</span> graph[pre]:<br>                in_deg[cur] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_deg[cur] == <span class="hljs-number">0</span>:<br>                    q.append(cur)<br>        <br>        <span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> how<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="630-课程表-III-力扣（LeetCode）"><a href="#630-课程表-III-力扣（LeetCode）" class="headerlink" title="630. 课程表 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iii/?envType=daily-question&envId=2023-09-11">630. 课程表 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 贪心＋优先队列 （反悔贪心） 很容易想到要先对结束时间排序 结束时间越晚 就越晚做，因为开始晚的先做如果做得完，可能前面的做不完了，开始晚的先做如果做不完，那前面的肯定做不完了。开始晚的后做，不管做不做得完，前一个肯定是不受影响的。</span><br><span class="hljs-comment"># 接着是按顺序取课 用sum记录当前总时间 h为优先队列（注意 heap默认是小根堆  为了使其成为大根堆 每次存入和取出使用相反数），如果sum+dur &lt;= end 说明是可以都上的 那就加上 并且放入h  如果&gt;end 不能都上 那么就判断当前的dur和之前已经存在的时间最长的课哪个时间更长 如果原来的课比当前课时间长 就要和当前的课进行替换（总数不变 sum变小） 使得sum最小 那么就更有可能多上几节课 如果当前的时间长 那这节课肯定选不了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scheduleCourse</span>(<span class="hljs-params">self, courses: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        courses.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>        n = <span class="hljs-built_in">len</span>(courses)<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        h = []<br>        <span class="hljs-keyword">for</span> dur, end <span class="hljs-keyword">in</span> courses:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> + dur &lt;= end:<br>                <span class="hljs-built_in">sum</span> += dur<br>                heappush(h, -dur)<br>            <span class="hljs-keyword">elif</span> h <span class="hljs-keyword">and</span> -h[<span class="hljs-number">0</span>] &gt; dur:<br>                <span class="hljs-built_in">sum</span> -= -h[<span class="hljs-number">0</span>] - dur<br>                heappop(h)<br>                heappush(h, -dur)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br></code></pre></td></tr></table></figure><h1 id="1462-课程表-IV-力扣（LeetCode）"><a href="#1462-课程表-IV-力扣（LeetCode）" class="headerlink" title="1462. 课程表 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkIfPrerequisite</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">bool</span>]:<br>        <span class="hljs-comment"># 拓扑排序的思路仍然是先建图 存储入度 循环找点  不同的是 （有向图） 这次0-1-2-3 不仅0-1连通 0-3也连通 要反映这样的一种关系 需要建立一个二维数组表示他们的连通关系  每次pop取出一个点 这个点是x连向的所有点 即列表graph[x] 遍历里面的每个元素 （入度减一等操作） 遍历每一个numCourse的点 如果他跟x有连接 或者跟y有连接就为True （h-y or h-x-y）</span><br>        <span class="hljs-comment"># Toposort</span><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        in_deg = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre].append(cur)<br>            in_deg[cur] += <span class="hljs-number">1</span><br>        ret = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        q = deque([i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_deg) <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                in_deg[y] -= <span class="hljs-number">1</span><br>                ret[x][y] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    ret[h][y] = ret[h][y] <span class="hljs-keyword">or</span> ret[h][x]<br>                <span class="hljs-keyword">if</span> in_deg[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br>        <span class="hljs-keyword">return</span> [ret[a][b] <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> queries]<br>    <br>    <br>        <span class="hljs-comment"># Floyd的思路 边权为True 建好图之后直接循环</span><br>        <span class="hljs-comment"># Floyd</span><br>        graph = [[<span class="hljs-literal">False</span>] * numCourses <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <span class="hljs-keyword">for</span> pre, cur <span class="hljs-keyword">in</span> prerequisites:<br>            graph[pre][cur] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>                    graph[i][j] = (graph[i][k] <span class="hljs-keyword">and</span> graph[k][j]) <span class="hljs-keyword">or</span> graph[i][j]<br><br>        <span class="hljs-keyword">return</span> [graph[i][j] <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure><h1 id="Problem-E-Codeforces（新二分板子）"><a href="#Problem-E-Codeforces（新二分板子）" class="headerlink" title="Problem - E - Codeforces（新二分板子）"></a><a href="https://codeforces.com/contest/1850/problem/E">Problem - E - Codeforces</a>（新二分板子）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 来自tllwtg的算法模板</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">更好记录答案 也更有逻辑</span><br><span class="hljs-string">if check():</span><br><span class="hljs-string">res = mid</span><br><span class="hljs-string">l = mid + 1</span><br><span class="hljs-string">else:</span><br><span class="hljs-string">r = mid - 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">return res</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>    l, r, res = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>, -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> l &lt;= r:<br>        mid = (l + r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-built_in">sum</span>([(nums[i] + <span class="hljs-number">2</span> * mid ) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]):<br>            res = mid <br>            l = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid - <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="Problem-D-Codeforces"><a href="#Problem-D-Codeforces" class="headerlink" title="Problem - D - Codeforces"></a><a href="https://codeforces.com/contest/1850/problem/D">Problem - D - Codeforces</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求去掉几个可以使连续的最大 就是求最大然后用n减去</span><br><span class="hljs-comment"># 用diff记录差值 但其实可以优化 毕竟排序之后 差值只需要和前一个比较即可</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    diff = [<span class="hljs-number">0</span>] * n<br>    diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># print(diff)</span><br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">if</span> diff[i] &lt;= k:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br>    <br><span class="hljs-comment"># 优化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    nums.sort()<br>    <br>    <br>    cnt = <span class="hljs-number">1</span><br>    maxi = <span class="hljs-number">0</span><br>    pre = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<span class="hljs-comment"># 0不看 因为cnt初始值为1 从1开始</span><br>        <span class="hljs-keyword">if</span> nums[i] - pre &gt; m:<br>            maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>            cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            cnt += <span class="hljs-number">1</span><br>    pre = nums[i]<br>    maxi = <span class="hljs-built_in">max</span>(maxi, cnt)<br>    <span class="hljs-built_in">print</span>(n - maxi)<br>    <br>    <br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    solve()<br></code></pre></td></tr></table></figure><h1 id="5151-程序调用-AcWing题库"><a href="#5151-程序调用-AcWing题库" class="headerlink" title="5151. 程序调用 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/description/5154/">5151. 程序调用 - AcWing题库</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 通过索引找值 再通过值找索引  并且实现交换 主要是两个数组 一个是原数组 一个是pos数组 注意每次交换的时候两个数组都要交换 知道值a pos[a]即为索引 那a的前一个数就是pos[a] - 1 然后交换</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m, k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cin &gt;&gt; s[i];<br>f[s[i]] = i;<br>w[i] = (i - <span class="hljs-number">1</span>) / k + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>ret += w[f[x]];<br><br><span class="hljs-keyword">if</span> (f[x] == <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br><br><span class="hljs-built_in">swap</span>(s[f[x]], s[f[x] - <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">swap</span>(f[s[f[x]]], f[s[f[x] - <span class="hljs-number">1</span>]]);<br>&#125;<br>cout &lt;&lt; ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="213-打家劫舍-II-力扣（LeetCode）"><a href="#213-打家劫舍-II-力扣（LeetCode）" class="headerlink" title="213. 打家劫舍 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打家劫舍1是一个动态规划问题 用f[k]来表示 前k间房子最多能偷多少钱 当k=n的时候就是答案 状态转移方程为f[i] = max(f[i -  1], f[i - 2] + nums[i]) 选i-1或者选i-2 + nums[i]  最后 如下的写法是优化空间复杂度的写法 因为每次仅需要前两个数和当前这个数 所以可以交替使用</span><br><span class="hljs-comment"># 打家劫舍2在1的基础上把首尾相连成环 这就导致首尾选不选的问题 这样的环的问题其实可以先排除掉环的影响再来做 即分为两类 首部选或不选（必定可且仅可分为两类）选首部的时候 尾部不能选（第二个也不能选） 那就是[2:-1] 不选首部的时候 就是[1:]然后看看哪个更大（有点类似之前实训课做过的枚举）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob1</span>(<span class="hljs-params">self, nums:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>)-&gt;<span class="hljs-built_in">int</span>:<br>        f0 = f1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            f0, f1 = f1, <span class="hljs-built_in">max</span>(f0 + x, f1)<br>        <br>        <span class="hljs-keyword">return</span> f1<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>] + self.rob1(nums[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]), self.rob1(nums[<span class="hljs-number">1</span>:]))<br>        <br></code></pre></td></tr></table></figure><h1 id="337-打家劫舍-III-力扣（LeetCode）"><a href="#337-打家劫舍-III-力扣（LeetCode）" class="headerlink" title="337. 打家劫舍 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iii/discussion/">337. 打家劫舍 III - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 树形DP 还是一样分析 根节点选或者不选（注意根节点不选 下一个结点也不一定要选）求出 左子树不选根的最大值和左子树选根的最大值 和 右子树不选根的最大值和右子树选根的最大值 如果选根 那么总共的最大值就是根+左不选根+右不选根 如果不选根 那就是左子树最大（选根和不选根 的最大）和右子树最大 相加</span><br><span class="hljs-comment"># 注意先想好dfs是做什么的  从root开始 返回选root的最大值 和不选root的最大值</span><br><br><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>           l_rob, l_not_rob = dfs(root.left)<br>            r_rob, r_not_rob = dfs(root.right)<br>            rob = root.val + l_not_rob + r_not_rob<br>            not_rob = <span class="hljs-built_in">max</span>(l_rob, l_not_rob) + <span class="hljs-built_in">max</span>(r_rob, r_not_rob)<br>            <span class="hljs-keyword">return</span> rob, not_rob<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dfs(root))<br></code></pre></td></tr></table></figure><h1 id="2560-打家劫舍-IV-力扣（LeetCode）"><a href="#2560-打家劫舍-IV-力扣（LeetCode）" class="headerlink" title="2560. 打家劫舍 IV - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/house-robber-iv/solutions/2093952/er-fen-da-an-dp-by-endlesscheng-m558/">2560. 打家劫舍 IV - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分答案 最小化能够抢到的最大值 类似的表述就是二分答案的套路</span><br><span class="hljs-comment"># 二分偷取的钱数（得到最小值）  当偷盗的房子数满足k的时候 就可以成为一个答案  本解还有贪心 只要遇到可偷的就立即偷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        minn = <span class="hljs-built_in">min</span>(nums)<br>        maxn = <span class="hljs-built_in">max</span>(nums)<br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> minn &lt;= maxn:<br>            mid = (maxn + minn) // <span class="hljs-number">2</span><br>            cnt = <span class="hljs-number">0</span><br>            vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis <span class="hljs-keyword">and</span> num &lt;= mid:<br>                    cnt += <span class="hljs-number">1</span><br>                    vis = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    vis = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> cnt &lt; k:<br>                <br>                minn = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res = mid<br>                maxn = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br>    <br><span class="hljs-comment"># 也可以用二分+动态规划 状态表示为从0~i可偷的房间数为f[i] 状态计算为f[i] = max(f[i - 1], f[i - 1] + 1) </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCapability</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">mx: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            f0 = f1 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &lt;= mx:<br>                   f0, f1 = f1, <span class="hljs-built_in">max</span>(f1, f0 + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                    f0 = f1<br>           <span class="hljs-keyword">return</span>  f1<br>       <span class="hljs-keyword">return</span> bisect_left(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(nums)), k, key=solve)<br></code></pre></td></tr></table></figure><h1 id="2603-收集树中金币-力扣（LeetCode）"><a href="#2603-收集树中金币-力扣（LeetCode）" class="headerlink" title="2603. 收集树中金币 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collectTheCoins</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(coins)<br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        deg = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">len</span>, graph))<br>        q = deque()<br>        res = n - <span class="hljs-number">1</span> <span class="hljs-comment"># 总边数</span><br>        <span class="hljs-comment"># 先把没有金币的叶子节点存入数组（相当于拓扑排序的放入入度为0的点</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">0</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 删除所有没有金币的叶子节点</span><br>        <span class="hljs-keyword">while</span> q:<br>            x = q.popleft()<br>            res -= <span class="hljs-number">1</span> <span class="hljs-comment"># 每次循环都会删掉一条边</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> coins[y] == <span class="hljs-number">0</span>:<br>                    q.append(y)<br><br>        <span class="hljs-comment"># 删除最下面两层结点（叶子结点和叶子节点的父节点）（此时的叶子节点是含金币的因为不含的已经删除）</span><br>        <span class="hljs-keyword">for</span> i, (d, c) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(deg, coins)):<br>            <span class="hljs-keyword">if</span> d == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c == <span class="hljs-number">1</span>:<br>                q.append(i)<br>        <span class="hljs-comment"># 这一层的所有含金币的叶子都被删除了 那么这些线就不用走了 删除的总数就是len(q)      </span><br>        res -= <span class="hljs-built_in">len</span>(q)<br><br>        <span class="hljs-comment"># 接下来删除叶子节点的父节点（叶子在上面已经删除）</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q:<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                deg[y] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> deg[y] == <span class="hljs-number">1</span>:<br>                    res -= <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, res * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="1993-树上的操作-力扣（LeetCode）"><a href="#1993-树上的操作-力扣（LeetCode）" class="headerlink" title="1993. 树上的操作 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/operations-on-tree/?envType=daily-question&envId=2023-09-23">1993. 树上的操作 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockingTree</span>:<br><span class="hljs-comment"># 初始化需要有父节点和每个父节点的子节点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        n = <span class="hljs-built_in">len</span>(parent)<br>        self.parent = parent<br>        self.lockNodeUser = [-<span class="hljs-number">1</span>] * n<br>        self.children = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <br>        <span class="hljs-keyword">for</span> node, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(parent):<br>            <span class="hljs-keyword">if</span> p != -<span class="hljs-number">1</span>:<br>                self.children[p].append(node)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == -<span class="hljs-number">1</span>:<br>            self.lockNodeUser[num] = user<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> self.lockNodeUser[num] == user:<br>            self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 难点主要是更新 如果该结点没有上锁 并且祖先没有上锁 并且孩子有上锁（同时解锁所有孩子） </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span>, user: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] == -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.haslockedansester(num) <span class="hljs-keyword">and</span> self.checkandlockdescendant(num)<br>        <span class="hljs-keyword">if</span> res:<br>            self.lockNodeUser[num] = user<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-comment"># 由父节点不断向上 直到根节点 如果有上锁的 就直接返回 否则就继续向上</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">haslockedansester</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        res = self.parent[num]<br>        <span class="hljs-keyword">while</span> num != -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.lockNodeUser[num] != -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                num = self.parent[num]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 如果找到了一个上锁的子节 就直接解锁  因为只要有上锁 就表示满足要求 需要解锁 而如果都没有上锁 那解锁操作也不会影响原来的结点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkandlockdescendant</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>        res = self.lockNodeUser[num] != -<span class="hljs-number">1</span><br>        self.lockNodeUser[num] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self.children[num]:<br>            res |= self.checkandlockdescendant(child)<br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-comment"># Your LockingTree object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LockingTree(parent)</span><br><span class="hljs-comment"># param_1 = obj.lock(num,user)</span><br><span class="hljs-comment"># param_2 = obj.unlock(num,user)</span><br><span class="hljs-comment"># param_3 = obj.upgrade(num,user)</span><br></code></pre></td></tr></table></figure><h1 id="146-LRU-缓存-力扣（LeetCode）"><a href="#146-LRU-缓存-力扣（LeetCode）" class="headerlink" title="146. LRU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=daily-question&envId=2023-09-24">146. LRU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>, value=<span class="hljs-number">0</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        self.prev = <span class="hljs-literal">None</span><br>        self.key = key<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br>    <span class="hljs-comment"># 因为需要O(1) 的存取 所以使用双向链表加字典</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.head = Node()<br>        self.head.prev = self.head<br>        self.head.<span class="hljs-built_in">next</span> = self.head<br>        self.<span class="hljs-built_in">map</span> = <span class="hljs-built_in">dict</span>()<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 插入 如果已经在的话就修改 如果不在的话首先 在map中记录 如何插入链表头 如果大于capacity的话 就删除链表尾(因为一开始把每次访问的都放在头部了（LRU的特性）所以删除的时候就可以直接删除尾部)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span><br>        <br>        self.<span class="hljs-built_in">map</span>[key] = node = Node(key, value)<br>        self.push_front(node)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.<span class="hljs-built_in">map</span>) &gt; self.capacity:<br>            back_node = self.head.prev<br>            <span class="hljs-keyword">del</span> self.<span class="hljs-built_in">map</span>[back_node.key]<br>            self.remove(back_node)<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev = self.head<br>        x.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        self.head.<span class="hljs-built_in">next</span>.prev = x<br>        self.head.<span class="hljs-built_in">next</span> = x<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x: Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-comment"># 查找 如果key不在map的话 return None 否则把他放到链表头</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[Node]:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">map</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.<span class="hljs-built_in">map</span>[key]<br>        self.remove(node)<br>        self.push_front(node)<br>        <span class="hljs-keyword">return</span> node<br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="460-LFU-缓存-力扣（LeetCode）"><a href="#460-LFU-缓存-力扣（LeetCode）" class="headerlink" title="460. LFU 缓存 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lfu-cache/?envType=daily-question&envId=2023-09-25">460. LFU 缓存 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-comment"># 结点的定义 双向链表的结点加上字典的key和访问次数cnt</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-number">0</span>,value=<span class="hljs-number">0</span>,<span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>,prev=<span class="hljs-literal">None</span></span>):<br>        self.value = value<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        self.prev = prev<br>        self.cnt = <span class="hljs-number">1</span><br>        self.key = key<br><br><span class="hljs-comment"># 需要建一个次数表 把访问次数相同的放在一起 用字典实现 key为访问次数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        self.capacity = capacity<br>        self.key_to_node = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_node</span>()-&gt;Node:<br>            head = Node()<br>            head.<span class="hljs-built_in">next</span> = head<br>            head.prev = head<br>            <span class="hljs-keyword">return</span> head<br>        self.freq_to_head = defaultdict(new_node)<br>    <br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 当这本书已经存在的时候 修改值 否则要放入（访问一次）中（注意先判断是否已满）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.get_node(key)<br>        <span class="hljs-keyword">if</span> node:<br>            node.value = value<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-comment"># 如果已满就拿出访问min_freq次的最下面的书（最不常用）</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.key_to_node) == self.capacity:<br>            phead = self.freq_to_head[self.min_freq]<br>            back_node = phead.prev <span class="hljs-comment"># 最不常用的</span><br>            <span class="hljs-keyword">del</span> self.key_to_node[back_node.key]  <span class="hljs-comment"># 从字典删除</span><br>            self.remove(back_node) <span class="hljs-comment"># 从链表中删除</span><br>            <span class="hljs-comment"># 如果删除的是头结点 那就直接把整个链表删除了</span><br>            <span class="hljs-keyword">if</span> phead.prev == phead:<br>                <span class="hljs-keyword">del</span> self.freq_to_head[self.min_freq]<br>        <span class="hljs-comment"># 插入这本书</span><br>        self.key_to_node[key] = node = Node(key, value)<br>        <span class="hljs-comment"># 放到最上面</span><br>        self.push_front(self.freq_to_head[<span class="hljs-number">1</span>],node)<br>        <span class="hljs-comment"># 刚插入的访问次数必定为1</span><br>        self.min_freq = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, head:Node, x:Node</span>):<br>        x.prev = head<br>        x.<span class="hljs-built_in">next</span> = head.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x<br>        x.prev.<span class="hljs-built_in">next</span> = x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, x:Node</span>):<br>        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span><br>        x.<span class="hljs-built_in">next</span>.prev = x.prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_node</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.key_to_node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = self.key_to_node[key]<span class="hljs-comment"># 找到这本书</span><br>        self.remove(node)<span class="hljs-comment"># 去掉</span><br>        phead = self.freq_to_head[node.cnt]<br>        <span class="hljs-comment"># 如果这本书原来所在的链表只有他一个 那就删除链表</span><br>        <span class="hljs-keyword">if</span> phead.prev == phead:<br>            <span class="hljs-keyword">del</span> self.freq_to_head[node.cnt]<br>            <span class="hljs-comment"># 如果这本书恰好是访问一次的链表 那么删除之后就没有访问一次的了 至少也是访问两次的</span><br>            <span class="hljs-keyword">if</span> self.min_freq == node.cnt:<br>                self.min_freq += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 这本书访问次数加1</span><br>        node.cnt += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 插到最上面</span><br>        self.push_front(self.freq_to_head[node.cnt], node)<br>        <span class="hljs-keyword">return</span> node<br>        <br><br><span class="hljs-comment"># Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LFUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h1 id="587-安装栅栏-力扣（LeetCode）"><a href="#587-安装栅栏-力扣（LeetCode）" class="headerlink" title="587. 安装栅栏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/erect-the-fence/description/">587. 安装栅栏 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outerTrees</span>(<span class="hljs-params">self, trees: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-comment"># 求扫过的面积 如果&lt;0 说明需要更新</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">cross</span>(<span class="hljs-params">p: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], q: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], r: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">return</span> (q[<span class="hljs-number">0</span>] - p[<span class="hljs-number">0</span>]) * (r[<span class="hljs-number">1</span>] - q[<span class="hljs-number">1</span>]) - (q[<span class="hljs-number">1</span>] - p[<span class="hljs-number">1</span>]) * (r[<span class="hljs-number">0</span>] - q[<span class="hljs-number">0</span>])<br>        <br>        n = <span class="hljs-built_in">len</span>(trees)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> trees<br><br>        trees.sort()<br><br>        hull = [<span class="hljs-number">0</span>]<br>        used = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-comment"># 求凸包下半部分</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                used[hull.pop()] = <span class="hljs-literal">False</span><br>            used[i] = <span class="hljs-literal">True</span><br>            hull.append(i)<br>        <span class="hljs-comment"># 求凸包的上半部分</span><br>        m = <span class="hljs-built_in">len</span>(hull)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[i]:<br>                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hull) &gt; m <span class="hljs-keyword">and</span> cross(trees[hull[-<span class="hljs-number">2</span>]], trees[hull[-<span class="hljs-number">1</span>]], trees[i]) &lt; <span class="hljs-number">0</span>:<br>                    used[hull.pop()] = <span class="hljs-literal">False</span><br>                used[i] = <span class="hljs-literal">True</span><br>                hull.append(i)<br>        <span class="hljs-comment"># hull[0] 是起点 同时参加上半部分的检测 所以要删掉</span><br>        hull.pop()<br>        <span class="hljs-keyword">return</span> [trees[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> hull]<br></code></pre></td></tr></table></figure><h1 id="2251-花期内花的数目-力扣（LeetCode）"><a href="#2251-花期内花的数目-力扣（LeetCode）" class="headerlink" title="2251. 花期内花的数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solutions/1445000/chai-fen-pythonjavacgo-by-endlesscheng-wz35/?envType=daily-question&envId=2023-09-28">2251. 花期内花的数目 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 差分前缀和 不需要每次把每个区间全部加上 这样复杂度过高 而是只需要在区间开头处+1 在区间结尾处-1 然后排序保证访问的时候是遍历的顺序 计算前缀和  如第一个人第二分钟来 那就算出第二分钟有几朵花 就是第二分钟的前缀和 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        diff = Counter()<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> flowers:<br>            diff[s] += <span class="hljs-number">1</span><br>            diff[e + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br><br>        time = <span class="hljs-built_in">sorted</span>(diff.keys())<br>        s = j = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> p, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(people, <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(people)))):<br>            <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(time) <span class="hljs-keyword">and</span> time[j] &lt;= p:<br>                s += diff[time[j]]<br>                j += <span class="hljs-number">1</span><br>            people[i] = s<br><br>        <span class="hljs-keyword">return</span> people<br>    <br><span class="hljs-comment"># 或者更简单的 直接计算第i分钟的花的数量  用第i分钟开花的数量减去第j分钟开花的数量 对开花时间和结束时间排序获得start和end数组 通过二分寻找开花数和凋谢数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fullBloomFlowers</span>(<span class="hljs-params">self, flowers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        start = <span class="hljs-built_in">sorted</span>(s <span class="hljs-keyword">for</span> s, _ <span class="hljs-keyword">in</span> flowers)<br>        end = <span class="hljs-built_in">sorted</span>(e <span class="hljs-keyword">for</span> _, e <span class="hljs-keyword">in</span> flowers)<br>        <span class="hljs-keyword">return</span> [bisect_right(start, p) - bisect_left(end, p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> people]<br>    <br></code></pre></td></tr></table></figure><h1 id="2731-移动机器人-力扣（LeetCode）"><a href="#2731-移动机器人-力扣（LeetCode）" class="headerlink" title="2731. 移动机器人 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/movement-of-robots/">2731. 移动机器人 - 力扣（LeetCode）</a></h1><p>发现 最后只需要计算机器人的间隔 左右相碰之后转向 其实也就可以视为两个之间互换了 之间的 距离不会受到影响 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">比如<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span>R <span class="hljs-selector-tag">b</span> <span class="hljs-number">2</span>L <span class="hljs-number">3s</span> <br><span class="hljs-number">1s</span> 时在<span class="hljs-number">1</span> 处相碰   转向 <span class="hljs-selector-tag">a</span>向左 <span class="hljs-selector-tag">b</span>向右<br>然后<span class="hljs-number">3s</span>后  <span class="hljs-selector-tag">a</span>在-<span class="hljs-number">1</span> <span class="hljs-selector-tag">b</span>在<span class="hljs-number">3</span><br>其实也就相当于  <span class="hljs-selector-tag">a</span>直接走<span class="hljs-number">3s</span>到<span class="hljs-number">3</span>  <span class="hljs-selector-tag">b</span>直接走<span class="hljs-number">3s</span>到-<span class="hljs-number">1</span>  距离不变  机器人间不需要区分<br></code></pre></td></tr></table></figure><p>然后计算距离  两两之间的差可以O(n)计算！！但是注意 必须有序</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1 3 4 8 9 之间的差为<br>3<span class="hljs-string">-1</span> + 4<span class="hljs-string">-1</span> + 8<span class="hljs-string">-1</span> + 9<span class="hljs-string">-1</span><br>      4<span class="hljs-string">-3</span> + 8<span class="hljs-string">-3</span> + 9<span class="hljs-string">-3</span> <br>            8<span class="hljs-string">-4</span> + 9<span class="hljs-string">-4</span><br>                  9<span class="hljs-string">-8</span><br>因此每次算一个即可  ans + i * nums[i] 表示排i的数共被加了几次 3 1次 4 两次 8 三次 9 四次<br>再减去s  s表示每次减去的数  第一次减1  第二次减4（1 + 3） 第三次减8 （1 + 3 + 4） 第四次减16（1 + 3 + 4 + 8）<br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumDistance</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], s: <span class="hljs-built_in">str</span>, d: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            f = -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            nums[i] += f * d<br>        nums.sort()<br><br>        ans = <span class="hljs-number">0</span><br>        s = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ans += i * nums[i] - s<br>            s += nums[i]<br>        <span class="hljs-keyword">return</span> ans % (<span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="2512-奖励最顶尖的-K-名学生-力扣（LeetCode）"><a href="#2512-奖励最顶尖的-K-名学生-力扣（LeetCode）" class="headerlink" title="2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reward-top-k-students/?envType=daily-question&envId=2023-10-11">2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）</a></h1><p>不需要用结构体也可以 用zip来直接sort</p><p>用split分割单词</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topStudents</span>(<span class="hljs-params">self, positive_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], negative_feedback: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], report: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], student_id: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        score = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> positive_feedback:<br>            score[w] = <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> negative_feedback:<br>            score[w] = -<span class="hljs-number">1</span><br>        a = <span class="hljs-built_in">sorted</span>((-<span class="hljs-built_in">sum</span>(score[w] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> r.split()), i) <span class="hljs-keyword">for</span> r, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(report, student_id))<br><br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> _, i <span class="hljs-keyword">in</span> a[:k]]<br></code></pre></td></tr></table></figure><h1 id="1488-避免洪水泛滥-力扣（LeetCode）"><a href="#1488-避免洪水泛滥-力扣（LeetCode）" class="headerlink" title="1488. 避免洪水泛滥 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/avoid-flood-in-the-city/">1488. 避免洪水泛滥 - 力扣（LeetCode）</a></h1><p>不是每次晴天就去寻找抽哪个  而是到了后面 发现他要发洪水之后 就去前面找他下雨之后的第一个晴天 把他的水抽干 如果没找到 就直接返回空数组</p><p>注意用bisect_left寻找该湖泊下雨后第一个晴天</p><p>用pop删除这个晴天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avoidFlood</span>(<span class="hljs-params">self, rains: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(rains)<br>        ans = [<span class="hljs-number">1</span>] * n<br>        sun_day = SortedList()<br>        full = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> rains[i] == <span class="hljs-number">0</span>:<br>                sun_day.add(i)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> rains[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> full:<br>                    full[rains[i]] = i<br>                <span class="hljs-keyword">else</span>:<br>                    j = sun_day.bisect_left(full[rains[i]])<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-built_in">len</span>(sun_day):<br>                        <span class="hljs-keyword">return</span> []<br>                    ans[sun_day.pop(j)] = rains[i]<br>                    full[rains[i]] = i<br>                ans[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="1726-同积元组-力扣（LeetCode）"><a href="#1726-同积元组-力扣（LeetCode）" class="headerlink" title="1726. 同积元组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组 - 力扣（LeetCode）</a></h1><p>不需要三重循环来找 a * b &#x2F;&#x2F; c 在字典里面的</p><p>而是计数  记录下同一个积的两个数 的组合有多少种  然后用a * (a - 1)  计算种数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mp = defaultdict(<span class="hljs-built_in">int</span>)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                mp[nums[i] * nums[j]] += <span class="hljs-number">1</span><br>        m = <span class="hljs-built_in">len</span>(mp)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> mp.values():<br>            ans += x * (x - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="2316-统计无向图中无法互相到达点对数-力扣（LeetCode）"><a href="#2316-统计无向图中无法互相到达点对数-力扣（LeetCode）" class="headerlink" title="2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/">2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）</a></h1><p>主要是最后计算乘法超时了 乘法不需要再额外循环来计算 可以直接在 BFS循环里面算出前缀和  然后相乘  求得两两相乘的和</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countPairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">i</span>):<br>            q.append(i)<br>            s = <span class="hljs-number">1</span><br>            vis[i] = <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">while</span> q:<br>                x = q.popleft()<br>                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[y]:<br>                        vis[y] = <span class="hljs-number">1</span><br>                        s += <span class="hljs-number">1</span><br>                        q.append(y)<br>            <span class="hljs-keyword">return</span> s<br>            <br>                    <br><br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> (a, b) <span class="hljs-keyword">in</span> edges:<br>            graph[a].append(b)<br>            graph[b].append(a)<br>        <br>        vis = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>        total = ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i]:<br>                size = bfs(i)<br>                ret += size * total<br>                total += size<br>        <span class="hljs-keyword">return</span> ret<br><br>        <br></code></pre></td></tr></table></figure><h1 id="1402-做菜顺序-力扣（LeetCode）"><a href="#1402-做菜顺序-力扣（LeetCode）" class="headerlink" title="1402. 做菜顺序 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reducing-dishes/description/">1402. 做菜顺序 - 力扣（LeetCode）</a></h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>每次有选和不选这道菜两种  用dp[i] [j] 表示前i道菜种选了j道菜  达到的最大值</p><p>当i &#x3D;&#x3D; j的时候必须选第i道菜</p><p>其他时候 就比较不选这道菜 dp[i - 1] [j]  和选这道菜dp[i -1 ] [j -1 ] + sa[i - 1] * j   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> dp[<span class="hljs-number">550</span>][<span class="hljs-number">550</span>];<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>public:<br>    <span class="hljs-built_in">int</span> maxSatisfaction(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; satisfaction) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">550</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">550</span>; j++)<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> n = satisfaction.size();<br>        sort(satisfaction.begin(), satisfaction.end());<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = satisfaction[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(i==j) <br>                        dp[i][j]= dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+satisfaction[i-<span class="hljs-number">1</span>]*j);<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[n][i]);<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><em>s</em>1+2<em>s</em>0&gt;<em>s</em>0即<em>s</em>1+<em>s</em>0&gt;0</p><p><em>s</em>2+2<em>s</em>1+3<em>s</em>0&gt;<em>s</em>1+2<em>s</em>0即<em>s</em>2+<em>s</em>1+<em>s</em>0&gt;0</p><p>因此只需要反向遍历  找到前面加起来大于0的部分 的和就是最大的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">sa.sort(key=<span class="hljs-keyword">lambda</span> x:-x)<br>        s = <span class="hljs-number">0</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> sa:<br>            <span class="hljs-keyword">if</span> s + c &gt; <span class="hljs-number">0</span>:<br>                s += c<br>                ret += s<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h1 id="力扣（LeetCode）官网-全球极客挚爱的技术成长平台"><a href="#力扣（LeetCode）官网-全球极客挚爱的技术成长平台" class="headerlink" title="力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台"></a><a href="https://leetcode.cn/problems/h-index/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></h1><p>至少有h篇论文有h引的次数 </p><p>排序之后 二分下标mid   有 citation[mid] 引的文章有n - mid篇  只要引用次数大于文章数  比如8引的文章有两篇 （此时h &#x3D; 2）说明要往前找 有没有更多文章      如果3引的文章有5篇（此时h &#x3D; 3）说明要往后找有没有更大的引用数 </p><p>最后二分得到的答案是最多引的最多文章数的   下标  比如 0 2 8 8 8 8 mid &#x3D; 2</p><p>所以返回答案应该是n – mid</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hIndex</span>(<span class="hljs-params">self, citations: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        citations.sort()<br>        n = <span class="hljs-built_in">len</span>(citations)<br>        l, r = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> citations[-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">mid</span>):<br>            <span class="hljs-keyword">if</span> citations[mid] &gt;= n - mid:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l &lt;= r:<br>            mid = (l + r) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> check(mid):<br>                l = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <br>                r = mid - <span class="hljs-number">1</span><br>                ret = mid<br>        <span class="hljs-keyword">return</span> n - ret<br></code></pre></td></tr></table></figure><h1 id="2003-每棵子树内缺失的最小基因值-力扣（LeetCode）"><a href="#2003-每棵子树内缺失的最小基因值-力扣（LeetCode）" class="headerlink" title="2003. 每棵子树内缺失的最小基因值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/">2003. 每棵子树内缺失的最小基因值 - 力扣（LeetCode）</a></h1><p>只要nums中没有1  那么直接返回1   所有的最小缺失值都是1</p><p>那么同理 只要一棵子树中没有1 那么这颗子树上的所有点的缺失值都是1</p><p>于是用一次dfs找出1 的位置 找到1 之后 从根到1 的这条链上 所有点的缺失值要重新计算  而其他链上的缺失值全部为1</p><p>计算根到 1 的这条链的缺失值  应该自底向上来找 由于缺失值是单调不减的 可以维护一个缺失值now 一旦now已经访问过 那就直接让now++ 直到最小的未访问的值</p><p>到底之后开始向上寻找 注意 链上的每个结点都有自己的子树 缺失值要在整棵子树上寻找 于是到达一个结点 要先访问所有的非链上的所有结点 把所有值做标记  最终把最小缺失值赋值给i</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestMissingValueSubtree</span>(<span class="hljs-params">self, parents: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <br>        g = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            g[parents[i]].append(i)<br>        visit = [<span class="hljs-literal">False</span>] * <span class="hljs-number">100010</span><br>        has1 = [<span class="hljs-literal">False</span>] * <span class="hljs-number">100010</span><br>        ans = [<span class="hljs-number">0</span>] * n<br>        now = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs1</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">1</span>:<br>                has1[i] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                has1[i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> g[i]:<br>                dfs1(f)<br>                has1[i] |= has1[f]<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[i]:<br>                ans[i] = <span class="hljs-number">1</span><br><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs3</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                dfs3(j)<br>            visit[nums[i]] = <span class="hljs-literal">True</span><br>                <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs2</span>(<span class="hljs-params">i</span>):<br>            <span class="hljs-keyword">nonlocal</span> now<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[i]:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                <span class="hljs-keyword">if</span> has1[j]:<br>                    dfs2(j)<br>            <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> g[i]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has1[j]:<br>                    dfs3(j)<br>            visit[nums[i]] = <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">while</span> visit[now]:<br>                now += <span class="hljs-number">1</span><br>            ans[i] = now<br>        <br>        dfs1(<span class="hljs-number">0</span>)<br>        dfs2(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）"><a href="#117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a></h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>关键在于 s &#x3D; len(q) 直接取出当前层的结点数  然后通过for循环来遍历</p><h2 id="层序-链表"><a href="#层序-链表" class="headerlink" title="层序+链表"></a>层序+链表</h2><p>遍历当前层的时候 连接下一层的结点 </p><p>设置哨兵结点 遍历完当前层之后从哨兵结点开始下一层遍历</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.left = left</span><br><span class="hljs-string">        self.right = right</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-string">&quot;&quot;&quot;q = deque([root])</span><br><span class="hljs-string">        while q:</span><br><span class="hljs-string">            s = len(q)</span><br><span class="hljs-string">            pre = None</span><br><span class="hljs-string">            for i in range(s):</span><br><span class="hljs-string">                x = q.popleft()</span><br><span class="hljs-string">                if pre:</span><br><span class="hljs-string">                    pre.next = x</span><br><span class="hljs-string">                pre = x</span><br><span class="hljs-string">                if x.left:</span><br><span class="hljs-string">                    q.append(x.left)</span><br><span class="hljs-string">                if x.right:</span><br><span class="hljs-string">                    q.append(x.right)</span><br><span class="hljs-string">                </span><br><span class="hljs-string">        return root&quot;&quot;&quot;</span><br>        cur = root<br>        <span class="hljs-keyword">while</span> cur:<br>            dummy = Node()<br>            pre = dummy<br>            <span class="hljs-keyword">while</span> cur:<br>                <span class="hljs-keyword">if</span> cur.left:<br>                    pre.<span class="hljs-built_in">next</span> = cur.left<br>                    pre = pre.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">if</span> cur.right:<br>                    pre.<span class="hljs-built_in">next</span> = cur.right<br>                    pre = pre.<span class="hljs-built_in">next</span><br>                cur = cur.<span class="hljs-built_in">next</span><br>            cur = dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> root<br>        <br></code></pre></td></tr></table></figure><h1 id="318-最大单词长度乘积-力扣（LeetCode）"><a href="#318-最大单词长度乘积-力扣（LeetCode）" class="headerlink" title="318. 最大单词长度乘积 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/description/">318. 最大单词长度乘积 - 力扣（LeetCode）</a></h1><h2 id="哈希-位运算"><a href="#哈希-位运算" class="headerlink" title="哈希-&gt;位运算"></a>哈希-&gt;位运算</h2><p>一开始想到用哈希表存储 每个单词中 每个字母是否出现 即用列表存储哈希表 但是这样时间复杂度太高 每次查重的时候都需要遍历前i个单词的每个字母</p><p>可以用位运算优化 26个单词对应26个bit位 每次查重只需要 做<strong>与运算</strong>就可以判断是否有重复的单词 </p><p>（前面单词的长度 为len(word[j]) 因为是for j in range(i)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        sc = []<br>        maxret = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            mask = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> words[i]:<br>                mask |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>            sc.append(mask)<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> mask &amp; sc[j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(words[j]) * <span class="hljs-built_in">len</span>(words[i]) &gt; maxret:<br>                    maxret = <span class="hljs-built_in">len</span>(words[j]) * <span class="hljs-built_in">len</span>(words[i])<br>        <span class="hljs-keyword">return</span> maxret<br></code></pre></td></tr></table></figure><h2 id="位运算-哈希"><a href="#位运算-哈希" class="headerlink" title="位运算+哈希"></a>位运算+哈希</h2><p>哈希表不止能放1 然后判断是否出现啊  可以放每个单词的长度</p><p>如果两个单词相同的话 就是对应的位运算值相同 也就是mask相同  那么只需要取最大的长度就可以了 即保证哈希表中存放的都是这个单词最大的长度 可以减少重复的循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mp = <span class="hljs-built_in">dict</span>()<br>        maxret = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            mask = <span class="hljs-number">0</span><br>            l = <span class="hljs-built_in">len</span>(words[i])<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> words[i]:<br>                mask |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br>            <span class="hljs-keyword">if</span> mask <span class="hljs-keyword">in</span> mp <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(words[i]) &gt; mp[mask]:<br>                mp[mask] = l<br>            <span class="hljs-keyword">elif</span> mask <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> mp:<br>                mp[mask] = l<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> m, v <span class="hljs-keyword">in</span> mp.items():<br>                <span class="hljs-keyword">if</span> mask &amp; m == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> v * l &gt; maxret:<br>                    maxret = v * l<br>        <span class="hljs-keyword">return</span> maxret<br></code></pre></td></tr></table></figure><h1 id="2258-逃离火灾-力扣（LeetCode）"><a href="#2258-逃离火灾-力扣（LeetCode）" class="headerlink" title="2258. 逃离火灾 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/escape-the-spreading-fire/?envType=daily-question&envId=2023-11-09">2258. 逃离火灾 - 力扣（LeetCode）</a></h1><p>其实类似于脑筋急转弯 最后分类完只需要看 人是不是比火先到达安全屋即可</p><ul><li>人能到安全屋</li><li><ul><li>火不能到安全屋10**9</li><li>火能到安全屋</li><li><ul><li>火比人先到 -1</li><li><ul><li>火能不能在中途烧到人？ 不可能 因为火如果在中途烧到人 那么火就可以沿着 人的这条路走到安全屋 那么火一定是比人先到的</li></ul></li><li>火比人后到 t</li></ul></li></ul></li><li>人不能到安全屋 -1</li></ul><p>最后再看  火如果烧到了安全屋的上和左两格  那就把路封死了 即人和火同时到这两格 是不行的 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">q: <span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]</span>) -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>):<br>            d = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> q:<br>                d[i][j] = <span class="hljs-number">0</span><br>            ti = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> q:<br>                t = q<br>                q = []<br>                <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> t:<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                        ni, nj = i + dx[k], j+ dy[k]<br>                        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; m <span class="hljs-keyword">and</span> grid[ni][nj] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d[ni][nj] &lt; <span class="hljs-number">0</span>:<br>                            d[ni][nj] = ti<br>                            q.append((ni, nj))<br>                ti += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> [d[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>], d[-<span class="hljs-number">1</span>][-<span class="hljs-number">2</span>], d[-<span class="hljs-number">2</span>][-<span class="hljs-number">1</span>]]<br>        <br>        man, m1, m2 = bfs([(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)])<br>        <span class="hljs-keyword">if</span> man &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        fire_pos = [(i, j) <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(grid) <span class="hljs-keyword">for</span> j, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row) <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>]<br>        fire, f1, f2 = bfs(fire_pos)<br>        <span class="hljs-keyword">if</span> fire &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> ** <span class="hljs-number">9</span><br>        <br>        d = fire - man<br>        <span class="hljs-keyword">if</span> d &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> m1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> m1 + d &lt; f1 <span class="hljs-keyword">or</span> m2 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> m2 + d &lt; f2:<br>            <span class="hljs-keyword">return</span> d<br>        <span class="hljs-keyword">return</span> d - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="Problem-1169B-Codeforces"><a href="#Problem-1169B-Codeforces" class="headerlink" title="Problem - 1169B - Codeforces"></a><a href="https://codeforces.com/problemset/problem/1169/B">Problem - 1169B - Codeforces</a></h1><p>思考题 乍一看很难  但是其实很简单 </p><p>找是否有两个数 x y 使得每个数对至少有一个x 或y</p><p>那我们就用第一个数对的两个数 这两个数 必定有一个是x </p><p>但是不知道哪个是  于是枚举</p><p>假设a[0] 是x  到所有的数对中找 是否都含了a[0] 如果不含 那么这个数对中  的a[i] b[i] 必定有一个数 是y 然后再用x y 到后面的每个数组中找 如果有不含x y 的就是NO 否则为YES  实现的话这里可以从0到m 找到就++ 看最后是不是m个  </p><p>注意 不要用+&#x3D;i 最后算 (m - 1) * m &#x2F; 2 会爆int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//这段代码还可以优化就是说...</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x)                          \</span><br><span class="hljs-meta">    &#123;                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debugfull(x)                                                      \</span><br><span class="hljs-meta">    &#123;                                                                     \</span><br><span class="hljs-meta">        cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*-------------------------------------------*/</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span>, <span class="hljs-title">b</span><span class="hljs-params">(N)</span>, <span class="hljs-title">ca</span><span class="hljs-params">(N)</span>, <span class="hljs-title">cb</span><span class="hljs-params">(N)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>, q = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            p = a[i];<br>            q = b[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> va = <span class="hljs-number">0</span>, vb = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x || a[i] == p || b[i] == p)<br>            va++;<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x || a[i] == q || b[i] == q)<br>            vb++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (va == m || vb == m)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(a[<span class="hljs-number">0</span>]) || <span class="hljs-built_in">check</span>(b[<span class="hljs-number">0</span>]))<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// clock_t st = clock(), ed;</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; setprecision(15) &lt;&lt; fixed;</span><br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-comment">// ed = clock();</span><br>    <span class="hljs-comment">// double endtime = (double)(ed - st) / CLOCKS_PER_SEC;</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; endtime &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="1457-二叉树中的伪回文路径-力扣（LeetCode）"><a href="#1457-二叉树中的伪回文路径-力扣（LeetCode）" class="headerlink" title="1457. 二叉树中的伪回文路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/">1457. 二叉树中的伪回文路径 - 力扣（LeetCode）</a></h1><h2 id="朴素1"><a href="#朴素1" class="headerlink" title="朴素1"></a>朴素1</h2><p>主要问题在于判断叶子结点  直接写root is None： 可能会出现 某结点只有一个孩子  也进入判断的情况 （这肯定不是叶子）</p><p>所以要改成左右都为空才是叶子  相应的 cnt计数的操作也需要变化</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        cnt = [<span class="hljs-number">0</span>] * <span class="hljs-number">11</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> res, cnt<br>            <br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cnt[root.val] += <span class="hljs-number">1</span><br>                odd = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>                    <span class="hljs-built_in">print</span>(cnt[i],end=<span class="hljs-string">&#x27;&#x27;</span>)<br>                    <span class="hljs-keyword">if</span> cnt[i] % <span class="hljs-number">2</span>:<br>                        odd += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>()<br>                <span class="hljs-keyword">if</span> odd &lt;= <span class="hljs-number">1</span>:<br>                    res += <span class="hljs-number">1</span><br>                cnt[root.val] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span><br>            cnt[root.val] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> root.left:<br>                dfs(root.left)<br>            <span class="hljs-keyword">if</span> root.right:<br>                dfs(root.right)<br>            cnt[root.val] -= <span class="hljs-number">1</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="朴素2"><a href="#朴素2" class="headerlink" title="朴素2"></a>朴素2</h2><p>这个是 res作为返回值的 要注意 res 什么时候是直接return  什么时候是res +&#x3D;   什么时候是 res &#x3D;</p><p>然后是这个 用了一个 root is None 判空  空 就不用加</p><p>再用一个 if root.left is root.right 判叶子 是叶子就看能不能加1  不是叶子就继续递归 注意不是return</p><p>还有 不需要记录cnt 的值 然后去数  只需要记录cnt 的奇偶就可以了 （由此导出位运算</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = [<span class="hljs-number">0</span>] * <span class="hljs-number">10</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            cnt[root.val] ^= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> root.right:<br>                res = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(cnt) &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                res = dfs(root.left) + dfs(root.right)<br>             <br>            cnt[root.val] ^= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>既然只需要看每一位的奇偶  那也不用数组了  直接用一个数 的每一位 来异或就可以</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pseudoPalindromicPaths</span> (self, root: <span class="hljs-type">Optional</span>[TreeNode]) -&gt; <span class="hljs-built_in">int</span>:<br>        mask = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> mask<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            mask ^= <span class="hljs-number">1</span> &lt;&lt; root.val<br><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> root.right:<br>                res = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> mask &amp; (mask - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                res = dfs(root.left) + dfs(root.right)<br><br>            mask ^= <span class="hljs-number">1</span> &lt;&lt; root.val             <br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h1 id="1038-从二叉搜索树到更大和树-力扣（LeetCode）"><a href="#1038-从二叉搜索树到更大和树-力扣（LeetCode）" class="headerlink" title="1038. 从二叉搜索树到更大和树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树 - 力扣（LeetCode）</a></h1><p>从右往左遍历 可以达到一次遍历的效果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    su = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bstToGst</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.bstToGst(root.right)<br>        self.su += root.val<br>        root.val = self.su<br>        self.bstToGst(root.left)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h1 id="0最少刷题数-蓝桥云课-lanqiao-cn"><a href="#0最少刷题数-蓝桥云课-lanqiao-cn" class="headerlink" title="0最少刷题数 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2143/learning/">0最少刷题数 - 蓝桥云课 (lanqiao.cn)</a></h1><p>求中间的数 因为有重复数字  就需要用计数的方法 遍历 而不能用数学方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> ret[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 请在此输入您的代码</span><br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin&gt;&gt;nums[i];<br>        ret[i] = nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums + <span class="hljs-number">1</span>, nums + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; ans == <span class="hljs-number">-1</span>; )<br>    &#123;<br>        j = i++;<br>        <span class="hljs-keyword">while</span> (i &lt;= n &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])i++;<br>        <span class="hljs-type">int</span> l = j - <span class="hljs-number">1</span>, r = n - i + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt; &quot; &quot;&lt;&lt;nums[j]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (l &gt; r)ans = nums[j];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &lt; r)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> ans = nums[j] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;ans&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ret[i] &lt; nums[j])x = ans - ret[i];<br>        cout&lt;&lt; x &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="0矩形拼接-蓝桥云课-lanqiao-cn"><a href="#0矩形拼接-蓝桥云课-lanqiao-cn" class="headerlink" title="0矩形拼接 - 蓝桥云课 (lanqiao.cn)"></a><a href="https://www.lanqiao.cn/problems/2154/learning/">0矩形拼接 - 蓝桥云课 (lanqiao.cn)</a></h1><p>枚举 先选3个矩形的顺序  再选每个矩形的边的顺序</p><p>枚举就是要达到 每个图形的每条边 都可以直接表示出来 比如a[i] [ii] 这样 而且比如第二个if （if (a[i] [ii] &#x3D;&#x3D; a[j] [jj] + a[k] [kk])）这里只用写一个 而**不需要写a[j] [jj] &#x3D; a[i] [ii] + a[k] [kk] ** 因为循环会枚举到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>    cin&gt;&gt;a[i][j];<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>    <span class="hljs-keyword">if</span> (i != j)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++)<br>    <span class="hljs-keyword">if</span> (i != k &amp;&amp; j != k)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">2</span>; ii++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">0</span>; jj &lt; <span class="hljs-number">2</span>; jj++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> kk = <span class="hljs-number">0</span>; kk &lt; <span class="hljs-number">2</span>; kk++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i][ii] == a[j][jj] || a[i][ii] == a[k][kk])<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">if</span> (a[j][jj] == a[k][kk])<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">4</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[i][ii] == a[j][jj] + a[k][kk])<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">if</span> (a[j][<span class="hljs-number">1</span> - jj] == a[k][<span class="hljs-number">1</span> - kk])<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">4</span>);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1405-最长快乐字符串-力扣（LeetCode）"><a href="#1405-最长快乐字符串-力扣（LeetCode）" class="headerlink" title="1405. 最长快乐字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-happy-string/description/">1405. 最长快乐字符串 - 力扣（LeetCode）</a></h1><p>思路很好想 就是先放多的 再放少的 但是具体的实现比较困难</p><p>由于只有三个数 不用优先队列 可以直接用排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; PII;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestDiverseString</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        vector&lt;PII&gt;arr = &#123;&#123;a, <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="hljs-string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="hljs-string">&#x27;c&#x27;</span>&#125;&#125;;<br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), [&amp;](PII a, PII b)&#123;a.first &gt; b.first;&#125;);<br>            <span class="hljs-type">bool</span> hasNext = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[n, c]: arr)<br>            &#123;<br>                <span class="hljs-type">int</span> len = ans.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">2</span> &amp;&amp; ans[len - <span class="hljs-number">1</span>] == c &amp;&amp; ans[len - <span class="hljs-number">2</span>] == c)<br>                    <span class="hljs-keyword">continue</span>;<br>                hasNext = <span class="hljs-literal">true</span>;<br>                ans += c;<br>                n--;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!hasNext)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA</title>
    <link href="/2023/08/22/LCA/"/>
    <url>/2023/08/22/LCA/</url>
    
    <content type="html"><![CDATA[<h1 id="最近公共祖先-数组"><a href="#最近公共祖先-数组" class="headerlink" title="最近公共祖先 数组"></a>最近公共祖先 数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python">root = <span class="hljs-number">1</span><br>num = <span class="hljs-number">0</span><br>dep = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000010</span><br>f = [[<span class="hljs-number">0</span>] * <span class="hljs-number">21</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br>head = [-<span class="hljs-number">1</span>] * <span class="hljs-number">10000010</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, to, <span class="hljs-built_in">next</span></span>):<br>self.to = to<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addedge</span>(<span class="hljs-params">from_,to</span>):<br><span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    e[num] = Edge(to, head[from_])<br>    head[from_] = num<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">v, father</span>):<br>dep[v] = dep[father] + <span class="hljs-number">1</span><br>    f[v][<span class="hljs-number">0</span>] = father<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):<br>        f[v][i] = f[f[v][i-<span class="hljs-number">1</span>]][i-<span class="hljs-number">1</span>]<br>        <br>    i = head[v]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        p1 = e[i].to<br>        <span class="hljs-keyword">if</span> p1 == father:<br>            i = e[i].<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        dfs(p1,v)<br>        i = e[i].<span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lca</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-keyword">if</span> dep[x] &lt; dep[y]:<br>        x, y = y, x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dep[f[x][i]] &gt;= dep[y]:<br>            x = f[x][i]<br>         <span class="hljs-keyword">if</span> x == y:<br><span class="hljs-keyword">return</span> x<br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> f[x][i] != f[y][i]:<br>            x = f[x][i]<br>            y = f[y][i]<br>            <br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>]<br><br><br>n, m, root = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>e = [Edge(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000001</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    addedge(u, v)<br>    addedge(v, u)<br><br><span class="hljs-comment"># 建立 LCA 预处理</span><br>dfs(root, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 查询 LCA</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    result = lca(x, y)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[x] = father;<br>de[x] = de[father] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i; i = edge[i].next)<br>&#123;<br><span class="hljs-keyword">if</span> (edge[i].to != father)<br>&#123;<br><span class="hljs-built_in">dfs</span>(edge[i].to, x);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (x != y)<br>&#123;<br><span class="hljs-keyword">if</span> (de[x] &gt;= de[y])<br>&#123;<br>x = fa[x];<br>&#125;<br><span class="hljs-keyword">else</span><br>y = fa[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="当是链表形式的时候-较为简单"><a href="#当是链表形式的时候-较为简单" class="headerlink" title="当是链表形式的时候 较为简单"></a>当是链表形式的时候 较为简单</h1><h2 id="236-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#236-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="236. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        <br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; right)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> left ? left : right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2096-从二叉树一个节点到另一个节点每一步的方向-力扣（LeetCode）"><a href="#2096-从二叉树一个节点到另一个节点每一步的方向-力扣（LeetCode）" class="headerlink" title="2096. 从二叉树一个节点到另一个节点每一步的方向 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description/">2096. 从二叉树一个节点到另一个节点每一步的方向 - 力扣（LeetCode）</a></h2><p>从st到end的路程中 必定会经过两个点的最近公共祖先 </p><p>1如果两个点没关系  那就先上升到最近公共祖先再下降</p><p>2如果st是end的父节点 那么st就是lca </p><p>3如果st是end的子节点 那么end就是lca</p><p>所以必定经过lca</p><p>再思考 从st到lca到end 是怎样的路程  首先不断上升 再下降</p><p>上升可以反过来想 从lca下降到st 再把路程中的L R换成U</p><p>所以就需要dfs 求出lca到st 和end的路程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lca</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> destValue)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root-&gt;val == startValue || root-&gt;val == destValue)<br>        <span class="hljs-keyword">return</span> root;<br><br>        TreeNode *left = <span class="hljs-built_in">lca</span>(root-&gt;left, startValue, destValue);<br>        TreeNode *right = <span class="hljs-built_in">lca</span>(root-&gt;right, startValue, destValue);<br><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> left ? left : right;<br>    &#125;<br>    string res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> t, string&amp; path)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val == t)<br>        &#123;<br>            res = path;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;left)<br>        &#123;<br>            path += <span class="hljs-string">&#x27;L&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(cur-&gt;left, t, path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right)<br>        &#123;<br>            path += <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(cur-&gt;right, t, path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">getDirections</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> destValue)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        TreeNode* newroot = <span class="hljs-built_in">lca</span>(root, startValue, destValue);<br><br>        string path = <span class="hljs-string">&quot;&quot;</span>;<br>        res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(newroot, startValue, path);<br>        <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-string">&#x27;U&#x27;</span>)</span></span>;<br>        res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(newroot, destValue, path);<br>        ans += res;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>lca</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论相关算法</title>
    <link href="/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/21/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> to, w;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;Edge&gt; edges[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    Edge e = &#123;to, w&#125;;<br>    edges[from].<span class="hljs-built_in">push_back</span>(e);<br>&#125;<br><span class="hljs-comment">// 无向图调用两次add即可</span><br><span class="hljs-comment">// vector的size方法可以返回其包含的元素个数 用于遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges[<span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>(); i++);<br><span class="hljs-comment">//或者range-base for</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;e: edges[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> to, w, next;<br>&#125;;<br><span class="hljs-type">int</span> head[MAXN], cnt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    edges[++cnt].w = w; <span class="hljs-comment">// 新增一条边为cnt + 1的边 边权w</span><br>    edges[cnt].to = to; <span class="hljs-comment">// 该边的终点为to</span><br>    edges[cnt].next = head[from]; <span class="hljs-comment">// 把下一条边 设置为当前起点的第一条边</span><br>    head[from] = cnt;<br>    <span class="hljs-comment">// 最后两步相当于一个头插 会把新元素插到最前面而不是最后面 </span><br>&#125;<br><br><span class="hljs-comment">// 遍历结束的标志为 edges[i].next = 0 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[<span class="hljs-number">2</span>]; e != <span class="hljs-number">0</span>; e = edges[e].next);<br><br></code></pre></td></tr></table></figure><p>感谢金牌✌[pecco的学习笔记](<a href="https://zhuanlan.zhihu.com/p/105467597">算法学习笔记（目录） - 知乎 (zhihu.com)</a>)</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>单源点最短路，不可判负权和环</p><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>cnt = <span class="hljs-number">0</span><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>ans = [INF] * (n + <span class="hljs-number">1</span>)<br>vis = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>edge = &#123;&#125;<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>edge[i] = INF<br><br><span class="hljs-comment"># 初始化到s点的距离为0</span><br>ans[s] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 重边取最小</span><br>    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">in</span> edge:<br>edge[a][b] = <span class="hljs-built_in">min</span>(edge[a].get(b, INF), c)<br>    <span class="hljs-keyword">else</span>:<br>        edge[a] = &#123;b:c&#125;<br>pos = s<br><br><span class="hljs-comment"># pos 未遍历时</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vis[pos]:<br>    minn = INF<br>    <span class="hljs-comment"># 标记</span><br>    vis[pos] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># pos 顶点在边上时</span><br>    <span class="hljs-keyword">if</span> pos <span class="hljs-keyword">in</span> edge:<br>        <span class="hljs-comment"># 取pos顶点指向的顶点（设为终点（有向图））和权值</span><br>        <span class="hljs-keyword">for</span> to, wei <span class="hljs-keyword">in</span> edge[pos].items():<br><span class="hljs-comment"># 如果终点未访问并且终点的值大于pos+wei 那就更新终点值的最短路</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[to] <span class="hljs-keyword">and</span> ans[to] &gt; ans[pos] + wei:<br>                ans[to] = ans[pos] + wei<br>        <span class="hljs-comment"># 遍历所有未遍历的点  如果小于minn 就更新minn（最短路） 并且让pos = i（最短子路）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vis[i] <span class="hljs-keyword">and</span> ans[i] &lt; minn:<br>                minn = ans[i]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(ans[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-comment"># 邻接矩阵</span><br>graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    graph[u].append((v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br><span class="hljs-comment"># 距离 初始化为无穷  源点初始化为0</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><span class="hljs-comment"># 先放入源点 第一个参数d表示源点s到当前结点的最短路   第二个参数node表示当前节点编号</span><br>q = [(<span class="hljs-number">0</span>,s)]<br><span class="hljs-comment"># 队列不空的时候</span><br><span class="hljs-keyword">while</span> q:<br><span class="hljs-comment"># 取出源点和起点</span><br>    d, node = heapq.heappop(q)<br>    <span class="hljs-comment"># 当当前最短路小于源点到node的距离时 跳过</span><br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br><span class="hljs-keyword">continue</span><br>    <span class="hljs-comment"># 从图中取出node结点的终点和权值</span><br>    <span class="hljs-keyword">for</span> neighbor, wei <span class="hljs-keyword">in</span> graph[node]:<br><span class="hljs-keyword">if</span> dist[node] + wei &lt; dist[neighbor]:<br>dist[neighbor] = dist[node] + wei<br>             heapq.heappush(q,(dist[neighbor],neighbor))<br>                <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Polar</span><br>&#123;<br>    <span class="hljs-type">int</span> dist, id;<br>    <span class="hljs-built_in">Polar</span>(<span class="hljs-type">int</span> dist, <span class="hljs-type">int</span> id) : <span class="hljs-built_in">dist</span>(dist), <span class="hljs-built_in">id</span>(id)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(Polar a, Polar b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.dist &gt; b.dist; <span class="hljs-comment">//这里是大于 使得距离短的先出队</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[s] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(<span class="hljs-number">0</span>, s));<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>().id;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[p])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[p] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edge[e].next)<br>        &#123;<br>            <span class="hljs-type">int</span> to = edges[e].to;<br>            dist[to] = <span class="hljs-built_in">min</span>(dist[to], dist[p] + edges[e].w);<br>            <span class="hljs-keyword">if</span> (!vis[to])<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Polar</span>(dist[to], to));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>head = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>edge = []<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-comment"># 判重</span><br>    exist = <span class="hljs-literal">False</span><br>    i = head[u]<br>    <span class="hljs-keyword">while</span> i:<br>        <span class="hljs-keyword">if</span> edge[i][<span class="hljs-number">0</span>] == v:<br>            exist = <span class="hljs-literal">True</span><br>            edge[i] = (v, <span class="hljs-built_in">min</span>(edge[i][<span class="hljs-number">1</span>],w), edge[i][<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">break</span><br>        i = edge[i][<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:<br>        edge.append((v,w,head[u]))<br>        head[u] = <span class="hljs-built_in">len</span>(edge) - <span class="hljs-number">1</span><br><br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>priority_queue = [(<span class="hljs-number">0</span>,s)]<br><br><span class="hljs-keyword">while</span> priority_queue:<br>    d,node = heapq.heappop(priority_queue)<br>    <span class="hljs-keyword">if</span> d &gt; dist[node]:<br>        <span class="hljs-keyword">continue</span><br>    i = head[node]<br>    <span class="hljs-keyword">while</span> i:<br>        neighbor, weight, nextt = edge[i]<br>        <span class="hljs-keyword">if</span> dist[node] + weight &lt; dist[neighbor]:<br>            dist[neighbor] = dist[node] + weight<br>            heapq.heappush(priority_queue, (dist[neighbor],neighbor))<br>        i = nextt<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(dist[i],end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h2><p>一般用链式前向星或者 邻接表存图 用结构体存结点</p><p>首先除起点外所有顶点到起点的距离dis数组初始化为无穷大</p><p>遍历每条边 对每条边的两个顶点进行松弛操作 直到不能再松弛</p><p>判断负环 如果迭代超过n - 1次还能继续松弛则说明存在负环</p><p>每次迭代k如果进行了松弛操作 则一定是经历了k条边的最短路</p><p>一共是n个顶点 如果不存在负环 某点到另一个点最多只有n - 1条边 </p><p>如果迭代k后没有点进行松弛操作 则代表已经找出了所有的最短路 迭代结束跳出循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, w;<br>&#125;;<br>vector&lt;vector&lt;edge&gt;&gt;<span class="hljs-built_in">e</span>(MAXN);<br><span class="hljs-type">int</span> dis[MAXN];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellman</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dis[u] == inf)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : e[u])<br>            &#123;<br>                <span class="hljs-type">int</span> v = x.v, w = x.w;<br>                <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w)<br>                &#123;<br>                    dis[v] = dis[u] + w;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p>单源点最短路，可判负权和环</p><p>“只更新可能更新的点”：</p><p>只让当前点能到达的点入队 </p><p>如果一个点已经在队列中 不重复入队 </p><p>如果u一条边未更新 那么他的终点不入队</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v, w</span>):<br>        self.v = v<br>        self.w = w<br>n, m, s = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br><br>graph = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">if</span> graph[u] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> graph[u].w &gt; w:<br>graph[u] = []<br>    graph[u].append(edge(v,w))<br>INF = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>dist = [INF] * (n + <span class="hljs-number">1</span>)<br>dist[s] = <span class="hljs-number">0</span><br><br>q = deque([s])<br><br><span class="hljs-comment"># 标记是否在队列中  以及计数 用来判断环</span><br>in_queue = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>in_queue[s] = <span class="hljs-literal">True</span><br>enqueue_count = [<span class="hljs-number">0</span>]  * (n + <span class="hljs-number">1</span>)<br>enqueue_count[s] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">while</span> q:<br>    <span class="hljs-comment"># 取出当前点 </span><br>    node = q.popleft()<br>    in_queue[node] = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 取当前点相连的所有边</span><br>    <span class="hljs-keyword">for</span> ed <span class="hljs-keyword">in</span> graph[node]:<br>        <span class="hljs-comment"># 取出终点和权值</span><br>        v, w = ed.v, ed.w<br>    <span class="hljs-keyword">if</span> dist[v] &gt;  dist[node] + w:<br>            dist[v] = dist[node] + w<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> in_queue[v]:<br>                q.append(v)<br>                in_queue[v] = <span class="hljs-literal">True</span><br>                enqueue_count[v] += <span class="hljs-number">1</span><br>                <br>                <span class="hljs-keyword">if</span> enqueue_count[v] &gt; n:<br>                    exit(<span class="hljs-number">0</span>)<br>                    <br></code></pre></td></tr></table></figure><h3 id="C-版-1"><a href="#C-版-1" class="headerlink" title="C++版"></a>C++版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        inqueue[p] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[p]; e != <span class="hljs-number">0</span>; e = edges[e].next)<br>        &#123;<br>            <span class="hljs-type">int</span> to = edges[e].to;<br>            <span class="hljs-keyword">if</span> (dist[to] &gt; dist[p] + edges[e].w)<br>            &#123;<br>                pre[to] = p; <span class="hljs-comment">// 存储路径 </span><br>                dist[to] = dist[p] + edges[e].w;<br>                <span class="hljs-keyword">if</span> (!inqueue[to])<br>                &#123;<br>                    inqueue[to] = <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(to);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>多源最短路</p><p>看是否可以是否可以通过k 来更新i到j的最短路 所以k在最外层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x3f3f3f3f</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>d = [[INF] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][i] = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], w)<br>    <span class="hljs-comment"># 同时要更新另一条边</span><br>    d[b][a] = <span class="hljs-built_in">min</span>(d[b][a], w)<br>    <br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k] + d[k][j])<br>            <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(d[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="Kahn"><a href="#Kahn" class="headerlink" title="Kahn"></a>Kahn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Kahn算法</span><br><span class="hljs-keyword">from</span> collection <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = []<br>din = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-comment"># 每次从队列取出 让他所有出边减一 当某点入度为0时加入队列  如果最后队列长n则有拓扑序 否则有环</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>(<span class="hljs-params">n</span>):<br>queue = deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> din[i] == <span class="hljs-number">0</span>:<br>queue.append(i)<br>    <span class="hljs-keyword">while</span> queue:<br>        x = queue.popleft()<br>        tp.append(x)<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>            din[y] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> din[y] == <span class="hljs-number">0</span>:<br>queue.append(y)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp) == n<br><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    e[a].append(b)<br>    din[b] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> toposort(n):<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tp:<br><span class="hljs-built_in">print</span>(x,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">100000</span><br>e = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>tp = [<span class="hljs-number">0</span>] * N<br>c = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> tp<br>    c[x] = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> e[x]:<br>        <span class="hljs-keyword">if</span> c[y] &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> c[y]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(y):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    c[x] = <span class="hljs-number">1</span><br>    tp.append(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toposort</span>():<br>    <span class="hljs-keyword">global</span> c, tp<br>    c = [<span class="hljs-number">0</span>] * N<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c[i]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    tp.reverse()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入为字典</span><br>activities = &#123;&#125;<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    name, duration, dependencies = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    activities[name] = &#123;<span class="hljs-string">&#x27;duration&#x27;</span>:duration, <span class="hljs-string">&#x27;dependencies&#x27;</span>:dependencies&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_early_late_times</span>(<span class="hljs-params">activities</span>):<br>    <span class="hljs-comment"># 初始化每个工作的最早开始时间和最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-comment"># 计算最早开始时间</span><br>    <span class="hljs-comment"># 遍历所有工作 如果依赖于前一项工作 就为前面所有工作的最早开始时间加上持续时间的最大值 如果没有依赖于其他工作则为0</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            max_dependency_end = <span class="hljs-built_in">max</span>([activities[dep][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[dep][<span class="hljs-string">&#x27;duration&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] = max_dependency_end<br><br>    <span class="hljs-comment"># 计算最后完成的工作的最晚开始时间 为所有工作的最晚的（最早开始时间+持续时间）</span><br>    end_activity = <span class="hljs-built_in">max</span>(activities,key=<span class="hljs-keyword">lambda</span> activity: activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>])<br>    activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;ES&#x27;</span>] + activities[end_activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>    <span class="hljs-comment"># 反向计算最晚开始时间</span><br>    <span class="hljs-comment"># 如果不依赖于其他工作 最晚开始时间为最后工作的最晚开始时间-持续时间  否则为最早的最晚开始时间</span><br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">list</span>(activities.key())):<br>        dependencies = activities[activity][<span class="hljs-string">&#x27;dependencies&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dependencies:<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = activities[end_activity][<span class="hljs-string">&#x27;LS&#x27;</span>] - activities[activity][<span class="hljs-string">&#x27;duration&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            min_dependency_start = <span class="hljs-built_in">min</span>([activities[dep][<span class="hljs-string">&#x27;LS&#x27;</span>] <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> dependencies])<br>            activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>] = min_dependency_start<br><br><br><span class="hljs-comment"># 最早开始时间=最晚开始时间即为关键路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal_critical_path</span>(<span class="hljs-params">activities</span>):<br>    critical_path = []<br>    <span class="hljs-keyword">for</span> activity <span class="hljs-keyword">in</span> activities:<br>        <span class="hljs-keyword">if</span> activities[activity][<span class="hljs-string">&#x27;ES&#x27;</span>] == activities[activity][<span class="hljs-string">&#x27;LS&#x27;</span>]:<br>            critical_path.append(activity)<br>    <span class="hljs-keyword">return</span> critical_path<br></code></pre></td></tr></table></figure><h1 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h1><p><a href="https://leetcode.cn/problems/critical-connections-in-a-network/solutions/?envType=study-plan-v2&envId=graph-theory">例题</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">criticalConnections</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, connections: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        graph = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> con <span class="hljs-keyword">in</span> connections:<br>            graph[con[<span class="hljs-number">0</span>]].append(con[<span class="hljs-number">1</span>])<br>            graph[con[<span class="hljs-number">1</span>]].append(con[<span class="hljs-number">0</span>])<br><br>        <br>        idx = [-<span class="hljs-number">1</span>] * n<br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">curnode, curid, parent</span>):<br>            idx[curnode] = curid<br><br>            <span class="hljs-keyword">for</span> nextnode <span class="hljs-keyword">in</span> graph[curnode]:<br>                <span class="hljs-keyword">if</span> nextnode == parent:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> idx[nextnode] == -<span class="hljs-number">1</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(dfs(nextnode,curid + <span class="hljs-number">1</span>, curnode),idx[curnode])<br>                <span class="hljs-keyword">else</span>:<br>                    idx[curnode] = <span class="hljs-built_in">min</span>(idx[curnode],idx[nextnode])<br><br>            <span class="hljs-comment"># 说明存在环</span><br>            <span class="hljs-keyword">if</span> idx[curnode] == curid <span class="hljs-keyword">and</span> curnode != <span class="hljs-number">0</span>:<br>                res.append((parent, curnode))<br>            <span class="hljs-comment"># 记得返回idx</span><br>            <span class="hljs-keyword">return</span> idx[curnode]<br>        <br><br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="朴素算法-1"><a href="#朴素算法-1" class="headerlink" title="朴素算法"></a>朴素算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v, w;<br>&#125;;<br>vector&lt;edge&gt;e;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>    d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; d[j] &lt; d[u])u = j;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        ans += d[u];<br>        <span class="hljs-comment">// 非连通图到u距离还是无穷  判断是否连通</span><br>        <span class="hljs-keyword">if</span> (d[u] != inf) cnt ++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed: e[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = ed.v, w = ed.w;<br>            <span class="hljs-keyword">if</span> (d[v] &gt; w)d[v] = w;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化-1"><a href="#堆优化-1" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">堆的第一个元素是他的边权 仅仅用来排序 没有其他任何作用 因为在使用到边权的时候 会使用d[u] 而不会使用q.top().first</span><br><span class="hljs-comment">所以直接建大根堆 放负边权即可</span><br><span class="hljs-comment">*/</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;q;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)d[i] = inf;<br>   d[s] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[u])<span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 先取出的必小 后取出的大 直接不看了</span><br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans += d[u];<br>        cnt ++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed: e[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = ed.v, w = ed.w;<br>            <span class="hljs-keyword">if</span> (d[v] &gt; w)<br>            &#123;<br>                d[v] = w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> u, v, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> edge&amp; t)<span class="hljs-type">const</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; t.w;<br>    &#125;<br>&#125;e[N];<br><span class="hljs-type">int</span> fa[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x])<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(e, e + m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)p[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(e[i].v);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(e[i].u);<br>        <span class="hljs-keyword">if</span>(x != y)<br>        &#123;<br>            fa[x] = y;<br>            ans += e[i].w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树题解</title>
    <link href="/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="P1827-USACO3-4-美国血统-American-Heritage"><a href="#P1827-USACO3-4-美国血统-American-Heritage" class="headerlink" title="[P1827 USACO3.4] 美国血统 American Heritage"></a>[P1827 <a href="https://www.luogu.com.cn/problem/P1827">USACO3.4] 美国血统 American Heritage</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 其实就是前中序转后序 递归 当前序为空的时候退出，否则取前序的第一个为根，再中序中找左边为左子树，右边为右子树。注意前序中，左边的前k个就是左子树的，后面就是右子树的。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(string pre, string inor)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">char</span> root = pre[<span class="hljs-number">0</span>];<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-type">int</span> k = inor.<span class="hljs-built_in">find</span>(root);<br>string leftinor = inor.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightinor = inor.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 注意这里</span><br>string leftpre = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k);<br>string rightpre = pre.<span class="hljs-built_in">substr</span>(k);<br><br><span class="hljs-built_in">change</span>(leftpre, leftinor);<br><span class="hljs-built_in">change</span>(rightpre, rightinor);<br><br>cout &lt;&lt; root;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string pre, inor;<br>cin &gt;&gt; inor &gt;&gt; pre;<br><span class="hljs-built_in">change</span>(pre, inor);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="449-序列化和反序列化二叉搜索树-力扣（LeetCode）"><a href="#449-序列化和反序列化二叉搜索树-力扣（LeetCode）" class="headerlink" title="449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br>    <span class="hljs-comment"># 序列化比较简单 就是一个后序遍历 注意最后的return部分 &#x27; &#x27;.join(map(str, arr)) 首先是&#x27;&#x27;要有空格 然后是map的用法 把arr转str</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            postOrder(root.left)<br>            postOrder(root.right)<br>            arr.append(root.val)<br>        postOrder(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,arr))<br>        <br><span class="hljs-comment"># 对于二叉搜索树来说 每个点的位置确定 所以比反序列化普通二叉树简单</span><br>    <span class="hljs-comment"># 首先把data还原成arr 当到达叶子节点的时候（也就是当前点不能插入这个地方）返回None    从arr中取出一个数作为跟 然后取出一个数作为右孩子 取出一个数作为左孩子 （后序遍历 先右再左）然后返回根   注意 初始的时候不限范围  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, data.split()))<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">lower,upper</span>):<br>            <span class="hljs-keyword">if</span> arr == [] <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &lt; lower <span class="hljs-keyword">or</span> arr[-<span class="hljs-number">1</span>] &gt; upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            val = arr.pop()<br>            root = TreeNode(val)<br>            root.right = construct(val, upper)<br>            root.left = construct(lower,val)<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> construct(-inf,inf)<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化-力扣（LeetCode）"><a href="#297-二叉树的序列化与反序列化-力扣（LeetCode）" class="headerlink" title="297. 二叉树的序列化与反序列化 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(root.val) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.left)) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">str</span>(self.serialize(root.right)) <br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        :type data: str</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">dataList</span>):<br>            val = dataList.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> val == <span class="hljs-string">&#x27;None&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            root = TreeNode(<span class="hljs-built_in">int</span>(val))<br>            root.left = dfs(dataList)<br>            root.right = dfs(dataList)<br>            <span class="hljs-keyword">return</span> root<br>        dataList = data.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">return</span> dfs(dataList)<br>        <br></code></pre></td></tr></table></figure><h1 id="1080-根到叶路径上的不足节点-力扣（LeetCode）"><a href="#1080-根到叶路径上的不足节点-力扣（LeetCode）" class="headerlink" title="1080. 根到叶路径上的不足节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点 - 力扣（LeetCode）</a></h1><p>很经典的二叉树  搜索问题 分为三步  1 判断根节点 2判断叶子节点 3递归左右 同时变化条件（limit）</p><p>这个题关键就是 看出来 只有左右都不满足的时候 （把左右都删掉）根才能不满足 如果左右没删除 说明有满足大于limit的 那么根必定是有大于limit的 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sufficientSubset</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> limit)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (limit &gt; <span class="hljs-number">0</span>)<br>                root = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (root-&gt;left) root-&gt;left = <span class="hljs-built_in">sufficientSubset</span>(root-&gt;left, limit - root-&gt;val);<br>        <span class="hljs-keyword">if</span> (root-&gt;right) root-&gt;right = <span class="hljs-built_in">sufficientSubset</span>(root-&gt;right, limit - root-&gt;val);<br>        <br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树</title>
    <link href="/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2023/08/08/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Splay树"><a href="#Splay树" class="headerlink" title="Splay树"></a><a href="https://www.luogu.com.cn/problem/P3369">Splay树</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, p, val;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> s[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> siz;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>cnt = siz = <span class="hljs-number">1</span>;<br>p = p1, v = v1;<br>&#125;<br>&#125;tree[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-comment">// 更新树的大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 旋转 旋转不仅使得x转到y处，x的其中一个儿子也要给y</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找到x的父节点y和y的父节点z，k判断x是否为y的右儿子 假设x为y的右儿子 k为1</span><br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = tree[y].s[<span class="hljs-number">1</span>] == x;<br><span class="hljs-comment">// 先转动使 y的右儿子处放上x的左儿子 然后让x的左儿子的父节点为y</span><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><span class="hljs-comment">// 然后使x的右儿子为y，y的父亲为x</span><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><span class="hljs-comment">// 如果z的右儿子为y 那么z的右儿子为x （x替代y） 然后x的父亲为z</span><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><span class="hljs-comment">//记得更新节点</span><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-comment">// splay 伸展结点，使x为k的儿子  k为0的时候使x为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br>        <span class="hljs-comment">// 当x的祖父结点不为k的时候 旋转</span><br><span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-comment">// y的左儿子为x 并且z的左儿子为y 也就是直线型 转动y（1^1=0） 折线型转动x</span><br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-comment">// 再转一次（双旋</span><br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br>    <span class="hljs-comment">// k为0的时候 让x为根</span><br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><span class="hljs-comment">// 查找v并让v为根</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 找前驱 先找到v 然后如果根的值小于v，直接返回x，因为比根大，不可能有前驱了（前驱是比）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br><span class="hljs-comment">// 根节点的左子树的最大结点就是前驱</span><br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>]) x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 找后继 同理</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br><br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">// 删除 并不是真的结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 先找前驱和后继</span><br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v);<br><span class="hljs-type">int</span> suc = <span class="hljs-built_in">get_suc</span>(v);<br><span class="hljs-comment">// 转动前驱到根，转动后继为前驱的儿子，就是逻辑上的删除了该结点（此时待删除结点为后继的左儿子）</span><br><span class="hljs-built_in">splay</span>(pre, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(suc, pre);<br>    <span class="hljs-comment">// 后继的左儿子设为del（即待删除的点）</span><br><span class="hljs-type">int</span> del = tree[suc].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[del].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">// 如果待删点不止一个，只删除一个并把他放回到根结点</span><br>tree[del].cnt--, <span class="hljs-built_in">splay</span>(del, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 后继的左儿子为0 即删除了待删除结点</span><br>tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">splay</span>(suc, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">return</span> tree[tree[root].s[<span class="hljs-number">0</span>]].siz;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (tree[y].siz + tree[x].cnt &lt; k)<br>&#123;<br>k -= tree[y].siz + tree[x].cnt;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[y].siz &gt;= k)x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> tree[x].v;<br>&#125;<br><span class="hljs-comment">// 插入结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; tree[x].v != v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br>    <span class="hljs-comment">// 转动新插入的结点为根</span><br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意先插入哨兵</span><br><span class="hljs-built_in">insert</span>(-INF), <span class="hljs-built_in">insert</span>(INF);<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; p &gt;&gt; val;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>)<span class="hljs-built_in">insert</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">2</span>)<span class="hljs-built_in">del</span>(val);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">3</span>)cout &lt;&lt; <span class="hljs-built_in">get_rank</span>(val) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">4</span>)cout &lt;&lt; <span class="hljs-built_in">get_val</span>(val + <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">5</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_pre</span>(val)].v &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">6</span>)cout &lt;&lt; tree[<span class="hljs-built_in">get_suc</span>(val)].v &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91rotate.png" alt="rotate"></p><p><img src="/../images/$%7Bfiilename%7D/%E5%B9%B3%E8%A1%A1%E6%A0%91splay.png" alt="splay"></p><h2 id="flag-写个python版的！"><a href="#flag-写个python版的！" class="headerlink" title="flag 写个python版的！"></a><del>flag</del> 写个python版的！</h2><h2 id="例题-营业额统计"><a href="#例题-营业额统计" class="headerlink" title="例题  营业额统计"></a>例题  <a href="https://www.luogu.com.cn/problem/P2234">营业额统计</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>, root;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>, N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> v, s[<span class="hljs-number">2</span>], cnt, siz, p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>v = v1, p = p1;<br>cnt = siz = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;tree[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz = tree[tree[x].s[<span class="hljs-number">0</span>]].siz + tree[tree[x].s[<span class="hljs-number">1</span>]].siz + tree[x].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-type">int</span> k = (tree[y].s[<span class="hljs-number">1</span>] == x);<br><br>tree[y].s[k] = tree[x].s[k ^ <span class="hljs-number">1</span>];<br>tree[tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br><br>tree[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>tree[y].p = x;<br><br>tree[z].s[tree[z].s[<span class="hljs-number">1</span>] == y] = x;<br>tree[x].p = z;<br><br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (tree[x].p != k)<br>&#123;<br><span class="hljs-type">int</span> y = tree[x].p, z = tree[y].p;<br><span class="hljs-keyword">if</span> (z != k)<br>(tree[y].s[<span class="hljs-number">0</span>] == x) ^ (tree[z].s[<span class="hljs-number">0</span>] == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &amp;&amp; v != tree[x].v)<br>p = x, x = tree[x].s[v &gt; tree[x].v];<br><br><span class="hljs-keyword">if</span> (x) tree[x].cnt++;<br><span class="hljs-keyword">else</span><br>&#123;<br>x = ++idx;<br>tree[p].s[v &gt; tree[p].v] = x;<br>tree[x].<span class="hljs-built_in">init</span>(p, v);<br>&#125;<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">while</span> (tree[x].s[v &gt; tree[x].v] &amp;&amp; v != tree[x].v)<br>x = tree[x].s[v &gt; tree[x].v];<br><span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &lt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">1</span>])x = tree[x].s[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-type">int</span> x = root;<br><span class="hljs-keyword">if</span> (tree[x].v &gt; v)<span class="hljs-keyword">return</span> x;<br>x = tree[x].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (tree[x].s[<span class="hljs-number">0</span>])x = tree[x].s[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span> (tree[root].cnt &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pre = <span class="hljs-built_in">get_pre</span>(v), suc = <span class="hljs-built_in">get_suc</span>(v);<br><br><span class="hljs-type">int</span> a = tree[pre].v, b = tree[suc].v;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - v) &lt; <span class="hljs-built_in">fabs</span>(b - v) ? <span class="hljs-built_in">fabs</span>(a - v) : <span class="hljs-built_in">fabs</span>(b - v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">insert</span>(INF), <span class="hljs-built_in">insert</span>(-INF);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; x;<br><span class="hljs-built_in">insert</span>(x);<br><span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>ret += <span class="hljs-built_in">search</span>(x);<br><span class="hljs-keyword">else</span> ret += x;<br>&#125;<br>cout &lt;&lt; ret &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h2><h3 id="几个需要注意的地方"><a href="#几个需要注意的地方" class="headerlink" title="几个需要注意的地方"></a>几个需要注意的地方</h3><ul><li>Node的siz和cnt需要设置为0 而不是1  在申请结点之后设置为1</li><li>idx需要自增（C++转python的时候 由于++idx并不是放在单独的一句，写的时候容易漏掉</li><li>idx自增之后x &#x3D; idx即可</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        self.s = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-comment"># son</span><br>        self.p = <span class="hljs-number">0</span> <span class="hljs-comment"># parent</span><br>        self.v = key <span class="hljs-comment"># val</span><br>        self.cnt = <span class="hljs-number">0</span><br>        self.siz = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SplayTree</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.N = <span class="hljs-number">100010</span><br>        self.INF = <span class="hljs-number">0x7fffffff</span><br>        self.tree = [Node(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N)]<br>        self.root = <span class="hljs-number">0</span><br>        self.idx = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 更新树的大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pushup</span>(<span class="hljs-params">self, x</span>):<br>        self.tree[x].siz = self.tree[self.tree[x].s[<span class="hljs-number">0</span>]].siz + self.tree[self.tree[x].s[<span class="hljs-number">1</span>]].siz + self.tree[x].cnt<br><br>    <span class="hljs-string">&quot;&quot;&quot;旋转操作 </span><br><span class="hljs-string">    首先得到x的父节点y和y的父节点z，用k来表示左旋和右旋（如果x在y的左子树右旋，x在y的右子树左旋）</span><br><span class="hljs-string">    以右旋为例 k为0</span><br><span class="hljs-string">    首先让y的左子树放上x的右子树 同时x的右子树的父亲设置为y</span><br><span class="hljs-string">    然后让x的右子树放上y 同时y的父亲设为x</span><br><span class="hljs-string">    最后让z的右子树放上x 同时x的父亲设为z</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    更新x y结点树的大小</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, x</span>):<br>        y = self.tree[x].p<br>        z = self.tree[y].p<br>        k = self.tree[y].s[<span class="hljs-number">1</span>] == x<br><br>        self.tree[y].s[k] = self.tree[x].s[k ^ <span class="hljs-number">1</span>]<br>        self.tree[self.tree[x].s[k ^ <span class="hljs-number">1</span>]].p = y<br><br>        self.tree[x].s[k ^ <span class="hljs-number">1</span>] = y<br>        self.tree[y].p = x<br><br>        self.tree[z].s[self.tree[z].s[<span class="hljs-number">1</span>] == y] = x<br>        self.tree[x].p = z<br><br>        self.pushup(y)<br>        self.pushup(x)<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    splay 使x为k的儿子 有三种情况 </span><br><span class="hljs-string">    k是根 做单旋  </span><br><span class="hljs-string">    k不是根 直线型 做双旋 </span><br><span class="hljs-string">    k不是根 折线形 做双旋</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    先不断向上找x的父节点 当不为k时继续循环：取出父节点y和祖先结点z 如果z不是x的祖先就旋转 </span><br><span class="hljs-string">    当为直线型的时候（用^判断）转x  折线形转y   最后还要再转一下x 双旋（y是根的时候只会转一次x）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    如果k为0 表示k为根节点 要设置x为根</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">splay</span>(<span class="hljs-params">self, x, k</span>):<br>        <span class="hljs-keyword">while</span> self.tree[x].p != k:<br>            y = self.tree[x].p<br>            z = self.tree[y].p<br>            <span class="hljs-keyword">if</span> z != k:<br>                <span class="hljs-keyword">if</span> (self.tree[y].s[<span class="hljs-number">0</span>] == x) ^ (self.tree[z].s[<span class="hljs-number">0</span>] == y):<br>                    self.rotate(x)<br>                <span class="hljs-keyword">else</span>:<br>                    self.rotate(y)<br>            self.rotate(x)<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            self.root = x<br><br>    <span class="hljs-comment"># 树的查找 找到之后要把x设为根（splay）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> self.tree[x].s[v &gt; self.tree[x].v] <span class="hljs-keyword">and</span> v != self.tree[x].v:<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        self.splay(x, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    找前驱 由于find是找到v且当v不存在时找到的是最接近v的值并将其设置为根</span><br><span class="hljs-string">    当该结点小于v的时候直接返回 否则返回他的左子树的最右边的值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pre</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &lt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">1</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_suc</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        x = self.root<br>        <span class="hljs-keyword">if</span> self.tree[x].v &gt; v:<br>            <span class="hljs-keyword">return</span> x<br>        x = self.tree[x].s[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> self.tree[x].s[<span class="hljs-number">0</span>]:<br>            x = self.tree[x].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    删除结点，并非真的删除，而是让他访问不到</span><br><span class="hljs-string">    先取出v的前驱和后继结点 并splay</span><br><span class="hljs-string">    设删除结点为del_node 如果出现次数大于1 就减一并splay del_node 否则splay 后继结点</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, v</span>):<br>        pre = self.get_pre(v)<br>        suc = self.get_suc(v)<br>        self.splay(pre, <span class="hljs-number">0</span>)<br>        self.splay(suc, pre)<br>        del_node = self.tree[suc].s[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> self.tree[del_node].cnt &gt; <span class="hljs-number">1</span>:<br>            self.tree[del_node].cnt -= <span class="hljs-number">1</span><br>            self.splay(del_node, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.tree[suc].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            self.splay(suc, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># v的排位即v为根的时候v的左子树大小</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rank</span>(<span class="hljs-params">self, v</span>):<br>        self.find(v)<br>        <span class="hljs-keyword">return</span> self.tree[self.tree[self.root].s[<span class="hljs-number">0</span>]].siz<br><br>    <span class="hljs-comment"># k位的值 不断找到x的左子树 如果左子树的siz加x的cnt大于k 就往左子树走 否则就让k减去他们俩的和并往右子树走</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_val</span>(<span class="hljs-params">self, k</span>):<br>        x = self.root<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            y = self.tree[x].s[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> self.tree[y].siz + self.tree[x].cnt &lt; k:<br>                k -= self.tree[y].siz + self.tree[x].cnt<br>                x = self.tree[x].s[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.tree[y].siz &gt;= k:<br>                    x = self.tree[x].s[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>        self.splay(x,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.tree[x].v<br><br>    <span class="hljs-comment"># 插入操作 先取出根节点 父节点为0 不断向下递归找到x的插入位置  找到之后 如果该结点已经存在 就让cnt+1 否则创建新节点（idx+1 p的儿子为x 初始化x</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, v</span>):<br>        x = self.root<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> x <span class="hljs-keyword">and</span> self.tree[x].v != v:<br>            p = x<br>            x = self.tree[x].s[v &gt; self.tree[x].v]<br>        <span class="hljs-keyword">if</span> x:<br>            self.tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 注意 这里的idx要先++</span><br>            self.idx += <span class="hljs-number">1</span><br>            x = self.idx<br>            self.tree[p].s[v &gt; self.tree[p].v] = x<br>            self.tree[x].p = p<br>            self.tree[x].v = v<br>            self.tree[x].cnt = <span class="hljs-number">1</span><br>            self.tree[x].siz = <span class="hljs-number">1</span><br>        self.splay(x, <span class="hljs-number">0</span>)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st = SplayTree()<br>    st.insert(-st.INF)<br>    st.insert(st.INF)<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        p, val = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:<br>            st.insert(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">2</span>:<br>            st.delete(val)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">print</span>(st.get_rank(val))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">print</span>(st.get_val(val + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_pre(val)].v)<br>        <span class="hljs-keyword">elif</span> p == <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">print</span>(st.tree[st.get_suc(val)].v)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> key;<br>Node* left, * right;<br><span class="hljs-type">int</span> Height;<br>&#125;;<br><br><span class="hljs-function">Node* <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>Node* newNode = <span class="hljs-keyword">new</span> Node;<br>newNode-&gt;Height = <span class="hljs-number">0</span>;<br>newNode-&gt;key = key;<br>newNode-&gt;left = newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> newNode;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetHeight</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetHeight</span>(root-&gt;left), <span class="hljs-built_in">GetHeight</span>(root-&gt;right));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetBalanceFactor</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">GetHeight</span>(root-&gt;left) - <span class="hljs-built_in">GetHeight</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">LRotate</span><span class="hljs-params">(Node* y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">   y</span><br><span class="hljs-comment">  / \</span><br><span class="hljs-comment"> O   x</span><br><span class="hljs-comment">/ \</span><br><span class="hljs-comment">   O   O</span><br><span class="hljs-comment">   */</span><br>Node* x = y-&gt;right;<br>Node* t = x-&gt;left;<br><br>x-&gt;left = y;<br>y-&gt;right = t;<br><br>x-&gt;Height = <span class="hljs-built_in">GetHeight</span>(x);<br>y-&gt;Height = <span class="hljs-built_in">GetHeight</span>(y);<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">RRotate</span><span class="hljs-params">(Node* y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 树结构示意图：</span><br><span class="hljs-comment">   y</span><br><span class="hljs-comment">  / \</span><br><span class="hljs-comment"> x   O</span><br><span class="hljs-comment">/ \</span><br><span class="hljs-comment">   O   O</span><br><span class="hljs-comment">   */</span><br>Node* x = y-&gt;left;<br>Node* t = x-&gt;right;<br><br>x-&gt;right = y;<br>y-&gt;left = t;<br><br>x-&gt;Height = <span class="hljs-built_in">GetHeight</span>(x);<br>y-&gt;Height = <span class="hljs-built_in">GetHeight</span>(y);<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function">Node* <span class="hljs-title">Insert</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">newNode</span>(key);<br><span class="hljs-keyword">if</span> (key &lt; root-&gt;key)<br>root-&gt;left = <span class="hljs-built_in">Insert</span>(root-&gt;left, key);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key)<br>root-&gt;right = <span class="hljs-built_in">Insert</span>(root-&gt;right, key);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> root;<br><br>root-&gt;Height = <span class="hljs-built_in">GetHeight</span>(root);<br><br><span class="hljs-type">int</span> bf = <span class="hljs-built_in">GetBalanceFactor</span>(root);<br><span class="hljs-comment">// L</span><br><span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// L</span><br><span class="hljs-keyword">if</span> (key &lt; root-&gt;left-&gt;key)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">RRotate</span>(root); <span class="hljs-comment">// 左左 右</span><br><span class="hljs-comment">// R</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;left-&gt;key)<br>&#123;<br>root-&gt;left = <span class="hljs-built_in">LRotate</span>(root-&gt;left);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">RRotate</span>(root);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (key &gt; root-&gt;right-&gt;key)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">LRotate</span>(root);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;right-&gt;key)<br>&#123;<br>root-&gt;right = <span class="hljs-built_in">RRotate</span>(root-&gt;right);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">LRotate</span>(root);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BST树"><a href="#BST树" class="headerlink" title="BST树"></a>BST树</h1><p>其中insert函数未使用引用 delete函数使用了引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left, * right;<br><span class="hljs-type">int</span> data;<br>&#125;Node;<br><br><span class="hljs-function">Node* <span class="hljs-title">searchBST</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> x, Node* f)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!root)<span class="hljs-keyword">return</span> f;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data == x)<span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data &gt; x)<span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, x, root);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, x, root);<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">insertBST</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>Node* p = <span class="hljs-built_in">searchBST</span>(root, x, <span class="hljs-literal">NULL</span>);<br>Node* s = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>s-&gt;data = x;<br>s-&gt;right = s-&gt;left = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (!p)<span class="hljs-keyword">return</span> s;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;data &gt; x)p-&gt;left = s;<br><span class="hljs-keyword">else</span> p-&gt;right = s;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Node*&amp; T)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!T-&gt;left &amp;&amp; !T-&gt;right)<br>&#123;<br>T = <span class="hljs-literal">NULL</span>; <br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (T-&gt;left)<br>&#123;<br>Node* s = T-&gt;left;<br>Node* q = T;<br><span class="hljs-keyword">while</span> (s-&gt;right)<br>&#123;<br>q = s;<br>s = s-&gt;right;<br>&#125;<br>T-&gt;data = s-&gt;data;<br><span class="hljs-keyword">if</span> (T != q)q-&gt;right = s-&gt;left;<br><span class="hljs-keyword">else</span> T-&gt;left = s-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Node* s = T-&gt;right;<br>Node* q = T;<br><span class="hljs-keyword">while</span> (s-&gt;left)<br>&#123;<br>q = s;<br>s = s-&gt;left;<br>&#125;<br>T-&gt;data = s-&gt;data;<br><span class="hljs-keyword">if</span> (T != q)q-&gt;left = s-&gt;right;<br><span class="hljs-keyword">else</span> T-&gt;right = s-&gt;right;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeBST</span><span class="hljs-params">(Node*&amp; T, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!T)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (T-&gt;data == e)<br>&#123;<br><span class="hljs-built_in">Delete</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data &gt; e)<br><span class="hljs-built_in">removeBST</span>(T-&gt;left, e);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">removeBST</span>(T-&gt;right, e);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二叉树</title>
    <link href="/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/08/07/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><a href="https://www.luogu.com.cn/problem/P5076">二叉搜索树</a></h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> cont = <span class="hljs-number">0</span>; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span><br>&#123;<br><span class="hljs-type">int</span> ls, rs, val, cnt, siz;<br>&#125;tree[<span class="hljs-number">1000010</span>];<br><br><span class="hljs-type">int</span> n,q,val;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[x].siz++;<span class="hljs-comment">// 首先，插入的这个结点的siz++</span><br><span class="hljs-comment">// 如果已经有这个结点，就cnt++，因为搜索树中不能有重复结点</span><br><span class="hljs-keyword">if</span> (val == tree[x].val)<br>&#123;<br>tree[x].cnt++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (val &lt; tree[x].val)<br>&#123;<br>        <span class="hljs-comment">// 到最左边</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">// 开辟新结点并赋值</span><br>cont++;<br>tree[cont].val = val;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[x].ls = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].ls, val);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>tree[x].rs = cont;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">add</span>(tree[x].rs, val);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 找前驱</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryfr</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果小于当前结点</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt;= val)<br>&#123;<br>        <span class="hljs-comment">// 找到最左边了，直接返回ans</span><br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//不然就继续找</span><br><span class="hljs-built_in">queryfr</span>(tree[x].ls, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &gt; val ? ans : tree[x].val;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">queryfr</span>(tree[x].rs, val, tree[x].val);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">// 找后继</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryne</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> ans)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (tree[x].val &lt;= val)<br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].rs == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].rs, val, ans);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (tree[x].ls == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> tree[x].val &lt; ans ? tree[x].val : ans;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">queryne</span>(tree[x].ls, val, tree[x].val);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 找val的排位</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 没找到就返回0，当找到最后还没有找到的时候，就会走到ls或rs==0，赋值给x，就会从这里退出</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 找到了就返回，当前这个结点的左子树的长度</span><br><span class="hljs-keyword">if</span> (tree[x].val == val)<br><span class="hljs-keyword">return</span> tree[tree[x].ls].siz;<br>    <span class="hljs-comment">// 如果小于当前结点的值，往左</span><br><span class="hljs-keyword">if</span> (tree[x].val &gt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].ls, val);<br>    <span class="hljs-comment">// 往右的时候要先减掉左子树和自身的值</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertval</span>(tree[x].rs, val) + tree[tree[x].ls].siz + tree[x].cnt;<br>&#125;<br><span class="hljs-comment">// 找排位为rk的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quertrk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> rk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// rk索引越界</span><br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> INF;<br><span class="hljs-comment">// 左子树大于rk，说明在左子树里面找</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz &gt;= rk)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].ls, rk);<br>    <span class="hljs-comment">// 左子树+cnt大于rk，说明就是当前的val</span><br><span class="hljs-keyword">if</span> (tree[tree[x].ls].siz + tree[x].cnt &gt;= rk)<br><span class="hljs-keyword">return</span> tree[x].val;<br>    <span class="hljs-comment">// 否则在右子树，要先减掉左子树和cnt</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">quertrk</span>(tree[x].rs, rk - tree[tree[x].ls].siz - tree[x].cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br>cin &gt;&gt; q &gt;&gt; val;<br><span class="hljs-keyword">switch</span> (q)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertval</span>(<span class="hljs-number">1</span>, val) + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-built_in">quertrk</span>(<span class="hljs-number">1</span>, val) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout&lt;&lt;<span class="hljs-built_in">queryfr</span>(<span class="hljs-number">1</span>, val, -INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>cout &lt;&lt; <span class="hljs-built_in">queryne</span>(<span class="hljs-number">1</span>, val, INF) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-comment">//特判根节点</span><br><span class="hljs-keyword">if</span> (cont == <span class="hljs-number">0</span>)<br>&#123;<br>cont++;<br>tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span>;<br>tree[cont].val = val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, val);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="这个小伙居然还用python写了一遍"><a href="#这个小伙居然还用python写了一遍" class="headerlink" title="这个小伙居然还用python写了一遍"></a><del>这个小伙居然还用python写了一遍</del></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python">INF = <span class="hljs-number">0x7fffffff</span><br>cont = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,val=<span class="hljs-number">0</span>,siz=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,ls=<span class="hljs-number">0</span>,rs=<span class="hljs-number">0</span></span>):<br>        self.val = val<br>        self.siz = siz<br>        self.cnt = cnt<br>        self.ls = ls<br>        self.rs = rs<br><br><br><span class="hljs-comment"># 神奇的方法</span><br>tree = [Node() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,v</span>):<br>    <span class="hljs-keyword">global</span> cont,tree<br>    tree[x].siz += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> tree[x].val == v:<br>        tree[x].cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> tree[x].val &gt; v:<br>        <span class="hljs-keyword">if</span> tree[x].ls != <span class="hljs-number">0</span>:<br>            add(tree[x].ls,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].ls = cont<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs != <span class="hljs-number">0</span>:<br>            add(tree[x].rs,v)<br>        <span class="hljs-keyword">else</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].val = v<br>            tree[cont].siz = tree[cont].cnt = <span class="hljs-number">1</span><br>            tree[x].rs = cont<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryfr</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &gt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].ls,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &lt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x].rs,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryfr(tree[x],val,ans)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryne</span>(<span class="hljs-params">x,val,ans</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> tree[x].val &lt;= val:<br>        <span class="hljs-keyword">if</span> tree[x].rs == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].rs,val,ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> tree[x].ls == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> tree[x].val &gt; val:<br>                <span class="hljs-keyword">return</span> tree[x].val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> ans<br>        <span class="hljs-comment"># 这里有点多余</span><br>        <span class="hljs-keyword">if</span> tree[x].cnt != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls,val,tree[x].val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> queryne(tree[x].ls, val,ans)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryrk</span>(<span class="hljs-params">x,rk</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> INF<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz &gt;= rk:<br>        <span class="hljs-keyword">return</span> queryrk(tree[x].ls,rk)<br>    <span class="hljs-keyword">if</span> tree[tree[x].ls].siz + tree[x].cnt &gt;= rk:<br>        <span class="hljs-keyword">return</span> tree[x].val<br>    <span class="hljs-keyword">return</span> queryrk(tree[x].rs,rk - tree[tree[x].ls].siz-tree[x].cnt)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queryval</span>(<span class="hljs-params">x,val</span>):<br>    <span class="hljs-keyword">global</span> tree<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> val == tree[x].val:<br>        <span class="hljs-keyword">return</span> tree[tree[x].ls].siz<br>    <span class="hljs-keyword">if</span> val &lt; tree[x].val:<br>        <span class="hljs-keyword">return</span> queryval(tree[x].ls,val)<br>    <span class="hljs-keyword">return</span> queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt<br><br><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    q,v = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    <span class="hljs-keyword">if</span> q == <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">if</span> cont == <span class="hljs-number">0</span>:<br>            cont += <span class="hljs-number">1</span><br>            tree[cont].cnt = tree[cont].siz = <span class="hljs-number">1</span><br>            tree[cont].val = v<br>        <span class="hljs-keyword">else</span>:<br>            add(<span class="hljs-number">1</span>,v)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(queryval(<span class="hljs-number">1</span>,v)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(queryrk(<span class="hljs-number">1</span>,v))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(queryfr(<span class="hljs-number">1</span>,v,-INF))<br>    <span class="hljs-keyword">elif</span> q == <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(queryne(<span class="hljs-number">1</span>,v,INF))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tree</tag>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex学习</title>
    <link href="/2023/08/02/latex%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/latex%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li><p>首先\documentclass[UTF8]{ctexart}</p><p>….(宏包)</p><p>\begin{document}</p><p>……</p><p>\end{document}</p></li><li><p>行内要用$$括起来 行间要用$$$$括起来</p></li><li><p>公式对齐 不同的环境语法不同 eqnarray是&amp;&#x3D;&amp;；align是&amp;&#x3D;</p></li><li><p>分段函数  cases环境  使用&amp; 对齐  \\换行</p></li><li><p>矩阵 array begin后面加{ccc}表示格式  需要$$$$和自己加括号</p></li><li><p>要表示带省略号的矩阵 用pmatrix环境</p></li><li><p>表格 数字表格即矩阵加|，带汉字的要使用tabular环境。表格的横线为\hline</p></li><li><p>插图 \includegraphics[scale&#x3D;<em>] [width&#x3D;</em>][height&#x3D;*]{.png}</p><p>或使用\figure环境</p><p>\begin{figure}[H]</p><p> \centering</p><p> % Requires \usepackage{graphicx}</p><p> \includegraphics[width&#x3D;12pt]{.png}\</p><p> \caption{图1}</p><p>\end{figure}</p></li></ul><h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><ul><li>\textbf{}加粗</li><li>\textit{}斜体</li><li>underline 下划线</li></ul><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125; //正文<br><br><span class="hljs-keyword">\part</span>&#123;A&#125; // 该部分标题为A 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\chapter</span>&#123;B&#125; //该章节标题为B 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\section</span>&#123;C&#125; //该章节标题为C 并且开始一个部分 直到下一个部分<br><br><span class="hljs-keyword">\subsection</span>&#123;D&#125; //创建子章节<br><br><span class="hljs-keyword">\subsubsection</span> //.<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125; //引入宏包<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;figure&#125;<br><span class="hljs-keyword">\centering</span> // 居中<br><span class="hljs-keyword">\includegraphics</span>[width=0.5<span class="hljs-keyword">\textwidth</span>]&#123;head&#125;<br><span class="hljs-keyword">\caption</span>&#123;...&#125; //图片标题<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>//无序列表环境为itemize<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\item</span> 列表项1<br><span class="hljs-keyword">\item</span> 列表项2<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>// 行内公式<br>AAAAA <span class="hljs-built_in">$</span>E = mc<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span><br>// 行间公式<br>// 使用equation环境<br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br>// 或者用<span class="hljs-keyword">\[</span> 和 <span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\[</span><br>E = mc<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h2 id="表-格"><a href="#表-格" class="headerlink" title="表 格"></a>表 格</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;table&#125;// 需要标题和居中的时候要把表格放在table环境中<br><br><span class="hljs-keyword">\center</span><br><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c c c&#125;  // c | c c代表表格共三列 每列内容都居中对齐 用l表示左对齐 r右 添加竖线代表竖边框 水平边框通过<span class="hljs-keyword">\hline</span>添加 每格之间用<span class="hljs-built_in">&amp;</span>隔开 每行之间用<span class="hljs-keyword">\\</span>隔开<br>// 把c改成p&#123;2cm&#125;自定义列宽<br><span class="hljs-keyword">\hline</span><br>单元格1 <span class="hljs-built_in">&amp;</span> 单元格2 <span class="hljs-built_in">&amp;</span> 单元格3 <span class="hljs-keyword">\\</span>      <br><span class="hljs-keyword">\hline</span> //双横线<br><span class="hljs-keyword">\hline</span><br>单元格4 <span class="hljs-built_in">&amp;</span> 单元格5 <span class="hljs-built_in">&amp;</span> 单元格6 <span class="hljs-keyword">\\</span><br>单元格7 <span class="hljs-built_in">&amp;</span> 单元格8 <span class="hljs-built_in">&amp;</span> 单元格9 <br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><br><span class="hljs-keyword">\caption</span>&#123;title&#125;<br><br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab学习</title>
    <link href="/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/02/matlab%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>部分表</li></ul><table><thead><tr><th><strong>help</strong></th><th>帮助查询</th></tr></thead><tbody><tr><td><strong>clc</strong></td><td>删除命令窗口的内容（已使用过的命令）</td></tr><tr><td><strong>clear</strong></td><td>删除内存中的变量（数据）</td></tr><tr><td><strong>clf</strong></td><td>删除图形窗口的内容</td></tr><tr><td><strong>who</strong></td><td>列出在MATLAB工作空间中已有的变量</td></tr><tr><td><strong>whos</strong></td><td>列出驻留变量的同时,还给出维数及性质</td></tr><tr><td><strong>home</strong></td><td>光标移到命令窗口的左上角</td></tr><tr><td><strong>↑</strong></td><td>调出刚才使用过的命令</td></tr><tr><td><strong>quit</strong></td><td>退出MATLAB</td></tr></tbody></table><table><thead><tr><th>r</th><th>红色</th><th>-</th><th>实线</th></tr></thead><tbody><tr><td>g</td><td>绿色</td><td>–</td><td>虚线</td></tr><tr><td>b</td><td>蓝色</td><td>:</td><td>点线</td></tr><tr><td>y</td><td>黄色</td><td>-.</td><td>点划线</td></tr><tr><td>m</td><td>洋红色</td><td>o</td><td>圆圈</td></tr><tr><td>c</td><td>青色</td><td>x</td><td>叉号</td></tr><tr><td>w</td><td>白色</td><td>+</td><td>加号</td></tr><tr><td>k</td><td>黑色</td><td>s</td><td>正方形</td></tr><tr><td>*</td><td>星号</td><td>d</td><td>菱形</td></tr><tr><td>v</td><td>向下三角</td><td>^</td><td>向上三角</td></tr><tr><td>.</td><td>点号</td><td>h</td><td>六角形</td></tr></tbody></table><ul><li><p>首先注意和数字运算的时候运算符要加点</p></li><li><p>axis([])设置坐标轴范围</p></li><li><p>grid on 显示网格线 title显示标题 xlabel标记x轴 legend添加图例</p></li></ul><h2 id="plot-x-y-’color-style-marker’-绘制图像"><a href="#plot-x-y-’color-style-marker’-绘制图像" class="headerlink" title="plot(x,y,’color-style-marker’)绘制图像"></a>plot(x,y,’color-style-marker’)绘制图像</h2><ul><li><p>选点：x &#x3D; linspace(0,1,100)  也可以使用x &#x3D; a : step : b</p><p>y1 &#x3D; linspace(0,1,100) 选择对应的点 plot(x,y,’r’) 需要保证是同维的</p><p>也可以使用解析式的方式，先确定x的范围，然后用x表示y即可，但是要注意表示的各个符号是否加点。</p><p>例：y &#x3D; -0,0234 * x + 1.2551 * x .^(2&#x2F;3)   y &#x3D; sin(x) </p></li><li><p>三维图像 plot3 用来绘制一组三维曲线  需要保证是同维的   </p><p> mesh 用来绘制三维曲面的网格线图 先选点 然后 [X,Y] &#x3D; meshgrid(x,y) Z &#x3D;  X.^2+Y.^2 最后mesh(X,Y,Z)\</p></li><li><p>如果想要画圆圈和连线那就是plot(x,a,’o’,x,a)  ‘bo’是蓝色圆圈</p><p> 前一个xa画圆圈（散点）后一个xa画直线</p></li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><p>solve 解线性方程组 使用前要定义变量 syms a b x …</p><p>S &#x3D; solve(方程，变量（默认x)  </p><p>[a,b] &#x3D; solve(90* a + 90^(2&#x2F;3)<em>b&#x3D;&#x3D;23.1,180</em>a+180^(2&#x2F;3)*b &#x3D;&#x3D; 35.8)</p></li></ul><h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><ul><li><p>for i &#x3D; n1:(step):n2</p><p>commands;</p><p>end</p></li><li><p>while …</p></li></ul><p>  commands;</p><p>  end</p><ul><li><p>if…</p><p>elseif…</p><p>else…</p><p>end</p></li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>function [x,y,z] &#x3D; f1(a,b)</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>csape(x,y,’compelete’,[-1,0])</p><p>complete代表通过给定数据点的完全样条函数 </p><p>[-1,0]表示一阶导数的边界</p>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表题解</title>
    <link href="/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/07/31/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><del>超，格式怎么这样了，下次再改</del></p><h1 id="妖梦拼木棒"><a href="#妖梦拼木棒" class="headerlink" title="妖梦拼木棒"></a><a href="https://www.luogu.com.cn/problem/P3799">妖梦拼木棒</a></h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>上道题中，妖梦斩了一地的木棒，现在她想要将木棒拼起来。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？</p><p>答案对 $10^9+7$ 取模。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$。</p><p>第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数代表答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $n \le 5 \times 10^3$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。</li></ul><p>一开始想错了，导致后面也被带偏。必须要两只一样长的木棒，剩下两个只需要和跟另外两个一样长就行了。并不需要相等长度，（想错，导致之后改错）其实也并不需要一开始的两只相等长度，比如7 7 2 +5这样。然后就是简单的组合数学</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">nums</span>(<span class="hljs-number">5001</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>nums[x]++;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">2</span>)<br>&#123;<br>a = nums[i] * (nums[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> == i &amp;&amp; nums[j] &gt;= <span class="hljs-number">2</span>)cnt += a * (nums[j] * (nums[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod) % mod;<br><span class="hljs-keyword">if</span> (j * <span class="hljs-number">2</span> != i &amp;&amp; nums[j] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i - j] &gt;= <span class="hljs-number">1</span>)cnt += a * ((nums[j] * nums[i - j]) % mod) % mod;<br>&#125;<br>cnt %= mod;<br>&#125;<br>&#125;<br>cout &lt;&lt; cnt % mod &lt;&lt; endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="kkksc03考前临时抱佛脚"><a href="#kkksc03考前临时抱佛脚" class="headerlink" title="kkksc03考前临时抱佛脚"></a><a href="https://www.luogu.com.cn/problem/P2392">kkksc03考前临时抱佛脚</a></h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">20<br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><p>本来是贪心+模拟。。但是有几个过不了，大概是情况没考虑全。btw别人想的都是把题目分成尽量平均的两部分啊。（模拟不是下意识就出来了吗，窝好菜</p><p>用dp求尽量平均的两部分，即01背包问题，分到左边和分到右边，状态表示为二维，集合为到j的时候的体积，状态计算为给左大脑和给右大脑，此处视左大脑为背包1，右大脑为0，放到让左边为1&#x2F;2总体积。每道题的时间既是价值，也是体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2000</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>)]<br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>            f[j][k] = f[j - <span class="hljs-number">1</span>][k]<br>            <span class="hljs-keyword">if</span> k &gt;= nums[j]:<br>                f[j][k] = <span class="hljs-built_in">max</span>(f[j][k],f[j - <span class="hljs-number">1</span>][k - nums[j]] + nums[j])<br>            t = <span class="hljs-built_in">max</span>(t,f[j][k])<br><br>    ans += <span class="hljs-built_in">max</span>(t, m-t)<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p>一维优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [<span class="hljs-number">0</span>] * <span class="hljs-number">100010</span><br>ans = <span class="hljs-number">0</span><br>lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">sum</span>(nums)<br>    n = <span class="hljs-built_in">len</span>(nums)<br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m//<span class="hljs-number">2</span>, nums[j]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[k] = <span class="hljs-built_in">max</span>(f[k],f[k - nums[j]] + nums[j])<br><br><br>    ans += m - f[m//<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>        f[i] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><h1 id="COCI2008-2009-2-PERKET"><a href="#COCI2008-2009-2-PERKET" class="headerlink" title="[COCI2008-2009#2] PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">[COCI2008-2009#2] PERKET</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。</p><p>众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。</p><p>另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$，表示可供选用的食材种类数。</p><p>接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示可能的总酸度和总苦度的最小绝对差。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>本题满分 $70$ 分。</li><li>题目译自 <a href="https://hsin.hr/coci/archive/2008_2009/">COCI2008-2009</a> <a href="https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf">CONTEST #2</a> PERKET，译者 @<a href="https://www.luogu.com.cn/user/115711">mnesia</a>。</li></ul><p>简单dfs 选或不选###的思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>nums = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>minn = <span class="hljs-number">0x7fffffff</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u,sor,bit</span>):<br>    <span class="hljs-keyword">global</span> minn<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">if</span> sor == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> bit == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            minn = <span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">abs</span>(sor - bit))<br>            <span class="hljs-keyword">return</span><br><br>    dfs(u + <span class="hljs-number">1</span>,sor,bit)<br>    dfs(u + <span class="hljs-number">1</span>,sor * nums[u][<span class="hljs-number">0</span>], bit + nums[u][<span class="hljs-number">1</span>])<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>   nums[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><br>dfs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(minn)<br></code></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#NOIP2016-普及组-海港-P2058-NOIP2016-普及组-海港-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [NOIP2016 普及组 海港]([P2058 NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [NOIP2016 普及组 海港]([P2058 <a href="https://www.luogu.com.cn/problem/P2058">NOIP2016 普及组] 海港 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T3</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。</p><p>小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。</p><p>小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $&#x3D;86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。</p><p>形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400&lt;t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。</p><p>接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。</p><p>保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。</p><p>保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。</p><p>其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">86401 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">86402 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>3<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>【样例解释 1】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；</p><p>第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 &#x3D; 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；</p><p>第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1&#x3D;7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。</p><p>【样例解释 2】</p><p>第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。</p><p>第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2&#x3D;6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。</p><p>第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2&#x3D;4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。</p><p>第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1&#x3D;5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。</p><p>【数据范围】</p><ul><li>对于 $10%$ 的测试点，$n&#x3D;1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。</li><li>对于 $20%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。</li><li>对于 $40%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。</li><li>对于 $70%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。</li><li>对于 $100%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主要是python的语法 ship.num = lis[2:]把2和后面的全都赋到num里面，然后就是python的语法，双端队列deque的使用方法，支持[]访问，直接用shiparr[Ship()]*100000，会导致错误，应该是类似于地址出错（所有的数组里面都是同一个值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    time = <span class="hljs-number">0</span><br>    num = []<br>    numpass = <span class="hljs-number">0</span><br><br><br>q = deque()<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>peo = [<span class="hljs-number">0</span>] * <span class="hljs-number">1000000</span><br>lis = []<br>shiparr = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>    ship = Ship()<br>    ship.time = lis[<span class="hljs-number">0</span>]<br>    ship.numpass = lis[<span class="hljs-number">1</span>]<br>    ship.num = lis[<span class="hljs-number">2</span>:]<br>    shiparr.append(ship)<br><br><br>country = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    ship = shiparr[j]<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> ship.time - q[<span class="hljs-number">0</span>].time &lt; <span class="hljs-number">86400</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> q[<span class="hljs-number">0</span>].num:<br>            peo[x] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>                country -= <span class="hljs-number">1</span><br>        q.popleft()<br>        i += <span class="hljs-number">1</span><br>    q.append(ship)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ship.num:<br>        <span class="hljs-keyword">if</span> peo[x] == <span class="hljs-number">0</span>:<br>            country += <span class="hljs-number">1</span><br>        peo[x] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(country)<br><br></code></pre></td></tr></table></figure><h1 id="括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#括号序列-P1241-括号序列-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="# [括号序列](P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a># [括号序列](<a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p><ol><li>空串是「平衡括号序列」</li><li>若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」</li><li>若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。</li></ol><p>例如，下面的字符串都是平衡括号序列：</p><p><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></p><p>而以下几个则不是：</p><p><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></p><p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：</p><ol><li>从左到右扫描整个字符串。</li><li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li></ol><p>配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 $s$。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([()<br></code></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">([)</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">()[]()<br></code></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $s$ 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 主要是题目，2.的意思是从遇到第一个右括号开始向左寻找第一个未匹配的左括号（其实根本不需要栈）。只需要在找到的地方做个标记表示已匹配即可。最后，输出的时候未匹配的就直接输出同类的完整括号，匹配的就正常输出。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt;stleft;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">char</span> ch;<br>string str;<br>cin &gt;&gt; str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-built_in">size</span>(); j++)<br>&#123;<br>ch = str[j];<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br>&#123;<br>a[i] = a[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; a[i] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;(&#x27;</span> || str[i] == <span class="hljs-string">&#x27;)&#x27;</span>))cout &lt;&lt; <span class="hljs-string">&quot;()&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;[&#x27;</span>||str[i] == <span class="hljs-string">&#x27;]&#x27;</span>)) cout &lt;&lt; <span class="hljs-string">&quot;[]&quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; str[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Our Game!</title>
    <link href="/2023/07/27/Our-Game/"/>
    <url>/2023/07/27/Our-Game/</url>
    
    <content type="html"><![CDATA[<h1 id="我们的游戏做完啦！"><a href="#我们的游戏做完啦！" class="headerlink" title="我们的游戏做完啦！"></a>我们的游戏做完啦！</h1><p>&emsp;好激动，四周的时间过的好快，好像昨天还在讨论游戏的原型设计。现在居然已经完成了所有的工作。感谢tllwtg和wegret的付出，<del>我们三个真强</del>（哈哈哈）。<br>希望zlgg和xyjj不要嫌我菜。</p><p><a href="https://github.com/tLLWtG/Capoo-Survival/releases">这里是我们的游戏</a>，点点star（可怜）</p><p>没错 就是开放世界冒险游戏（没有虚假宣传。。。开放、世界、冒险都有）</p><p>做游戏的过程还是很开心的（可能是给我的活太少了），感觉自己没做什么，还好通过我精密的计算，最后障碍物终于没有重叠了，不然就没脸见人了。<br>好怀念教室只剩下我们在讨论和实现，在群里商量分工，一件件地完成TODO。本来是很讨厌组队的，<br>但是这种组队的感觉真的好棒！跟某些课程全部都是摆子的组队感觉完全不一样哇）</p><p>第一次上去汇报手都在发抖捏，但是后面感觉还行，对！根本就没人会听，啊，你说我吗？我也不听别人讲😀（wow，居然能插入表情嘛）。一开始做ppt只会白底黑字，<br>后面加了模板，是好看一点wo。</p><p>啊!台风了，最后一次汇报没有了，本来还想拍个照片然后一起去恰个饭的，不知道下次还有没有机会，呜呜。</p><p>贴一些图片（才不是太久没写说说，写不出来东西了呢</p><p>靠 截图审美好差</p><p>部分代码截图和游戏使用图片</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog1-16907768245555.png" alt="部分代码截图和游戏使用图片"></p><p>汇报ppt</p><p><img src="/images/$%7Bfiilename%7D/Myfirstblog2-16907767706092.png" alt="汇报ppt"></p><p>还没写完，但是不想写了，嘿嘿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法</title>
    <link href="/2023/07/23/python%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/23/python%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python语法注意事项"><a href="#python语法注意事项" class="headerlink" title="python语法注意事项"></a>python语法注意事项</h1><p><del>啊，受不了了，写了几个题不是运错就是编错，还有一堆奇奇怪怪的报错，痛苦.jpg。</del><br>已经遇见未来不短的时间内会不断报错并且看不懂然后写在这里了，希望这篇可以早日停更。</p><ul><li><p>n &#x3D; int(input())</p></li><li><p>控制不住if后面加()，哭，剁手</p></li><li><p>xmuoj不支持类型注解，呜呜</p></li><li><p>没有while(n–)的操作了，用while会忘记–，死循环了，好蠢</p></li><li><p>range的范围</p></li><li><p>读入二维列表 (老是忘记lis的append，想半天)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lis = <span class="hljs-selector-attr">[]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    d = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(int,<span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>()))<br>    lis<span class="hljs-selector-class">.append</span>()<br></code></pre></td></tr></table></figure></li><li><p>浮点数确定精度输出 print(“%.1f” % n) 注意是双引号并且没有逗号</p></li><li><p>dx &#x3D; [1,0,-1,0] <del>这里是今晚最佳</del> 加了个list怎么找也找不出来，list dx[]-&gt;笑死</p></li><li><p>全排列 选哪个？ 标记选过的不再选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">sol,num,on_path</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sol) == <span class="hljs-built_in">len</span>(num):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(sol[i], <span class="hljs-string">&quot;&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> on_path[i] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                on_path[i] = <span class="hljs-number">1</span><br>                permute(sol+[num[i]],num,on_path)<br>                on_path[i] = <span class="hljs-number">0</span><br>                <br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>sol = []<br>num = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)]<br>on_path = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>permute(sol,num,onpath]<br></code></pre></td></tr></table></figure></li><li><p>字典的使用方法  记得一定要先判断是否存在 <del>呜呜，明明之前才记过，写的时候又忘记了，泰蠢辣</del></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">st</span> = input()<br><br>d = dict()<br>for <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">st</span>:<br>    if <span class="hljs-number">ch</span> <span class="hljs-keyword">in</span> d:<br>        d[<span class="hljs-number">ch</span>] += <span class="hljs-number">1</span><br><span class="hljs-symbol">    else:</span><br>        d[<span class="hljs-number">ch</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>上面的题是用来求只出现一次的字符的 难过 在c++知道用count 在python就变蠢力</p></li><li><p>python线性筛 芜湖~</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">N</span> = <span class="hljs-number">100010</span><br><span class="hljs-attribute">st</span> =<span class="hljs-meta"> [False for _ in range(N)]</span><br><span class="hljs-attribute">prime</span> =<span class="hljs-meta"> [0 for _ in range(N)]</span><br><br><span class="hljs-attribute">def</span> get_prime(n):<br>    <span class="hljs-attribute">cnt</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">2</span>,n + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">if</span> not st[i]:<br>            <span class="hljs-attribute">prime</span>[cnt] = i<br>            <span class="hljs-attribute">cnt</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> prime[j] &lt; n // i:<br>        <span class="hljs-attribute">st</span>[prime[j] * i] = True<br>        <span class="hljs-attribute">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">break</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>range是左开右闭</p></li><li><p>我超 在函数里面用全局变量的时候要加global </p></li><li><p>python归并</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = int(input(n))<br><span class="hljs-attribute">nums</span> = list(map(int,input()))<br><span class="hljs-attribute">temp</span> =<span class="hljs-meta"> [0 for _ in range(n)]</span><br><br><span class="hljs-attribute">merge_sort</span>(l, r):<br>    <span class="hljs-attribute">if</span> l &gt;= r:<br>        <span class="hljs-attribute">return</span> <br>    <span class="hljs-attribute">mid</span> = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-attribute">merge_sort</span>(l, mid)<br>    <span class="hljs-attribute">merge_sort</span>(mid + <span class="hljs-number">1</span>, r)<br>    <span class="hljs-attribute">i</span>, j, k = l, mid + <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-attribute">if</span> nums[i] &lt;= nums[j]:<br>            <span class="hljs-attribute">temp</span>[k] = nums[i]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">temp</span>[k] = nums[j]<br>            <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>            <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> i &lt;= mid:<br>        <span class="hljs-attribute">temp</span>[k] = nums[i]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">while</span> j &lt;= r:<br>        <span class="hljs-attribute">temp</span>[k] = nums[j]<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-attribute">j</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in range(l, r + <span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">nums</span>[i] = temp[j]<br>        <span class="hljs-attribute">j</span> += <span class="hljs-number">1</span><br>        <br>        <br><span class="hljs-attribute">merge_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>)# n-<span class="hljs-number">1</span>!!<br></code></pre></td></tr></table></figure></li><li><p>python手动增加递归的层数<br>import sys<br>sys.setrecursionlimit(5000)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训题目整理</title>
    <link href="/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
    <url>/2023/07/23/%E5%AE%9E%E8%AE%AD%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.10">熄灯问题</a></h1><p>枚举&#x2F;二进制优化</p><p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。</p><p>在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。</p><p>请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。</p><ul><li>输入<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p><ul><li>输出<br>5行组成，每一行包括6个数字（0或1）。</li></ul><p>相邻两个数字之间用单个空格隔开。</p><p>其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p><ul><li>输入样例</li></ul><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0</p><ul><li>输出样例</li></ul><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>注意：PUZZLE行结尾没有空格，数字行最后有一个空格。   </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/* 每次碰一个开关就会使他上下左右（还有自己！）的灯都改变状态，灯只有开关两种状态，那么要使灯全部关掉，</span><br><span class="hljs-comment">其实每个灯最多只需要按一次。</span><br><span class="hljs-comment">  如何枚举？从第二排开始，只关注当前行和上一行的状态，用当前行把上一行的灯都关掉，而不考虑其他变</span><br><span class="hljs-comment">化，这样到最后一行，如果恰好全部熄灭，就是结果。能够影响结果的，就是第一行的状态，枚举第一行。</span><br><span class="hljs-comment">  第一行的状态怎么表示？由于只有开关（1/0）两种状态，可以用二进制数来表示，之后再按顺序输入到矩阵中</span><br><span class="hljs-comment">*/</span><br><br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>bool <span class="hljs-symbol">ButtomStatu</span>(const int m, int ori[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>], int res[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])<br>&#123;<br>//枚举第一行的所有按键情况 利用二进制数来枚举 由于有<span class="hljs-number">6</span>列 情况为<span class="hljs-number">2</span>^<span class="hljs-number">6</span>种 得到第一行的按键情况<br>int temp = m;<br><br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>res[<span class="hljs-number">0</span>][i] = temp <span class="hljs-comment">% 2;</span><br>temp /= <span class="hljs-number">2</span>;<br>&#125;<br> <br>//把上面的情况按一遍 记得按自己所在的位置<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>if (res[<span class="hljs-number">0</span>][i])<br>&#123;<br>ori[<span class="hljs-number">0</span>][i]= (ori[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[<span class="hljs-number">1</span>][i] = (ori[<span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] = (ori[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>&#125;<br>&#125;<br><br>//从第一行下面的每一行枚举 （核心是 第一行决定了下面每一行的情况 所以只需要枚举第一行<br>for (int i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>if (ori[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">0</span>)<br>&#123;<br>if (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<br>if (i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">5</span>)ori[i + <span class="hljs-number">1</span>][j] = (ori[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j + <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span>)ori[i][j + <span class="hljs-number">1</span>] = (ori[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>if (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)ori[i][j - <span class="hljs-number">1</span>] = (ori[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>ori[i][j]= (ori[i][j] + <span class="hljs-number">1</span>) <span class="hljs-comment">% 2;</span><br>res[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>//如果灯全部关完 则为true<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>if (ori[i][j] != <span class="hljs-number">0</span>)return false;<br><br>return true;<br>&#125;<br><br><br>int main()<br>&#123;<br>int n;<br>cin &gt;&gt; n;<br>int orilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int resultlight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>int constorilight[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br>for(int k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br>for (int row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">5</span>; row++)<br>&#123;<br>for (int col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">6</span>; col++)<br>&#123;<br>cin &gt;&gt; constorilight[row][col];<br>&#125;<br>&#125;<br>//枚举<span class="hljs-number">64</span>种情况<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>&#123;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>&#123;<br>orilight[i][j] = constorilight[i][j];<br>resultlight[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>//如果得到结果就输出<br>if (<span class="hljs-symbol">ButtomStatu</span>(i, orilight, resultlight))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;PUZZLE #&quot;</span> &lt;&lt; k &lt;&lt; endl;<br>for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++)<br>cout &lt;&lt; resultlight[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a><a href="http://www.xmuoj.com/contest/193/problem/1.5">假币问题</a></h1><p>枚举</p><p>林克有12枚银币。其中有11枚真币和1枚假币。假币看起来和真币没有区别，但是重量不同。但林克不知道假币比真币轻还是重。</p><p>于是他向他朋友约珥借了一架天平，用这架天平称了这些币三次。</p><p>如果用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。</p><p>经过精心的设计，聪明的林克根据这三次称量结果找出假币，并且能够确定假币是轻是重。</p><p>如果给你林克的称量数据，你也可以找出假币并且确定假币是轻是重吗？（林克提供的称量数据保证一定能找出假币）。</p><ul><li>输入</li></ul><p>第一行有一个数字n，表示有n组测试用例。</p><p>对于每组测试用例：</p><p>输入有三行，每行表示一次称量的结果。林克事先将银币标号为A-L。</p><p>每次称量的结果用三个以空格隔开的字符串表示：</p><p>天平左边放置的硬币  天平右边放置的硬币  平衡状态。</p><p>其中平衡状态用’’up’’, ‘’down’’, 或 ‘’even’’表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p><ul><li>输出</li></ul><p>输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)</p><ul><li>输入样例 1</li></ul><p>1<br>ABCD EFGH even<br>ABCI EFJK up<br>ABIJ EFGH even  </p><ul><li>输出样例 1</li></ul><p>K is the counterfeit coin and it is light. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 枚举十二枚硬币和轻重共24种状态，先设假币为轻，那么一定在上升的一边，依次枚举十二枚硬币是否在</span><br><span class="hljs-comment">上升的一边，如果不是，说明为真币或者假币不为轻，那么返回false。否则遍历三次称重，最后返回true，说明</span><br><span class="hljs-comment">这个就是假币并且为轻。</span><br><span class="hljs-comment">优化：不需要分别写轻，重的函数，只需要传一个参数表示状态，当判断重时把左右交换，就与判断轻的代码一样</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>vector&lt;string&gt;<span class="hljs-built_in">lef</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">rig</span>(<span class="hljs-number">3</span>);<br>vector&lt;string&gt;<span class="hljs-built_in">zt</span>(<span class="hljs-number">3</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> iCoin,<span class="hljs-type">bool</span> is_light)</span></span><br><span class="hljs-function"></span>&#123;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>string l = lef[i];<br>string r = rig[i];<br>string z = zt[i];<br><span class="hljs-keyword">if</span> (!is_light)<br><span class="hljs-built_in">swap</span>(l, r);<br><span class="hljs-keyword">switch</span> (zt[i][<span class="hljs-number">0</span>])<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)!=string::npos||r.<span class="hljs-built_in">find</span>(iCoin)!=string::npos)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//说明在平衡的地方找到了  肯定是真币</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//现在枚举的是轻的 那么假币一定在上升的一方 </span><br><span class="hljs-comment">//右边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//左边没找到那就肯定是真币</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">find</span>(iCoin)==string::npos)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> cmp[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cin &gt;&gt; lef[i]&gt;&gt;rig[i]&gt;&gt; zt[i];<br>&#125;<br><br><span class="hljs-comment">//枚举十二枚硬币</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> iCoin = <span class="hljs-string">&#x27;A&#x27;</span>; iCoin &lt;= <span class="hljs-string">&#x27;L&#x27;</span>; iCoin++) <br>&#123;<br><span class="hljs-comment">//枚举假币为轻的情况</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">true</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is light. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iCoin,<span class="hljs-literal">false</span>))<br>&#123;<br>cout &lt;&lt; iCoin &lt;&lt; <span class="hljs-string">&quot; is the counterfeit coin and it is heavy. &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>lef.<span class="hljs-built_in">clear</span>(), rig.<span class="hljs-built_in">clear</span>(), zt.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拨钟问题"><a href="#拨钟问题" class="headerlink" title="拨钟问题"></a><a href="http://www.xmuoj.com/problem/GW102">拨钟问题</a></h1><p>子集型回溯</p><p>有9个时钟，排成一个3*3的矩阵。</p><p>(图 1)<del>明显显示不出来嘛！</del>  </p><p>现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。</p><p>移动    影响的时钟</p><p> 1         ABDE<br> 2         ABC<br> 3         BCEF<br> 4         ADG<br> 5         BDEFH<br> 6         CFI<br> 7         DEGH<br> 8         GHI<br> 9         EFHI         </p><ul><li>输入</li></ul><p>9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0&#x3D;12点、1&#x3D;3点、2&#x3D;6点、3&#x3D;9点。</p><ul><li>输出</li></ul><p>输出一个最短的时钟指针移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。 相邻两个整数之间用单个空格隔开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*子集型回溯：进入dfs之后首先判断退出条件。之后是选或不选，对于1~9每个拨钟的方法，都可以选择拨或者</span><br><span class="hljs-comment">不拨！！然后是每个数字循环三次（最多只需要拨三次）。</span><br><span class="hljs-comment">判断，k&gt;9的时候判断是否符合，符合判断最短，之前应记录每一步。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;inf = &#123; <span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;ABDE&quot;</span> ,<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-string">&quot;BCEF&quot;</span>,<span class="hljs-string">&quot;ADG&quot;</span>,<span class="hljs-string">&quot;BDEFH&quot;</span>,<span class="hljs-string">&quot;CFI&quot;</span>,<span class="hljs-string">&quot;DEGH&quot;</span>,<span class="hljs-string">&quot;GHI&quot;</span>,<span class="hljs-string">&quot;EFHI&quot;</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ori</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">movevec</span>(<span class="hljs-number">100</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">showvec</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> si = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mi = <span class="hljs-number">50</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;ori)</span><span class="hljs-comment">//检查是否符合条件（全为0</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (ori[i] != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><span class="hljs-comment">//移动的距离</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inf[k].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] = (ori[inf[k][i] - <span class="hljs-string">&#x27;A&#x27;</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">9</span>)<span class="hljs-comment">//相当于循环9次  即枚举9种拨钟方法</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ori) &amp;&amp; si &lt; mi)<span class="hljs-comment">//由于需要最少的次数所以用mi记录（当全为0时）最少次数</span><br>&#123;<br>mi = si;<br>showvec = movevec;<span class="hljs-comment">//记录最少次数的走法 由于是按顺序枚举 所以一定是从小到大的</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br> <span class="hljs-comment">//子集型回溯  可以一个都不选</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<span class="hljs-comment">//先进去9次  这样才可以回溯 只拨第9个不行 从这里退出 拨第8个和第9个 由于move（K） 则可以枚举到1次8 1次9 2次9 3次9 ） 2次8 1次9 2次9 3次9 ）3次8 1次9 2次9 3次9。。。依次类推可以枚举到全部的情况</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<span class="hljs-comment">//每一种方法拨三次</span><br>&#123;<br>movevec[si++] = k;<span class="hljs-comment">//记录拨钟方法和次数</span><br><span class="hljs-built_in">move</span>(k);<span class="hljs-comment">//拨钟</span><br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br>si -= <span class="hljs-number">3</span>;<br><span class="hljs-built_in">move</span>(k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>cin &gt;&gt; ori[i];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;mi ; i++)<br>&#123;<br>cout &lt;&lt; showvec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2的幂次方表示"><a href="#2的幂次方表示" class="headerlink" title="2的幂次方表示"></a><a href="http://www.xmuoj.com/problem/GW104">2的幂次方表示</a></h1><p>递归  <del>呜呜 递归真的好抽象 难过 tllwtg和wegret怎么都说自然就会了</del></p><p><del>题目居然是图片 那就点链接了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 当n=1的时候怎么办？n=2的时候怎么办？n=其他数的时候怎么办？再把次方也递归一下（1次方要特判！！）</span><br><span class="hljs-comment">然后减去这个数，剩下的数再拆分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 1不可划分 直接输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2(0)&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-comment">// 2不可划分</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 其他数 可划分 </span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a * <span class="hljs-number">2</span> &lt;= n)<br>&#123;<br>a *= <span class="hljs-number">2</span>;<br>k++;<br>&#125;<br><span class="hljs-comment">// 分解次方</span><br><span class="hljs-comment">// 这个地方要特判  因为只剩一个2的时候就直接输出了 而不是把k=1再拿去递归</span><br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-built_in">mf</span>(k);<br>cout &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-type">int</span> x = n - a;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;+&quot;</span>;<br><span class="hljs-built_in">mf</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">mf</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直接用python写算了"><a href="#直接用python写算了" class="headerlink" title="直接用python写算了"></a>直接用python写算了</h2><h1 id="算24"><a href="#算24" class="headerlink" title="算24"></a><a href="http://www.xmuoj.com/problem/NQ079">算24</a></h1><p>回溯<br>熟悉了递归和深度优先搜索，小华知道现在是让小鲁综合运用所学知识的时候了，他让小鲁调整一道经典题：算24.</p><p>给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。</p><p>这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。</p><p>比如，对于5，5，5，1，我们知道5 * (5 – 1 &#x2F; 5) &#x3D; 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。</p><p>注意：输入数字的次序可以改变。</p><ul><li><p>输入<br>输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。</p></li><li><p>输出<br>对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;回溯，首先寻找结束条件，当等于24时退出递归，记得用绝对值和浮点数判断。</span><br><span class="hljs-string">然后基本思路时把每种组合的加减乘除都算一遍，如何储存状态？使用一个列表，每次选出两个数，进行四则</span><br><span class="hljs-string">运算，然后把剩余的没算的数也加进shengyu数组里面，递归运算。记得要回溯pop，还要排除b == 0的情况（被除数）。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">lis</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lis) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> math.fabs(lis[<span class="hljs-number">0</span>] - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">1e-6</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br><br>            <span class="hljs-keyword">if</span> i == j:<br>                <span class="hljs-keyword">continue</span><br><br>            a = lis[i]<br>            b = lis[j]<br>            shengyu = []<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lis)):<br>                <span class="hljs-keyword">if</span> k != i <span class="hljs-keyword">and</span> k != j:<br>                    shengyu.append(lis[k])<br>            <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            sum1 = a + b<br>            sub = a - b<br>            mul = a * b<br>            div = a / b<br>            left = [sum1, sub, mul, div]<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> left:<br>                shengyu.append(x)<br>                <span class="hljs-keyword">if</span> cal(shengyu):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                shengyu.pop()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    lis = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">if</span> lis.count(<span class="hljs-number">0</span>) == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">if</span> cal(lis):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;YES&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="求排列的逆序数"><a href="#求排列的逆序数" class="headerlink" title="求排列的逆序数"></a><a href="http://www.xmuoj.com/problem/GW108">求排列的逆序数</a></h1><p>分治 递归</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-string">&quot;&quot;</span>&quot;<br>首先分治的思路分别来求逆序数，只在左半边的，只在右半边的和跨两边的。利用归并排序的模板，当左边<br>的数大于右边的时候，就是逆序数，由于归并排序已经排好了数，所以逆序数的个数为 mid - i + 1，<br>（mid右边的比i小）<br><span class="hljs-string">&quot;&quot;</span>&quot;<br><span class="hljs-keyword">n</span> = int(<span class="hljs-keyword">input</span>())<br>temp = [0 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">n</span>)]<br><span class="hljs-keyword">lis</span> = <span class="hljs-keyword">list</span>(map(int, <span class="hljs-keyword">input</span>().<span class="hljs-keyword">split</span>()))<br><span class="hljs-keyword">ret</span> = 0<br><br>def <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, r):<br>    <span class="hljs-keyword">global</span> <span class="hljs-keyword">ret</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">l</span> &gt;= r:<br>        <span class="hljs-keyword">return</span><br>    mid = (<span class="hljs-keyword">l</span> + r) &gt;&gt; 1<br>    <span class="hljs-keyword">merge</span>(<span class="hljs-keyword">l</span>, mid)<br>    <span class="hljs-keyword">merge</span>(mid + 1, r)<br>    i, j, k = <span class="hljs-keyword">l</span>, mid + 1, 0<br>    <span class="hljs-keyword">while</span> i &lt;= mid and j &lt;= r:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">lis</span>[i] &lt;= <span class="hljs-keyword">lis</span>[j]:<br>            temp[k] = <span class="hljs-keyword">lis</span>[i]<br>            i += 1<br>            k += 1<br>        <span class="hljs-keyword">else</span>:<br>            temp[k] = <span class="hljs-keyword">lis</span>[j]<br>            j += 1<br>            k += 1<br>            <span class="hljs-keyword">ret</span> += mid - i + 1<br>    <span class="hljs-keyword">while</span> i &lt;= mid:<br>        temp[k] = <span class="hljs-keyword">lis</span>[i]<br>        i += 1<br>        k += 1<br>    <span class="hljs-keyword">while</span> j &lt;= r:<br>        temp[k] = <span class="hljs-keyword">lis</span>[j]<br>        j += 1<br>        k += 1<br><br>    j = 0<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">l</span>, r + 1):<br>        <span class="hljs-keyword">lis</span>[i] = temp[j]<br>        j += 1<br><br><span class="hljs-keyword">merge</span>(0, <span class="hljs-keyword">n</span> - 1)<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ret</span>)<br></code></pre></td></tr></table></figure><h1 id="海拉鲁城堡问题"><a href="#海拉鲁城堡问题" class="headerlink" title="海拉鲁城堡问题"></a><a href="http://www.xmuoj.com/problem/GW090">海拉鲁城堡问题</a></h1><p>深搜 位运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;因为需要找到所有房间中最大的，而一次搜索只能找一个房间的面积，可以遍历寻找未搜索过的房间。</span><br><span class="hljs-string">深搜和广搜选哪个，一看是找面积最大的本来想用广搜但是判断条件写出来可能会比深搜麻烦很多，所以还是用深搜。</span><br><span class="hljs-string">每次搜索之前，位运算判断该位是否可以走</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> sys<br>sys.setrecursionlimit(<span class="hljs-number">5000</span>)<br>N = <span class="hljs-number">100</span><br>row = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>col = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>lis = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>color = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>maxArea = <span class="hljs-number">0</span><br>maxRoom = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask3</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mask4</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">8</span>) == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> maxArea, maxRoom<br>    <span class="hljs-keyword">if</span> color[a][b] != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    maxArea += <span class="hljs-number">1</span><br>    color[a][b] = maxRoom<br>    <span class="hljs-keyword">if</span> mask1(lis[a][b]):<br>        dfs(a, b - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask2(lis[a][b]):<br>        dfs(a - <span class="hljs-number">1</span>, b)<br>    <span class="hljs-keyword">if</span> mask3(lis[a][b]):<br>        dfs(a, b + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> mask4(lis[a][b]):<br>        dfs(a + <span class="hljs-number">1</span>, b)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>        lis[i][j+<span class="hljs-number">1</span>] = a[j]<br><br>retArea = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> color[i][j] == <span class="hljs-number">0</span>:<br>            maxArea = <span class="hljs-number">0</span><br>            maxRoom += <span class="hljs-number">1</span><br>            dfs(i, j)<br>            retArea = <span class="hljs-built_in">max</span>(retArea, maxArea)<br><br><span class="hljs-built_in">print</span>(maxRoom)<br><span class="hljs-built_in">print</span>(retArea)<br></code></pre></td></tr></table></figure><h1 id="英杰们的蛋糕塔"><a href="#英杰们的蛋糕塔" class="headerlink" title="英杰们的蛋糕塔"></a><a href="http://www.xmuoj.com/problem/GW092">英杰们的蛋糕塔</a></h1><p>深搜 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-comment">//宏定义简化</span><br>#define <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span> (r*r)<br>#define sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> (<span class="hljs-number">2</span>*r*h)<br>#define <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>,<span class="hljs-params">h</span>)</span> ((r)*(r)*(h))<br>#define <span class="hljs-constructor">V2surArea(<span class="hljs-params">r</span>,<span class="hljs-params">v</span>)</span> (<span class="hljs-number">2</span>*v/(r))<br>#define INF <span class="hljs-number">0x7fffffff</span> <br><span class="hljs-built_in">int</span> N, V, minsurArea = INF;<br><span class="hljs-built_in">int</span> sumMinS<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>, sumMinV<span class="hljs-literal">[<span class="hljs-number">27</span>]</span>;<br><br><span class="hljs-comment">// 搜索的主体是 枚举每一层的R H 寻找体积符合时 最小的表面积</span><br>void dfs(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> nr,<span class="hljs-built_in">int</span> nh,<span class="hljs-built_in">int</span> lv,<span class="hljs-built_in">int</span> cs)<br>&#123;<br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (lv<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>cs &lt; minsurArea)minsurArea = cs;<br>return;<br>&#125;<br><span class="hljs-comment">// 剪枝操作 1.当前剩余的体积小于上面累加起来最小的体积 说明已经不符合 </span><br><span class="hljs-comment">// 2.当前表面积加上上面的最小表面积 大于minsurArea 不符合</span><br><span class="hljs-comment">// 3.启发式剪枝 提前看到下一步的结果 当nr没到最后一层 并且 上一层的表面积加上当前累加的面积已经大于minsurArea 不符合</span><br><span class="hljs-keyword">if</span> (lv &lt; sumMinV<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>)return;<br><span class="hljs-keyword">if</span> (cs + sumMinS<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> &gt;= minsurArea)return;<br><span class="hljs-keyword">if</span> (nr &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">V2surArea(<span class="hljs-params">nr</span> - 1, <span class="hljs-params">lv</span>)</span> + cs &gt;= minsurArea)return;<br><br><span class="hljs-comment">//从最大层 （r最大） 到最小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = nr - <span class="hljs-number">1</span>; r &gt;= u; r--)<br>&#123;<br><span class="hljs-comment">// 当到达最高层的时候 让这一层的面积等于 底面积（后面是加上表面积 是每个都有的操作 </span><br><span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span>N)cs = <span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>;<br><span class="hljs-comment">// 预处理出最大高度的最小值 （如果把当前剩余的体积 全部做成一层 除以当前的表面积 就是最大高度</span><br><span class="hljs-built_in">int</span> H_max = (<span class="hljs-number">1.0</span><span class="hljs-operator"> * </span>lv<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(<span class="hljs-params">r</span>)</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (H_max &gt; nh - <span class="hljs-number">1</span>)H_max = nh - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 枚举h</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = H_max; h &gt;= u; h--)<br>&#123;<br><span class="hljs-built_in">int</span> s = sur<span class="hljs-constructor">Area(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br><span class="hljs-built_in">int</span> v = <span class="hljs-constructor">Volume(<span class="hljs-params">r</span>, <span class="hljs-params">h</span>)</span>;<br>dfs(u - <span class="hljs-number">1</span>, r, h, lv - v, cs + s);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>cin &gt;&gt; V &gt;&gt; N;<br><br><span class="hljs-comment">//预处理出 累加到每一层的最小的面积和体积 用于后面的剪枝</span><br>sumMinS<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>&#123;<br>sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinS<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + sur<span class="hljs-constructor">Area(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sumMinV<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> + <span class="hljs-constructor">Volume(<span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>;<br>&#125;<br><span class="hljs-comment">//预处理出 最下面一层的 R H的上界 减少计算</span><br><span class="hljs-built_in">int</span> maxH = (V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> / </span><span class="hljs-constructor">ButtonArea(N)</span> + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> maxR = sqrt(double((V - sumMinV<span class="hljs-literal">[N - <span class="hljs-number">1</span>]</span>) + <span class="hljs-number">1</span>));<br><br>dfs(N, maxR, maxH, V, <span class="hljs-number">0</span>);<span class="hljs-comment">//从最大的蛋糕往上搜索</span><br><span class="hljs-keyword">if</span> (minsurArea<span class="hljs-operator"> == </span>INF)<br>cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; minsurArea &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="击杀黄金蛋糕人马"><a href="#击杀黄金蛋糕人马" class="headerlink" title="击杀黄金蛋糕人马"></a><a href="http://www.xmuoj.com/problem/NQ090">击杀黄金蛋糕人马</a></h1><p>记忆化搜索 动态规划   </p><p>在海拉鲁大陆冒险，没有绝佳的剑法+想象力是不可能存活下来的。<br>这不，林克遇到了一个特别巨大的敌人——黄金蛋糕人马（莱尼尔的变种）<br>这黄金蛋糕人马长相非常特别，没有脚没有手没有嘴巴没有头，整个身材就是一个大矩形（喂喂，这不就是黄金莱尼尔吗？）<br>它的长和宽分别是整数w、h。<br>林克举起大师之剑，挥向黄金蛋糕人马，要将其切成m块矩形小块打包走，分给自己的朋友（每块都必须是矩形、且长和宽均为整数）。<br>大师之剑无比锐利，每一斩带出的剑气能将黄金蛋糕人马劈成两半（形成两个小矩形蛋糕）<br>经过m-1斩，黄金蛋糕人马居然被劈成m块小蛋糕（喂喂，你的想象力也太丰富了，明明切不开好吗？）<br>请计算：最后得到的m块小蛋糕中，最大的那块蛋糕的面积下限。<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 4，则下面的斩击可使得其中最大蛋糕块的面积最小。(十字斩)<br>假设w&#x3D; 4,h&#x3D; 4,m&#x3D; 3，则下面的斩击可使得其中最大蛋糕块的面积最小:.(二连斩)</p><ul><li>输入</li></ul><p>共有多行，每行表示一个测试案例。<br>每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh.<br>当 w &#x3D; h &#x3D; m &#x3D; 0 时不需要处理，表示输入结束。</p><ul><li>输出</li></ul><p>每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 记忆化搜索 储存已经搜过的值 下次需要时直接返回 储存的一般为搜索的值 dfs返回值一般定义为int（不为void）</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 原来的方法主要是分成左右两边的时候不好表示 </span><br><span class="hljs-comment">* 该方法dfs传入的是当前的方块的长和宽 分为左右两边（分治）枚举左右边切的位置 和左右边分别切的刀数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w, h, m;<br><span class="hljs-type">int</span> maxCake[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>][<span class="hljs-number">500</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当m为0的时候返回当前的面积</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> w * h;<br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-keyword">if</span> (maxCake[w][h][m])<span class="hljs-keyword">return</span> maxCake[w][h][m];<br><br><span class="hljs-type">int</span> a, b, ans = inf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; w; j++) <br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(j, h, i);<span class="hljs-comment">// 切m 刀的蛋糕是由切i刀和m - i - 1刀组成的   w - i 最后会反转 可以变量所有情况</span><br>b = <span class="hljs-built_in">dfs</span>(w - j, h, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<span class="hljs-comment">// 得到最大的蛋糕 取最小</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; h; j++)<br>&#123;<br>a = <span class="hljs-built_in">dfs</span>(w, j, i);<br>b = <span class="hljs-built_in">dfs</span>(w, h - j, m - <span class="hljs-number">1</span> - i);<br><span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-built_in">max</span>(a, b))ans = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br>&#125;<br>maxCake[w][h][m] = ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; h &gt;&gt; m)<br>&#123;<br><span class="hljs-keyword">if</span> (w == h &amp;&amp; h == m &amp;&amp; m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">dfs</span>(w, h, m - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">memset</span>(maxCake, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> maxCake);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滚石柱"><a href="#滚石柱" class="headerlink" title="滚石柱"></a><a href="http://www.xmuoj.com/problem/XMU023">滚石柱</a></h1><p>广搜 结构体</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs arduino">广搜加上结构体表示物体的状态，主要难点就在于状态的表示。用结构体表示物体的状态，更新状<br>态时，用三维数组，增加的一维用来表示<span class="hljs-number">0</span>立着横着竖着<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span><br>&#123;<br><span class="hljs-type">int</span> x, y, lie;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> d[N][N][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> row, col;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;&#125;,<span class="hljs-comment">//0 立着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;,<span class="hljs-comment">//1 横着</span><br>&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;&#125;<span class="hljs-comment">//2 竖着</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= row || y &gt;= col || x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> g[x][y] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State start, State end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>d[start.x][start.y][start.lie] = <span class="hljs-number">0</span>;<br>queue&lt;State&gt;q;<br>q.<span class="hljs-built_in">push</span>(start);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>State t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>State next = &#123; t.x + dir[t.lie][i][<span class="hljs-number">0</span>],t.y + dir[t.lie][i][<span class="hljs-number">1</span>],dir[t.lie][i][<span class="hljs-number">2</span>] &#125;;<br><span class="hljs-type">int</span> x = next.x, y = next.y;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(x, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x, y + <span class="hljs-number">1</span>))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (next.lie == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">check</span>(x + <span class="hljs-number">1</span>, y))<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (d[x][y][next.lie] == <span class="hljs-number">-1</span>)<br>&#123;<br>d[x][y][next.lie] = d[t.x][t.y][t.lie] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[end.x][end.y][end.lie];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; row &gt;&gt; col, row || col)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>cin &gt;&gt; g[i];<br><br>State start = &#123; <span class="hljs-number">-1</span> &#125;, end;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; start.x == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (g[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)start = &#123; i,j,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">else</span> start = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#123;<br>end = &#123; i,j,<span class="hljs-number">0</span> &#125;;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(start, end);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br><span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python速成笔记</title>
    <link href="/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/22/python%E9%80%9F%E6%88%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python速成的一些学习笔记"><a href="#python速成的一些学习笔记" class="headerlink" title="python速成的一些学习笔记"></a>python速成的一些学习笔记</h1><p>什么？！你说python速成？-&gt;[<a href="https://oi.wiki/lang/python/">Python 速成 - OI Wiki</a>]</p><ul><li><p>pow函数可以实现快速幂</p></li><li><p>对Unicode的字符使用函数ord可以将其转换成对应的Unicode编码 逆向转换使用chr</p></li><li><p>字符串居然也可以用加和乘的运算 但是好像不能用减？ </p></li><li><p>字符串和列表都有方便的子串&#x2F;元素检测 in 如 a in str</p></li><li><p>字符串与列表的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">70</span>))            <br>lis = [<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> num]           <br><span class="hljs-built_in">print</span>(lis)                  <br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(lis)                    <br><span class="hljs-built_in">print</span>(s)            <br></code></pre></td></tr></table></figure></li><li><p>二维[数组]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">via = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]                    <br><span class="hljs-built_in">print</span>(via)              <br>via[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>               <br><span class="hljs-built_in">print</span>(via)              <br></code></pre></td></tr></table></figure></li><li><p>使用NumPy建立多维数组和访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np      <br><br><span class="hljs-comment">#容量为3 未初始化       </span><br>lis = np.empty(<span class="hljs-number">3</span>)       <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#3*3 初始化为0      </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)     <br><span class="hljs-built_in">print</span>(lis)      <br><span class="hljs-comment">#整数数组       </span><br>lis = np.zeros(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>, dtype=<span class="hljs-built_in">int</span>)      <br><span class="hljs-built_in">print</span>(lis.shape)        <br><span class="hljs-comment">#获取数组最大值         </span><br>np.<span class="hljs-built_in">max</span>(lis)     <br><span class="hljs-comment">#展平       </span><br>lis.flatten()       <br><span class="hljs-comment">#对每行排序 返回排序结果</span><br>np.sort(lis, axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#行方向原地排序</span><br>lis.sort(axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#浮点数输出</span><br>pi = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.4f&quot;</span> % pi)<br><span class="hljs-string">&quot;%.4f - %8f = %d&quot;</span> % (pi, <span class="hljs-number">0.1416</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">#输入</span><br>s = <span class="hljs-built_in">input</span>()<br>a = s.split()<br><span class="hljs-built_in">print</span>(a)<br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a]<br><span class="hljs-comment">#或者</span><br>a = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment">#固定输入</span><br>u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典</span><br>dic = &#123;&#125;<br>dic = &#123;<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>&#125;<br>dic1 = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">69</span>)&#125;<br><span class="hljs-comment"># 翻转</span><br>dic1 = &#123;dic1[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1&#125;<br><span class="hljs-built_in">print</span>(dic1)<br><span class="hljs-comment"># 要先判断才能打印</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">in</span> dic1:<br>    <span class="hljs-built_in">print</span>(dic1[<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-keyword">else</span>:<br>    dic1[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">98</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="更新！学了两个月之后再看一遍"><a href="#更新！学了两个月之后再看一遍" class="headerlink" title="更新！学了两个月之后再看一遍"></a>更新！学了两个月之后再看一遍</h1><ul><li><p>format() 输出浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br>formatted_pi = <span class="hljs-string">&quot;圆周率的近似值是 &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi)<br><span class="hljs-built_in">print</span>(formatted_pi)<br>:<span class="hljs-number">.2</span>f 是一个格式规范，它指定了要显示小数点后两位的浮点数<br><br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">20</span><br>result = <span class="hljs-string">&quot;x 的值是 &#123;&#125;，y 的值是 &#123;&#125;，它们的和是 &#123;&#125;。&quot;</span>.<span class="hljs-built_in">format</span>(x, y, x + y)<br><span class="hljs-built_in">print</span>(result)<br><br>name = <span class="hljs-string">&quot;Alice&quot;</span><br>age = <span class="hljs-number">30</span><br>message = <span class="hljs-string">f&quot;我的名字是 <span class="hljs-subst">&#123;name&#125;</span>，年龄是 <span class="hljs-subst">&#123;age&#125;</span>。&quot;</span><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">u, v, w = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><br><span class="hljs-comment"># 二维数组</span><br>mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>N = <span class="hljs-number">4</span>; mat = [[<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>mat  <span class="hljs-comment"># 先按行读入二维数组</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>u, v, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">list</span>, <span class="hljs-built_in">zip</span>(*mat))   <br><span class="hljs-comment"># *将 mat 解包得到里层的多个列表</span><br><span class="hljs-comment"># zip() 将多个列表中对应元素聚合成元组，得到一个迭代器</span><br><span class="hljs-comment">## 内置函数 zip() 可以将多个等长序列中的对应元素拼接在「元组」内，得到新序列</span><br><span class="hljs-comment"># map(list, iterable) 将序列中的元素（这里为元组）转成列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u, v, w)  <span class="hljs-comment"># 直接将 map() 得到的迭代器拆包，分别赋值给 u, v, w</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li><p>内置容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dict</span><br>dic = &#123;<span class="hljs-built_in">chr</span>(i): i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)&#125;<br>dic = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)], <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))<br><span class="hljs-comment"># 键值对逆转</span><br>dic = &#123;dic[k]: k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic&#125;<br>dic = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()&#125;  <span class="hljs-comment"># 和上行作用相同，dic.items() 以元组存放单个键值对</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dic.items(), key=<span class="hljs-keyword">lambda</span> x:-x[<span class="hljs-number">1</span>])&#125;  <span class="hljs-comment"># 字典按值逆排序，用到了 lambda 表达式</span><br></code></pre></td></tr></table></figure></li><li><p>装饰器</p><p>lru_cache转记忆化</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2023/07/22/My-first-blog/"/>
    <url>/2023/07/22/My-first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>做这个网站真的做了好久，教程确实很详细了，但是还是有些地方默认读者已经会了（我现在确实会了）。感谢tllwtg的帮助，没有tllwtg，就没有这个网站，呜呜。<br>tllwtg告诉我教程之后还帮我调了两次（&#x2F;跪谢）。</p><p>之后自己做的过程中也好多次感觉根本搞不出来，不想搞了。但是但是，这个好有意思，最后还是做出来了。tllwtg还跟我说做两三天是很正常的，我真的哭死。做完还是很开心的。<br>我也学到了好多东西，自己去看教程，搜资料，虽然会花很多时间，但是效果确实好欸，比如之前觉得很难的git的操作，，，一直不愿意去学（卧室蓝苟）最后也被迫学会了，<br>除了做网站本身，还学到好多其他的东西。效果比tllwtg直接帮我打出来好很多。（如果我那天不是删了重新做，而是让tllwtg帮我弄一下，我现在估计还是什么都不会&#x2F;难过）。</p><p>好！不当蓝苟从现在开始。（QQ机器人？好难，下次再说吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/22/hello-world/"/>
    <url>/2023/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
