---
title: 5月
date: 2024-05-13 18:57:33
tags: Ans
---

# 回溯

## [xmuoj | 最小化蒙德城的旅行者队伍](http://www.xmuoj.com/contest/235/problem/1)

相同的车队是一个等差数列 要最小化车队的数量 就要找出等差数列包含尽可能多的车队

可以先预处理出所有可能的行进路线。将问题转化为在合法的线路中找出多少条才能覆盖所有的车队。

由于可能有同时到达的，且所有的车队都在0~59之间到达，因此可以用哈希表来存储，符合要求时-1表示已经属于某个车队。当全部为0时表示覆盖了所有车队。

预处理线路

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int n;
int nums[60];
typedef pair<int, int>PII;
vector<pair<int, PII>>routes;
int check(int x, int d)
{
    for (int i = x; i < 60; i += d)
    {
        if (nums[i] == 0)
            return false;
    }
    return true;
}
int main()
{
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin>>x;
        nums[x]++;
    }
    // i表示开始时间 即初项 j表示公差
    // check计算这个组合是否每个时间都有车队到达
    for (int i = 0; i < 60; i++)
    {
        for (int j = i; i + j < 60; j++)
        {
            if (check(i, j))
            routes.push_back({(59 - i) / j + 1, {i, j}});
        }
    }
    // 按（59 - i）/ j排序 从可以包含更多的数的等差数列开始回溯 更快找到最优解
    sort(routes.begin(), routes.end(), greater<>);
    
}
```

然后就对所有可能的等差数列进行回溯，求出覆盖所有车队需要的最小数

```C++
// depth表示选了几条路线可以覆盖所有的车（迭代到第几层） 也就是最终的结果，因为已经按覆盖的多少排序了，所以覆盖的多的先选肯定是更好的 当覆盖完一定是最优解
// 比如depth=2 表示最多迭代2层 在depth==u的时候(u从0开始增加depth不变)就判断是否覆盖完了 

bool backtrack(int depth, int u, int sum, int start)
{
    if (depth == u)
    {
        return sum == n;
    }
    //剪枝 当前层最多可以覆盖的车数量 * （层数） + 已经覆盖了的车的数量 如果小于总数 那必不可能 直接return false
    if (routes[start].first * (depth - u) + sum < n)return false;
    for (int i = start; i < routes.size(); i++)
    {
        auto r = routes[i];
        int a = r.second.first, d = r.second.second;
        if (!check(a, d))continue;
        //回溯
        for (int j = a; j < 60; j+=d)nums[j]--;
        if(backtrack(depth, u + 1, sum + r.first, i))return true;
        for (int j = a; j < 60; j+=d)nums[j]++;
    }
    return false;
}
```

补充main函数

```C++
int depth = 0;
while (!backtrack(depth, 0, 0, 0))depth++;
cout << depth << endl;
```

主要的难点在于题意比较难读懂 还有预处理出等差数列之后用迭代加深的做法进行求解(设depth的深度，每次增加depth 用depth限制迭代深度)这种做法适用于n较大但是答案较小的情况，比如本题说了最多17条路线，depth最多为17.

## [xmuoj | 恢复破碎的符咒木牌](http://www.xmuoj.com/contest/235/problem/2)

因为有很多重复的长度 所以用哈希表存储

枚举可以选择的长度：最小就是【所有木棍里最大的长度】

最大就是【所有木棍的总长/2】（最大可以分成这样 再往后只能直接用总长了）

```C++
#include <iostream>
using namespace std;
int n;
const int N = 100010;
int nums[N], maxn, minn, sum;
int main()
{
    while (cin>>n && n)
    {
        finished = false;
        maxn = 0, minn = 1e9, sum = 0;
        for (int i = 0; i < n; i++)
        {
            int x;
            cin>>x;
            nums[x]++;
            maxn = max(maxn, x);
            minn = min(minn, x);
            sum += x;
        }
        int temp = sum / 2;
        for (int i = maxn; i <= temp; i++)
        {
            if (sum % i == 0)
                dfs(sum / i, 0, i, maxn);
        }
        if (!finished)cout<<sum<<endl;
    }
}
```

假设当前的答案长度为one_len 一共有all_left根这样长的棍子 每次选一段 当前的这根的长度为now_len 当now_len==one_len表示已经凑够了一根

```C++
void dfs(int all_left, int now_len, int one_len, int now_max)
{
    if(finished)return;
    if (all_len == 0)
    {
        cout<<one_len<<endl;
        finished = true;
        return;
    }
    if (one_len == now_len)
    {
        dfs(all_left + 1, 0, one_len, maxn);
        return;
    }
    // 从大的开始 可以更早到达临界 状态更少回溯更快
    for (int i = now_max; i >= minn; i--)
    {
        if (nums[i] && i + now_len <= one_len)
        {
            nums[i]--;
            dfs(all_left, now_len + i, one_len, i);
            nums[i]++;
            if (now_len == 0 || now_len + i == one_len)
                return ;
        }
    }
}
```

难点在于剪枝的部分和dfs的参数表示，要用哪些参数来表示，一开始只能想到all_left one_len 和now_len 但是要加上now_max才能减少搜索次数

## [xmuoj | 提瓦特情报传递网络](http://www.xmuoj.com/contest/235/problem/3)

建图+bfs 建立有向图然后进行bfs搜索 只要step小于层数L即可

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
const int N = 1010;
typedef pair<int, int> PII;
bool g[N][N], vis[N];
int n, m;
int maxn = 0;
void bfs(int s)
{
	queue<PII>q;
	q.push({ s, 0 });
	vis[s] = 1;
	while (!q.empty())
	{
		
		int step = q.front().second, now = q.front().first;
		q.pop();
		for (int i = 1; i <= n; i++)
		{
			if (vis[i] || !g[now][i])continue;
			vis[i] = true;

			if (step + 1 <= m)
			{
				q.push({ i, step + 1 });
				maxn++;
			}
		}
	}
}
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		for (int j = 0; j < x; j++)
		{
			int y;
			cin >> y;
			g[y][i] = true;
		}
	}
	int x;
	cin >> x;
	for (int i = 1; i <= x; i++)
	{
		memset(vis, 0, sizeof(vis));
		maxn = 0;
		int y;
		cin >> y;
		bfs(y);
		cout << maxn << endl;
	}
}
```

## [xmuoj | 神庙石塔挑战](http://www.xmuoj.com/contest/238/problem/2)

生日蛋糕

每次减少一层 直到最后一层的时候 体积如果等于题目要求的体积 就可以更新答案

dfs中需要有参数【当前是第几层 当前层的高和半径 当前的总体积总面积】

```C++
#include<iostream>
using namespace std;
int n, d;
void backtrack(int step, int r, int h, int s, int v)
{
    if (step == 0)
    {
        if (v == n)
            mins = min(mins, s);
        return ;
    }
    
    for (int i = r - 1; i >= step; i--)
    {
        if (step == m)s = i * i;
       	for (int j = h - 1; j >= step; j--)
        {
            backtrack(step - 1, i, j, s + 2 * i * j, v + i * i * j);
        }
    }
}
int main()
{
    cin>>n>>d;
    backtrack(m, n, n, 0, 0);
}
```

很明显这样是过不了的 需要剪枝

当当前的体积+后面几层体积已经大于要求的体积时 没有解（约束函数）

当当前面积+后面几层面积已经大于最小面积时 不可能导出最优解（限界函数）

当当前的面积加上后面的所有层的可能的最小面积 大于最小面积时 不可能导出最优解

当i = r - 1进行回溯的时候，如果h - 1超出了体积 可以计算当前可能到达的最大的h = 总体积-当前体积-后几层体积/当前的底面积 =高=maxh

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
int n, m;
const int N = 30;
int mins = 0x3f3f3f3f;
int leftmins[N], leftminv[N];
void backtrack(int step, int r, int h, int s, int v)
{
	if (step == 0)
	{
		if (v == n)
			mins = min(mins, s);

		return;
	}
	if (s + leftmins[step] >= mins)return;
	if (v + leftminv[step] > n)return;
	if (s + 2.0 * (n - v) / r >= mins)return;

	for (int i = r - 1; i >= step; i--)
	{
		if (step == m)s = i * i;
      	int maxh = min((n - v - leftminv[step - 1]) / (i * i), h - 1);

		for (int j = maxh; j >= step; j--)
		{
			backtrack(step - 1, i, j, s + 2 * i * j, v + i * i * j);
		}
	}
}

int main()
{
	cin >> n >> m;

	for (int i = 1; i <= m + 1; i++)
	{
		leftmins[i] = leftmins[i - 1] + i * 2 * i;
		leftminv[i] = leftminv[i - 1] + i * i * i;
	}

	backtrack(m, n, n, 0, 0);
	if (mins == 0x3f3f3f3f)cout << 0;
	else
		cout << mins;
}
```

## [xmuoj | “原神”探秘：穿越神秘迷宫](http://www.xmuoj.com/contest/238/problem/1)

dfs每次将当前的位置保存在数组中，深度优先搜索，直到找到出口。如果无法继续向下走，就回溯。回溯到上一状态时需要把原来的路径也同时删除。

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
using namespace std;
int n;
int nums[1000][1000];
vector<pair<int, int>>rode;
int dy[4] = { 1, 0, -1, 0 };
int dx[4] = { 0, 1, 0, -1 };
bool flag = false;

void Print()
{
	for (int i = 0; i < rode.size(); i++)
	{
		cout << "(" << rode[i].first << "," << rode[i].second << ")";
	}
}
void dfs(int x, int y)
{
	if (flag)return;
	if (x == n - 2 && y == n - 2)
	{
		Print();
		flag = true;
		return;
	}
	for (int i = 0; i < 4; i++)
	{
		int nx = x + dx[i], ny = y + dy[i];
		if (nums[nx][ny] == 0)
		{
			nums[nx][ny] = 1;
			rode.push_back({ nx, ny });
			dfs(nx, ny);
			rode.pop_back();
		}
	}

}
int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			cin >> nums[i][j];
		}
	}
	if (nums[1][1] == 1)
	{
		cout << "NO";
		return 0;
	}
	rode.push_back({ 1,1 });
	dfs(1, 1);

	if (!flag)
	{
		cout << "NO";
		return 0;
	}
	
}
```

## [37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/description/)

主要是注意行、列、宫的表示方法 用哈希表填数 表示这个数已经用过

将需要填的坐标放在队列中 每次取出填数

```C++
class Solution {
public:
bool hang[9][9];
bool lie[9][9];
bool gezi[3][3][9];
bool valid=false;
vector<pair<int,int>>spaces;
    void dfs(vector<vector<char>>&board,int pos)//pos 代表第pos个填上的空格
    {
        if(pos==spaces.size())
        {
            valid=true;
            return ;
        }
        
        //每次处理掉一个格子 第pos个空格 的行和列为i j
        auto [i,j]=spaces[pos];
        for(int digit=0;digit<9&&!valid;digit++)
        {
            if(!hang[i][digit]&&!lie[j][digit]&&!gezi[i/3][j/3][digit])
            {
                hang[i][digit]=lie[j][digit]=gezi[i/3][j/3][digit]=true;
                board[i][j]=digit+'0'+1;//0-8  +1  1-9

                dfs(board,pos+1);

                hang[i][digit]=lie[j][digit]=gezi[i/3][j/3][digit]=false;
            }
        }
    }

    void solveSudoku(vector<vector<char>>& board)
    {
       //填入 初始状态
        for(int i=0;i<9;i++)
        {
            for(int j=0;j<9;j++)
            {
                if(board[i][j]=='.')
                {
                    spaces.emplace_back(i,j);
                }
                else
                {
                    int digit=board[i][j]-'0'-1;//1-9 越界 -1 表示 0-8
                    hang[i][digit]=lie[j][digit]=gezi[i/3][j/3][digit]=true;
                }
            }
        }

        dfs(board,0);
    }
    
};
```

## [xmuoj | 提瓦特地图探险](https://www.xmuoj.com/contest/239/problem/1)

* 方法一 记忆化搜索

复杂度较低的做法，在回溯的过程中记录每个点所能到达的最长上坡路径的长度。

分四个方向进行递归，使用temp记录当前这个格子下，最长的路径，用备忘录记录后，返回最长路径。

dfs函数就处理每个格子的最长路径，对每个格子都作为起点进行一次搜索（搜索中记录已访问的结点）即可得到最长的路径。

```C++
define _CRT_SECURE_NO_WARNINGS
include <iostream>
include<vector>
include <queue>
using namespace std;
int row, col;
vector<vector<int>>nums;
int memo[1000][1000];
int ans;
int dx[4] = { 0,1,0,-1 };
int dy[4] = { 1,0,-1,0 };

int dfs(int x, int y)
{
	int temp = 0;
	for (int i = 0; i < 4; i++)
	{
		int nx = dx[i] + x, ny = dy[i] + y;
		if (nx >= 0 && nx < row && ny >= 0 && ny < col && nums[nx][ny] > nums[x][y])
		{
			temp = max(temp, memo[nx][ny] != 0 ? memo[nx][ny] : dfs(nx, ny));
		}
	}
	memo[x][y] = temp + 1;
	ans = max(ans, memo[x][y]);
	return memo[x][y];
}

int main()
{
	cin >> row >> col;
	nums = vector<vector<int>>(row, vector<int>(col));
	
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			cin >> nums[i][j];
		}
	}
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			dfs(i, j);
		}
	}
	cout << ans << endl;
}

```

* 方法二

暴力的做法，直接对每个点进行搜索，但是不记录每个点的长度。最后用打擂台的方式记录最长的。

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include<vector>
#include <queue>
using namespace std;
int row, col;
vector<vector<int>>nums;
int memo[1000][1000];
int ans;
int dx[4] = { 0,1,0,-1 };
int dy[4] = { 1,0,-1,0 };

void dfs(int step, int x, int y)
{
	ans = max(ans, step);
	for (int i = 0; i < 4; i++)
	{
		int nx = x + dx[i], ny = y + dy[i];
		if (nx >= 0 && nx < row && ny >= 0 && ny < col && nums[nx][ny] > nums[x][y])
			dfs(step + 1, nx, ny);
	}
}

int main()
{
	cin >> row >> col;
	nums = vector<vector<int>>(row, vector<int>(col));
	
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			cin >> nums[i][j];
		}
	}
	for (int i = 0; i < row; i++)
	{
		for (int j = 0; j < col; j++)
		{
			dfs(1, i, j);
		}
	}
	cout << ans << endl;
}
```

## [xmuoj | 石碑之谜：滚动机关](https://www.xmuoj.com/contest/239/problem/2)

bfs搜索。本题要注意很多细节问题。

首先是状态定义，与二维的走迷宫不同，在每个点可能有三个状态 横竖立，那么这个点可以以不同的方式被经过。

```c++
struct State
{
	int x, y, lie;
};//0立1横2竖
```

在记录每个点的步数的时候，d[1] [1] [0]和d[1] [1] [1] 同样是在1 1这一格，但是状态不同，因此要走的步数也是不同的。

接下来是状态更新，每一步如何走:

```C++
int dir[3][4][3] =
{
	{{1,0,2},{-2,0,2},{0,1,1},{0,-2,1}},//0 立着
	{{-1,0,1},{0,2,0},{1,0,1},{0,-1,0}},//1 横着
	{{-1,0,0},{2,0,0},{0,1,2},{0,-1,2}}//2 竖着
};
```

当立着的时候，如果转为横着，那就是向左或右倒下，状态改变为1，同时走过了1格。以此类推就可以求出每一种状态转移的方式。

check函数判断是否越界或为墙壁

```C++
bool check(int x, int y)
{
	if (x >= row || y >= col || x < 0 || y < 0)
		return false;
	return g[x][y] != '#';
}
```

在main函数中输入的时候就要处理好开始和结束位置

开始位置为搜索到X之后，马上搜索X的下右，是否还有第二个X，表示初始状态是横？竖？立？最终状态只会是立着。

```C++
for (int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				if (g[i][j] == 'X' && start.x == -1)
				{
					if (g[i + 1][j] == 'X')start = { i,j,2 };
					else if (g[i][j + 1] == 'X')start = { i,j,1 };
					else start = { i,j,0 };
				}
				else if (g[i][j] == 'O')
				{
					end = { i,j,0 };
				}
			}
		}
```

关键函数bfs函数，只需要在每一步都判断一下当前这一步是否可以走（不能越界，立着不能站在易碎平台，横竖多出来的一格不能越界）

```C++
memset(d, -1, sizeof d);
	d[start.x][start.y][start.lie] = 0;
	queue<State>q;
	q.push(start);

	while (!q.empty())
	{
		State t = q.front();
		q.pop();

		for (int i = 0; i < 4; i++)
		{
			State next = { t.x + dir[t.lie][i][0],t.y + dir[t.lie][i][1],dir[t.lie][i][2] };
			int x = next.x, y = next.y;
			if (!check(x, y))continue;
			if (next.lie == 0 && g[x][y] == 'E')continue;
			if (next.lie == 1 && !check(x, y + 1))continue;
			if (next.lie == 2 && !check(x + 1, y))continue;
			if (d[x][y][next.lie] == -1)
			{
				d[x][y][next.lie] = d[t.x][t.y][t.lie] + 1;
				q.push(next);
			}
		}
	}
	return d[end.x][end.y][end.lie];
```

完整代码

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
using namespace std;

struct State
{
	int x, y, lie;
};//0立1横2竖
const int N = 510;
char g[N][N];
int d[N][N][3];
int row, col;
int dir[3][4][3] =
{
	{{1,0,2},{-2,0,2},{0,1,1},{0,-2,1}},//0 立着
	{{-1,0,1},{0,2,0},{1,0,1},{0,-1,0}},//1 横着
	{{-1,0,0},{2,0,0},{0,1,2},{0,-1,2}}//2 竖着
};

bool check(int x, int y)
{
	if (x >= row || y >= col || x < 0 || y < 0)
		return false;
	return g[x][y] != '#';
}

int bfs(State start, State end)
{
	memset(d, -1, sizeof d);
	d[start.x][start.y][start.lie] = 0;
	queue<State>q;
	q.push(start);

	while (!q.empty())
	{
		State t = q.front();
		q.pop();

		for (int i = 0; i < 4; i++)
		{
			State next = { t.x + dir[t.lie][i][0],t.y + dir[t.lie][i][1],dir[t.lie][i][2] };
			int x = next.x, y = next.y;
			if (!check(x, y))continue;
			if (next.lie == 0 && g[x][y] == 'E')continue;
			if (next.lie == 1 && !check(x, y + 1))continue;
			if (next.lie == 2 && !check(x + 1, y))continue;
			if (d[x][y][next.lie] == -1)
			{
				d[x][y][next.lie] = d[t.x][t.y][t.lie] + 1;
				q.push(next);
			}
		}
	}
	return d[end.x][end.y][end.lie];
}


int main()
{
	while (cin >> row >> col, row || col)
	{
		for (int i = 0; i < row; i++)
			cin >> g[i];

		State start = { -1 }, end;
		for (int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				if (g[i][j] == 'X' && start.x == -1)
				{
					if (g[i + 1][j] == 'X')start = { i,j,2 };
					else if (g[i][j + 1] == 'X')start = { i,j,1 };
					else start = { i,j,0 };
				}
				else if (g[i][j] == 'O')
				{
					end = { i,j,0 };
				}
			}
		}

		int res = bfs(start, end);
		if (res == -1)puts("Impossible");
		else cout << res << endl;
	}
}
```

## [xmuoj | 璃月森林探险：符文之路](https://www.xmuoj.com/contest/239/problem/3)

回溯法

本题需要有较多的分类主要为：本来没有颜色，现在也没有颜色；本来没有颜色，现在有颜色；本来有颜色，现在有相同、不同颜色

需要分类讨论

 关键在于回溯的同时需要保存用魔法改变的 、只能存在一回合的颜色。

可以在函数中使用参数color，记录上一格的颜色（使用魔法变化后）然后原本的数组中的颜色不变，这样就可以将魔法变化的颜色区分开。

都没有颜色的时候直接返回

前面有颜色现在没颜色，花费2使用魔法变成与前面一样的颜色。并且在像下一格搜索时颜色要记录为魔法改变后的颜色。

都有颜色如果相同直接向下搜索，如果不同，需要花费1的代价改变颜色。

对每种情况分别回溯，记录每个点可以达到的最小值。

```C++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include <cstring>
#include <queue>
using namespace std;
const int N = 1010;
int g[N][N], vis[N][N], dis[N][N];
int n, m;
int dx[4] = { 0, 1, 0, -1 };
int dy[4] = { 1, 0, -1, 0 };
int ans = 0x3f3f3f3f;
void dfs(int a, int b, int color, int cost)
{
	if (a == n && b == n)
	{
		ans = min(ans, cost);
		return;
	}
	for (int i = 0; i < 4; i++)
	{
		int nx = a + dx[i], ny = b + dy[i];
		if (nx > 0 && nx <= n && ny > 0 && ny <= n && !vis[nx][ny])
		{
			//都没有颜色
			if (g[a][b] == 0 && g[nx][ny] == 0)continue;
			//前面有颜色 现在没颜色 变为前面的颜色 花费2
			if (g[nx][ny] == 0)
			{
				if (cost + 2 < dis[nx][ny])
				{
					vis[nx][ny] = 1;
					dis[nx][ny] = cost + 2;
					dfs(nx, ny, color, cost + 2);
					vis[nx][ny] = 0;
				}
			}
			// 现在位置有颜色（前面位置不管 "本来" 有没有颜色 他站在那 肯定是要么本来有 要么用了魔法有）
			else
			{
				// 如果颜色和前面相等 不花费 直接进
				if (color == g[nx][ny] && cost < dis[nx][ny])
				{
					vis[nx][ny] = 1;
					dis[nx][ny] = cost;
					dfs(nx, ny, color, cost);
					vis[nx][ny] = 0;

				}
				// 如果颜色不相等 需要花费1
				else if (cost + 1 < dis[nx][ny] && cost + 1 < ans)
				{
					dis[nx][ny] = cost + 1;
					vis[nx][ny] = 1;
					dfs(nx, ny, g[nx][ny], cost + 1);
					vis[nx][ny] = 0;
				}

			}
		}
	}
}
int main()
{
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;

		g[u][v] = w + 1;
	}
	vis[1][1] = 1;
	memset(dis, 0x3f3f3f3f, sizeof(dis));
	dfs(1, 1, g[1][1], 0);

	/*for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			cout << dis[i][j] << " ";
		}
		cout << endl;
	}*/
	if (ans == 0x3f3f3f3f)cout << -1;
	else cout << ans;
}
```

# 贪心

## [2981. 找出出现至少三次的最长特殊子字符串 I - 力扣（LeetCode）](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i/)

使用贪心的思想。注意题目要求的特殊字符串只能由单一的字符组成，那么就可以记录每段连续相同字符的最长长度。

对这些长度进行排序，有多种情况

* 第一种 a[0] - 2:

  aaaaa要使其连续出现三次，那么就可以为**aaa**aa、a**aaa**a、aa**aaa**，可以发现最长的就是长度-2.

* 第二种 a[2]:

​	假设a字符有3个长为5的串，那么a[0],a[1],a[2]都为5，此时最长的 就是a[2]

* 第三种 a[1]==a[0]-1:

  当a[1] == a[0] - 1的时候 类似第一种情况 ，a[0] - 1可以凑两个，再加上a[1]就可以达到三个

选出其中的最大值，由于第一种和第三种相差1 可以直接取其中的较小值来决定是1还是3

```py
class Solution:
    def maximumLength(self, s: str) -> int:
        cnt = 0
        groups = defaultdict(list)
        for i, x in enumerate(s):
            cnt += 1
            if i + 1 == len(s) or x != s[i + 1]:
                groups[x].append(cnt)
                cnt = 0
        
        ans = -1
        for a in groups.values():
            a.sort(reverse=True)
            a.extend([0,0])
            ans = max(ans, a[0] - 2, min(a[0] - 1, a[1]), a[2])
        return -1 if ans == 0 else ans
```

## [56. 合并- 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/)

类似区间合并，但是要求输出修改后的区间值，首先对区间进行排序，然后就可以不断更新区间的右端点

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals = sorted(intervals, key=lambda x:(x[0], x[1]))
        n = len(intervals)
        ans = [intervals[0]]
        for ele in intervals:
            if ele[0] > ans[-1][1]:
                ans.append(ele)
            else:
                ans[-1][1] = max(ans[-1][1], ele[1])
        return ans
```

## [2028. 找出缺失的观测数据 - 力扣（LeetCode）](https://leetcode.cn/problems/find-missing-observations/description/)

求出缺失值，可以由输入数据求出数据的总和，再减去输入数据的和，就可以得到缺失值的和。

关键在于缺失值必须都在1-6之间。可以从6开始枚举，可以选择多少个，尽量多选择大的数，只要在区间内，就一定可以求出解。

```py
class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        sz = n + len(rolls)
        left = mean * sz - sum(rolls)
        a = [i for i in range(6, 0, -1)]
        if left < n or left > 6 * n:
            return []
        else:
            ans = [left // n] * n
            if left % n == 0:
                return ans
            else:
                left = left % n
                for i in range(left):
                    ans[i] += 1
                return ans
```

# Trie树

## [2935. 找出强数对的最大异或值 II - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-strong-pair-xor-ii/submissions/482713400/)

```py
class Node():
    __slots__ = 'children', 'cnt'

    def __init__(self):
        self.children = [None, None]
        self.cnt = 0

class Trie():
    HIGH_BIT = 19

    def __init__(self):
        self.root = Node()
    
    def insert(self, val: int) -> None:
        cur = self.root
        for i in range(Trie.HIGH_BIT, -1, -1):
            bit = (val >> i) & 1
            if cur.children[bit] is None:
                cur.children[bit] = Node()
            cur = cur.children[bit]
            cur.cnt += 1
        return cur

    def remove(self, val: int) -> None:
        cur = self.root
        for i in range(Trie.HIGH_BIT, -1, -1):
            cur = cur.children[(val >> i) & 1]
            cur.cnt -= 1
        return cur

    def max_xor(self, val: int) -> int:
        cur = self.root
        ans = 0
        for i in range(Trie.HIGH_BIT, -1, -1):
            bit = (val >> i) & 1
            if cur.children[bit ^ 1] and cur.children[bit ^ 1].cnt:
                ans |= 1 << i
                bit ^= 1
            cur = cur.children[bit]
        return ans

class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        root = Trie()        
        nums.sort()
        n = len(nums)
        ret = left = 0
        for y in nums:
            root.insert(y)
            while nums[left] * 2 < y:
                root.remove(nums[left])
                left += 1
            ret = max(ret, root.max_xor(y))            
        return ret
```

# 贡献法

## [828. 统计子串中的唯一字符 - 力扣（LeetCode）](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/?envType=daily-question&envId=2023-11-26)

贡献法  一个字符 能贡献1 代表他在这个子数组里 是唯一的 那就求这样的子数组有多少个 那就在前后找 他上一个和下一个相同元素 这中间的所有数的子数组个数 就是贡献度

预处理这个字符的前后的相同的字符的位置 然后再用乘法原理算出来相同子数组的个数  注意这里的子数组是类子串而不是类子序列

```py
class Solution:
    def uniqueLetterString(self, s: str) -> int:
        n = len(s)
        res = 0
        m = {}
        l = [0] * n
        r = [0] * n
        for i in range(n):
            x = s[i]
            l[i] = m.get(x, -1)
            m[x] = i
        m.clear()
        for i in range(n - 1, -1, -1):
            x = s[i]
            r[i] = m.get(x, n)
            m[x] = i
        
        res = sum((i - a) * (b - i) for i, (a, b) in enumerate(zip(l, r)))
        return res
```

## [907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27)

贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 

一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n

要找这样的数 每个数的前后比他更小的  就用单调栈

从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 

此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界

```py
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        mod = 10 ** 9 + 7
        n = len(arr)
        left, right = [-1] * n, [n] * n
        st = []
        i = 0
        for i, x in enumerate(arr):
            while st and arr[st[-1]] <= x:
                right[st.pop()] = i
            if st:
                left[i] = st[-1]
            st.append(x)
        res = sum(a * (i - l) * (r - i) for i, (l, r) in enumerate(zip(left, right)))
        return res
```

## 2477. 到达首都的最少油耗 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/)

计算每条边的贡献 到首都的人数是固定的 每个人要走的边也是固定的 因此可以用贡献法直接计算出每条边会有多少人经过 然后再把这个贡献 // 车载数 就可以得到这条边上要消耗的油量 然后把所有边加起来就行

```py
class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
    g = defaultdict(list)
    for a, b in roads:
        g[a].append(b)
        g[b].append(a)
    
    ans = 0
    # 令dfs返回这条路的人数
    def dfs(x, fa):
        # 每条路至少有端点这一个人走
        ret = 1
        for y in g[x]:
            if y != fa:
                nonlocal ans
                t = dfs(y, x)
                ans += (t - 1) // seats + 1
                # 现在ret 就是这个点到终点的人数 （注意一个点可通向多个点 有多个终点 这些终点是不算在这个ret里的 而是算在fa的ret里）
            	ret += t
        return ret
	dfs(0, -1)
    return ans
                
```

## [979. 在二叉树中分配硬币 - 力扣（LeetCode）](https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/)

类似于贡献法 算出棵子树的硬币总数 和结点数 就可以算出 有多少硬币要移出这棵子树  然后就可以算出 有多少硬币要移出这个子树的边![image-20231206230837411](../images/$%7Bfiilename%7D/image-20231206230837411.png)



```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def distributeCoins(self, root: Optional[TreeNode]) -> int:
        ans = 0
        # 返回硬币数和结点数
        def dfs(root:TreeNode) -> (int, int):
            if root is None:
                return (0, 0)
            l_c, l_n = dfs(root.left)
            r_c, r_n = dfs(root.right)
          	coin = l_c + r_c + root.val
            node = l_n + r_n + 1
            nonlocal ans
            ans += abs(coin - node)
            return (coin, node)
        dfs(root)
        return 
```

# 单调栈



## [907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/?envType=daily-question&envId=2023-11-27)

贡献法 求每个数能为答案贡献多少度 那就要看 他在几个子数组里是最小值 那就分别去找 这个数两边 是不是有比他更小的数 

一个数能提供的度数 就是a * （i - l）*（r - i） 其中l， r 为他左右比他更小的数的下标 没有就是-1 或 n

要找这样的数 每个数的前后比他更小的  就用单调栈

从左往右 放入数  一旦遇到比栈顶小的 就pop 直到比栈顶大或栈为空 放入元素 更新下标 

此时 把栈顶踢出的（i）是栈顶的右边界   而最终停止pop后 如果栈顶有元素（说明是比i小的）就是i的左边界

```py
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        mod = 10 ** 9 + 7
        n = len(arr)
        left, right = [-1] * n, [n] * n
        st = []
        i = 0
        for i, x in enumerate(arr):
            while st and arr[st[-1]] <= x:
                right[st.pop()] = i
            if st:
                left[i] = st[-1]
            st.append(x)
        res = sum(a * (i - l) * (r - i) for i, (l, r) in enumerate(zip(left, right)))
        return res
```

## [2454. 下一个更大元素 IV - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-iv/description/)

要找到下下个更大的元素   其实就是用单调栈  一个单调栈用于找下一个更大的元素  两个单调栈就可以找下下个更大的元素

st1存放 (暂时没找到比他大的)元素   st2存放(已经有一个比他大)的元素

每次先判断当前元素x 是否大于st2中的元素 如果是  就直接更新ans

然后判断有多少个st1中的数可以被更新到st2

```py
class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n = len(nums)
        st1 = []
        st2 = []
        ans = [-1] * n
        for i, x in enumerate(nums):
            while st2 and nums[st2[-1]] < x:
                ans[st2.pop()] = x
            j = len(st1) - 1
            while j >= 0 and nums[st1[j]] < x:
                j -= 1
            st2 += st1[j + 1:]
            del st1[j + 1:]
            st1.append(i)
        return ans
```

## [1673. 找出最具竞争力的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/)

主要是没看出来是用单调栈的题目 

一般来说需要从小到大（比如每日温度那个题）就是用单调栈

这个题目就满足 为了取最小的数 需要小数放前面 大数放后面 而且要按照数组中出现的顺序 所以可以考虑用单调栈

特别的是 这个题还有数量要求 必须是k个数字

**那就设置last = n - k 表示pop的次数** 在单调栈循环内 如果pop超过了last次 后面就不再pop了 否则数量不够k个  在单调栈循环结束后 如果last大于0 表示超过了k个数 需要再pop掉last次 由于小的数字放越前面越好 所以pop肯定是越早越好 所以就是遇到可以pop的就pop 后面的次数不够了就直接push进来

然后注意这题单调栈里面放的是数 不是下标

```C++
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) 
    {
        int n = nums.size();
        int last = n - k;
        vector<int>st;
        for (int i = 0; i < n; i++)
        {
            while (!st.empty() && last > 0 && st.back() > nums[i])
            {
                st.pop();
                last--;
            }
        }
        while(last--)
            st.pop();
        return st;
    }
};
```

# 滑动窗口

## [2302. 统计得分小于 K 的子数组数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)

这题首先是个数学问题  当出现连续的子数组的时候 每次答案增加的数量是 **r - l + 1** 知道这个之后就好想到滑动窗口

```C++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, long long k) 
    {
        int n = nums.size();
        long long ans = 0L;
        int l = 0;
        long long sum = 0L;
        for (int r = 0; r < n; r++)
        {
            sum += nums[r];
            while (sum * (r - l + 1) >= k) 
            {
                sum -= nums[l++];
            }
            ans += r - l + 1;
        }
        return ans;

    }
};
```

# 图

## P5318 【深基18.例3】查找文献 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5318)

用vector<int>graph[N]存图 类似于defaultdict(list)

```C++
#include <bits/stdc++.h>

using namespace std;
const int N = 100010;
vector<int>graph[N];
int n, m;
bool vis[N];

void dfs(int x)
{
	vis[x] = true;
	cout << x << " ";
	for (int i = 0; i < graph[x].size(); i++)
	{
		if (!vis[graph[x][i]])
		{
			dfs(graph[x][i]);
		}
	}
}

void bfs(int x)
{
	queue<int>q;
	q.push(x);
	vis[x] = 1;
	while (!q.empty())
	{
		int a = q.front();
		q.pop();
		cout << a << " ";
		for (int i = 0; i < graph[a].size();i++)
		{
			if (!vis[graph[a][i]])
			{
				vis[graph[a][i]] = true;
				q.push(graph[a][i]);
			}
		}
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		int a, b;
		cin >> a >> b;
		graph[a].emplace_back(b);
	}
	for (int i = 1; i <= n; i++)
		sort(graph[i].begin(), graph[i].end());

	dfs(1);
	cout << endl;

	memset(vis, false, sizeof vis);

	bfs(1);
	cout << endl;
	return 0;
}
```

## [P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3916)

有向图求每个点能到达的编号最大的点

图论的经典做法  存反图然后从最大的点开始遍历他能到达的所有点 更新  后续如果这个点已经更新过了 就不再更新了

```C++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include <vector>
using namespace std;
const int N = 100010;
vector<int>fgraph[N];
int dis[N] = { 0 };

void dfs(int x, int d)
{
	if (dis[x] != 0)
		return;
	dis[x] = d;
	for (int i = 0; i < fgraph[x].size(); i++)
	{
		dfs(fgraph[x][i], d);
	}
}

int main()
{
	int n, m;
	cin >> n >> m;
	while (m--)
	{
		int u, v;
		cin >> u >> v;
		fgraph[v].push_back(u);
	}
	for (int i = n; i >= 0; i--)
	{
		dfs(i, i);
	}
	for (int i = 1; i <= n; i++)
	{
		cout << dis[i] << " ";
	}
}
```

## [P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1113)

经典拓扑+动态规划

把前面的杂物干完才能干后面的事  拓扑排序

并且加上了动态规划（有点类似dijkstra）   完成所有杂物的最短时间 每次循环更新 到u这个任务需要的最短时间 （即f[u] = max(f[u], f[x] + t[u]）到u的最短 即到源点到x的最短加上到x到u的最短

```python
#include <bits/stdc++.h>
using namespace std;
const int N = 500500;

vector<int>graph[N];
int deg[N];
int f[N];
int t[N];
int main()
{
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		int u, v;
		cin >> u >> t[i];
		while (cin >> v && v)
		{
			graph[v].push_back(u);
			deg[u]++;
		}
	}
	queue<int>q;
	for (int i = 1; i <= n; i++)
	{
		if (deg[i] == 0)
		{
			q.push(i);
			f[i] = t[i];
		}
	}
	while (!q.empty())
	{
		int x = q.front();
		q.pop();

		for (int i = 0; i < graph[x].size(); i++)
		{
			int u = graph[x][i];
			deg[u]--;
			if (deg[u] == 0)
			{
				q.push(u);
			}
			f[u] = max(f[u], f[x] + t[u]);
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		ans = max(ans, f[i]);
	}
	cout << ans << endl;
}
```

## [P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4017)

求食物链的数量（食物链必须到最高消费者 即不被捕食的动物 即出度为0的）

拓扑排序+动态规划 

比如a->b->c   每次更新时 nums[b] = nums[b] + nums[a] 把到第a的食物链条数全部累加到b中  最后把出度为0的点的条数加上 即为答案

```C++
#define _CRT_SECURE_NO_WARNINGS
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
const int mod = 80112002;
vector<int>graph[N];
int deg[N], out[N], nums[N];
int main()
{
	int n, m;
	cin >> n >> m;
	int a, b;

	while (m--)
	{
		cin >> a >> b;
		graph[a].push_back(b);
		deg[b]++;
		out[a]++;
	}
	queue<int>q;

	for (int i = 1; i <= n; i++)
	{
		if (deg[i] == 0)
		{
			q.push(i);
			nums[i] = 1;
		}
	}

	while (!q.empty())
	{
		int x = q.front();
		q.pop();
		for (int i = 0; i < graph[x].size(); i++)
		{
			int u = graph[x][i];
			deg[u]--;
			if (deg[u] == 0)
			{
				q.push(u);
			}
			nums[u] = (nums[u] + nums[x]) % mod;
		}

	}
	long long ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (out[i] == 0)
		{
			ans = (nums[i] + ans)%mod;
		}
	}
	cout << ans;
}
```

## [P1807 最长路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1807)

最长路问题   还是动态规划  d[i] = max(d[x]  + mp[x ] [ i ], d[i])

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
using namespace std;
const int N = 2000, M = 55000;
int n, m;
int d[N], mp[N][N];

int main()
{
	memset(d, -1, sizeof d); 
	d[1] = 0;
	cin >> n >> m;
	int u, v, w;
	while (m--)
	{
		cin >> u >> v >> w;
		mp[u][v] = max(mp[u][v], w);
	}

	queue<int>q;
	q.push(1);
	while (!q.empty())
	{
		int x = q.front();
		q.pop();
		for (int i = 1; i <= n; i++)
		{
			if (mp[x][i] && d[i] < d[x] + mp[x][i])
			{
				d[i] = d[x] + mp[x][i];
				q.push(i);
			}

		}
	}

	cout << d[n] << endl;

}
```

## [P2853 [USACO06DEC\] Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2853)

求有几个地方 是所有的奶牛都可以的到达的

那每次走过的时候次数+1  当all[x] == k 的时候就代表这个点都可以到达

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m, k;
int a[N], vis[N], all[N];
vector<int>graph[N];

void dfs(int x)
{
	if (vis[x] != 0)
		return;
	vis[x] = 1;
	all[x] += 1;
	for (int i = 0; i < graph[x].size(); i++)
	{
		int y = graph[x][i];
		if (vis[y] == 0)
			dfs(y);
	}
}

int main()
{
	cin >> k >> n >> m;
	for (int i = 1; i <= k; i++)
		cin >> a[i];
	for (int i = 1; i <= m; i++)
	{
		int a, b;
		cin >> a >> b;
		graph[a].push_back(b);
	}
	for (int i = 1; i <= k; i++)
	{
		dfs(a[i]);
		memset(vis, 0, sizeof vis);
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (all[i] == k)
			ans += 1;
	}
	cout << ans;
}
```

## [P1363 幻象迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1363)

无线的地图 那么只要它能够回到原点 就说明可以从一个点到另一个点  就可以无限走 就符合题意

用vis储存横纵坐标和是否访问  

每次进入先判断该点（是取模过的点 ***）是否已经访问过  如果访问过 并且x， y跟之前的不一样（只要有一个不一样就行）那就说明走到了另一个地图的原点 说明可以无限

如果访问过 并且是回到了原点 那就退回

标记该点为已访问 像四个方向拓展  lx和ly用来记录是否走出  要取模

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
using namespace std;
int m, n, sx, sy, dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 }, ans = 0;
const int N = 1510;
bool graph[N][N] = { false };
int vis[N][N][3] = { 0 };
void dfs(int x, int y, int lx, int ly)
{
	if (vis[lx][ly][2] && (vis[lx][ly][0] != x || vis[lx][ly][1] != y))
	{
		ans = 1;
		return;
	}

	if (vis[lx][ly][2] && vis[lx][ly][0] == x && vis[lx][ly][1] == y)return;
	vis[lx][ly][0] = x; vis[lx][ly][1] = y; vis[lx][ly][2] = 1;
	int nx, ny;
	for (int w = 0; w < 4; w++)
	{
		nx = (lx + dx[w] + n) % n;
		ny = (ly + dy[w] + m) % m;
		if (graph[nx][ny])dfs(x + dx[w], y + dy[w], nx, ny);
	}
	
}
int main()
{
	char c;
	while (cin >> n >> m)
	{
		memset(vis, false, sizeof(vis));
		memset(graph, false, sizeof(graph));
		ans = 0;

		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < m; j++)
			{
				cin >> c;
				if (c == '.')graph[i][j] = true;
				else if (c == 'S')
				{
					sx = i, sy = j;
					graph[i][j] = true;
				}
				else graph[i][j] = false;
			} 
		}
		dfs(sx, sy, sx, sy);
		if (ans)puts("Yes");
		else puts("No");
	}
}
```

## [省份数量]([547. 省份数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-provinces/?envType=study-plan-v2&envId=graph-theory))

```python
# dfs 用一个标记数组记下已经访问过的城市 然后遍历所有的城市 每一次dfs都可以遍历一个省份的所有城市
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
		cities = len(isConnected)
        province = 0
        vis = [0] * cities

        def dfs(i):
            for j in range(cities):
                if not vis[j] and isConnected[i][j] == 1:
                    vis[j] = 1
                    dfs(j)

        for i in range(cities):
            if not vis[i]:
                vis[i] = 1
                province += 1
                dfs(i)

        return province
    
   # 也可用并查集 对每个点查找祖先结点 合并 最后有几个祖先结点就有几个省份 
# 重点在并查集的写法
		uf = UnionFind()
        for i in range(len(isConnected)):
            uf.add(i)
            for j in range(i):
                if isConnected[i][j] == 1:
                    uf.merge(i,j)
        return uf.num_of_sets

class UnionFind:
    def __init__(self):
        self.father = {}
        self.num_of_sets = 0

    def find(self,x):
        root = x
        while self.father[root] != None:
            root = self.father[root]
		# 让并查集更宽 减少时间复杂度
        while x != root:
            original_father = self.father[x]
            self.father[x] = root
            x = original_father
        return root

    def merge(self,x,y):
        root_x, root_y = self.find(x),self.find(y)

        if root_x != root_y:
            self.father[root_x] = root_y
            self.num_of_sets -= 1

    def add(self,x):
        if x not in self.father:
            self.father[x] = None
            self.num_of_sets += 1

```

## [找到最终的安全状态]([802. 找到最终的安全状态 - 力扣（LeetCode）](https://leetcode.cn/problems/find-eventual-safe-states/?envType=study-plan-v2&envId=graph-theory))

```python
"""
所有结点都通向终端结点的结点为安全结点，只要没有环的话，那所有结点肯定都是通向终端结点的，所以题目就是求出所有不组成环的结点
"""

"""
dfs 深搜找环 用三色标记法，未访问为0，还处于递归栈中或在环上为1，搜素完毕是安全结点为2
一开始全为0，开始搜索，搜到的0标记为1，当搜索到的是1，说明遇到环了，此时退出。当没有搜到环 在退出dfs前，将标记改为2，表示安全
""" 
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
		n = len(graph)
        color = [0] * n
        
        def safe(x: int)->bool:
            # 访问已经搜过的结点 1为有环 2为无环
            if color[x] > 0:
                return color[x] == 2
            # 如果是0
            color[x] = 1
            for y in graph[x]:
                # 快速退出
                if not safe(y):
                    return False
            # 如果上面检测了都没有环 那么就说明该结点无环 标记为2并返回True
            color[x] = 2
            return True
       	
        return [i for i in range(n) if safe(i)]
    
    
    """
    拓扑排序 拓扑排序可以用来判环，如果一个结点没有出边那么就是安全的（终端）如果一个结点的出边连接的结点是安全的，那该结点也是安全的
    那么可以把图的所有边反向，得到一个反图，再在反图上拓扑排序
    循环结束后 所有入度为0的结点都是安全的
    意思是，原图的出度为0的结点，和指向出度为0的结点的结点
    （由于存了反图并拓扑排序
    """
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
		rg = [[] for _ in graph]
        # 如 graph[0] = [1,2] 0指向1 2反向：  x = 0 ys = [1,2] 让1指向0 2 指向0
        for  x, ys in enumerate(graph):
			for y in ys:
				rg[y].append(x)
        # in_deg 表示入度 值为graph的每个数组的长度（即每个点的出度）（就是反图的入度）
        in_deg = [len(ys) for ys in graph]
        
        q = deque([i for i, d in enumerate(in_deg) if d == 0])
		while q:
            for x in rg[q.popleft()]:
                in_deg[x] -= 1
                if in_deg[x] == 0:
                    q.append(x)
        return [i for i, d  in enumerate(in_deg) if d == 0]
```

## [ 颜色交替的最短路径 ](https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 其实就是双源bfs（边权为1 可以直接用单源的算法 初始化加上另一个源点） 并且每次只能交替走颜色不同的路 用邻接矩阵来储存图 储存点是否访问等 用点对 第二个参数表示颜色
class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        g = [[] for _ in range(n)]
        for x, y in redEdges:
            g[x].append((y,0))
        for x, y in blueEdges:
            g[x].append((y,1))
        

        dis = [-1] * n
        vis = {(0,0),(0,1)}
        q = {(0,0),(0,1)}
        level = 0
        while q:
            tmp = q
            q = []
            for x, color in tmp:
                if dis[x] == -1:
                    dis[x] = level
                for p in g[x]:
                    if p[1] != color and p not in vis:
                        vis.add(p)
                        q.append(p)
            level += 1
        return dis
```

## [通知所有员工所需的时间 ](https://leetcode.cn/problems/time-needed-to-inform-all-employees/solutions/2251785/tong-zhi-suo-you-yuan-gong-suo-xu-de-shi-503h/)

```python
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        g = collections.defaultdict(list)
        for i in range(n):
            g[manager[i]].append(i)

        q = collections.deque()
        q.append((headID, 0))
        res = 0
        while q:
            tid, val = q.popleft()
            if len(g[tid]) == 0:
                res = max(res, val)
            else:
                for ne in g[tid]:
                    q.append((ne, val + informTime[tid]))
        return res
```

## [1466. 重新规划路线 - 力扣（LeetCode）](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 这个题要找 到0的路线 先用defaultdict建图 正向记为1反向记为0 然后bfs 
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        res = 0
        g = defaultdict(list)
        for a, b in connections:
            g[a].append((b, 1))
            g[b].append((a, 0))
        
        q = deque([0])
        vis = [False] * n
        while q:
            cur = q.popleft()
            # 遍历所有和cur相邻的边
            for end, dirction in range(g[cur]):
                if not vis[end]:
                    vis[end] = True
                    # 如果方向不对就反转
                    res += dirction
                    q.append(end)
        return res
    
    
# 或者 用set一次遍历  有点问题
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        s = {0}
        res = 0
        for l, r in connection:
            if r in s:
                s.add(l)
            # 右边不通向0 并且左边通向0 （左边通向右边） 那就让r->l r就可以到0
            elif l in s:
                s.add(r)
                res += 1
        return res
                
        
```

## [1192. 查找集群内的关键连接 - 力扣（LeetCode）](https://leetcode.cn/problems/critical-connections-in-a-network/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 用Tarjan算法 标记图中的所有环 然后把所有环和环外链接线加入答案 因为环内肯定不存在关键路径 只有在环与非环的链接处 或者所有的非环之间 才有关键路径
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        for con in connections:
            graph[con[0]].append(con[1])
            graph[con[1]].append(con[0])

        
        idx = [-1] * n
        res = []

        def dfs(curnode, curid, parent):
            idx[curnode] = curid

            for nextnode in graph[curnode]:
                if nextnode == parent:
                    continue
                elif idx[nextnode] == -1:
                    idx[curnode] = min(dfs(nextnode,curid + 1, curnode),idx[curnode])
                else:
                    idx[curnode] = min(idx[curnode],idx[nextnode])

            # 说明存在环 （此时的curnode为入口结点）
            if idx[curnode] == curid and curnode != 0:
                res.append((parent, curnode))
            # 记得返回idx
            return idx[curnode]
        

        dfs(0,0,-1)
        return res
```

## [934. 最短的桥 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 两座相同的岛 先找到第一个不为0的数然后dfs标记这个岛的全部，然后用bfs搜索当第一次搜到第二个岛的step即是答案，注意dfs的时候要把第一个岛全部放入q（因为每个点都可能是距离第二个岛最近的点）搜完上下左右一圈后step + 1 （不需要vis数组记录 直接把走过的设为-1即可）
class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        def dfs(x, y):
            grid[x][y] = -1
            q.append((x, y))
            for nx, ny in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):
                if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:
                    dfs(nx, ny)

        n = len(grid)
        q = deque()
        i, j = next((i, j) for i in range(n) for j in range(n) if grid[i][j])
        dfs(i, j)
        step = 0

        while True:
            for _ in range(len(q)):
                x, y = q.popleft()
                for nx, ny in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):
                    if 0 <= nx < n and 0 <= ny < n :
                        if grid[nx][ny] == 1:
                            return step
                        if grid[nx][ny] == 0:
                            grid[nx][ny] = -1
                            q.append((nx, ny))
            step += 1
```

## [127. 单词接龙 - 力扣（LeetCode）](https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=graph-theory)

```python
# 每次枚举26个字母 一一替换单词 直到找到wordList的单词 如果是end的话就直接返回 否则step+1放入q继续bfs
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if beginWord == endWord:
            return 0
        wordList = set(wordList)
        if endWord not in wordList:
            return 0
        
        word = [chr(i) for i in range(97, 123)]
        q = deque([(beginWord, 1)])
        while q:
            cur, step = q.popleft()
            for i, x in enumerate(cur):
                for y in word:
                    if x != y:
                        nxt = cur[:i] + y + cur[i + 1:]
                        if nxt in wordList:
                            if nxt == endWord:
                                return step + 1
                            q.append((nxt, step + 1))
                            wordList.remove(nxt)
        return 0
```

## [126. 单词接龙 II - 力扣（LeetCode）](https://leetcode.cn/problems/word-ladder-ii/description/)

```python
# 这个方法相当于是每次把step=1的所有数都找出来并且加进去 把所有step=2的都找出来加进去这样（"hit","hot","dot" and "hit","hot","lot"）     当q（内层）取完之后表示当前步数可以链接的下一个单词已经全部找到 可以step+1 然后把s中暂存的给q 再次循环    直到end 加入答案 （当内层q为0的时候表示所有路径都已经加进去 就直接return） 当q（外层）取完（也就是sq交换的时候s为[]）之后表示所有路径都已经走过 但是还没有遇到end 这时返回[]
# 首先 建图方面 建立这个单词可以变的其他单词 变化处用* 表示 用defaultdict后面可以快速访问 
# 然后q用来存储当前值和当前路径 s与q相同 但是s是用来存储每轮的数据 每次开始时s都为[] （保证数据 相当于temp）
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        wordList = set(wordList)
        if endWord not in wordList:
            return []
        dic = defaultdict(list)
        n = len(beginWord)
        for w in wordList:
            for i in range(n):
                dic[w[:i] + '*' + w[i + 1:]].append(w)
        
        q, s = [(beginWord, [beginWord])], []
        res = []
        vis = set()
        while q:
            while q:
                w, path = q.pop()
                vis.add(w)
                if w == endWord:
                    res.append(path)
                for i in range(n):
                    for nxt in dic[w[:i] + '*' + w[i + 1:]]:
                        if nxt not in vis:
                            s.append((nxt, path + [nxt]))
            if res:
                return res
            q, s = s, q
        return []
```

## [542. 01 矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/01-matrix/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 多起点的最短路问题 可以将所有的0 看成同一个源点 然后使用bfs 因为每次扩散一轮 所有的都加一时候再扩散下一轮（队列 先进先出）每次只需要搜索四个方向 然后再原来的ret的基础上加一
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        n, m = len(mat), len(mat[0])
        ret = [[-1] * m for _ in range(n)]
        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        q = deque()
        for i in range(n):
            for j in range(m):
                if mat[i][j] == 0:
                    ret[i][j] = 0
                    q.append([i,j])
        
        while q:
            i, j = q.popleft()
            for k in range(4):
                ni, nj = i + dx[k], j + dy[k]
                if 0 <= ni < n and 0 <= nj < m and ret[ni][nj] == -1:
                    ret[ni][nj] = ret[i][j] + 1
                    q.append([ni, nj])

        return ret
```

## [863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/?envType=study-plan-v2&envId=graph-theory)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        # 首先用字典node_parent存储每个结点的父节点
        node_parent = dict()

        def dfs_find_parent(node: TreeNode) -> None:
            if node is None:
                return 
            if node.left:
                node_parent[node.left] = node
            if node.right:
                node_parent[node.right] = node
            dfs_find_parent(node.left)
            dfs_find_parent(node.right)


        dfs_find_parent(root)
        if k == 0:
            return [target.val]
        res = []

        q = deque()
        vis = set()
        q.append(target)
        vis.add(target)
        # 现在依次遍历和target距离为level的结点（波纹法 一层层搜索）
        level = 0
        while q and level < k:
            level += 1 # 先加还是后加取决于level初值
            for _ in range(len(q)):
                x = q.popleft()
                for y in [node_parent[x] if x in node_parent else None, x.left, x.right]: # 遍历和当前点相邻的所有结点（每次搜索一层 注意要用set判重）
                    if y and y not in vis:
                        if level == k:
                            res.append(y.val)
                        q.append(y)
                        vis.add(y)
        return res

                
```

## [864. 获取所有钥匙的最短路径 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/?envType=study-plan-v2&envId=graph-theory)

```python
# 不同之处在于 并不是一个点只能走一次 而是可以多次走 找到最短的路
class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        n = len(grid)
        m = len(grid[0])
        cnt = 0
        # dis 用于记录每个点走的距离 不同的是 现在有3个状态 多了一个钥匙数的状态 
        dis = defaultdict(lambda: 0x3f3f3f3f)
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] == '@':
                    q = deque([(i, j, 0)])
                    dis[(i, j, 0)] = 0
                elif grid[i][j].islower():
                    cnt += 1


        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        
        
        while q:
            i, j, cur = q.popleft()
            step = dis[(i,  j, cur)]
            for k in range(4):
                ni, nj = i + dx[k], j + dy[k]
                if 0 <= ni < n and 0 <= nj < m:
                    c = grid[ni][nj]
                    if c == '#':
                        continue
                    # 先将cur右移c位然后&1判断是否为1
                    if 'A' <= c <= 'Z' and (cur >> (ord(c) - ord('A')) & 1) == 0:
                        continue
                    ncur = cur
                    if 'a' <= c <= 'z':
                        # 标记为已有
                        ncur |= (1 << ord(c) - ord('a'))
                    if ncur == (1 << cnt) - 1:
                        return step + 1
                    # 如果曾经走到过这里 并且步数更少的话 更新 （如果没有走到过的话 那就是0x3f3f3f3f 必定更新）
                    if step + 1 < dis[(ni, nj, ncur)]:
                        dis[(ni, nj, ncur)] = step + 1
                        q.append((ni, nj, ncur))
        
        return -1

```

## [1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

题目要求一个城市在距离小于distanceThreshold下能够到达的城市

可以直接求 对每个城市进行搜索 也可以直接用Floyd 算法求出每两个城市之间的距离 再找距离小于dis的



```py
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        graph = [[inf] * n for _ in range(n)]
        for a, b, w in edges:
            graph[a][b] = graph[b][a] = w
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
        
        ans = min_cnt = 0
        for i in range(n):
            cnt = 0
            for j in range(n):
                if j != i and graph[i][j] <= distanceThreshold:
                    cnt += 1
            if cnt <= min_cnt:
                min_cnt = cnt
                ans = i
        return ans
```

## [2646. 最小化旅行的价格总和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/)

树形DP  要算所有的路径  的总和可以先暴力DFS算出所有的路径的**贡献**：也就是比如0-1-2中求(0,2)(1,2) 那么1-2 算了两次 这样求出所有边走的次数cnt[x]

遍历(start, end) 求cnt

然后知道每个边的 次数之后再用树形DP（打家劫舍3）求出最小值   每个点减或不减

```py
class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        cnt = [0] * n
        for start, end in trips:
            def dfs(x:int, fa:int) -> bool:
                if x == end:
                    cnt[x] += 1
                    return True
                for y in g[x]:
                    # dfs(y) 是为了说明这是可以到end的路(到end之后再往回更新cnt)
                    if y != fa and dfs(y):
                        cnt[x] += 1
                        return True
                return False
        	dfs(start, -1)
        
       	# 现在就得到了走的边的次数 再加上已知点的权值 用树形DP求
        def dfs(x:int, fa:int) -> (int, int):
            now_not_halve = price[x] * cnt[x]
            now_halve = price[x] * cnt[x] // 2
            for y in g[x]:
                if y != fa:
                    kid_not_halve, kid_halve = dfs(y, x)
                    now_not_halve += min(kid_not_halve, kid_halve)
                    now_halve += kid_not_halve
            return now_not_halve, now_halve
        return min(dfs(0, -1))
        
                        
```

## [1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/)

看起来像DP但是其实是图论的题  为什么呢  因为dp只能向一个方向更新 比如只能一直向下 选择 [i + 1] [j - 1] 、[i + 1] [j] 、[i + 1] [j + 1] 这三种 但是这个题明显就是有4个方向 类似BFS

## 方法一、 二分+BFS

二分可能的最大差异值 用bfs计算 如果最大差异大于x则...

注意这里维护的是最大差异  每次当更新的时候如果差异值小于x才更新 最终如果能到达右下角说明这个x可以

```py
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n, m = len(heights), len(heights[0])
        l, r = 0, 10**6+10
        def bfs(mid):
            dx = [0, 1, 0, -1]
            dy = [1, 0, -1, 0]
            q = deque()
            q.append((0, 0))
            minn = maxn = heights[0][0]
            vis = [[False] * m for i in range(n)]
            vis[0][0] = 1
            while q:
                x, y = q.popleft()

                for i in range(4):
                    nx = x + dx[i]
                    ny = y + dy[i]
                    if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny] and abs(heights[x][y] - heights[nx][ny]) <= mid:
                        vis[nx][ny] = 1
                        q.append((nx, ny))

            return vis[n - 1][m - 1]
```

## 方法二、并查集

其实是Kruskal算法  对所有边排序之后 不断添加边 同时维护最大差异值 直到左上角和右下角联通 

```py
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n, m = len(heights), len(heights[0])
        def find(x):
            if fa[x] == x:
                return x
            fa[x] = find(fa[x])
            return fa[x]
        def union(x, y):
            fa[find(x)] = find(y)

        edgelen = []
        fa = [i for i in range(n * m)]
        for i in range(n):
            for j in range(m):
                pos = i * m + j
                if i < n - 1:
                    edgelen.append([abs(heights[i + 1][j] - heights[i][j]), pos, pos + m])
                if j < m - 1:
                    edgelen.append([abs(heights[i][j + 1] - heights[i][j]), pos, pos + 1])
        
        edgelen.sort()
        for e in edgelen:
            union(e[1], e[2])
            if find(0) == find(m * n - 1):
                return e[0]
        return 0
```

## 方法三、最短路

Dijikstra算法  只不过本来维护最短距离  现在维护最大差异 本来是存边  现在不需要存边 直接用BFS

```py
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n, m = len(heights), len(heights[0])
        q = [(0, 0, 0)]
        dis = [inf] * (m * n)
        dis[0] = 0
        vis = set()
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        while q:
            d, x, y = heapq.heappop(q)
            pos = x * m + y
            if pos in vis:
                continue
            if (x, y) == (n - 1, m - 1):
                break
            vis.add(pos)
            
            for i in range(4):
                nx = dx[i] + x
                ny = dy[i] + y
                if 0 <= nx < n and 0 <= ny < m and max(d, abs(heights[x][y] - heights[nx][ny])) <= dis[nx * m + ny]:
                    dis[nx * m + ny] = max(d, abs(heights[x][y] - heights[nx][ny]))
                    heapq.heappush(q, (dis[nx * m + ny], nx, ny))
        return dis[m * n - 1]

```

## [1345. 跳跃游戏 IV - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-iv/)

BFS 但是要分情况 主要是存图要用map存 map[arr[i]].push_back(i);

```C++
class Solution {
public:
    int minJumps(vector<int>& arr) 
    {
        unordered_map<int, vector<int>>mp;
        for (int i = 0; i < n; i++)
        {
            mp[arr[i]].push_back(i);
        }
        const int inf = 0x3f3f3f3f;
        queue<int>q;
        vector<int>dist(n, inf);
        q.push(0);
        dist[0] = 0;
        while (!q.empty())
        {
            int x = q.front(), step = dist[x];
            q.pop();
            if (x == n - 1)return step;
            if (x + 1 < n && dist[x + 1] == inf)
            {
                dist[x + 1] = step + 1;
                q.push(x + 1);
            }
            if (x - 1 >= 0 && dist[x - 1] == inf)
            {
                dist[x - 1] = step + 1;
                q.push(x - 1);
            }
            for (auto y : mp[arr[x]])
            {
                if (dist[y] == inf)
                {
                    dist[y] = step + 1;
                    q.push(y);
                }
            }
            mp[arr[x]].clear();
        }
        return -1;
    }
};
```

## [1207. 大臣的旅费 - AcWing题库](https://www.acwing.com/problem/content/description/1209/)

求树的直径问题

要求相距最远的两个城市 也就是求树的直径 

先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径

用dis记录任意点到i点的最远距离

dfs中需要添加father 防止回头

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n ;
int w[N] , e[N] , ne[N] , h[N] , idx ;
int maxu , maxd ;
int dis[N];
void add(int a , int b , int c )
{
    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;
}
void dfs(int u , int fa , int d)
{
    dis[u] = d;
    for(int i = h[u] ; i != -1 ; i = ne[i])
    {
        int j = e[i];
        if(j != fa)
            dfs(j,u,d + w[i]);
    }
}
int main()
{
    cin >> n ;
    memset(h,-1,sizeof h);
    for (int i = 0; i < n; i++)
    {
        int a , b , c ;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,-1,0);
    for (int i = 1 ; i <= n; i++)
    {
        if (dis[maxu] < dis[i]) 
        {   
            maxu = i;
            maxd = dis[maxu];
        }
    }
    
    dfs(maxu,-1,0);
    for (int i = 1 ; i <= n; i++)
    {
        if (dis[maxu] < dis[i]) 
        {   
            maxu = i;
            maxd = dis[maxu];
        }
    }
    cout << maxd * 10 + (maxd + 1ll) * maxd / 2 << endl ;
    return 0;
}

```

