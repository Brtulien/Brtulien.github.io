---
title: 赛题题解
date: 2023-09-24 10:17:32
tags: Ans
---

# [Problem - C - Codeforces](https://codeforces.com/contest/1873/problem/C)

先给每一圈赋一个权重dis

算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int dis[5] = {1, 2, 3, 4, 5};
void solve()
{
    vector<string> nums;
    int n = 10;
    while (n--)
    {
        string s;
        cin >> s;
        nums.emplace_back(s);
    }
    ll res = 0;
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (nums[i][j] == '.')
                continue;
            else
            {
                res += dis[min(min(i, j), min(9 - i, 9 - j))];
            }
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```



# [Problem - E - Codeforces](https://codeforces.com/contest/1873/problem/E)

赛时调了半天没调出来，寄，害的F也没调出来/kk 

二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 2e5 + 10;
int nums[N];
int n, m;
bool check(int mid)
{
    ll res = 0;
    for (int i = 0; i < n; i++)
    {
        if (mid - nums[i] >= 0)
            res += (mid - nums[i]);
        if (res > m)
            return false;
    }
    return true;
}

void solve()
{

    cin >> n >> m;
    memset(nums, 0, sizeof(nums));
    ll l = 1, r = 2e9 + 1;
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    int res = 1, mid;

    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (check(mid))
        {
            res = mid;
            l = mid + 1;
        }
        else
        {

            r = mid - 1;
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - G - Codeforces](https://codeforces.com/contest/1873/problem/G)

AB->BC BA->CB

那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 

如果有两个B连在一起的话只可能是B..BB...B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B 

如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int n;
    cin >> n;
    while (n--)
    {
        string s;
        cin >> s;
        bool flag = false;
        ll sum = 0;
        int n = s.size();
        int cnt = 0;
        int minn = 1e9 + 7;
        if (s[0] == 'B' || s[n - 1] == 'B')
            flag = true;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == 'A')
                sum++, cnt++;
            else if (s[i] == 'B')
            {
                minn = min(minn, cnt);
                cnt = 0;
                if (i + 1 < n && s[i + 1] == 'B')
                    flag = true;
            }
        }
        minn = min(minn, cnt);
        if (flag)
        {
            cout << sum << endl;
        }
        else
        {
            if (minn != 1e9 + 7)
                cout << sum - minn << endl;
            else
                cout << 0 << endl;
        }
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - H - Codeforces](https://codeforces.com/contest/1873/problem/H)

寻找基环树（套路）因为这个题不仅要判断环 而且需要储存

```c++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n, a, b; // a is M b is V
    cin >> n >> a >> b;
    vector<vector<int>> graph(n + 1);
    // 存无向图
    for (int i = 0; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        graph[u].pb(v);
        graph[v].pb(u);
    }
    if (a == b)
    {
        cout << "NO" << endl;
        return;
    }
    vector<int> incircle(n + 1, 0), vis(n + 1, 0), pre(n + 1, 0);
    bool ok = false;
    
    function<void(int, int)> dfs = [&](int u, int fa)
    {
        for (int v : graph[u])
        {
            if (ok)
                return;
            if (v == fa)
                continue;
            if (vis[v]) // 第二次经过代表有环
            {
                ok = true;
                incircle[v] = 1; // 标记在环上
                int x = u;
                do
                {
                    incircle[x] = 1;
                    x = pre[x];
                } while (x != v); // 标记环上的所有点
            }
            else
            {
                vis[v] = 1;
                pre[v] = u;
                dfs(v, u);
            }
        }
    };
    vis[1] = 1;
    dfs(1, 0);
    // 如果已经在环上了
    if (incircle[b]) 
    {
        cout << "YES" << endl;
        return;
    }
    int goal = -1, gdis = -1;
    queue<PII> q;
    // 清空vis数组
    vis.assign(n + 1, 0);
    q.push({b, 0});
    vis[b] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (incircle[v])
            {
                goal = v;
                gdis = dis + 1;
                goto end;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
end:;
    if (goal == a)
    {
        cout << "NO" << endl;
        return;
    }

    while (!q.empty())
    {
        q.pop();
    }
    int tdis = -1;
    vis.assign(n + 1, 0);
    q.push({a, 0});
    vis[a] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (v == goal)
            {
                tdis = dis + 1;
                if (tdis <= gdis)
                    cout << "NO" << endl;
                else
                    cout << "YES" << endl;
                return;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [5153. 删除 - AcWing题库](https://www.acwing.com/problem/content/5156/)

一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除
而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推
所以只需要枚举1 2 3 位数

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    string s;
    cin >> s;
    int n = s.size();
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '8')
        {
            cout << "YES" << endl;
            cout << "8" << endl;
            return 0;
        }
        if (s[i] == '0')
        {
            cout << "YES" << endl;
            cout << "0" << endl;
            return 0;
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            int a = ((s[i] - '0') * 10 + s[j] - '0');
            if (a % 8 == 0)
            {
                cout << "YES" << endl;
                cout << a << endl;
                return 0;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            for (int k = j + 1; k < n; k++)

            {
                int a = ((s[i] - '0') * 100 + (s[j] - '0') * 10 + s[k] - '0');
                if (a % 8 == 0)
                {
                    cout << "YES" << endl;
                    cout << a << endl;
                    return 0;
                }
            }
        }
    }
    cout << "NO" << endl;

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - D - Codeforces](https://codeforces.com/contest/1878/problem/D)

给出区间 然后反转 可以用差分 当这个下标被旋转奇数次的时候就需要旋转 被旋转偶数次的时候 就相当于没动 不用旋转 

每次旋转要找到唯一一个i 使得a[i] <= x && b[i] >= x 然后旋转a[i] b[i] 的元素 

可以用cnt（类似差分数组）记录x出现的次数   并且不需要根据x寻找第二行所说的那个区间 而是遍历区间 找到这个区间的x

遍历区间 然后取出子串 从left到mid依次与right到mid交换 （根据sum的奇偶来判断）sum就是当前位置和对称位被交换次数之和（累计   因为是差分）然后输出子串

```python
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n, k;
    string s;
    cin >> n >> k;
    cin >> s;
    vector<int> a(k), b(k);
    vector<int> cnt(n);
    for (int i = 0; i < k; i++)
        cin >> a[i], a[i]--;
    for (int i = 0; i < k; i++)
        cin >> b[i], b[i]--;
    int q;
    cin >> q;
    for (int i = 0; i < q; i++)
    {
        int x;
        cin >> x;
        cnt[x - 1]++;
    }

    for (int i = 0; i < k; i++)
    {
        string s1 = s.substr(a[i], b[i] - a[i] + 1);
        int sum = 0;
        int l = a[i];
        int r = b[i];
        for (int j = l; j <= (l + r) / 2; j++)
        {
            sum += cnt[j] + cnt[r - j + l];
            if (sum % 2)
                swap(s1[j - l], s1[r - j]);
        }
        cout << s1;
    }
    cout << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/description/)

按位与的结果只能越来越小 因此要求最小的按位与的子数组的和 就是全部与在一起的和 就是最小的 但是又特殊情况 就是 当全部的与为0时 可能中间有一部分已经为0了  这样就可以拆成很多个与为0的子数组   如果不为0  那必然整个数组的与就是最小值

```python
class Solution:
    def maxSubarrays(self, nums: List[int]) -> int:
        t = nums[0]
        n = len(nums)
        cnt = 0
        for i in range(1, n):
            if t == 0:
                cnt += 1
                t = nums[i]
            t&=nums[i]
        if t == 0:
            cnt += 1
        return cnt if cnt != 0 else 1
```

# [2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/2464559/javapython3cshen-du-you-xian-sou-suo-tan-3r78/)

由于题目说了 整棵树所有结点的和一定为k的倍数 那么从中取出一棵节点和为k的倍速的子树  剩下的部分的结点和一定也为k的倍数  

因此可以自底向上递归  每次找到一棵节点和为k的倍数的子树 就直接加入答案 

```python
class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        # 建树
        self.link = [[] for _ in range(n)]
        for s, e in edges:
            self.link[s].append(e)
            self.link[e].append(s)
        self.res = 1
        # 递归
        self.dfs(0, -1, values, k)
        return self.res
	
    
    	def dfs(self, node, parent, values, k):
            node_sum = values[node]
            for child in self.link[node]:
                # 因为建的是无向图 要去掉父节点
                if child == parent:
                    continue
                child_sum = dfs(child, node, values, k)
                if child_sum % k == 0:
                    self.res += 1
                else:
                    node_sum += child_sum
            return node_sum
```

# [100086. 有序三元组中的最大值 II - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/)

遍历j 算出j的前缀的最大值和j的后缀的最大值 因为求得是(nums[i] - nums[j]) * nums[k] 所以i k要尽量大

后缀就是从n - 1往前 求出每一个j值所对应的最大后缀  前缀同理

最后直接计算

```python
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        n = len(nums)
        surmax = [-1] * (n + 1)
        for i in range(n - 1, -1, -1):
            surmax[i] = max(surmax[i + 1], nums[i])
        premax = nums[0]
        ans = 0
        for i in range(n - 1):
            ans = max(ans, (surmax[i + 1] * (premax - nums[i])))
            premax = max(premax, nums[i])
        return ans 
```

# [100076. 无限数组的最短子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)

滑动窗口

子数组是连续的 要求最短的就是先看看 能凑成几个完整的原序列  然后再两个序列间 凑出剩余的

剩余的就用滑动窗口来算

```python
class Solution:
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        n = len(nums)
        total = sum(nums)
        nums = nums + nums
        x = target // total
        target %= total
        s = l = 0
        ret = 10 ** 9
        for i in range(n * 2):
            s += nums[i]
            while s > target:
                s -= nums[l]
                l += 1
            if s == target:
                ret = min(ret, i - l + 1)
        return ret + x * n
        
```

# [8028. 执行操作使两个字符串相等 - 力扣（LeetCode）](https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/)

## O(n^2)

首先 1的个数的奇偶不同就不能变成一样的 返回-1

用dfs计算加上@cache变为记忆化搜索

每次变都是两个一起变 操作1 第一个变的时候就记录这次变化的消耗  然后另一个就相当于可以免费变化  记录免费变化的次数

操作2 不能像操作1那样在任意位置变  而是 只要用了操作2 必定是连续的两个变

```python
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
        if s1.count('1') % 2 != s2.count('1') % 2:
            return -1

        n = len(s1)
        # 从前往后遍历 
        @cache
        def dfs(i: int, j: int, pre_rever: bool) -> int:
            # 到头了
            if i == n:
                return inf if j or pre_rever else 0
            # 不需要反转
            # 当前不相等 但是前面有反转了 导致这两个相等
            if s1[i] != s2[i] and pre_rever:
                return dfs(i + 1, j, False)
            # 当前相等 并且前面没反转 这两个仍然相等
            if s1[i] == s2[i] and not pre_rever:
                return dfs(i + 1, j, False)
            
            # 需要反转 分别用操作1 和 操作2 取最小值 记得加上反转的代价 操作1为x 操作2为1
            res = min(dfs(i + 1, j + 1, False) + x, dfs(i + 1, j, True) + 1)
            
            # 操作1的免费反转（操作2的免费反转在上面）
            if j:
                res = min(res, dfs(i + 1, j - 1, pre_rever))
            
            return res

        return dfs(0, 0, False)
```

## O(n)

dp做法

把所有需要变的位置先写出来 然后每次消除  通过操作1 每次消除一个 消耗x/2（最后必定是可以消完的因为不行的情况已经返回-1了）或者用操作2 每次消除两个 比如1，4位置需要变化 那就需要3次操作12 23 34 这样  需要消耗 p[i] - p[i - 1]

```py
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
        if s1 == s2:
            return 0
        p = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]
        if len(p) % 2:
            return -1
        m = len(p)

        @cache
        def dfs(i: int) -> int:
            # 递归出口  到-1 说明是正常退出 （操作1 的0 - 1  操作2 的1 - 2）
            if i == -1:
                return 0
            # 到-2说明有问题 返回inf代表这个答案不能用
            if i == -2:
                return inf
            return min(dfs(i - 1) + x, dfs(i - 2) + (p[i] - p[i - 1]) * 2)
        return dfs(m - 1) // 2
```

再翻译成递推 dfs(i) -> f[i]   注意翻译的时候 i - 1和i - 2  如果是f[i - 1] 和 f[i - 2] 会导致最后 i == -1 和i == -2 无法表示  所以 每个下标加上2

```py
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
        f = [0] * (m + 1)
        f[0] = 0
        f[1] = x
        for i in range(1, m):
            new_f = min(f[i] + x, f[i - 1] + (p[i] - p[i - 1]) * 2)
           	f[0] = f[1]
            f[1] = new_f
        return f[m] // 2
```



​     然后空间优化  

```py
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
    	f0, f1 = 0, x
        for i in range(1, m):
            f0, f1 = f1, min(f1 + x, f0 + (p[i] - p[i - 1]) * 2)
        return f1 // 2
```



# [2897. 对数组执行操作使平方和最大 - 力扣（LeetCode）](https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/)

与 越与越小 或越或越大   而x^y + y ^ 2 < (x - d)^2 + (y + d)^2  所以 要尽量做或操作 直到最大

用位运算思考 先记录所有数每个比特位上有多少个1  然后构造尽量大的数 

```py
class Solution:
    def maxSum(self, nums: List[int], k: int) -> int:
        m = max(nums).bit_length()
        cnt = [0] * m
        for x in nums:
            for i in range(m):
                cnt[i] += x >> i & 1
        ans = 0
        # 构造出k个尽可能大的数
        for _ in range(k):
            x = 0
            for i in range(m):
                if cnt[i]:
                    # 消耗该比特位上的一个1
                    cnt[i] -= 1
                    # x |= 就是直接把该位变成1 而1<<i就是对应位
                    x |= 1 << i 
            ans += x * x
        return ans % (10 ** 9 + 7)
```

# [8026. 构造乘积矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-product-matrix/description/)

前后缀优化

类似的还有[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/)

不能用乘积全部乘起来再除的方法 因为首先可能有0的情况 会导致错误 然后就是复杂度太高了

虽然说没有写循环 但是 乘积是高精度乘法 复杂度非常高所以会超时

同理  在每次计算前后缀的时候也需要取模防止数据过大超时

```py
class Solution:
    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        pre = suf = 1
        m = len(grid)
        n = len(grid[0])
        ans = [[0] * n for i in range(m)]
        mod = 12345

        for i in range(m):
            for j in range(n):
                ans[i][j] = pre % mod
                pre = pre * grid[i][j] % mod

        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                ans[i][j] = ans[i][j] * suf % mod
                suf = suf * grid[i][j] % mod
        return ans
```

# [100101. 找出满足差值条件的下标 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/)

这种题目 下标差 然后再找满足另一个条件的 就需要 储存前缀（或后缀）的最大值和最小值

类似于股票的第一题

```py
class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        n = len(nums)
        max_idx = 0
        min_idx = 0
        for i in range(indexDifference, n):
            j = i - indexDifference
            if nums[j] > nums[max_idx]:
                max_idx = j
            elif nums[j] < nums[min_idx]:
                min_idx = j

            if abs(nums[i] - nums[max_idx]) >= valueDifference:
                return [i, max_idx]
            if abs(nums[i] - nums[min_idx]) >= valueDifference:
                return [i, min_idx]
        return [-1, -1] 
```

# [100077. 最长相邻不相等子序列 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/description/)

[100077. 最长相邻不相等子序列 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/solutions/2484023/python3zhu-ju-fen-xi-dong-tai-gui-hua-qi-gdss/)

# [100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/)

滑动窗口 

一开始写的时候 出了好多错ww 下标什么的 while循环的条件带不带等号 还有最后更新忘记判断字典序

```py
class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -> str:
        n = len(s)
        ans = ""
        
        l = 0
        cnt = 0
        i = 0
        for i in range(n):
            if s[i] == '1':
                cnt += 1
            while cnt > k:
                if s[l] == '1':
                    cnt -= 1
                    l += 1
            while l < n and s[l] == '0':
                l += 1
            if cnt == k:
                if len(ans) == 0:
                    ans = s[l:i + 1]
                if i - l + 1 < len(ans):
                    ans = s[l: i + 1]
                elif i - l + 1 == len(ans):
                    if s[l: i + 1] < ans:
                        ans = s[l:i + 1]

        
        return ans
    

```

