---
title: 赛题题解
date: 2023-09-24 10:17:32
tags: Ans
---

# [Problem - C - Codeforces](https://codeforces.com/contest/1873/problem/C)

先给每一圈赋一个权重dis

算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int dis[5] = {1, 2, 3, 4, 5};
void solve()
{
    vector<string> nums;
    int n = 10;
    while (n--)
    {
        string s;
        cin >> s;
        nums.emplace_back(s);
    }
    ll res = 0;
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (nums[i][j] == '.')
                continue;
            else
            {
                res += dis[min(min(i, j), min(9 - i, 9 - j))];
            }
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```



# [Problem - E - Codeforces](https://codeforces.com/contest/1873/problem/E)

赛时调了半天没调出来，寄，害的F也没调出来/kk 

二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 2e5 + 10;
int nums[N];
int n, m;
bool check(int mid)
{
    ll res = 0;
    for (int i = 0; i < n; i++)
    {
        if (mid - nums[i] >= 0)
            res += (mid - nums[i]);
        if (res > m)
            return false;
    }
    return true;
}

void solve()
{

    cin >> n >> m;
    memset(nums, 0, sizeof(nums));
    ll l = 1, r = 2e9 + 1;
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    int res = 1, mid;

    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (check(mid))
        {
            res = mid;
            l = mid + 1;
        }
        else
        {

            r = mid - 1;
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - G - Codeforces](https://codeforces.com/contest/1873/problem/G)

AB->BC BA->CB

那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 

如果有两个B连在一起的话只可能是B..BB...B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B 

如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int n;
    cin >> n;
    while (n--)
    {
        string s;
        cin >> s;
        bool flag = false;
        ll sum = 0;
        int n = s.size();
        int cnt = 0;
        int minn = 1e9 + 7;
        if (s[0] == 'B' || s[n - 1] == 'B')
            flag = true;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == 'A')
                sum++, cnt++;
            else if (s[i] == 'B')
            {
                minn = min(minn, cnt);
                cnt = 0;
                if (i + 1 < n && s[i + 1] == 'B')
                    flag = true;
            }
        }
        minn = min(minn, cnt);
        if (flag)
        {
            cout << sum << endl;
        }
        else
        {
            if (minn != 1e9 + 7)
                cout << sum - minn << endl;
            else
                cout << 0 << endl;
        }
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - H - Codeforces](https://codeforces.com/contest/1873/problem/H)

寻找基环树（套路）因为这个题不仅要判断环 而且需要储存

```c++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n, a, b; // a is M b is V
    cin >> n >> a >> b;
    vector<vector<int>> graph(n + 1);
    // 存无向图
    for (int i = 0; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        graph[u].pb(v);
        graph[v].pb(u);
    }
    if (a == b)
    {
        cout << "NO" << endl;
        return;
    }
    vector<int> incircle(n + 1, 0), vis(n + 1, 0), pre(n + 1, 0);
    bool ok = false;
    
    function<void(int, int)> dfs = [&](int u, int fa)
    {
        for (int v : graph[u])
        {
            if (ok)
                return;
            if (v == fa)
                continue;
            if (vis[v]) // 第二次经过代表有环
            {
                ok = true;
                incircle[v] = 1; // 标记在环上
                int x = u;
                do
                {
                    incircle[x] = 1;
                    x = pre[x];
                } while (x != v); // 标记环上的所有点
            }
            else
            {
                vis[v] = 1;
                pre[v] = u;
                dfs(v, u);
            }
        }
    };
    vis[1] = 1;
    dfs(1, 0);
    // 如果已经在环上了
    if (incircle[b]) 
    {
        cout << "YES" << endl;
        return;
    }
    int goal = -1, gdis = -1;
    queue<PII> q;
    // 清空vis数组
    vis.assign(n + 1, 0);
    q.push({b, 0});
    vis[b] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (incircle[v])
            {
                goal = v;
                gdis = dis + 1;
                goto end;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
end:;
    if (goal == a)
    {
        cout << "NO" << endl;
        return;
    }

    while (!q.empty())
    {
        q.pop();
    }
    int tdis = -1;
    vis.assign(n + 1, 0);
    q.push({a, 0});
    vis[a] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (v == goal)
            {
                tdis = dis + 1;
                if (tdis <= gdis)
                    cout << "NO" << endl;
                else
                    cout << "YES" << endl;
                return;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [5153. 删除 - AcWing题库](https://www.acwing.com/problem/content/5156/)

一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除
而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推
所以只需要枚举1 2 3 位数

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    string s;
    cin >> s;
    int n = s.size();
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '8')
        {
            cout << "YES" << endl;
            cout << "8" << endl;
            return 0;
        }
        if (s[i] == '0')
        {
            cout << "YES" << endl;
            cout << "0" << endl;
            return 0;
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            int a = ((s[i] - '0') * 10 + s[j] - '0');
            if (a % 8 == 0)
            {
                cout << "YES" << endl;
                cout << a << endl;
                return 0;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            for (int k = j + 1; k < n; k++)

            {
                int a = ((s[i] - '0') * 100 + (s[j] - '0') * 10 + s[k] - '0');
                if (a % 8 == 0)
                {
                    cout << "YES" << endl;
                    cout << a << endl;
                    return 0;
                }
            }
        }
    }
    cout << "NO" << endl;

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

