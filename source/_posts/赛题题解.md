---
title: 赛题题解
date: 2023-09-24 10:17:32
tags: Ans
---

# [Problem - C - Codeforces](https://codeforces.com/contest/1873/problem/C)

先给每一圈赋一个权重dis

算该点具体在那一个圈权值多少 就用dis[min(min(i, j), min(n-i, n-j))]

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int dis[5] = {1, 2, 3, 4, 5};
void solve()
{
    vector<string> nums;
    int n = 10;
    while (n--)
    {
        string s;
        cin >> s;
        nums.emplace_back(s);
    }
    ll res = 0;
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (nums[i][j] == '.')
                continue;
            else
            {
                res += dis[min(min(i, j), min(9 - i, 9 - j))];
            }
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```



# [Problem - E - Codeforces](https://codeforces.com/contest/1873/problem/E)

赛时调了半天没调出来，寄，害的F也没调出来/kk 

二分的板子没问题啊，主要是r的范围错了，r是要超过x很多的，而且还要同时注意 开ll 如果太大的话mid的范围也要注意

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 2e5 + 10;
int nums[N];
int n, m;
bool check(int mid)
{
    ll res = 0;
    for (int i = 0; i < n; i++)
    {
        if (mid - nums[i] >= 0)
            res += (mid - nums[i]);
        if (res > m)
            return false;
    }
    return true;
}

void solve()
{

    cin >> n >> m;
    memset(nums, 0, sizeof(nums));
    ll l = 1, r = 2e9 + 1;
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    int res = 1, mid;

    while (l <= r)
    {
        mid = (l + r) >> 1;
        if (check(mid))
        {
            res = mid;
            l = mid + 1;
        }
        else
        {

            r = mid - 1;
        }
    }
    cout << res << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - G - Codeforces](https://codeforces.com/contest/1873/problem/G)

AB->BC BA->CB

那么只要有B就可以把所有的A都消除掉（只能消除一边）分几种情况来讨论 首先B在首或尾的时候如果中间没有B 可以全部消除完 

如果有两个B连在一起的话只可能是B..BB...B 中间的..可能是A也可能是B 都可以把所有A消除（左边的B消掉左边的A 右边的B消除右边的B 

如果没有两个B连在一起的话那么中间必然会有空缺  AABABAA那么只能消掉三个中的两个 所以最后要减去A最少的一段

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int n;
    cin >> n;
    while (n--)
    {
        string s;
        cin >> s;
        bool flag = false;
        ll sum = 0;
        int n = s.size();
        int cnt = 0;
        int minn = 1e9 + 7;
        if (s[0] == 'B' || s[n - 1] == 'B')
            flag = true;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == 'A')
                sum++, cnt++;
            else if (s[i] == 'B')
            {
                minn = min(minn, cnt);
                cnt = 0;
                if (i + 1 < n && s[i + 1] == 'B')
                    flag = true;
            }
        }
        minn = min(minn, cnt);
        if (flag)
        {
            cout << sum << endl;
        }
        else
        {
            if (minn != 1e9 + 7)
                cout << sum - minn << endl;
            else
                cout << 0 << endl;
        }
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - H - Codeforces](https://codeforces.com/contest/1873/problem/H)

寻找基环树（套路）因为这个题不仅要判断环 而且需要储存

```c++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n, a, b; // a is M b is V
    cin >> n >> a >> b;
    vector<vector<int>> graph(n + 1);
    // 存无向图
    for (int i = 0; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        graph[u].pb(v);
        graph[v].pb(u);
    }
    if (a == b)
    {
        cout << "NO" << endl;
        return;
    }
    vector<int> incircle(n + 1, 0), vis(n + 1, 0), pre(n + 1, 0);
    bool ok = false;
    
    function<void(int, int)> dfs = [&](int u, int fa)
    {
        for (int v : graph[u])
        {
            if (ok)
                return;
            if (v == fa)
                continue;
            if (vis[v]) // 第二次经过代表有环
            {
                ok = true;
                incircle[v] = 1; // 标记在环上
                int x = u;
                do
                {
                    incircle[x] = 1;
                    x = pre[x];
                } while (x != v); // 标记环上的所有点
            }
            else
            {
                vis[v] = 1;
                pre[v] = u;
                dfs(v, u);
            }
        }
    };
    vis[1] = 1;
    dfs(1, 0);
    // 如果已经在环上了
    if (incircle[b]) 
    {
        cout << "YES" << endl;
        return;
    }
    int goal = -1, gdis = -1;
    queue<PII> q;
    // 清空vis数组
    vis.assign(n + 1, 0);
    q.push({b, 0});
    vis[b] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (incircle[v])
            {
                goal = v;
                gdis = dis + 1;
                goto end;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
end:;
    if (goal == a)
    {
        cout << "NO" << endl;
        return;
    }

    while (!q.empty())
    {
        q.pop();
    }
    int tdis = -1;
    vis.assign(n + 1, 0);
    q.push({a, 0});
    vis[a] = 1;
    while (!q.empty())
    {
        int u = q.front().first;
        int dis = q.front().second;
        q.pop();
        for (int v : graph[u])
        {
            if (vis[v])
                continue;
            if (v == goal)
            {
                tdis = dis + 1;
                if (tdis <= gdis)
                    cout << "NO" << endl;
                else
                    cout << "YES" << endl;
                return;
            }
            else
            {
                q.push({v, dis + 1});
                vis[v] = 1;
            }
        }
    }
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [5153. 删除 - AcWing题库](https://www.acwing.com/problem/content/5156/)

一位数 两位数 三位数 分别表达 而四位数及以上时 不需要 因为1000 可以被8 整除 而所有的四位数 如1000 2000 3000 等都可以被8整除
而所有的四位数都可以被表示为 1000 * k + x （x为一位数或者两位数 或者三位数 ） 更高位的以此类推
所以只需要枚举1 2 3 位数

```
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    string s;
    cin >> s;
    int n = s.size();
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '8')
        {
            cout << "YES" << endl;
            cout << "8" << endl;
            return 0;
        }
        if (s[i] == '0')
        {
            cout << "YES" << endl;
            cout << "0" << endl;
            return 0;
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            int a = ((s[i] - '0') * 10 + s[j] - '0');
            if (a % 8 == 0)
            {
                cout << "YES" << endl;
                cout << a << endl;
                return 0;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            for (int k = j + 1; k < n; k++)

            {
                int a = ((s[i] - '0') * 100 + (s[j] - '0') * 10 + s[k] - '0');
                if (a % 8 == 0)
                {
                    cout << "YES" << endl;
                    cout << a << endl;
                    return 0;
                }
            }
        }
    }
    cout << "NO" << endl;

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [Problem - D - Codeforces](https://codeforces.com/contest/1878/problem/D)

给出区间 然后反转 可以用差分 当这个下标被旋转奇数次的时候就需要旋转 被旋转偶数次的时候 就相当于没动 不用旋转 

每次旋转要找到唯一一个i 使得a[i] <= x && b[i] >= x 然后旋转a[i] b[i] 的元素 

可以用cnt（类似差分数组）记录x出现的次数   并且不需要根据x寻找第二行所说的那个区间 而是遍历区间 找到这个区间的x

遍历区间 然后取出子串 从left到mid依次与right到mid交换 （根据sum的奇偶来判断）sum就是当前位置和对称位被交换次数之和（累计   因为是差分）然后输出子串

```python
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n, k;
    string s;
    cin >> n >> k;
    cin >> s;
    vector<int> a(k), b(k);
    vector<int> cnt(n);
    for (int i = 0; i < k; i++)
        cin >> a[i], a[i]--;
    for (int i = 0; i < k; i++)
        cin >> b[i], b[i]--;
    int q;
    cin >> q;
    for (int i = 0; i < q; i++)
    {
        int x;
        cin >> x;
        cnt[x - 1]++;
    }

    for (int i = 0; i < k; i++)
    {
        string s1 = s.substr(a[i], b[i] - a[i] + 1);
        int sum = 0;
        int l = a[i];
        int r = b[i];
        for (int j = l; j <= (l + r) / 2; j++)
        {
            sum += cnt[j] + cnt[r - j + l];
            if (sum % 2)
                swap(s1[j - l], s1[r - j]);
        }
        cout << s1;
    }
    cout << endl;
}

int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# [100019. 将数组分割成最多数目的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/description/)

按位与的结果只能越来越小 因此要求最小的按位与的子数组的和 就是全部与在一起的和 就是最小的 但是又特殊情况 就是 当全部的与为0时 可能中间有一部分已经为0了  这样就可以拆成很多个与为0的子数组   如果不为0  那必然整个数组的与就是最小值

```python
class Solution:
    def maxSubarrays(self, nums: List[int]) -> int:
        t = nums[0]
        n = len(nums)
        cnt = 0
        for i in range(1, n):
            if t == 0:
                cnt += 1
                t = nums[i]
            t&=nums[i]
        if t == 0:
            cnt += 1
        return cnt if cnt != 0 else 1
```

# [2872. 可以被 K 整除连通块的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-k-divisible-components/solutions/2464559/javapython3cshen-du-you-xian-sou-suo-tan-3r78/)

由于题目说了 整棵树所有结点的和一定为k的倍数 那么从中取出一棵节点和为k的倍速的子树  剩下的部分的结点和一定也为k的倍数  

因此可以自底向上递归  每次找到一棵节点和为k的倍数的子树 就直接加入答案 

```python
class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        # 建树
        self.link = [[] for _ in range(n)]
        for s, e in edges:
            self.link[s].append(e)
            self.link[e].append(s)
        self.res = 1
        # 递归
        self.dfs(0, -1, values, k)
        return self.res
	
    
    	def dfs(self, node, parent, values, k):
            node_sum = values[node]
            for child in self.link[node]:
                # 因为建的是无向图 要去掉父节点
                if child == parent:
                    continue
                child_sum = dfs(child, node, values, k)
                if child_sum % k == 0:
                    self.res += 1
                else:
                    node_sum += child_sum
            return node_sum
```

# [100086. 有序三元组中的最大值 II - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/)

```python
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        n = len(nums)
        surmax = [-1] * (n + 1)
        for i in range(n - 1, -1, -1):
            surmax[i] = max(surmax[i + 1], nums[i])
        premax = nums[0]
        ans = 0
        for i in range(n - 1):
            ans = max(ans, (surmax[i + 1] * (premax - nums[i])))
            premax = max(premax, nums[i])
        return ans 
```

# [100076. 无限数组的最短子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)

```python
class Solution:
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        n = len(nums)
        total = sum(nums)
        nums = nums + nums
        x = target // total
        target %= total
        s = l = 0
        ret = 10 ** 9
        for i in range(n * 2):
            s += nums[i]
            while s > target:
                s -= nums[l]
                l += 1
            if s == target:
                ret = min(ret, i - l + 1)
        return ret + x * n
        
```

