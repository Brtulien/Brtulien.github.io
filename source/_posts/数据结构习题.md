---
title: 数据结构习题
date: 2023-09-12 10:00:13
tags: Ans
---

# [First week]([PTA | 程序设计类实验辅助教学平台 (pintia.cn)](https://pintia.cn/problem-sets/1700336300474802176/exam/problems/1700336300504162305?type=6&page=0))

## 减一运算

```C
//超级抽象的C语言题 不仅要动态申请内存 还要高精度运算

int* MinusOne(int* digits, int digitsSize, int* returnSize)
{
    int num[2000];
    for (int i = 0; i < digitsSize; i++)
    {
        num[i] = *(digits + i);
    }
    int* res = (int*)malloc(1001 * sizeof(int));// 因为外面有free 所以要malloc

    if (num[0] == 1 && digitsSize == 1)
    {
        *res = 0;
        *returnSize = 1;
        return res;
    }

    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (num[i] >= 1)
        {
            num[i] -= 1;
            break;
        }
        else
        {
            num[i] = 9;
        }
    }
    int flag = 0;
    *returnSize = digitsSize;
    if (num[0] == 0)
    {
        *returnSize -= 1; // 记得更新returnSize
        flag = 1;
    }

    
    for (int i = flag, j = 0; i <= *returnSize; i++, j++)
    {
        *(res + j) = num[i];
    }
    return res;
}

```

## 最大子列和

```C++
// 在线算法 O(n) 
#include <iostream>
using namespace std;
const int N = 1000010;
int nums[N];
int qzh[N];
int n;

int main()
{
	cin >> n;
	int now = 0;
	int maxi = -(1e9+7);
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i];
	}
    // 当now为当前子列和 如果当前子列和大于maxi就更新   注意一点 当now<0的时候now=0 即可以之间不选
	for (int i = 0; i < n; i++)
	{
		now += nums[i];
		if (now > maxi)
			maxi = now;
		if (now < 0)
			now = 0;
	}
	cout << maxi;
}
```

## 最长连续递增子序列

```python
# 跟上一个一样。。
n = int(input())
nums = list(map(int, input().split()))

maxi, maxn = 0, 0
cnt = 1
for i in range(1, n):
    if nums[i] > nums[i - 1]:
        cnt += 1
    else:
        if maxn < cnt:
            maxi = i
            maxn = cnt
        cnt = 1

if maxn < cnt:
    maxi = n
    maxn = cnt

for i in range(maxi - maxn, maxi):
    if i != maxi - 1:
        print(nums[i], end=' ')
    else:
         print(nums[i],end='')
```

# Second week

## 2-1

注意顺序表的概念 需要是连续的 每次插入删除需要位移  不能插入在tail+1之后的位置 

```C
List MakeEmpty()
{
    List newList = (List)malloc(sizeof(struct LNode));
    newList->Last = -1;
    for (int i = 0; i < MAXSIZE; i++)
    {
        newList->Data[i] = -1;
    }
    return newList;
}
Position Find(List L, ElementType X)
{
    for (int i = 0; i <= L->Last; i++)
    {
        if (L->Data[i] == X)
            return i;
    }
    return ERROR;
}
bool Insert(List L, ElementType X, Position P)
{
    if (L->Last == MAXSIZE - 1)
    {
        printf("FULL");
        return false;
    }

    if (P > L->Last + 1 || P < 0)
    {
        printf("ILLEGAL POSITION");
        return false;
    }
    
    for (int j = L->Last; j >= P; j--)
    {
        L->Data[j + 1] = L->Data[j];
    }
    L->Data[P] = X;
    L->Last++;
    return true;
}
bool Delete(List L, Position P)
{
    if (P > L->Last || P < 0)
    {
        printf("POSITION %d EMPTY", P);
        return false;
    }
    for (int i = P + 1; i < L->Last; i++)
    {
        L->Data[i - 1] = L->Data[i];
    }
    L->Last--;
    return true;
}
```

## 2-3

求中位数的方法  具体证明看力扣

```C++
def GetKthElement(k):
    global n
    idx1, idx2 = 0, 0
    while True:
        if idx1 == n:
            return nums2[idx2]
        if idx2 == n:
            return nums1[idx1]
        if k == 1:
            return min(nums1[idx1], nums2[idx2])
        nidx1, nidx2 = idx1 + k // 2 - 1, idx2 + k // 2 - 1
        p1, p2 = nums1[nidx1], nums2[nidx2]
        if p1 <= p2:
            k -= nidx1 - idx1 + 1
            idx1 = nidx1 + 1
        else:
            k -= nidx2 - idx2 + 1
            idx2 = nidx2 + 1

n = int(input())
nums1 = list(map(int, input().split()))
nums2 = list(map(int, input().split()))
print(GetKthElement(n))

```

# 

```
#include <cstdio>
#include <vector>
#include <set>
#include <cmath>
using namespace std;
const int maxn=1e5;

int n,head;
set<int> vis;

struct Node{
    int address;
	int value, next;
}nodes[maxn+5];

int main() {
//    freopen("1.txt","r",stdin);
    scanf("%d%d",&head,&n);
    for (int i=1,add,val,nex;i<=n;i++){
        scanf("%d%d%d",&add,&val,&nex);
        nodes[add]={add,val,nex};
    }
    vector<Node> ans, another;
    int now=head;
    Node node;
    while (now!=-1){
        node=nodes[now];
        if (vis.find(abs(node.value))==vis.end())
            vis.insert(abs(node.value)),ans.push_back(node);
        else
            another.push_back(node);
        now=node.next;
    }
    for (int i=0;i<ans.size();i++){
        printf("%05d %d ",ans[i].address,ans[i].value);
        if (i!=ans.size()-1)
            printf("%05d\n",ans[i+1].address);
        else 
            puts("-1");
    }
    for (int i=0;i<another.size();i++){
        printf("%05d %d ",another[i].address,another[i].value);
        if (i!=another.size()-1)
            printf("%05d\n",another[i + 1].address);
        else
            puts("-1");
    }
    return 0;
}
```

## 2-7

链表去重 静态链表写法

```C++
#include <cstdio>
#include <vector>
#include <set>
#include <cmath>
using namespace std;
const int maxn=1e5;

int n,head;
set<int> vis;

struct Node{
    int address;
	int value, next;
}nodes[maxn+5];

int main() {
//    freopen("1.txt","r",stdin);
    scanf("%d%d",&head,&n);
    for (int i=1,add,val,nex;i<=n;i++){
        scanf("%d%d%d",&add,&val,&nex);
        nodes[add]={add,val,nex};
    }
    vector<Node> ans, another;
    int now=head;
    Node node;
    while (now!=-1){
        node=nodes[now];
        if (vis.find(abs(node.value))==vis.end())
            vis.insert(abs(node.value)),ans.push_back(node);
        else
            another.push_back(node);
        now=node.next;
    }
    for (int i=0;i<ans.size();i++){
        printf("%05d %d ",ans[i].address,ans[i].value);
        if (i!=ans.size()-1)
            printf("%05d\n",ans[i+1].address);
        else 
            puts("-1");
    }
    for (int i=0;i<another.size();i++){
        printf("%05d %d ",another[i].address,another[i].value);
        if (i!=another.size()-1)
            printf("%05d\n",another[i + 1].address);
        else
            puts("-1");
    }
    return 0;
}
```

## 2-10

多项式除法 用map来储存次数和系数 通过次数找系数 

其实每次只需要最高次数的去除 被除数不断地被除 余数仍然放在被除数中 不断循环（每次循环得到一位商） 直到最高次小于除数的最高次 结束  最后就可以得到商和余数 

四舍五入的方法也很重要 （x*10 +/- 0.5）/10 

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <map>
using namespace std;
const int N = 100010;
// 注意 前面是指数 后面是系数
map<int, double>division;// 除数
map<int, double>divided;// 被除数
map<int, double>ans;// 商

int main()
{
	int n;
	cin >> n;
	int e;
	double c;
	int maxe1 = 0;
	int maxe2 = 0;
	int mine2 = 1000000;
	int maxe3 = 0;
	while (n--)
	{
		cin >> e >> c;
		divided[e] += c;
		maxe1 = max(maxe1, e);
	}
	cin >> n;

	while (n--)
	{
		cin >> e >> c;
		division[e] += c;
		maxe2 = max(maxe2, e);
		mine2 = min(mine2, e);
	}
	for (int i = maxe1; i >= maxe2; i--)
	{
		int sub = i - maxe2;
		double div = 1.0 * divided[i] / division[maxe2];
		ans[sub] = div;
		maxe3 = max(maxe3, sub);
		for (int j = maxe2; j >= 0; j--)
		{
			if(div)
				divided[j + sub] -= division[j] * div;
		}
	}

	int cnt = 0;
	for (int i = maxe3; i >= 0; i--)
	{
		ans[i] = double(int(ans[i] * 10 + (ans[i] > 0 ? 0.5 : -0.5)) / 10.0);
		if (ans[i] != 0)cnt++;
	}
	if (!cnt)printf("0 0 0.0");
	else cout << cnt;
	for (int i = maxe3; i >= 0; i--)
	{
		if (ans[i])
			printf(" %d %.1lf", i, ans[i]);
	}
	cout << endl;

	cnt = 0;
	for (int i = maxe1; i >= 0; i--)
	{
		divided[i] = double(int(divided[i] * 10 + (divided[i] > 0 ? 0.5 : -0.5)) / 10.0);
		if (divided[i] != 0)cnt++;
	}
	if (!cnt)printf("0 0 0.0");
	else cout << cnt;
	for (int i = maxe1; i >= 0; i--)
	{
		if (divided[i])
			printf(" %d %.1lf", i, divided[i]);
	}
	cout << endl;
}

```

