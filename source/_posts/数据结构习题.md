---
title: 数据结构习题
date: 2023-09-12 10:00:13
tags: Ans
---

# [First week]([PTA | 程序设计类实验辅助教学平台 (pintia.cn)](https://pintia.cn/problem-sets/1700336300474802176/exam/problems/1700336300504162305?type=6&page=0))

## 减一运算

```C
//超级抽象的C语言题 不仅要动态申请内存 还要高精度运算

int* MinusOne(int* digits, int digitsSize, int* returnSize)
{
    int num[2000];
    for (int i = 0; i < digitsSize; i++)
    {
        num[i] = *(digits + i);
    }
    int* res = (int*)malloc(1001 * sizeof(int));// 因为外面有free 所以要malloc

    if (num[0] == 1 && digitsSize == 1)
    {
        *res = 0;
        *returnSize = 1;
        return res;
    }

    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (num[i] >= 1)
        {
            num[i] -= 1;
            break;
        }
        else
        {
            num[i] = 9;
        }
    }
    int flag = 0;
    *returnSize = digitsSize;
    if (num[0] == 0)
    {
        *returnSize -= 1; // 记得更新returnSize
        flag = 1;
    }

    
    for (int i = flag, j = 0; i <= *returnSize; i++, j++)
    {
        *(res + j) = num[i];
    }
    return res;
}

```

## 最大子列和

```C++
// 在线算法 O(n) 
#include <iostream>
using namespace std;
const int N = 1000010;
int nums[N];
int qzh[N];
int n;

int main()
{
	cin >> n;
	int now = 0;
	int maxi = -(1e9+7);
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i];
	}
    // 当now为当前子列和 如果当前子列和大于maxi就更新   注意一点 当now<0的时候now=0 即可以之间不选
	for (int i = 0; i < n; i++)
	{
		now += nums[i];
		if (now > maxi)
			maxi = now;
		if (now < 0)
			now = 0;
	}
	cout << maxi;
}
```

## 最长连续递增子序列

```python
# 跟上一个一样。。
n = int(input())
nums = list(map(int, input().split()))

maxi, maxn = 0, 0
cnt = 1
for i in range(1, n):
    if nums[i] > nums[i - 1]:
        cnt += 1
    else:
        if maxn < cnt:
            maxi = i
            maxn = cnt
        cnt = 1

if maxn < cnt:
    maxi = n
    maxn = cnt

for i in range(maxi - maxn, maxi):
    if i != maxi - 1:
        print(nums[i], end=' ')
    else:
         print(nums[i],end='')
```

