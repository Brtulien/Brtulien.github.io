---
title: 数据结构习题
date: 2023-09-12 10:00:13
tags: Ans
---

# [First week]([PTA | 程序设计类实验辅助教学平台 (pintia.cn)](https://pintia.cn/problem-sets/1700336300474802176/exam/problems/1700336300504162305?type=6&page=0))

## 减一运算

```C
//超级抽象的C语言题 不仅要动态申请内存 还要高精度运算

int* MinusOne(int* digits, int digitsSize, int* returnSize)
{
    int num[2000];
    for (int i = 0; i < digitsSize; i++)
    {
        num[i] = *(digits + i);
    }
    int* res = (int*)malloc(1001 * sizeof(int));// 因为外面有free 所以要malloc

    if (num[0] == 1 && digitsSize == 1)
    {
        *res = 0;
        *returnSize = 1;
        return res;
    }

    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (num[i] >= 1)
        {
            num[i] -= 1;
            break;
        }
        else
        {
            num[i] = 9;
        }
    }
    int flag = 0;
    *returnSize = digitsSize;
    if (num[0] == 0)
    {
        *returnSize -= 1; // 记得更新returnSize
        flag = 1;
    }

    
    for (int i = flag, j = 0; i <= *returnSize; i++, j++)
    {
        *(res + j) = num[i];
    }
    return res;
}

```

## 最大子列和

```C++
// 在线算法 O(n) 
#include <iostream>
using namespace std;
const int N = 1000010;
int nums[N];
int qzh[N];
int n;

int main()
{
	cin >> n;
	int now = 0;
	int maxi = -(1e9+7);
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i];
	}
    // 当now为当前子列和 如果当前子列和大于maxi就更新   注意一点 当now<0的时候now=0 即可以之间不选
	for (int i = 0; i < n; i++)
	{
		now += nums[i];
		if (now > maxi)
			maxi = now;
		if (now < 0)
			now = 0;
	}
	cout << maxi;
}
```

## 最长连续递增子序列

```python
# 跟上一个一样。。
n = int(input())
nums = list(map(int, input().split()))

maxi, maxn = 0, 0
cnt = 1
for i in range(1, n):
    if nums[i] > nums[i - 1]:
        cnt += 1
    else:
        if maxn < cnt:
            maxi = i
            maxn = cnt
        cnt = 1

if maxn < cnt:
    maxi = n
    maxn = cnt

for i in range(maxi - maxn, maxi):
    if i != maxi - 1:
        print(nums[i], end=' ')
    else:
         print(nums[i],end='')
```

# [Second week](https://pintia.cn/problem-sets/1703316708057788416/exam/problems/type/6)

## 2-1

注意顺序表的概念 需要是连续的 每次插入删除需要位移  不能插入在tail+1之后的位置 

```C
List MakeEmpty()
{
    List newList = (List)malloc(sizeof(struct LNode));
    newList->Last = -1;
    for (int i = 0; i < MAXSIZE; i++)
    {
        newList->Data[i] = -1;
    }
    return newList;
}
Position Find(List L, ElementType X)
{
    for (int i = 0; i <= L->Last; i++)
    {
        if (L->Data[i] == X)
            return i;
    }
    return ERROR;
}
bool Insert(List L, ElementType X, Position P)
{
    if (L->Last == MAXSIZE - 1)
    {
        printf("FULL");
        return false;
    }

    if (P > L->Last + 1 || P < 0)
    {
        printf("ILLEGAL POSITION");
        return false;
    }
    
    for (int j = L->Last; j >= P; j--)
    {
        L->Data[j + 1] = L->Data[j];
    }
    L->Data[P] = X;
    L->Last++;
    return true;
}
bool Delete(List L, Position P)
{
    if (P > L->Last || P < 0)
    {
        printf("POSITION %d EMPTY", P);
        return false;
    }
    for (int i = P + 1; i < L->Last; i++)
    {
        L->Data[i - 1] = L->Data[i];
    }
    L->Last--;
    return true;
}
```

## 2-3

求中位数的方法  具体证明看力扣

```C++
def GetKthElement(k):
    global n
    idx1, idx2 = 0, 0
    while True:
        if idx1 == n:
            return nums2[idx2]
        if idx2 == n:
            return nums1[idx1]
        if k == 1:
            return min(nums1[idx1], nums2[idx2])
        nidx1, nidx2 = idx1 + k // 2 - 1, idx2 + k // 2 - 1
        p1, p2 = nums1[nidx1], nums2[nidx2]
        if p1 <= p2:
            k -= nidx1 - idx1 + 1
            idx1 = nidx1 + 1
        else:
            k -= nidx2 - idx2 + 1
            idx2 = nidx2 + 1

n = int(input())
nums1 = list(map(int, input().split()))
nums2 = list(map(int, input().split()))
print(GetKthElement(n))

```

# 

```
#include <cstdio>
#include <vector>
#include <set>
#include <cmath>
using namespace std;
const int maxn=1e5;

int n,head;
set<int> vis;

struct Node{
    int address;
	int value, next;
}nodes[maxn+5];

int main() {
//    freopen("1.txt","r",stdin);
    scanf("%d%d",&head,&n);
    for (int i=1,add,val,nex;i<=n;i++){
        scanf("%d%d%d",&add,&val,&nex);
        nodes[add]={add,val,nex};
    }
    vector<Node> ans, another;
    int now=head;
    Node node;
    while (now!=-1){
        node=nodes[now];
        if (vis.find(abs(node.value))==vis.end())
            vis.insert(abs(node.value)),ans.push_back(node);
        else
            another.push_back(node);
        now=node.next;
    }
    for (int i=0;i<ans.size();i++){
        printf("%05d %d ",ans[i].address,ans[i].value);
        if (i!=ans.size()-1)
            printf("%05d\n",ans[i+1].address);
        else 
            puts("-1");
    }
    for (int i=0;i<another.size();i++){
        printf("%05d %d ",another[i].address,another[i].value);
        if (i!=another.size()-1)
            printf("%05d\n",another[i + 1].address);
        else
            puts("-1");
    }
    return 0;
}
```

## 2-7

链表去重 静态链表写法

```C++
#include <cstdio>
#include <vector>
#include <set>
#include <cmath>
using namespace std;
const int maxn=1e5;

int n,head;
set<int> vis;

struct Node{
    int address;
	int value, next;
}nodes[maxn+5];

int main() {
//    freopen("1.txt","r",stdin);
    scanf("%d%d",&head,&n);
    for (int i=1,add,val,nex;i<=n;i++){
        scanf("%d%d%d",&add,&val,&nex);
        nodes[add]={add,val,nex};
    }
    vector<Node> ans, another;
    int now=head;
    Node node;
    while (now!=-1){
        node=nodes[now];
        if (vis.find(abs(node.value))==vis.end())
            vis.insert(abs(node.value)),ans.push_back(node);
        else
            another.push_back(node);
        now=node.next;
    }
    for (int i=0;i<ans.size();i++){
        printf("%05d %d ",ans[i].address,ans[i].value);
        if (i!=ans.size()-1)
            printf("%05d\n",ans[i+1].address);
        else 
            puts("-1");
    }
    for (int i=0;i<another.size();i++){
        printf("%05d %d ",another[i].address,another[i].value);
        if (i!=another.size()-1)
            printf("%05d\n",another[i + 1].address);
        else
            puts("-1");
    }
    return 0;
}
```

## 2-10

多项式除法 用map来储存次数和系数 通过次数找系数 

其实每次只需要最高次数的去除 被除数不断地被除 余数仍然放在被除数中 不断循环（每次循环得到一位商） 直到最高次小于除数的最高次 结束  最后就可以得到商和余数 

四舍五入的方法也很重要 （x*10 +/- 0.5）/10 

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <map>
using namespace std;
const int N = 100010;
// 注意 前面是指数 后面是系数
map<int, double>division;// 除数
map<int, double>divided;// 被除数
map<int, double>ans;// 商

int main()
{
	int n;
	cin >> n;
	int e;
	double c;
	int maxe1 = 0;
	int maxe2 = 0;
	int mine2 = 1000000;
	int maxe3 = 0;
	while (n--)
	{
		cin >> e >> c;
		divided[e] += c;
		maxe1 = max(maxe1, e);
	}
	cin >> n;

	while (n--)
	{
		cin >> e >> c;
		division[e] += c;
		maxe2 = max(maxe2, e);
		mine2 = min(mine2, e);
	}
	for (int i = maxe1; i >= maxe2; i--)
	{
		int sub = i - maxe2;
		double div = 1.0 * divided[i] / division[maxe2];
		ans[sub] = div;
		maxe3 = max(maxe3, sub);
		for (int j = maxe2; j >= 0; j--)
		{
			if(div)
				divided[j + sub] -= division[j] * div;
		}
	}

	int cnt = 0;
	for (int i = maxe3; i >= 0; i--)
	{
		ans[i] = double(int(ans[i] * 10 + (ans[i] > 0 ? 0.5 : -0.5)) / 10.0);
		if (ans[i] != 0)cnt++;
	}
	if (!cnt)printf("0 0 0.0");
	else cout << cnt;
	for (int i = maxe3; i >= 0; i--)
	{
		if (ans[i])
			printf(" %d %.1lf", i, ans[i]);
	}
	cout << endl;

	cnt = 0;
	for (int i = maxe1; i >= 0; i--)
	{
		divided[i] = double(int(divided[i] * 10 + (divided[i] > 0 ? 0.5 : -0.5)) / 10.0);
		if (divided[i] != 0)cnt++;
	}
	if (!cnt)printf("0 0 0.0");
	else cout << cnt;
	for (int i = maxe1; i >= 0; i--)
	{
		if (divided[i])
			printf(" %d %.1lf", i, divided[i]);
	}
	cout << endl;
}

```

# [Third Week](https://pintia.cn/problem-sets/1706269130417893376/exam/problems)

3-1

注意写题的时候 类型一般是ElementType 

然后申请空间的时候 像栈等 就是 先申请一个Stack类型的  再去申请Stack里面的数组

```C
Stack CreateStack(int MaxSize)
{
    Stack st = (Stack)malloc(sizeof(Stack));
    st->Data = (ElementType*)malloc(sizeof(ElementType) * (MaxSize - 1));//注意是ElementType不是int
    st->MaxSize = MaxSize;
    
    st->Top1 = -1;
    st->Top2 = st->MaxSize;
    return st;
}
bool Push(Stack S, ElementType X, int Tag)
{
    if (Tag == 1)
    {
        if (S->Top1 + 1 == S->Top2)
        {
            printf("Stack Full\n");
            return false;
        }
        else
        {
            S->Data[++S->Top1] = X;
        }
    }
    else
    {
        if (S->Top1 == S->Top2 - 1)
        {
            printf("Stack Full\n");
            return false;
        }
        else
            S->Data[--S->Top2] = X;
    }
    return true;
}
ElementType Pop(Stack S, int Tag)
{
    if ((Tag == 1 && S->Top1 == -1) || (Tag == 2 && S->Top2 == S->MaxSize))
    {
        printf("Stack %d Empty\n", Tag);
        return ERROR;
    }
    if (Tag == 1)
        return S->Data[S->Top1--];
    else
        return S->Data[S->Top2++];
}
```

3-2

负数的时候 特判一下负号  由于减号后面是空格而负号后面是数字 用这个来判断

```python
ElementType EvalPostfix(char* expr)
{
    double stack[100010];
    int top = -1;
    int flag = 0;
    int len = strlen(expr);
    for (int i = 0; i < len;)
    {
        if (expr[i] == '-' && expr[i + 1] != ' ' && i + 1 < len)
        {
            flag = 1;
            i++;
        }
        else if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*' || expr[i] == '/')
        {
            if (top == -1)
                return Infinity;
            double b = stack[top--];
            double a = stack[top--];

            double ans;
            switch (expr[i])
            {
            case '+':
                ans = a + b;
                break;
            case '-':
                ans = a - b;
                break;
            case '*':
                ans = a * b;
                break;
            case '/':
                if (b == 0)
                    return Infinity;
                ans = a / b;
                break;
            default:
                break;
            }
            stack[++top] = ans;
            i++;
        }
        else if (expr[i] >= '0' && expr[i] <= '9')
        {
            double a = atof(expr + i);
            while (expr[i] != ' ' && i < len)
            {
                i++;
            }
            
            stack[++top] = flag ? -a : a;
            flag = 0;
        }
        else i++;
    }
    if (top == 0)return stack[top];
    else return Infinity;
}
```

3-9

双端队列 有头插头删尾插尾删



注意由于这个多开辟了一个空间当D->front == D->rear 的时候是空

D->front - 1 == D->rear 的时候是满

index函数

```C

int index(int i, Deque D)
{
    return (i + D->MaxSize) % (D->MaxSize);
}
bool Push(ElementType X, Deque D)
{
    if (abs((index(D->Front - 1, D) - D->Rear) ) == 0)
    {
        return false;
    }
    D->Front = index(D->Front - 1, D);
    D->Data[D->Front] = X;

    return true;
}
ElementType Pop(Deque D)
{
    if (D->Front == D->Rear)return ERROR;
    ElementType x = D->Data[D->Front];
    D->Front = index(D->Front + 1, D);
    return x;
}
bool Inject(ElementType X, Deque D)
{
    if (abs((index(D->Front - 1, D) - D->Rear)) == 0)
    {
        return false;
    }
    D->Data[D->Rear] = X;
    D->Rear = index(D->Rear + 1, D);
    
    
    return true;
}
ElementType Eject(Deque D)
{
    if (D->Front == D->Rear)return ERROR;
    
    D->Rear = index(D->Rear - 1, D);
    ElementType x = D->Data[index(D->Rear, D)];
    return x;
}
```

3-8

两个堆栈 大的用来放出队小的用来放入队  当出队的时候先把入队的全部倒着放到出队中 再出队

```C++
#include <iostream>
using namespace std;
typedef int ElementType;
int main()
{
	ElementType stko[1000], stki[1000];
	int capacityo, capacityi;
	cin >> capacityo >> capacityi;
	if (capacityo > capacityi)swap(capacityo, capacityi);
	int topo = -1, topi = -1;
	char op;
	cin >> op;
	while (op != 'T')
	{
		if (op == 'A')
		{
			int x;
			cin >> x;
			if (topo == capacityo - 1)
			{
				if (topi == -1)
				{
					while (topo != -1) 
					{
						stki[++topi] = stko[topo--];
					}
					stko[++topo] = x;
				}
				else
				{
					cout << "ERROR:Full" << endl;
				}
			}
			else
			{
				stko[++topo] = x;
			}
		}
		else
		{
			if (topi != -1)
			{
				cout << stki[topi--] << endl;
			}
			else
			{
				if (topo == -1)
				{
					cout << "ERROR:Empty" << endl;
				}
				else
				{
					while (topo != -1)
					{
						stki[++topi] = stko[topo--];
					}
					cout << stki[topi--] << endl;
				}
			}
		}
		cin >> op;
	}
}
```

3-3

中缀表达式转后缀表达式 

有几个注意的点 (栈为空就直接放)

首先是优先级问题 当顺着遇到+或-的时候优先级小于* 和 / 所以要把栈顶的所有*  和/先输出出来 然后再把+ - 放进去

遇到*  或/ 的时候就直接放进去  （直接放

遇到）的时候要一直输出符号 直到遇到（

数字直接当场输出

数字的处理 由于加减前面必须有数字  那么前面没有数字的加减 就是**正负号** i==0 或者前一个是（ 都满足这个情况 然后数字和小数点都加上

```C++
#define _CRT_SECURE_NO_WARNINGS
#include<bits/stdc++.h>
using namespace std;
map<char, int>yxj;
int flag = 0;

void print()
{
	if (flag == 0)
	{
		flag += 1;
	}
	else {
		cout << " ";
	}
}
int main()
{
	yxj.insert({ '+', 1});
	yxj.insert({ '-', 1});
	yxj.insert({ '*', 2});
	yxj.insert({ '/', 2});
	yxj.insert({ '(', 0});

	string s;
	cin >> s;
	int n = s.size();
	stack<char>cal;

	for (int i = 0; i < n;)
	{
		if (((s[i] == '+' || s[i] == '-') && (i == 0 || s[i - 1] == '(')) || ((s[i] >= '0' && s[i] <= '9') || s[i] == '.'))
		{
			print();
			if (s[i] != '+')
				cout << s[i];
			i++;
			while (((s[i] >= '0' && s[i] <= '9') || s[i] == '.'))
			{
				cout << s[i];
				i++;
			}
		}
		else if (s[i] == '(')
		{
			cal.push('(');
			i++;
		}
		else if (s[i] == ')')
		{
			while (cal.top() != '(')
			{
				char a = cal.top();
				print();
				cout << a;

				cal.pop();
			}
			cal.pop();
			i++;
		}
		else
		{
			if (!cal.empty())
			{
				char a = cal.top();
				char b = s[i];
				while (yxj[a] >= yxj[b] && !cal.empty())
				{
					print();
					cout << a;
					
					cal.pop();
					if (cal.empty())break;
					a = cal.top();
				}
				cal.push(b);
			}
			else
			{
				cal.push(s[i]);
			}
			i++;
		}
	}

	while (!cal.empty())
	{
		if (cal.top() != '(')
		{
			print();
			cout << cal.top();
		}
		cal.pop();
	}
}
```

