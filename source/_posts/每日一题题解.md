---
title: 每日一题题解
date: 2023-08-26 22:27:27
tags: Ans
subtitle: Brtulien每天都要写一题，嘿嘿
---

# [5166. 对称山脉 - AcWing题库](https://www.acwing.com/problem/content/5169/)

```python
# DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])
# 用ans记录每个长度j下的最小值
n = int(input())
nums = list(map(int, input().split()))

s = [[0] * 5010 for _ in range(5010)]
ans = [0x3f3f3f3f] * 5010
h = [0] * 5010

for i in range(n):
    h[i+1] =  nums[i]   

for j in range(2,n + 1):
    for i in range(1,n-j+2):
        s[i][i + j - 1] = s[i + 1][i + j - 2] + abs(h[i] - h[i + j - 1])
        ans[j] = min(ans[j], s[i][i + j - 1])

ans[1] = 0
for j in range(1,n + 1):
    print(ans[j],end=' ')
```

# [5180. 正方形泳池 - AcWing题库](https://www.acwing.com/problem/content/5183/)

```python
"""
枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离
"""
n = int(input())
t = int(input())
tree = []
tree.append([-1,-1]) # 占位
for i in range(1,t + 1):
    a, b = map(int,input().split())
    tree.append([a, b])

tree.append([0, 0])
tree.append([0, n + 1])
tree.append([n + 1, 0])
tree.append([n + 1, n + 1])
t += 4 # 四个顶点插入树 树的个数要加上

ans = -1
tree.sort(key=lambda x:x[0]) #  对x排序
"""
先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]
不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）
更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d

"""
for i in range(1, t + 1):
    d, u = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if x - a - 1 > u - d - 1:
            break
        ans = max(ans, x - a - 1)
        if y >= b:
            u = min(u, y)
        if y <= b:
            d = max(d, y)

tree.sort(key=lambda x: x[1])
for i in range(1, t + 1):
    l, r = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if y - b - 1 > r - l - 1:
            break
        ans = max(ans, y - b - 1)
        if x >= a:
            r = min(r, x)
        if x <= a:
            l = max(l, x)

print(ans)

```

# [1654. 到家的最少跳跃次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)

```python
# BFS 搜索
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    	q,vis = deque([[0,1,0]]), set([0])
        lower, upper = 0,max(max(forbidden) + a, x) + b
        forbiddenSet = set(forbidden)
        while q:
            position, direction, step = q.popleft()
            if x == position:
                return step
            nextposition = position + a
            nextdirection = 1
            if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                vis.add(nextposition * nextdirection)
                q.append([nextposition, nextdirection, step + 1])
            # 不能两次退后
            if direction == 1:
                nextposition = position - b
                nextdirection = -1
                if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                    vis.add(nextposition * nextdirection)
                    q.append([nextposition, nextdirection, step + 1])
    return -1
```

# [823. 带因子的二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-trees-with-factors/)

```python
"""
dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索
"""
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        s = set(arr)
        @cache
        def dfs(val):
            ans = 1
            for x in arr:
                if val % x == 0 and val // x in s:
                    ans += dfs(x) * dfs(val // x)
            return ans
       	return sum(dfs(x) for x in arr) % (10 ** 9 + 7)
    
# 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        idx = {x: i for i, x in enumerate(arr)}
        f = [1] * len(arr)
        for i in range(len(arr)):
            for j in range(i):
                val = arr[i]
                x = arr[j]
                if val % x == 0 and val // x in idx:
                    f[i] += f[j] * f[idx[val // x]]
        return sum(f) % (10 ** 9 + 7)
					
```

# [1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/)

```python
# 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次
# 用邻接矩阵来储存 

class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        g = [[0] * n for _ in range(n)]
        degree = [0] * n
        
        for x, y in edges:
            x, y = x - 1, y - 1
            g[x][y] = g[y][x] = 1
            degree[x] += 1
            degree[y] += 1
        
        ans = inf
        for i in range(n):
            for j in range(i, n):
                if g[i][j] == 1:
                    for k in range(j, n):
                        if g[i][k] == g[j][k] == 1:
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
      	return -1 if ans == inf else ans
				
```

# [5183. 好三元组 - AcWing题库](https://www.acwing.com/problem/content/description/5186/)

```python
"""
由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。
所有情况为n * (n - 1) * (n - 2) // 6
当三个数在同一点上时 不合规
两个点在同一点上 不合规
三个点在同一个半圆内时 不合规
同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规
所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1
最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来
"""
N = 2000100
n, c = map(int, input().split())
p = list(map(int,input().split()))
cnt = [0] * N
s = [0] * N
for i in range(1, n + 1):
    cnt[p[i - 1]] += 1
    cnt[p[i - 1] + c] += 1

res = n * (n - 1) * (n - 2) // 6

s[0] = cnt[0]
for i in range(1, 2 * c):
    s[i] = s[i - 1] + cnt[i]
    
for i in range(c):
    if cnt[i] == 0:
        continue
    t = cnt[i]
    d = s[i + c // 2] - s[i]
    
    # 其实不需要判断也行
    if t >= 2:
        if t >= 3:
            res -= t * (t - 1) * (t - 2) // 6
        res -= t * (t - 1) // 2 * d
    res -= t * d * (d - 1) // 2

if c % 2 == 0:
    for i in range(c // 2):
        u, v = cnt[i], cnt[i + c // 2]
        if u >= 2:
            res += u * (u - 1) // 2 * v
        if v >= 2:
            res += v * (v - 1) // 2 * u

print(res)
```

# [5145. 同色环 - AcWing题库](https://www.acwing.com/problem/content/5148/)

```C++
// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  
#include <bits/stdc++.h>
using namespace std;
const int N = 100;
int n, m;
char nums[N][N];
bool vis[N][N];
int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };

bool dfs(int x, int y, int ox, int oy)
{
    vis[x][y] = true;
    
    for (int i = 0; i < 4; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];

        if (nx >= 0 && nx < n && ny >= 0 && ny < m
            // 这一句的意思是 不能退回
            && !(nx == ox && ny == oy)
            // 颜色相同
            && nums[nx][ny] == nums[x][y])
        {
            // 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况
            if (vis[nx][ny] || dfs(nx, ny, x, y))
                return true;
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> nums[i][j];
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!vis[i][j])
            {
                if (dfs(i, j, -1, -1))
                {
                    cout << "Yes" << endl;
                    return 0;
                }
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
```

# [1921. 消灭怪物的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03)

```python
# 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）
class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        n = len(dist)
        # 上取整
        arrivetime = [math.ceil(dist[i] / speed[i]) for i in range(n)]

        arrivetime.sort()
        for attacktime, arrivetime in enumerate(arrivetime):
            if attacktime >= arrivetime:
                return attacktime
        return n
```

# [统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛](https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/)

```python
# Counter 返回字典 每个元素是键 出现次数为值
# dfs
# 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）

class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        Mod = 10 ** 9 + 7
        mx = -1
        ans = 0
        keys = list(c.keys())
        def dfs(i, count, add, mul):
            nonlocal mx, ans
            if count == k:
                if add > mx:
                    mx = add
                    ans = mul
                elif add == mx:
                    ans += mul
                ans %= Mod
                return
            if i + k - count > len(keys):
                return
            dfs(i + 1, count + 1, add + c[keys[i]], mul * c[keys[i]] % Mod)
            dfs(i + 1, count, add, mul)
        dfs(0,0,0,1)
        return ans


# 数学
# 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）
class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        else:
            from math import comb
            Mod = 10 ** 9 + 7
            values = sorted(c.values(), reverse=True)
            ans = 1
            c = 0
            for i in range(k):
                if values[i] > values[k - 1]:
                    ans *= values[i]
                    ans %= Mod
                elif values[i] == values[k - 1]:
                    c += 1
                    ans *= values[i]
                    ans %= Mod
            return ans * comb(values.count(values[k - 1]),c) % Mod

```

# [2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/)

```python
# 主要是看一下这个写法 s = set(nums1) & set(nums2) 直接取出1 2 中的相同的数字
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        ret = 0
        a = min(nums1)
        b = min(nums2)
        if a > b:
            a, b = b, a
        ret = a * 10 + b

        s = set(nums1) & set(nums2)
        if not s:
            return ret 
        return min(s)
```

# [5198. 整理书籍 - AcWing题库](https://www.acwing.com/problem/content/description/5201/)

```python
# 计算有几个L几个M 然后算有几个L不在前面 有几个M不在中间 然后至多需要交换这么多次 才能换好 但是当错位的L和M互换时 两次就只需要一次了 所以说取min(l,m)(这就是LM相互错位的个数)减掉就行
nums = list(input().strip())
n = len(nums)
cl, cm, cs = 0, 0, 0
for i, x in enumerate(nums):
    if x == 'L':
        cl += 1
    elif x == 'M':
        cm += 1
    elif x == 'S':
        cs += 1


wl, wm, lm, ml = 0, 0, 0, 0
for i in range(cl):
    if nums[i] != 'L':
        wl += 1
    if nums[i] == 'M':
        lm += 1
for i in range(cl, cl + cm):
    if nums[i] != 'M':
        wm += 1
    if nums[i] == 'L':
        ml += 1

print(wl + wm - min(lm, ml))

```

# [2594. 修车的最少时间 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-time-to-repair-cars/description/)

```python
# 二分最长的时间 计算这个时间每个人可以修的车的数量 和 cars比较 （并不需要实际地去算 应该给每个人安排多少车 而是求最大修车数 看能不能修完）
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        left = 0
        right = cars * cars * min(ranks)
        
        while left < right:
            mid = (left + right) // 2
            if sum(isqrt(mid // r) for r in ranks) >= cars:
                right = mid
            else:
                left = mid + 1
        return right
```

# [Problem - F - Codeforces](https://codeforces.com/contest/1850/problem/F)

```python
# 求一个数，他的约数的个数（同一个约数可能出现很多次）最多，遍历1~n，ans[j] += len(cs[i])。因为i的所有倍数上的点，都满足条件。所以把每个ans[j] 都加上i的个数。遍历到n的时候，就把所有的数都加上了
import collections
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    cs = collections.defaultdict(list)
    for i, x in enumerate(a):
        cs[x].append(i)
    ans = [0] * (n + 1)
    m = len(cs)
    for i in range(1, n + 1):
        j = i
        while j <= n:
            ans[j] += len(cs[i])
            j += i

    print(max(ans))

n = int(input())
for _ in range(n):
    solve()
```

# [210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/?envType=daily-question&envId=2023-09-10)

```python
# 拓扑排序(注意拓扑排序 是看是不是所有的都进入过q 或者说 最后是不是所有入度都为0) 首先建图 同时增加入度 然后把入度为0的都加入q 不断循环 每次pop的同时 numCourse-1 记录进入q的个数 如果全部进了代表没有环 那么就可以返回 而上课顺序 恰好是从q pop的顺序
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        in_deg = [0] * numCourses
        for cur, pre in prerequisites:
            graph[pre].append(cur)
            in_deg[cur] += 1
        
        q = deque([i for i, x in enumerate(in_deg) if x == 0])
        how = []
        while q:
            pre = q.popleft()
            numCourses -= 1
            how.append(pre)
            for cur in graph[pre]:
                in_deg[cur] -= 1
                if in_deg[cur] == 0:
                    q.append(cur)
        
        if numCourses == 0:
            return how
        else:
            return []
```

# [630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/?envType=daily-question&envId=2023-09-11)

```python
# 贪心＋优先队列 （反悔贪心） 很容易想到要先对结束时间排序 结束时间越晚 就越晚做，因为开始晚的先做如果做得完，可能前面的做不完了，开始晚的先做如果做不完，那前面的肯定做不完了。开始晚的后做，不管做不做得完，前一个肯定是不受影响的。
# 接着是按顺序取课 用sum记录当前总时间 h为优先队列（注意 heap默认是小根堆  为了使其成为大根堆 每次存入和取出使用相反数），如果sum+dur <= end 说明是可以都上的 那就加上 并且放入h  如果>end 不能都上 那么就判断当前的dur和之前已经存在的时间最长的课哪个时间更长 如果原来的课比当前课时间长 就要和当前的课进行替换（总数不变 sum变小） 使得sum最小 那么就更有可能多上几节课 如果当前的时间长 那这节课肯定选不了
class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key = lambda x: x[1])
        n = len(courses)
        sum = 0
        h = []
        for dur, end in courses:
            if sum + dur <= end:
                sum += dur
                heappush(h, -dur)
            elif h and -h[0] > dur:
                sum -= -h[0] - dur
                heappop(h)
                heappush(h, -dur)
        return len(h)
```

# [1462. 课程表 IV - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12)

```python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        # 拓扑排序的思路仍然是先建图 存储入度 循环找点  不同的是 （有向图） 这次0-1-2-3 不仅0-1连通 0-3也连通 要反映这样的一种关系 需要建立一个二维数组表示他们的连通关系  每次pop取出一个点 这个点是x连向的所有点 即列表graph[x] 遍历里面的每个元素 （入度减一等操作） 遍历每一个numCourse的点 如果他跟x有连接 或者跟y有连接就为True （h-y or h-x-y）
        # Toposort
        graph = defaultdict(list)
        in_deg = [0] * numCourses
        for pre, cur in prerequisites:
            graph[pre].append(cur)
            in_deg[cur] += 1
        ret = [[False] * numCourses for _ in range(numCourses)]
        q = deque([i for i, x in enumerate(in_deg) if x == 0])
        while q:
            x = q.popleft()
            for y in graph[x]:
                in_deg[y] -= 1
                ret[x][y] = True
                for h in range(numCourses):
                    ret[h][y] = ret[h][y] or ret[h][x]
                if in_deg[y] == 0:
                    q.append(y)
        return [ret[a][b] for a, b in queries]
    
    	
        # Floyd的思路 边权为True 建好图之后直接循环
        # Floyd
        graph = [[False] * numCourses for _ in range(numCourses)]
        for pre, cur in prerequisites:
            graph[pre][cur] = True
        
        for k in range(numCourses):
            for i in range(numCourses):
                for j in range(numCourses):
                    graph[i][j] = (graph[i][k] and graph[k][j]) or graph[i][j]

        return [graph[i][j] for i, j in queries]
```

# [Problem - E - Codeforces](https://codeforces.com/contest/1850/problem/E)（新二分板子）

```python
# 来自tllwtg的算法模板
"""
更好记录答案 也更有逻辑
if check():
res = mid
l = mid + 1
else:
r = mid - 1

return res
"""
import math
def solve():
    n, c = map(int, input().split())
    nums = list(map(int, input().split()))

    l, r, res = 1, 10 ** 9, -1

    while l <= r:
        mid = (l + r) // 2
        if c >= sum([(nums[i] + 2 * mid ) ** 2 for i in range(n)]):
            res = mid 
            l = mid + 1
        else:
            r = mid - 1
    print(res)

n = int(input())
for _ in range(n):
    solve()
```

# [Problem - D - Codeforces](https://codeforces.com/contest/1850/problem/D)

```python
# 求去掉几个可以使连续的最大 就是求最大然后用n减去
# 用diff记录差值 但其实可以优化 毕竟排序之后 差值只需要和前一个比较即可
def solve():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    nums.sort()
    diff = [0] * n
    diff[0] = nums[0]
    for i in range(1, n):
        diff[i] = nums[i] - nums[i - 1]
    # print(diff)
    cnt = 1
    maxi = 0
    for i in range(1, n):
        if diff[i] <= k:
            cnt += 1
        else:
            maxi = max(maxi, cnt)
            cnt = 1
    maxi = max(maxi, cnt)
    print(n - maxi)
    

n = int(input())
for _ in range(n):
    solve()
    
# 优化
def solve():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    nums.sort()
    
    
    cnt = 1
    maxi = 0
    pre = nums[0]
    for i in range(1, n):# 0不看 因为cnt初始值为1 从1开始
        if nums[i] - pre > m:
            maxi = max(maxi, cnt)
            cnt = 1
        else:
            cnt += 1
    	pre = nums[i]
    maxi = max(maxi, cnt)
    print(n - maxi)
    
    
n = int(input())
for _ in range(n):
    solve()
```

 # [5151. 程序调用 - AcWing题库](https://www.acwing.com/problem/content/description/5154/)

```C++
// 通过索引找值 再通过值找索引  并且实现交换 主要是两个数组 一个是原数组 一个是pos数组 注意每次交换的时候两个数组都要交换 知道值a pos[a]即为索引 那a的前一个数就是pos[a] - 1 然后交换
#include <iostream>
using namespace std;
const int N = 1e5 + 7;
int s[N];
int f[N];
int w[N];
int main()
{
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> s[i];
		f[s[i]] = i;
		w[i] = (i - 1) / k + 1;
	}
	long long ret = 0;
	for (int i = 1; i <= m; i++)
	{
		int x;
		cin >> x;
		ret += w[f[x]];

		if (f[x] == 1)continue;

		swap(s[f[x]], s[f[x] - 1]);
		swap(f[s[f[x]]], f[s[f[x] - 1]]);
	}
	cout << ret;
}
```

# [213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)

```python
# 打家劫舍1是一个动态规划问题 用f[k]来表示 前k间房子最多能偷多少钱 当k=n的时候就是答案 状态转移方程为f[i] = max(f[i -  1], f[i - 2] + nums[i]) 选i-1或者选i-2 + nums[i]  最后 如下的写法是优化空间复杂度的写法 因为每次仅需要前两个数和当前这个数 所以可以交替使用
# 打家劫舍2在1的基础上把首尾相连成环 这就导致首尾选不选的问题 这样的环的问题其实可以先排除掉环的影响再来做 即分为两类 首部选或不选（必定可且仅可分为两类）选首部的时候 尾部不能选（第二个也不能选） 那就是[2:-1] 不选首部的时候 就是[1:]然后看看哪个更大（有点类似之前实训课做过的枚举）
class Solution:
    def rob1(self, nums:List[int])->int:
        f0 = f1 = 0
        for x in nums:
            f0, f1 = f1, max(f0 + x, f1)
        
        return f1

    def rob(self, nums: List[int]) -> int:
        return max(nums[0] + self.rob1(nums[2:-1]), self.rob1(nums[1:]))
        
```

