---
title: 每日一题题解
date: 2023-08-26 22:27:27
tags: Ans
subtitle: Brtulien每天都要写一题，嘿嘿
---

# [5166. 对称山脉 - AcWing题库](https://www.acwing.com/problem/content/5169/)

```python
# DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])
# 用ans记录每个长度j下的最小值
n = int(input())
nums = list(map(int, input().split()))

s = [[0] * 5010 for _ in range(5010)]
ans = [0x3f3f3f3f] * 5010
h = [0] * 5010

for i in range(n):
    h[i+1] =  nums[i]   

for j in range(2,n + 1):
    for i in range(1,n-j+2):
        s[i][i + j - 1] = s[i + 1][i + j - 2] + abs(h[i] - h[i + j - 1])
        ans[j] = min(ans[j], s[i][i + j - 1])

ans[1] = 0
for j in range(1,n + 1):
    print(ans[j],end=' ')
```

# [5180. 正方形泳池 - AcWing题库](https://www.acwing.com/problem/content/5183/)

```python
"""
枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离
"""
n = int(input())
t = int(input())
tree = []
tree.append([-1,-1]) # 占位
for i in range(1,t + 1):
    a, b = map(int,input().split())
    tree.append([a, b])

tree.append([0, 0])
tree.append([0, n + 1])
tree.append([n + 1, 0])
tree.append([n + 1, n + 1])
t += 4 # 四个顶点插入树 树的个数要加上

ans = -1
tree.sort(key=lambda x:x[0]) #  对x排序
"""
先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]
不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）
更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d

"""
for i in range(1, t + 1):
    d, u = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if x - a - 1 > u - d - 1:
            break
        ans = max(ans, x - a - 1)
        if y >= b:
            u = min(u, y)
        if y <= b:
            d = max(d, y)

tree.sort(key=lambda x: x[1])
for i in range(1, t + 1):
    l, r = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if y - b - 1 > r - l - 1:
            break
        ans = max(ans, y - b - 1)
        if x >= a:
            r = min(r, x)
        if x <= a:
            l = max(l, x)

print(ans)

```

# [1654. 到家的最少跳跃次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)

```python
# BFS 搜索
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    	q,vis = deque([[0,1,0]]), set([0])
        lower, upper = 0,max(max(forbidden) + a, x) + b
        forbiddenSet = set(forbidden)
        while q:
            position, direction, step = q.popleft()
            if x == position:
                return step
            nextposition = position + a
            nextdirection = 1
            if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                vis.add(nextposition * nextdirection)
                q.append([nextposition, nextdirection, step + 1])
            # 不能两次退后
            if direction == 1:
                nextposition = position - b
                nextdirection = -1
                if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                    vis.add(nextposition * nextdirection)
                    q.append([nextposition, nextdirection, step + 1])
    return -1
```

# [823. 带因子的二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-trees-with-factors/)

```python
"""
dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索
"""
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        s = set(arr)
        @cache
        def dfs(val):
            ans = 1
            for x in arr:
                if val % x == 0 and val // x in s:
                    ans += dfs(x) * dfs(val // x)
            return ans
       	return sum(dfs(x) for x in arr) % (10 ** 9 + 7)
    
# 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        idx = {x: i for i, x in enumerate(arr)}
        f = [1] * len(arr)
        for i in range(len(arr)):
            for j in range(i):
                val = arr[i]
                x = arr[j]
                if val % x == 0 and val // x in idx:
                    f[i] += f[j] * f[idx[val // x]]
        return sum(f) % (10 ** 9 + 7)
					
```

# [1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/)

```python
# 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次
# 用邻接矩阵来储存 

class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        g = [[0] * n for _ in range(n)]
        degree = [0] * n
        
        for x, y in edges:
            x, y = x - 1, y - 1
            g[x][y] = g[y][x] = 1
            degree[x] += 1
            degree[y] += 1
        
        ans = inf
        for i in range(n):
            for j in range(i, n):
                if g[i][j] == 1:
                    for k in range(j, n):
                        if g[i][k] == g[j][k] == 1:
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
      	return -1 if ans == inf else ans
				
```

# [5183. 好三元组 - AcWing题库](https://www.acwing.com/problem/content/description/5186/)

```python
"""
由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。
所有情况为n * (n - 1) * (n - 2) // 6
当三个数在同一点上时 不合规
两个点在同一点上 不合规
三个点在同一个半圆内时 不合规
同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规
所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1
最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来
"""
N = 2000100
n, c = map(int, input().split())
p = list(map(int,input().split()))
cnt = [0] * N
s = [0] * N
for i in range(1, n + 1):
    cnt[p[i - 1]] += 1
    cnt[p[i - 1] + c] += 1

res = n * (n - 1) * (n - 2) // 6

s[0] = cnt[0]
for i in range(1, 2 * c):
    s[i] = s[i - 1] + cnt[i]
    
for i in range(c):
    if cnt[i] == 0:
        continue
    t = cnt[i]
    d = s[i + c // 2] - s[i]
    
    # 其实不需要判断也行
    if t >= 2:
        if t >= 3:
            res -= t * (t - 1) * (t - 2) // 6
        res -= t * (t - 1) // 2 * d
    res -= t * d * (d - 1) // 2

if c % 2 == 0:
    for i in range(c // 2):
        u, v = cnt[i], cnt[i + c // 2]
        if u >= 2:
            res += u * (u - 1) // 2 * v
        if v >= 2:
            res += v * (v - 1) // 2 * u

print(res)
```

# [5145. 同色环 - AcWing题库](https://www.acwing.com/problem/content/5148/)

```C++
// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  
#include <bits/stdc++.h>
using namespace std;
const int N = 100;
int n, m;
char nums[N][N];
bool vis[N][N];
int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };

bool dfs(int x, int y, int ox, int oy)
{
    vis[x][y] = true;
    
    for (int i = 0; i < 4; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];

        if (nx >= 0 && nx < n && ny >= 0 && ny < m
            // 这一句的意思是 不能退回
            && !(nx == ox && ny == oy)
            // 颜色相同
            && nums[nx][ny] == nums[x][y])
        {
            // 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况
            if (vis[nx][ny] || dfs(nx, ny, x, y))
                return true;
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> nums[i][j];
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!vis[i][j])
            {
                if (dfs(i, j, -1, -1))
                {
                    cout << "Yes" << endl;
                    return 0;
                }
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
```

# [1921. 消灭怪物的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03)

```python
# 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）
class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        n = len(dist)
        # 上取整
        arrivetime = [math.ceil(dist[i] / speed[i]) for i in range(n)]

        arrivetime.sort()
        for attacktime, arrivetime in enumerate(arrivetime):
            if attacktime >= arrivetime:
                return attacktime
        return n
```

# [统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛](https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/)

```python
# Counter 返回字典 每个元素是键 出现次数为值
# dfs
# 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）

class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        Mod = 10 ** 9 + 7
        mx = -1
        ans = 0
        keys = list(c.keys())
        def dfs(i, count, add, mul):
            nonlocal mx, ans
            if count == k:
                if add > mx:
                    mx = add
                    ans = mul
                elif add == mx:
                    ans += mul
                ans %= Mod
                return
            if i + k - count > len(keys):
                return
            dfs(i + 1, count + 1, add + c[keys[i]], mul * c[keys[i]] % Mod)
            dfs(i + 1, count, add, mul)
        dfs(0,0,0,1)
        return ans


# 数学
# 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）
class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        else:
            from math import comb
            Mod = 10 ** 9 + 7
            values = sorted(c.values(), reverse=True)
            ans = 1
            c = 0
            for i in range(k):
                if values[i] > values[k - 1]:
                    ans *= values[i]
                    ans %= Mod
                elif values[i] == values[k - 1]:
                    c += 1
                    ans *= values[i]
                    ans %= Mod
            return ans * comb(values.count(values[k - 1]),c) % Mod

```

# [2605. 从两个数字数组里生成最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/)

```python
# 主要是看一下这个写法 s = set(nums1) & set(nums2) 直接取出1 2 中的相同的数字
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        ret = 0
        a = min(nums1)
        b = min(nums2)
        if a > b:
            a, b = b, a
        ret = a * 10 + b

        s = set(nums1) & set(nums2)
        if not s:
            return ret 
        return min(s)
```

# [5198. 整理书籍 - AcWing题库](https://www.acwing.com/problem/content/description/5201/)

```python
# 计算有几个L几个M 然后算有几个L不在前面 有几个M不在中间 然后至多需要交换这么多次 才能换好 但是当错位的L和M互换时 两次就只需要一次了 所以说取min(l,m)(这就是LM相互错位的个数)减掉就行
nums = list(input().strip())
n = len(nums)
cl, cm, cs = 0, 0, 0
for i, x in enumerate(nums):
    if x == 'L':
        cl += 1
    elif x == 'M':
        cm += 1
    elif x == 'S':
        cs += 1


wl, wm, lm, ml = 0, 0, 0, 0
for i in range(cl):
    if nums[i] != 'L':
        wl += 1
    if nums[i] == 'M':
        lm += 1
for i in range(cl, cl + cm):
    if nums[i] != 'M':
        wm += 1
    if nums[i] == 'L':
        ml += 1

print(wl + wm - min(lm, ml))

```

# [2594. 修车的最少时间 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-time-to-repair-cars/description/)

```python
# 二分最长的时间 计算这个时间每个人可以修的车的数量 和 cars比较 （并不需要实际地去算 应该给每个人安排多少车 而是求最大修车数 看能不能修完）
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        left = 0
        right = cars * cars * min(ranks)
        
        while left < right:
            mid = (left + right) // 2
            if sum(isqrt(mid // r) for r in ranks) >= cars:
                right = mid
            else:
                left = mid + 1
        return right
```

# [Problem - F - Codeforces](https://codeforces.com/contest/1850/problem/F)

```python
# 求一个数，他的约数的个数（同一个约数可能出现很多次）最多，遍历1~n，ans[j] += len(cs[i])。因为i的所有倍数上的点，都满足条件。所以把每个ans[j] 都加上i的个数。遍历到n的时候，就把所有的数都加上了
import collections
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    cs = collections.defaultdict(list)
    for i, x in enumerate(a):
        cs[x].append(i)
    ans = [0] * (n + 1)
    m = len(cs)
    for i in range(1, n + 1):
        j = i
        while j <= n:
            ans[j] += len(cs[i])
            j += i

    print(max(ans))

n = int(input())
for _ in range(n):
    solve()
```

# [210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/?envType=daily-question&envId=2023-09-10)

```python
# 拓扑排序(注意拓扑排序 是看是不是所有的都进入过q 或者说 最后是不是所有入度都为0) 首先建图 同时增加入度 然后把入度为0的都加入q 不断循环 每次pop的同时 numCourse-1 记录进入q的个数 如果全部进了代表没有环 那么就可以返回 而上课顺序 恰好是从q pop的顺序
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        in_deg = [0] * numCourses
        for cur, pre in prerequisites:
            graph[pre].append(cur)
            in_deg[cur] += 1
        
        q = deque([i for i, x in enumerate(in_deg) if x == 0])
        how = []
        while q:
            pre = q.popleft()
            numCourses -= 1
            how.append(pre)
            for cur in graph[pre]:
                in_deg[cur] -= 1
                if in_deg[cur] == 0:
                    q.append(cur)
        
        if numCourses == 0:
            return how
        else:
            return []
```

# [630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/?envType=daily-question&envId=2023-09-11)

```python
# 贪心＋优先队列 （反悔贪心） 很容易想到要先对结束时间排序 结束时间越晚 就越晚做，因为开始晚的先做如果做得完，可能前面的做不完了，开始晚的先做如果做不完，那前面的肯定做不完了。开始晚的后做，不管做不做得完，前一个肯定是不受影响的。
# 接着是按顺序取课 用sum记录当前总时间 h为优先队列（注意 heap默认是小根堆  为了使其成为大根堆 每次存入和取出使用相反数），如果sum+dur <= end 说明是可以都上的 那就加上 并且放入h  如果>end 不能都上 那么就判断当前的dur和之前已经存在的时间最长的课哪个时间更长 如果原来的课比当前课时间长 就要和当前的课进行替换（总数不变 sum变小） 使得sum最小 那么就更有可能多上几节课 如果当前的时间长 那这节课肯定选不了
class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key = lambda x: x[1])
        n = len(courses)
        sum = 0
        h = []
        for dur, end in courses:
            if sum + dur <= end:
                sum += dur
                heappush(h, -dur)
            elif h and -h[0] > dur:
                sum -= -h[0] - dur
                heappop(h)
                heappush(h, -dur)
        return len(h)
```

# [1462. 课程表 IV - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12)

```python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        # 拓扑排序的思路仍然是先建图 存储入度 循环找点  不同的是 （有向图） 这次0-1-2-3 不仅0-1连通 0-3也连通 要反映这样的一种关系 需要建立一个二维数组表示他们的连通关系  每次pop取出一个点 这个点是x连向的所有点 即列表graph[x] 遍历里面的每个元素 （入度减一等操作） 遍历每一个numCourse的点 如果他跟x有连接 或者跟y有连接就为True （h-y or h-x-y）
        # Toposort
        graph = defaultdict(list)
        in_deg = [0] * numCourses
        for pre, cur in prerequisites:
            graph[pre].append(cur)
            in_deg[cur] += 1
        ret = [[False] * numCourses for _ in range(numCourses)]
        q = deque([i for i, x in enumerate(in_deg) if x == 0])
        while q:
            x = q.popleft()
            for y in graph[x]:
                in_deg[y] -= 1
                ret[x][y] = True
                for h in range(numCourses):
                    ret[h][y] = ret[h][y] or ret[h][x]
                if in_deg[y] == 0:
                    q.append(y)
        return [ret[a][b] for a, b in queries]
    
    	
        # Floyd的思路 边权为True 建好图之后直接循环
        # Floyd
        graph = [[False] * numCourses for _ in range(numCourses)]
        for pre, cur in prerequisites:
            graph[pre][cur] = True
        
        for k in range(numCourses):
            for i in range(numCourses):
                for j in range(numCourses):
                    graph[i][j] = (graph[i][k] and graph[k][j]) or graph[i][j]

        return [graph[i][j] for i, j in queries]
```

# [Problem - E - Codeforces](https://codeforces.com/contest/1850/problem/E)（新二分板子）

```python
# 来自tllwtg的算法模板
"""
更好记录答案 也更有逻辑
if check():
res = mid
l = mid + 1
else:
r = mid - 1

return res
"""
import math
def solve():
    n, c = map(int, input().split())
    nums = list(map(int, input().split()))

    l, r, res = 1, 10 ** 9, -1

    while l <= r:
        mid = (l + r) // 2
        if c >= sum([(nums[i] + 2 * mid ) ** 2 for i in range(n)]):
            res = mid 
            l = mid + 1
        else:
            r = mid - 1
    print(res)

n = int(input())
for _ in range(n):
    solve()
```

# [Problem - D - Codeforces](https://codeforces.com/contest/1850/problem/D)

```python
# 求去掉几个可以使连续的最大 就是求最大然后用n减去
# 用diff记录差值 但其实可以优化 毕竟排序之后 差值只需要和前一个比较即可
def solve():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    nums.sort()
    diff = [0] * n
    diff[0] = nums[0]
    for i in range(1, n):
        diff[i] = nums[i] - nums[i - 1]
    # print(diff)
    cnt = 1
    maxi = 0
    for i in range(1, n):
        if diff[i] <= k:
            cnt += 1
        else:
            maxi = max(maxi, cnt)
            cnt = 1
    maxi = max(maxi, cnt)
    print(n - maxi)
    

n = int(input())
for _ in range(n):
    solve()
    
# 优化
def solve():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    nums.sort()
    
    
    cnt = 1
    maxi = 0
    pre = nums[0]
    for i in range(1, n):# 0不看 因为cnt初始值为1 从1开始
        if nums[i] - pre > m:
            maxi = max(maxi, cnt)
            cnt = 1
        else:
            cnt += 1
    	pre = nums[i]
    maxi = max(maxi, cnt)
    print(n - maxi)
    
    
n = int(input())
for _ in range(n):
    solve()
```

 # [5151. 程序调用 - AcWing题库](https://www.acwing.com/problem/content/description/5154/)

```C++
// 通过索引找值 再通过值找索引  并且实现交换 主要是两个数组 一个是原数组 一个是pos数组 注意每次交换的时候两个数组都要交换 知道值a pos[a]即为索引 那a的前一个数就是pos[a] - 1 然后交换
#include <iostream>
using namespace std;
const int N = 1e5 + 7;
int s[N];
int f[N];
int w[N];
int main()
{
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> s[i];
		f[s[i]] = i;
		w[i] = (i - 1) / k + 1;
	}
	long long ret = 0;
	for (int i = 1; i <= m; i++)
	{
		int x;
		cin >> x;
		ret += w[f[x]];

		if (f[x] == 1)continue;

		swap(s[f[x]], s[f[x] - 1]);
		swap(f[s[f[x]]], f[s[f[x] - 1]]);
	}
	cout << ret;
}
```

# [213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)

```python
# 打家劫舍1是一个动态规划问题 用f[k]来表示 前k间房子最多能偷多少钱 当k=n的时候就是答案 状态转移方程为f[i] = max(f[i -  1], f[i - 2] + nums[i]) 选i-1或者选i-2 + nums[i]  最后 如下的写法是优化空间复杂度的写法 因为每次仅需要前两个数和当前这个数 所以可以交替使用
# 打家劫舍2在1的基础上把首尾相连成环 这就导致首尾选不选的问题 这样的环的问题其实可以先排除掉环的影响再来做 即分为两类 首部选或不选（必定可且仅可分为两类）选首部的时候 尾部不能选（第二个也不能选） 那就是[2:-1] 不选首部的时候 就是[1:]然后看看哪个更大（有点类似之前实训课做过的枚举）
class Solution:
    def rob1(self, nums:List[int])->int:
        f0 = f1 = 0
        for x in nums:
            f0, f1 = f1, max(f0 + x, f1)
        
        return f1

    def rob(self, nums: List[int]) -> int:
        return max(nums[0] + self.rob1(nums[2:-1]), self.rob1(nums[1:]))
        
```

# [337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/discussion/)

```python
# 树形DP 还是一样分析 根节点选或者不选（注意根节点不选 下一个结点也不一定要选）求出 左子树不选根的最大值和左子树选根的最大值 和 右子树不选根的最大值和右子树选根的最大值 如果选根 那么总共的最大值就是根+左不选根+右不选根 如果不选根 那就是左子树最大（选根和不选根 的最大）和右子树最大 相加
# 注意先想好dfs是做什么的  从root开始 返回选root的最大值 和不选root的最大值

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(root):
            if root is None:
                return 0, 0
           	l_rob, l_not_rob = dfs(root.left)
            r_rob, r_not_rob = dfs(root.right)
            rob = root.val + l_not_rob + r_not_rob
            not_rob = max(l_rob, l_not_rob) + max(r_rob, r_not_rob)
            return rob, not_rob
        
        return max(dfs(root))
```

# [2560. 打家劫舍 IV - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iv/solutions/2093952/er-fen-da-an-dp-by-endlesscheng-m558/)

``` python
# 二分答案 最小化能够抢到的最大值 类似的表述就是二分答案的套路
# 二分偷取的钱数（得到最小值）  当偷盗的房子数满足k的时候 就可以成为一个答案  本解还有贪心 只要遇到可偷的就立即偷
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        minn = min(nums)
        maxn = max(nums)
        res = -1
        while minn <= maxn:
            mid = (maxn + minn) // 2
            cnt = 0
            vis = False
            for num in nums:
                if not vis and num <= mid:
                    cnt += 1
                    vis = True
                else:
                    vis = False
            if cnt < k:
                
                minn = mid + 1
            else:
                res = mid
                maxn = mid - 1
        return res
    
# 也可以用二分+动态规划 状态表示为从0~i可偷的房间数为f[i] 状态计算为f[i] = max(f[i - 1], f[i - 1] + 1) 
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        def solve(mx: int) -> int:
            f0 = f1 = 0
            for num in nums:
                if num <= mx:
                   f0, f1 = f1, max(f1, f0 + 1)
            	else:
                    f0 = f1
           	return  f1
       	return bisect_left(range(max(nums)), k, key=solve)
```

# [2603. 收集树中金币 - 力扣（LeetCode）](https://leetcode.cn/problems/collect-coins-in-a-tree/)

```python
class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n = len(coins)
        graph = [[] for _ in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        deg = list(map(len, graph))
        q = deque()
        res = n - 1 # 总边数
        # 先把没有金币的叶子节点存入数组（相当于拓扑排序的放入入度为0的点
        for i, (d, c) in enumerate(zip(deg, coins)):
            if d == 1 and c == 0:
                q.append(i)
        # 删除所有没有金币的叶子节点
        while q:
            x = q.popleft()
            res -= 1 # 每次循环都会删掉一条边
            for y in graph[x]:
                deg[y] -= 1
                if deg[y] == 1 and coins[y] == 0:
                    q.append(y)

        # 删除最下面两层结点（叶子结点和叶子节点的父节点）（此时的叶子节点是含金币的因为不含的已经删除）
        for i, (d, c) in enumerate(zip(deg, coins)):
            if d == 1 and c == 1:
                q.append(i)
        # 这一层的所有含金币的叶子都被删除了 那么这些线就不用走了 删除的总数就是len(q)      
        res -= len(q)

        # 接下来删除叶子节点的父节点（叶子在上面已经删除）
        for x in q:
            for y in graph[x]:
                deg[y] -= 1
                if deg[y] == 1:
                    res -= 1

        return max(0, res * 2)
```

# [1993. 树上的操作 - 力扣（LeetCode）](https://leetcode.cn/problems/operations-on-tree/?envType=daily-question&envId=2023-09-23)



```python
class LockingTree:
	# 初始化需要有父节点和每个父节点的子节点
    def __init__(self, parent: List[int]):
        n = len(parent)
        self.parent = parent
        self.lockNodeUser = [-1] * n
        self.children = [[] for _ in range(n)]
        
        for node, p in enumerate(parent):
            if p != -1:
                self.children[p].append(node)


    def lock(self, num: int, user: int) -> bool:
        if self.lockNodeUser[num] == -1:
            self.lockNodeUser[num] = user
            return True
        else:
            return False

    def unlock(self, num: int, user: int) -> bool:
        if self.lockNodeUser[num] == user:
            self.lockNodeUser[num] = -1
            return True
        else:
            return False
	# 难点主要是更新 如果该结点没有上锁 并且祖先没有上锁 并且孩子有上锁（同时解锁所有孩子） 
    def upgrade(self, num: int, user: int) -> bool:
        res = self.lockNodeUser[num] == -1 and not self.haslockedansester(num) and self.checkandlockdescendant(num)
        if res:
            self.lockNodeUser[num] = user
        return res
    # 由父节点不断向上 直到根节点 如果有上锁的 就直接返回 否则就继续向上
    def haslockedansester(self, num: int) -> bool:
        res = self.parent[num]
        while num != -1:
            if self.lockNodeUser[num] != -1:
                return True
            else:
                num = self.parent[num]
        return False
	# 如果找到了一个上锁的子节 就直接解锁  因为只要有上锁 就表示满足要求 需要解锁 而如果都没有上锁 那解锁操作也不会影响原来的结点
    def checkandlockdescendant(self, num: int)->bool:
        res = self.lockNodeUser[num] != -1
        self.lockNodeUser[num] = -1
        for child in self.children[num]:
            res |= self.checkandlockdescendant(child)
        return res
# Your LockingTree object will be instantiated and called as such:
# obj = LockingTree(parent)
# param_1 = obj.lock(num,user)
# param_2 = obj.unlock(num,user)
# param_3 = obj.upgrade(num,user)
```

# [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/?envType=daily-question&envId=2023-09-24)

```python
class Node:
    def __init__(self, key=0, value=0):
        self.value = value
        self.next = None
        self.prev = None
        self.key = key

class LRUCache:
    # 因为需要O(1) 的存取 所以使用双向链表加字典
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.head = Node()
        self.head.prev = self.head
        self.head.next = self.head
        self.map = dict()

    
    def get(self, key: int) -> int:
        node = self.get_node(key)
        return node.value if node else -1

    # 插入 如果已经在的话就修改 如果不在的话首先 在map中记录 如何插入链表头 如果大于capacity的话 就删除链表尾(因为一开始把每次访问的都放在头部了（LRU的特性）所以删除的时候就可以直接删除尾部)
    def put(self, key: int, value: int) -> None:
        node = self.get_node(key)
        if node:
            node.value = value
            return
        
        self.map[key] = node = Node(key, value)
        self.push_front(node)
        if len(self.map) > self.capacity:
            back_node = self.head.prev
            del self.map[back_node.key]
            self.remove(back_node)

    
    def push_front(self, x: Node):
        x.prev = self.head
        x.next = self.head.next
        self.head.next.prev = x
        self.head.next = x
    
    def remove(self, x: Node):
        x.prev.next = x.next
        x.next.prev = x.prev

    # 查找 如果key不在map的话 return None 否则把他放到链表头
    def get_node(self, key: int) -> Optional[Node]:
        if key not in self.map:
            return None
        node = self.map[key]
        self.remove(node)
        self.push_front(node)
        return node

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

# [460. LFU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lfu-cache/?envType=daily-question&envId=2023-09-25)

```python
class Node:
    # 结点的定义 双向链表的结点加上字典的key和访问次数cnt
    def __init__(self, key=0,value=0,next=None,prev=None):
        self.value = value
        self.next = next
        self.prev = prev
        self.cnt = 1
        self.key = key

# 需要建一个次数表 把访问次数相同的放在一起 用字典实现 key为访问次数
class LFUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.key_to_node = dict()
        def new_node()->Node:
            head = Node()
            head.next = head
            head.prev = head
            return head
        self.freq_to_head = defaultdict(new_node)
    
        

    def get(self, key: int) -> int:
        node = self.get_node(key)
        return node.value if node else -1
    # 当这本书已经存在的时候 修改值 否则要放入（访问一次）中（注意先判断是否已满）
    def put(self, key: int, value: int) -> None:
        node = self.get_node(key)
        if node:
            node.value = value
            return 
        # 如果已满就拿出访问min_freq次的最下面的书（最不常用）
        if len(self.key_to_node) == self.capacity:
            phead = self.freq_to_head[self.min_freq]
            back_node = phead.prev # 最不常用的
            del self.key_to_node[back_node.key]  # 从字典删除
            self.remove(back_node) # 从链表中删除
            # 如果删除的是头结点 那就直接把整个链表删除了
            if phead.prev == phead:
                del self.freq_to_head[self.min_freq]
        # 插入这本书
        self.key_to_node[key] = node = Node(key, value)
        # 放到最上面
        self.push_front(self.freq_to_head[1],node)
        # 刚插入的访问次数必定为1
        self.min_freq = 1

    def push_front(self, head:Node, x:Node):
        x.prev = head
        x.next = head.next
        x.next.prev = x
        x.prev.next = x

    def remove(self, x:Node):
        x.prev.next = x.next
        x.next.prev = x.prev

    def get_node(self, key: int):
        if key not in self.key_to_node:
            return None
        node = self.key_to_node[key]# 找到这本书
        self.remove(node)# 去掉
        phead = self.freq_to_head[node.cnt]
        # 如果这本书原来所在的链表只有他一个 那就删除链表
        if phead.prev == phead:
            del self.freq_to_head[node.cnt]
            # 如果这本书恰好是访问一次的链表 那么删除之后就没有访问一次的了 至少也是访问两次的
            if self.min_freq == node.cnt:
                self.min_freq += 1
        # 这本书访问次数加1
        node.cnt += 1
        # 插到最上面
        self.push_front(self.freq_to_head[node.cnt], node)
        return node
        

# Your LFUCache object will be instantiated and called as such:
# obj = LFUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

# [587. 安装栅栏 - 力扣（LeetCode）](https://leetcode.cn/problems/erect-the-fence/description/)

```python
class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        # 求扫过的面积 如果<0 说明需要更新
        def cross(p: List[int], q: List[int], r: List[int]) -> int:
            return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])
        
        n = len(trees)
        if n < 4:
            return trees

        trees.sort()

        hull = [0]
        used = [False] * n
        # 求凸包下半部分
        for i in range(1, n):
            while len(hull) > 1 and cross(trees[hull[-2]], trees[hull[-1]], trees[i]) < 0:
                used[hull.pop()] = False
            used[i] = True
            hull.append(i)
        # 求凸包的上半部分
        m = len(hull)
        for i in range(n - 2, -1, -1):
            if not used[i]:
                while len(hull) > m and cross(trees[hull[-2]], trees[hull[-1]], trees[i]) < 0:
                    used[hull.pop()] = False
                used[i] = True
                hull.append(i)
        # hull[0] 是起点 同时参加上半部分的检测 所以要删掉
        hull.pop()
        return [trees[i] for i in hull]
```

# [2251. 花期内花的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solutions/1445000/chai-fen-pythonjavacgo-by-endlesscheng-wz35/?envType=daily-question&envId=2023-09-28)

```python
# 差分前缀和 不需要每次把每个区间全部加上 这样复杂度过高 而是只需要在区间开头处+1 在区间结尾处-1 然后排序保证访问的时候是遍历的顺序 计算前缀和  如第一个人第二分钟来 那就算出第二分钟有几朵花 就是第二分钟的前缀和 
class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        diff = Counter()
        for s, e in flowers:
            diff[s] += 1
            diff[e + 1] -= 1

        time = sorted(diff.keys())
        s = j = 0

        for p, i in sorted(zip(people, range(len(people)))):
            while j < len(time) and time[j] <= p:
                s += diff[time[j]]
                j += 1
            people[i] = s

        return people
    
# 或者更简单的 直接计算第i分钟的花的数量  用第i分钟开花的数量减去第j分钟开花的数量 对开花时间和结束时间排序获得start和end数组 通过二分寻找开花数和凋谢数
class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        start = sorted(s for s, _ in flowers)
        end = sorted(e for _, e in flowers)
        return [bisect_right(start, p) - bisect_left(end, p) for p in people]
    
```

# [2731. 移动机器人 - 力扣（LeetCode）](https://leetcode.cn/problems/movement-of-robots/)

发现 最后只需要计算机器人的间隔 左右相碰之后转向 其实也就可以视为两个之间互换了 之间的 距离不会受到影响 

```
比如a 0R b 2L 3s 
1s 时在1 处相碰   转向 a向左 b向右
然后3s后  a在-1 b在3
其实也就相当于  a直接走3s到3  b直接走3s到-1  距离不变  机器人间不需要区分
```

然后计算距离  两两之间的差可以O(n)计算！！但是注意 必须有序

```
1 3 4 8 9 之间的差为
3-1 + 4-1 + 8-1 + 9-1
      4-3 + 8-3 + 9-3 
            8-4 + 9-4
                  9-8
因此每次算一个即可  ans + i * nums[i] 表示排i的数共被加了几次 3 1次 4 两次 8 三次 9 四次
再减去s  s表示每次减去的数  第一次减1  第二次减4（1 + 3） 第三次减8 （1 + 3 + 4） 第四次减16（1 + 3 + 4 + 8）
```



```py
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        n = len(nums)
        for i in range(n):
            f = -1 if s[i] == 'L' else 1
            nums[i] += f * d
        nums.sort()

        ans = 0
        s = 0
        for i in range(n):
            ans += i * nums[i] - s
            s += nums[i]
        return ans % (10 ** 9 + 7)
```

# [2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）](https://leetcode.cn/problems/reward-top-k-students/?envType=daily-question&envId=2023-10-11)

不需要用结构体也可以 用zip来直接sort

用split分割单词

```py
class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        score = defaultdict(int)
        for w in positive_feedback:
            score[w] = 3
        for w in negative_feedback:
            score[w] = -1
        a = sorted((-sum(score[w] for w in r.split()), i) for r, i in zip(report, student_id))

        return [i for _, i in a[:k]]
```



# [1488. 避免洪水泛滥 - 力扣（LeetCode）](https://leetcode.cn/problems/avoid-flood-in-the-city/)

不是每次晴天就去寻找抽哪个  而是到了后面 发现他要发洪水之后 就去前面找他下雨之后的第一个晴天 把他的水抽干 如果没找到 就直接返回空数组

注意用bisect_left寻找该湖泊下雨后第一个晴天

用pop删除这个晴天

```python
from sortedcontainers import SortedList

class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        n = len(rains)
        ans = [1] * n
        sun_day = SortedList()
        full = {}
        for i in range(n):
            if rains[i] == 0:
                sun_day.add(i)
            else:
                if rains[i] not in full:
                    full[rains[i]] = i
                else:
                    j = sun_day.bisect_left(full[rains[i]])
                    if not 0 <= j < len(sun_day):
                        return []
                    ans[sun_day.pop(j)] = rains[i]
                    full[rains[i]] = i
                ans[i] = -1
        return ans
```

