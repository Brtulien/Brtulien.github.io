---
title: 每日一题题解
date: 2023-08-26 22:27:27
tags: Ans
---

# [5166. 对称山脉 - AcWing题库](https://www.acwing.com/problem/content/5169/)

```python
# DP 状态转移为 第i到k的答案是 第i+1到第k-1个的答案再加上 abs(h[i] - h[i + j - 1])
# 用ans记录每个长度j下的最小值
n = int(input())
nums = list(map(int, input().split()))

s = [[0] * 5010 for _ in range(5010)]
ans = [0x3f3f3f3f] * 5010
h = [0] * 5010

for i in range(n):
    h[i+1] =  nums[i]   

for j in range(2,n + 1):
    for i in range(1,n-j+2):
        s[i][i + j - 1] = s[i + 1][i + j - 2] + abs(h[i] - h[i + j - 1])
        ans[j] = min(ans[j], s[i][i + j - 1])

ans[1] = 0
for j in range(1,n + 1):
    print(ans[j],end=' ')
```

# [5180. 正方形泳池 - AcWing题库](https://www.acwing.com/problem/content/5183/)

```python
"""
枚举n太复杂，枚举t，枚举每棵树的位置（按顺序）然后不断更新 ans和上下距离 ans和水平距离
"""
n = int(input())
t = int(input())
tree = []
tree.append([-1,-1]) # 占位
for i in range(1,t + 1):
    a, b = map(int,input().split())
    tree.append([a, b])

tree.append([0, 0])
tree.append([0, n + 1])
tree.append([n + 1, 0])
tree.append([n + 1, n + 1])
t += 4 # 四个顶点插入树 树的个数要加上

ans = -1
tree.sort(key=lambda x:x[0]) #  对x排序
"""
先初始化最低点最高点d,u 为0 和 n + 1 然后枚举tree[i] 右边的tree[j]
不断向右枚举 当i j的水平距离大于 上下的最大距离（u-d-1）的时候 退出（因为被上下距离限制了，再往右的话 水平距离增大，但是没有用，正方形就看最短的边）
更新ans为x-a-1 然后更新上下的最短距离（每一次都更新，因为中间有树挡着了，就会减小泳池的面积）更新u和d

"""
for i in range(1, t + 1):
    d, u = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if x - a - 1 > u - d - 1:
            break
        ans = max(ans, x - a - 1)
        if y >= b:
            u = min(u, y)
        if y <= b:
            d = max(d, y)

tree.sort(key=lambda x: x[1])
for i in range(1, t + 1):
    l, r = 0, n + 1
    for j in range(i + 1, t + 1):
        x, y = tree[j]
        a, b = tree[i]
        if y - b - 1 > r - l - 1:
            break
        ans = max(ans, y - b - 1)
        if x >= a:
            r = min(r, x)
        if x <= a:
            l = max(l, x)

print(ans)

```

# [1654. 到家的最少跳跃次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)

```python
# BFS 搜索
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    	q,vis = deque([[0,1,0]]), set([0])
        lower, upper = 0,max(max(forbidden) + a, x) + b
        forbiddenSet = set(forbidden)
        while q:
            position, direction, step = q.popleft()
            if x == position:
                return step
            nextposition = position + a
            nextdirection = 1
            if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                vis.add(nextposition * nextdirection)
                q.append([nextposition, nextdirection, step + 1])
            # 不能两次退后
            if direction == 1:
                nextposition = position - b
                nextdirection = -1
                if lower <= nextposition <= upper and nextposition * nextdirection not in vis and nextposition not in forbiddenSet:
                    vis.add(nextposition * nextdirection)
                    q.append([nextposition, nextdirection, step + 1])
    return -1
```

# [823. 带因子的二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-trees-with-factors/)

```python
"""
dfs 先找到val的答案的个数 然后找val的左子树（x）的答案的个数 再找val的右子树（val//x）的答案 用@cache 变为记忆化搜索
"""
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        s = set(arr)
        @cache
        def dfs(val):
            ans = 1
            for x in arr:
                if val % x == 0 and val // x in s:
                    ans += dfs(x) * dfs(val // x)
            return ans
       	return sum(dfs(x) for x in arr) % (10 ** 9 + 7)
    
# 递推 用f表示这个点作为根节点的时候有多少种情况 用idx反向查询这个点的下标
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        idx = {x: i for i, x in enumerate(arr)}
        f = [1] * len(arr)
        for i in range(len(arr)):
            for j in range(i):
                val = arr[i]
                x = arr[j]
                if val % x == 0 and val // x in idx:
                    f[i] += f[j] * f[idx[val // x]]
        return sum(f) % (10 ** 9 + 7)
					
```

# [1761. 一个图中连通三元组的最小度数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/2417898/yi-ge-tu-zhong-lian-tong-san-yuan-zu-de-wuv8o/)

```python
# 枚举每一个三元组，然后求度数，可以预处理度数 注意最后出度要减6 因为三元组内每条相连的边被算了两次
# 用邻接矩阵来储存 

class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        g = [[0] * n for _ in range(n)]
        degree = [0] * n
        
        for x, y in edges:
            x, y = x - 1, y - 1
            g[x][y] = g[y][x] = 1
            degree[x] += 1
            degree[y] += 1
        
        ans = inf
        for i in range(n):
            for j in range(i, n):
                if g[i][j] == 1:
                    for k in range(j, n):
                        if g[i][k] == g[j][k] == 1:
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
      	return -1 if ans == inf else ans
				
```

# [5183. 好三元组 - AcWing题库](https://www.acwing.com/problem/content/description/5186/)

```python
"""
由于直接算不好算，所以先算出所有三元组的情况，之后再减去不符合的情况。
所有情况为n * (n - 1) * (n - 2) // 6
当三个数在同一点上时 不合规
两个点在同一点上 不合规
三个点在同一个半圆内时 不合规
同一个半圆内的点即距离（i，i + c/2]的点 这里面的每个点和Pi点都不合规
所以要预处理出前缀和，前缀和要处理到2 * c，因为环要变成链来处理的话就需要cnt不仅计数0~c-1还要计数c~2c-1
最后，当c为偶数的时候，i和i+c/2是对称的，会多减，要加回来
"""
N = 2000100
n, c = map(int, input().split())
p = list(map(int,input().split()))
cnt = [0] * N
s = [0] * N
for i in range(1, n + 1):
    cnt[p[i - 1]] += 1
    cnt[p[i - 1] + c] += 1

res = n * (n - 1) * (n - 2) // 6

s[0] = cnt[0]
for i in range(1, 2 * c):
    s[i] = s[i - 1] + cnt[i]
    
for i in range(c):
    if cnt[i] == 0:
        continue
    t = cnt[i]
    d = s[i + c // 2] - s[i]
    
    # 其实不需要判断也行
    if t >= 2:
        if t >= 3:
            res -= t * (t - 1) * (t - 2) // 6
        res -= t * (t - 1) // 2 * d
    res -= t * d * (d - 1) // 2

if c % 2 == 0:
    for i in range(c // 2):
        u, v = cnt[i], cnt[i + c // 2]
        if u >= 2:
            res += u * (u - 1) // 2 * v
        if v >= 2:
            res += v * (v - 1) // 2 * u

print(res)
```

# [5145. 同色环 - AcWing题库](https://www.acwing.com/problem/content/5148/)

```C++
// 判断环 那就是不能往回退 一直走到下一次遇见一个vis  注意设计dfs的时候要加上 ox oy 用于判断初始情况  注意什么时候用ox 什么时候用x  
#include <bits/stdc++.h>
using namespace std;
const int N = 100;
int n, m;
char nums[N][N];
bool vis[N][N];
int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };

bool dfs(int x, int y, int ox, int oy)
{
    vis[x][y] = true;
    
    for (int i = 0; i < 4; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];

        if (nx >= 0 && nx < n && ny >= 0 && ny < m
            // 这一句的意思是 不能退回
            && !(nx == ox && ny == oy)
            // 颜色相同
            && nums[nx][ny] == nums[x][y])
        {
            // 再不可退回的情况下 只有存在首尾相接的环才可能碰到vis=true的情况
            if (vis[nx][ny] || dfs(nx, ny, x, y))
                return true;
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> nums[i][j];
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (!vis[i][j])
            {
                if (dfs(i, j, -1, -1))
                {
                    cout << "Yes" << endl;
                    return 0;
                }
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
```

# [1921. 消灭怪物的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/?envType=daily-question&envId=2023-09-03)

```python
# 看起来很简单 但是有几个点一直过不了 主要是怪物到达的时间有问题 应该是上取整  如果直接用//的话是下取整（突然觉得好傻）
class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        n = len(dist)
        # 上取整
        arrivetime = [math.ceil(dist[i] / speed[i]) for i in range(n)]

        arrivetime.sort()
        for attacktime, arrivetime in enumerate(arrivetime):
            if attacktime >= arrivetime:
                return attacktime
        return n
```

# [统计一个字符串的 k 子序列美丽值最大的数目 - 力扣 (LeetCode) 竞赛](https://leetcode.cn/contest/biweekly-contest-112/problems/count-k-subsequences-of-a-string-with-maximum-beauty/)

```python
# Counter 返回字典 每个元素是键 出现次数为值
# dfs
# 首先是dfs找到k子序列 在子序列满足长度为k的同时比较其美丽值是否为最大 当美丽值更新时（此时为第一个最大美丽值 所以直接让ans = mul）否则ans+mul  之后就是选或不选 add为当前这个子序列的美丽值 mul为当前这个子序列的美丽值的个数 （因为重复的元素）

class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        Mod = 10 ** 9 + 7
        mx = -1
        ans = 0
        keys = list(c.keys())
        def dfs(i, count, add, mul):
            nonlocal mx, ans
            if count == k:
                if add > mx:
                    mx = add
                    ans = mul
                elif add == mx:
                    ans += mul
                ans %= Mod
                return
            if i + k - count > len(keys):
                return
            dfs(i + 1, count + 1, add + c[keys[i]], mul * c[keys[i]] % Mod)
            dfs(i + 1, count, add, mul)
        dfs(0,0,0,1)
        return ans


# 数学
# 求出出现频率前k高的字母 最大的美丽值就在这里面 需要注意的是 最后一个出现频率（k-1位）可能有多个字母（这样组成的子序列美丽值都相同且最大 ） 所以需要再次计算 算出重复的字母数量 然后进行组合计算C（n,k）n为相同的字母的个数 c为可以选的个数（前k个里面 去掉大于的 还要在等于的里面选c个 凑k子序列）
class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        c = Counter(s)
        if k > len(c):
            return 0
        else:
            from math import comb
            Mod = 10 ** 9 + 7
            values = sorted(c.values(), reverse=True)
            ans = 1
            c = 0
            for i in range(k):
                if values[i] > values[k - 1]:
                    ans *= values[i]
                    ans %= Mod
                elif values[i] == values[k - 1]:
                    c += 1
                    ans *= values[i]
                    ans %= Mod
            return ans * comb(values.count(values[k - 1]),c) % Mod

```

