---
title: 3月
date: 2024-02-27 14:28:18
tags: 课程报告
---

# PS：

* 3月刷题的总结 
* acwing、codeforces、洛谷 都没办法看当月提交的数量以及难易度 因此没有做ac截图  但是所有的题都做好了思路整理和答题总结 并附上相关代码  codeforces甚至没有难度 有点难数 填表的时候会按报告整理的题目数量来填 codeforces的难度按当时做题的感受来填
* 有些过于简单的题目 出现于力扣的每日一题，力扣、codeforces的竞赛靠前的题目 没有再做整理 
* 报告是按算法进行分类整理 [其中每题都附有相应的日期] （背包这种较大的算法 就不统一分在DP中）因为我自己一直有整理做过的题目  发在博客和网站上 我自己做的整理是按算法分类的 报告是在3月 把整理的题目复制过来形成的 
* 没有题目 但是附上了题目的链接 点击跳转

# 背包问题 

* 3/28 

tip：一维的枚举可以从v[i]开始 省去条件判断（if(j >= v[i])）

## [2. 01背包问题 - AcWing题库](https://www.acwing.com/problem/content/2/)

+ **二维动态规划**

状态表示 dp[i] [j] 表示到第i个物品 当前体积为j的时候的最大价值

状态转移 第i个物品取或不取

取的话要先判断当前的体积够不够取 然后从j - v[i]处更新过来 再加上第i个的价值

 dp[i] [j] = max(dp[i - 1] [j],dp[i - 1] [j - v[i]] + w[i])

不能取的话 直接从i - 1转移过来

dp[i] [j] = dp[i - 1] [j]

```C++
#include <iostream>
using namespace std;
const int N = 1010;
int v[N], w[N];
int dp[N][N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i];
    }
    // 到第i个 体积为j 的最大价值
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (j >= v[i])dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
            else dp[i][j] = dp[i - 1][j];
        }
    }
    cout<<dp[n][m];
}
```

* **状态压缩**:一维动态规划

从二维的代码中可以发现 整个转移的过程i这个维度只用到了 i - 1这一个 所以不需要记录整个的dp[i] [....] 数组 只需要一个变量就可以了 

状态表示为f[j] 表示取到体积为j的时候的最大价值

状态计算为 当前这个物品取或者不取 不取的话体积不变 仍为f[j] 取的话 从体积为f[i - v[i]] 转移过来

f[j] = max(f[j], f[j - v[i]] + w[i])

但是在去除掉i这一维之后 就不能像二维一样直接枚举1~m了 因为动态规划实际上是利用之前已经计算过的**重复子问题**来简化计算 二维中利用的重复子问题为dp[i - 1] [j - v[i]]。在枚举到 dp[i] [j] 的时候dp[i - 1] [j - v[i]]已经被计算过了 所以可以直接拿来用。但是如果去掉了i这一维度 此时f[j - v[i]] 代表的意义是二维状态下的 dp[i] [j - v[i]] 而不是我们上一段代码中写到的dp[i - 1] [j - v[i]]。那么再从1~m枚举  枚举到j的时候 j - v[i] 的时候 他用到的值是 dp[i] [j - v[i]] 就会出错

所以可以从m开始倒着枚举 这样的话 枚举到j的时候 他用的值是dp[i - 1] [j - v[i]] 因为第i个物品 还没更新到j - v[i] 他用的还是上一轮也就是i - 1的时候的值 

```C++
#include <iostream>
using namespace std;
const int N = 1010;
int v[N];
int w[N];
int dp[N][N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i];
    }
    // 直接枚举 体积为j的最大价值
    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j - v[i]] + w[i], f[j]);
        }
    }
    cout<<f[m];
}
```

## [3. 完全背包问题 - AcWing题库](https://www.acwing.com/problem/content/3/)

* 二维动态规划+三重循环

每件物品无限使用的话 可以直接在01背包的基础上加一重循环k 枚举每个物品取多少个 

时间复杂度太高 需要优化

```C++
#include<iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
int v[N], w[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i];
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            for (int k = 0; k * v[i] <= j; k++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout<<dp[n][m];
}
```

* 二维动态规划+二重循环

```txt
思考每次对于k的循环
dp[i][j]=max(dp[i-1][j],dp[i-1][j-v]+w,dp[i-1][j-2v]+2w,...dp[i-1][j-kv]+kw...)
dp[i][j-v]=max(         dp[i-1][j-v],  dp[i-1][j-2v]+w,... dp[i-1][j-kv]+(k-1)w...)
可以发现 dp[i][j-v] 和dp[i][j]从2开始的后半段非常相似 只相差了一个w
因此可以进行状态压缩 dp[i][j]=max(dp[i-1][j],dp[i][j-v]+w)
```

接下来就可以写出二重循环的做法

```C++
#include<iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
int v[N], w[N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i];
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (j >= v[i])
            	dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]); 
            else 
                dp[i][j] = dp[i - 1][j];
        }
    }
    
    cout<<dp[n][m];
}
```

* 一维动态规划+状态压缩

由此我们可以发现这个代码和01背包十分相似

```C++
dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]); // 完全背包
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); // 01背包
```

所以可以对完全背包也做状态压缩的优化 

但是需要思考：此时j是正着枚举还是倒着枚举？

看子问题，在对第i个物品进行更新的时候 完全背包用到的是dp[i] [...] 是第i个的状态 而直接去掉第一维 恰好剩下的也是第i个的状态所以可以直接正着枚举  dp[i - 1] [j] 用的是i - 1? 没关系 因为现在就是要从[i - 1] [j]更新到[i] [j]

```C++
#include<iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
int v[N], w[N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i];
    }
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (j >= v[i])
            f[j] = max(f[j - v[i]] + w[i], f[j]);
        }
    }
    cout<<f[m];
}
```

## [9. 分组背包问题 - AcWing题库](https://www.acwing.com/problem/content/9/)

* 二维动态规划+三重枚举

每组只能选一个 枚举每一组的不同的数  

其实本身就是一个01背包问题  只不过加了一个组的条件 枚举处理即可

```C++
#include <iostream>
using namespace std;
const int N = 1010;
int s[N];
int v[N][N], w[N][N];
int dp[N][N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>s[i];
        for (int j = 1; j <= s[i]; j++)
        {
            cin>>v[i][j]>>w[i][j];
        }
    }
    // 到i为止 体积为j的最大价值
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            dp[i][j] = dp[i - 1][j];
            for (int k = 1; k <= s[i]; k++)
            {
                if (j >= v[i][k])
                dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout<<dp[n][m];
}
```

* 一维动态规划+状态压缩

```C++
#include <iostream>
using namespace std;
const int N = 1010;
int s[N];
int v[N][N], w[N][N];
int dp[N][N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>s[i];
        for (int j = 1; j <= s[i]; j++)
        {
            cin>>v[i][j]>>w[i][j];
        }
    }
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= 1; j--)
        {
            for (int k = 1; k <= s[i]; k++)
                if (j >= v[i][k])
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
        }
    }
    cout<<f[m];
}
```

## [4. 多重背包问题 I - AcWing题库](https://www.acwing.com/problem/content/4/)

* 二维动态规划+三重循环

每个物品个数有限 同样可以三重枚举 在枚举的时候加一个条件判断 不超过当前物品的数量

```C++
#include <iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
int v[N], w[N], s[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i]>>s[i];
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            for (int k = 0; k * v[i] <= j && k <= s[i]; k++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);
            }
        }
    }

    cout<<dp[n][m];
}
```

* 二进制优化

接下来用一个非常神奇的寄巧 将多重背包直接变为01背包 这就是二进制优化

```txt
二进制优化是将物品按1 2 4 8 ... 打包成一组一组的优化方式
可行性 这样的组合可以表示任何数 比如20可以被分为1 2 4 8 5
而这又可以表示0~20内的任何数 比如 3==1+2   16=1+2+8+5
这样分组就可以将时间优化到log的级别
```

二进制优化之后 每个物品都被分成了很多组 对每一组进行选择 就可以实现对第i个物品的最佳数量的选择 比如第1个物品有20个 选16个是最优的 那就可以选择v[1]+v[2]+v[4]+v[5]   然后再选第二个物品...

每一组的**数量限制**就被**取消**了，这就是一个01背包问题

```C++
#include <iostream>
using namespace std;
const int N = 100010;
int v[N], w[N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    int cnt = 0;

    for (int i = 1; i <= n; i++)
    {
        int a, b, s;
        cin>>a>>b>>s;
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout<<f[m];
}
```

## [7. 混合背包问题 - AcWing题库](https://www.acwing.com/problem/content/description/7/)

```txt
混合背包：
s = -1表示只能用一次--01背包
s = 0表示可以用无限次--完全背包
s > 0表示可用s次--多重背包
```

* 二维动态规划

直接写出01背包 完全背包 多重背包的代码分s的情况来使用

```C++
#include <iostream>
using namespace std;
const int N = 1010, INF = 1e9;
int dp[N][N];
int v[N], s[N], w[N];

int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>v[i]>>w[i]>>s[i];
        if (s[i] == 0)s[i] = INF;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (s[i] == -1)
            {
                if (j >= v[i])
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
                else dp[i][j] = dp[i - 1][j];
            }
            else 
            {
                for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k);
                }
            }
        }
    }
    cout<<dp[n][m];
}
```

* 一维动态规划+二进制优化

用二进制优化的方法 将三种背包都转化成01背包 s < 0直接赋为1

s == 0 就让s = m / a 表示最大体积m 每一个体积a 能取到的最大个数

还有原本s 就大于0 的  全部用二进制优化的方法

现在所有的限制都被消除 直接用一维的01背包解决

```C++
#include <iostream>
using namespace std;
const int N = 100010, INF = 1e9;
int v[N], s[N], w[N];
int f[N];
int main()
{
    int n, m;
    cin>>n>>m;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a, b, s;
        cin>>a>>b>>s;
        if (s < 0)s = 1;
        else if (s == 0)s = m / a;
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout<<f[m];
}
```

# DP/递归/回溯

## [1212. 地宫取宝 - AcWing题库](https://www.acwing.com/problem/content/1214/)

* 3/1

这个题目与上一个题有点像 都是矩阵型 状态转移方程也是由左(j  - 1)上(i - 1)转移到[i, j]

四维DP      状态表示 dp[i] [j] [cnt] [d] 表示i到j中 拿到cnt个物品且最大价值为d的情况

状态计算 有选或不选两种 （只有当拿的东西不多于k并且价值大于当前最大价值才可以拿）

不选就直接转移   dp[i] [j] [c] [d] = (dp[i] [j] [c] [d] + dp[i - 1] [j] [c] [d]) % mod;

选的话 需要从c - 1转移过来 并且要加上所有价值小于d的情况

最后需要加上所有的最大价值的情况 

注意初始化

```c++
#include <iostream>
using namespace std;
int row, col, k;
const int N = 55, mod = 1e9+7, M = 15;
int nums[N][N], dp[N][N][M][M];
int main()
{
    cin>>row>>col>>k;
    for (int i = 1; i <= row; i++)
    {
        for (int j = 1; j <= col; j++)
        {
            cin>>nums[i][j];
            nums[i][j]++; // 防止0的情况
        }
    }
    dp[1][1][0][0] = 1;// 不拿 c = 0  d = 0
    dp[1][1][1][nums[1][1]] = 1; // 拿了的话 c = 1 d = nums[1][1](当前最大值)
    for (int i = 1; i <= row; i++)
    {
        for (int j = 1; j <= col; j++)
        {
            for (int c = 0; c <= k; c++)
            {
                for (int d = 0; d < M; d++)
                {
                    // 不选
                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - 1][j][c][d]) % mod;
                    dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - 1][c][d]) % mod;
                    // 选
                    if (c > 0 && d == nums[i][j])
                    {
                        for (int s = 0; s < d; s++) // 从前面每个最大值转移
                        {
                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i - 1][j][c - 1][s]) % mod;
                            dp[i][j][c][d] = (dp[i][j][c][d] + dp[i][j - 1][c - 1][s]) % mod;
                        }
                    }
                }
            }
        }
    }
    int res = 0;
    for (int i = 0 ;i < M; i++)
    {
        res = (res + dp[row][col][k][i])%mod;
    }
    cout<<res;
}
```

循环 选或不选的部分可以优化  不选的话 就直接转移    选的话 需要从c转移到c + 1那么c+1 就需要小于k 并且nums[i + 1] [j] 要大于当前最大值d

```c++
if (dp[i][j][c][d])
{
    dp[i + 1][j][c][d] = (dp[i + 1][j][c][d] + dp[i][j][c][d]) % mod;
    dp[i][j + 1][c][d] = (dp[i][j + 1][c][d] + dp[i][j][c][d]) % mod;
}
if (c + 1 <= k)
{
    if (nums[i + 1][j] > d)
    	dp[i + 1][j][c + 1][nums[i + 1][j]] = (dp[i + 1][j][c + 1][nums[i + 1][j]] + dp[i][j][c][d]) % mod;
    if (nums[i][j + 1] > d)
    	dp[i][j + 1][c + 1][nums[i][j + 1]] = (dp[i][j + 1][c + 1][nums[i][j + 1]] + dp[i][j][c][d]) % mod; 
    }
```

## [2369. 检查数组是否存在有效划分 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/)

动态规划 状态表示为f[i] 表示从0到i 是否存在有效划分    

0存在有效划分 判断 i 是否存在有效划分 如果i - 2存在并且nums[i - 2] == nums[i - 1] 则可以  或者i - 3存在 并且三个相等或者连续递增

```C++
class Solution {
public:
    bool validPartition(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>f(n + 1);
        f[0] = 1;
        for (int i = 2; i <= n; i++)
        {
            if (i >= 2 && f[i - 2] && nums[i - 2] == nums[i - 1] || 
            i >= 3 && f[i - 3] && (nums[i - 3] == nums[i - 2] && nums[i - 1] == nums[i - 2] || nums[i - 3] == nums[i - 2] - 1 && nums[i - 2] == nums[i - 1] - 1))
            f[i] = 1;
        }
        return f[n];
    }
};
```

<img src="../images/$%7Bfiilename%7D/image-20240301150042018.png" alt="image-20240301150042018" style="zoom:25%;" />

## [1055. 股票买卖 II - AcWing题库](https://www.acwing.com/problem/content/1057/)

状态机DP 状态表示为dp[i] [0]和dp[i] [1]分别表示 到第i天的时候手上有股票和没有股票的最大获利

状态计算 第i天手上有股票的最大获利为 第i - 1天手上没股票 在第i天买入 和 第i - 1天手上有股票 第i天不进行操作  两者较大值

无股票同理

最后输出为第n天手上没有股票的最大获利（

```C++
#include <iostream>
using namespace std;
int nums[100010];
int dp[100010][2];
int main()
{
    int n;
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    dp[0][1] = -nums[0];
    for (int i = 1; i < n; i++)
    {
        dp[i][0] = max(dp[i - 1][1] + nums[i], dp[i - 1][0]);
        dp[i][1] = max(dp[i - 1][0] - nums[i], dp[i - 1][1]);
    }
    cout<<dp[n - 1][0];
}
```

## [xmuoj | 寻找蒙德之宝](https://www.xmuoj.com/contest/215/problem/2)

* 3/6 

是之前在力扣写过的石子游戏7 很像有点像博弈论 但是其实是递归 （原题是取数游戏）

这样思考dfs(l, r)  让他表示轮到当前选手（不论是谁）的时候他可以取的nums[l] 和nums[r]

首先 递归出口就是l == r的时候 这时候就直接返回nums[l] 表示只能取这一个

然后是递归 当前选手的赢面 意思是当前选手取的值 减去下一步对手取的值  每次都求最大的赢面 意为最优决策

然后分为取左的赢面和取右的赢面 选较大值即可

dfs(0, n - 1)就是我的赢面 因为是我先开始 所以答案就是dfs是否大于0

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

const int N = 100010;
int nums[N];
int dfs(int l, int r)
{
	if (l == r)return nums[l];

	int hl = nums[l] - dfs(l + 1, r); 
	int hr = nums[r] - dfs(l, r - 1);
	return max(hl, hr);
}

int main()
{
	char c;
	scanf("%c", &c);
	int k = 0;
	while (c != ']')
	{
		scanf("%d%c", &nums[k++], &c);
	}
	/*for (int i = 0; i < k; i++)
		cout << nums[i] << " ";*/
	int l = 0, r = k - 1;
	if (dfs(l, r) >= 0)
		puts("true");
	else
		puts("false");
}
```

记忆化搜索  比直接dfs快了很多倍（因为xmuoj输入太抽象了 这里用力扣的题（ 

### [486. 预测赢家 - 力扣（LeetCode）](https://leetcode.cn/problems/predict-the-winner/description/)

```C++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) 
    {
        int n = nums.size();
        vector<vector<int>>memo(n, vector<int>(n,-1));
        
        function<int(int,int)> dfs = [&](int l, int r)->int
        {
            if (l == r)
            {
                return nums[l];
            }
            if (memo[l][r] != -1)
            return memo[l][r];

            int hl = nums[l] - dfs(l + 1, r); 
            int hr = nums[r] - dfs(l, r - 1);
            memo[l][r] = max(hl, hr);
            return memo[l][r];
        };

        return dfs(0, n - 1) >= 0;
    }
};
```

## [xmuoj | 最短突破天数](https://www.xmuoj.com/contest/215/problem/5)

思考回溯的方法 这个题是选哪个的问题

dfs(int u, int k) u表示当前枚举到哪个材料 k表示需要多少天

从第i天到第k天 每天都试一下能不能放上nums[u] 然后递归、回溯 

还要 增加新的一天 新一天可以放上当前的u 也可以不放（回溯）

递归出口就是u == n的时候 记录答案 当前了多少天

由于要求最短的天数 可以用ans记录一下 当k > ans 的时候说明已经不是最佳答案了 可以剪枝

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100;
int nums[N], day[N]; 
int n, w;
int ans = N;

void dfs(int u, int k)
{
    if (k >= ans)return ;
    if (u == n)
    {
        ans = k;
        return ;
    }
    // 看这每一天哪一个还能再放的下nums[u] 其实是在枚举nums[u]放在di'ji
    for (int i = 0; i < k; i++)
    {
        if (day[i] + nums[u] <= w)
        {
            day[i] += nums[u];
            dfs(u + 1, k);
            day[i] -= nums[u];
        }
    }
    
    day[k] = nums[u];// 新的一天
    dfs(u + 1, k + 1);
    day[k] = 0;
}


int main()
{
	
	cin >> n >> w;
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i];
	}
	sort(nums, nums + n, [&](int a, int b) {return a > b; });
	
	dfs(0, 0);
	cout << ans;
}
```

## [Problem - E - Codeforces](https://codeforces.com/contest/1941/problem/E)

* 3/11

单调队列优化DP 

学习了tllwtg的代码 发现multiset居然也可以发挥和priority_queue一样的功能 并且默认是最小堆（priority_queue默认最大堆）

最后选出k个最大的 原来都是排序 是$O(nlogn+k)$没想到居然可以$O(n)$ ：滑动窗口 维护长度为k的滑动窗口 ans取出最小

思路： 枚举每一条河 找出最便宜的k条 如果直接用动态规划会超时 因为m 和d范围都是1e6 所以要用单调队列优化

需要开最小堆  堆中存放【到当前坐标需要的花费，当前的坐标】 对于花费要从小到大排序 优先取出最小的花费 对坐标要从大到小排列 优先取出大的坐标（离对岸更近）tip：可以把坐标存负值 取出来的时候取正

到j点的时候 看要从前面哪个点更新过来，先循环去掉距离j超过d的点 然后选出距离合适的 花费最少的点   

记录当前的花费 并且存入优先队列中

如果当前的点距离对岸小于m 说明可以直接到对岸 用ans记录最小花费

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<ll, ll>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 200001;
ll nums[101][N];
void solve()
{
    int n, m, k, d;
    cin >> n >> m >> k >> d;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cin >> nums[i][j];
        }
    }
    vector<ll> res(n + 1);
    for (int i = 1; i <= n; i++)
    {
        priority_queue<PII, vector<PII>, greater<>> q;
        q.push({0, -1}); // 到当前这个点的花费 和距离 按花费从小到大排序 高度相同的 按距离从大到小排序 因此距离存负 拿出来后取正
        ll ans = 1e18;
        for (int j = 2; j <= m - 1; j++)
        {
            while (1)
            {
                auto [cost, last] = q.top();
                last = -last;
                if (j - last > d + 1)
                    q.pop();
                else
                    break;
            }
            auto [cost, last] = q.top();
            last = -last;
            cost += nums[i][j] + 1;
            if (m - j <= d + 1)
            {
                ans = min(ans, cost);
            }
            q.push({cost, -j});
        }
        if (d >= m - 2)
            ans = 0;
        res[i] = ans + 2;
    }
    ll ans = 1e18, cur = 0;
    for (int i = 1; i <= k; ++i)
        cur += res[i];
    ans = cur;
    for (int i = k + 1; i <= n; ++i)
    {
        cur += res[i];
        cur -= res[i - k];
        ans = min(ans, cur);
    }
    cout << ans << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [1360. 有序分数 - AcWing题库](https://www.acwing.com/problem/content/description/1362/)

* 3/13

递归 可以发现 0/1 和1/1之间有 1/2  

0/1和1/2之间有1/3 0/1和1/3之间有1/4 0/1和1/4之间有1/5...

a/b和c/d之间存在a + c / b + d

递归  dfs表示当前的两个分数a/b 和c/d算出他们两个中间的数 然后输出 

```C++
#include <iostream>
using namespace std;
int n;
void dfs(int a, int b, int c, int d)
{
    if (b + d > n)return ;
    
    dfs(a, b, a + c, b + d);
    cout<<a + c<<"/"<<b + d<<endl;
    dfs(a + c, b + d, c, d);
}
int main()
{
    cin>>n;
    cout<<"0/1"<<endl;
    dfs(0,1,1,1);
    cout<<"1/1"<<endl;
}
```

## [4645. 选数异或 - AcWing题库](https://www.acwing.com/problem/content/4648/)

* 3/14

动态规划+位运算

a^b = x --> a^x = b

用last数组记录b出现的坐标 每次查询a^x 如果等于b 那么就 标记 dp[i] 为 b的坐标  

状态表示 dp[r] = l 表示与这个r异或为x的最近的l 

```C++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;
typedef long long ll;
const int N = 100010;
ll dp[N];
ll n, m, x;

int main()
{
    cin>>n>>m>>x;
    ll a;
    unordered_map<ll, ll>last;
    for (int i = 1 ;i <= n; i++)
    {
        cin>>a;
        dp[i] = max(dp[i - 1], last[a ^ x]);
        last[a] = i;
    }
    while (m--)
    {
        int l, r;
        cin>>l>>r;
        if (dp[r] >= l)puts("yes");
        else puts("no");
    }
}
```

## [2312. 卖木头块 - 力扣（LeetCode）](https://leetcode.cn/problems/selling-pieces-of-wood/?envType=daily-question&envId=2024-03-15)

* 3/15

每次对木头横切或者竖切一刀 求出最后能卖出的最大价值  切完后木头还可以再切 那就是一个子问题 可以用递归来解决

设dp[i] [j] 为 长i 宽j的木块最多能卖多少钱  可以选择不切 也就是直接卖长i宽j的木块 

选择在长的k处 切一刀 那么长就变为了 i - k 和k 木块就变成dp[k] [j] + dp[i - k] [j]

竖切同理  所以就需要枚举切的位置

```C++
class Solution {
public:
    long long sellingWood(int m, int n, vector<vector<int>>& prices) 
    {
        vector<vector<int>> pr(m + 1, vector<int>(n + 1));
        for (auto &p: prices) {
            pr[p[0]][p[1]] = p[2];
        }

        vector<vector<long long>>dp(m + 1, vector<long long>(n + 1));

        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dp[i][j] = pr[i][j];
                for (int k = 1; k < j; k++)dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]);
                for (int k = 1; k < i; k++)dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]);
                
            }
        }
        return dp[m][n];
    }
};
```

## [2684. 矩阵中移动的最大次数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/?envType=daily-question&envId=2024-03-16)

* 3/16

动态规划 矩阵型动态规划 但是状态计算的更新点是前一列的上中下

f[i] [j] 表示到f[i] [j] 最多能走几步  如果比当前数前面大的话就可以从前面更新过来

但是这个题 跟之前不一样 他必须要从最前面开始往后走 断掉了就不算  所以说要加判断 如果f[i] [j] != j 的话 就说明断了 直接赋为0

注意 要先枚举列 在枚举行 因为每次更新的时候 都必须从前一列更新过来  那就必须有前一列的数据 也就是说要先算前一列 所以先枚举列再枚举行

```C++
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) 
    {
        int row = grid.size(), col = grid[0].size();
        vector<vector<int>>f(row + 1, vector<int>(col + 1)); // f[i][j] 表示i j的最大移动次数
        int maxn = 0;
        for (int j = 1; j < col; j++)
        {
            for (int i = 0; i < row; i++)
            {
                if (grid[i][j] > grid[i][j - 1])f[i][j] = max(f[i][j - 1] + 1, f[i][j]);
                if (i - 1 >= 0 && grid[i][j] > grid[i - 1][j - 1])f[i][j] = max(f[i - 1][j - 1] + 1, f[i][j]);
                if (i + 1 < row && grid[i][j] > grid[i + 1][j - 1])f[i][j] = max(f[i + 1][j - 1] + 1, f[i][j]);
                if (f[i][j] != j)f[i][j] = 0;
                maxn = max(maxn, f[i][j]);
            }
        }
        return maxn;
    }
};
```

## [4997. 更小的数 - AcWing题库](https://www.acwing.com/problem/content/5000/)

* 3/16

用dp[l] [r] 表示l r区间是否可以旋转 

如果s[l] > s[r] 标记为可以

当s[l] == s[r]的时候 就看dp[l + 1] [r - 1] 也就是他们里面的一个子数组

枚举长度len 和左端点l 计算出右端点 如果当前区间可以旋转就标记

由于是枚举len 从小到大 所以dp[l + 1] [r - 1] 必定是已经计算过的 可以直接使用

```C++
#include<iostream>
using namespace std;
int dp[6000][6000];
int main()
{
    string s;
    cin>>s;
    int n = s.size();
    int cnt = 0;
    
    for (int len = 2; len <= n; len++)
    {
        for (int l = 0; l + len - 1 < n; l++)
        {
            int r = l + len - 1;
            if (s[l] > s[r])dp[l][r] = 1;
            else if (s[l] == s[r]) dp[l][r] = dp[l + 1][r - 1];
            cnt += (dp[l][r] == 1);
        }
    }
    cout<<cnt<<endl;
}
```

## [P9242 [蓝桥杯 2023 省 B\] 接龙数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P9242)

* 3/18

类似于最长上升子序列问题 最少的删除个数不好求  但是可以求最长的接龙的长度 然后用n减去 注意是**子序列**所以才会符合题目要求

把最长上升子序列的上升改为前后相等

```C++
for (int i = 1; i <= n; i++)
{
    dp[i] = 1;
    for (int j = 1; j < i; j++)
    {
        // 由于j < i 所以j在前面 j就要是second
        if (nums[j].second == nums[i].first)
        {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}
```

注意和最长公共子序列区分

```c++
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= m; j++)
    {
        if (text1[i - 1] == text2[j - 1])
            dp[i][j] = dp[i - 1][j - 1] + 1;
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
    }
}
```

但是这样做会超时 所以还需要优化   可以令dp数组表示到i为止 以j结尾的最长的子序列 设b为起点 e为终点 

那么当$e_i = j$的时候就可以更新 $dp[e_i] = max(dp[b_{i}]+1, dp[e_i])$为什么再$b_i$的时候可以加1 因为$dp[b_i]$就是以$b_i$结尾的最长的子序列 然后$b_i$现在又是第i个数的开头 所以就可以更新

```C++
for (int i = 1; i <= n; i++)
    {
        string s;
        cin >> s;
        dp[s[s.size() - 1] - '0'] = max(dp[s[s.size() - 1] - '0'], dp[s[0] - '0'] + 1);
    }
```

## [P9241 [蓝桥杯 2023 省 B\] 飞机降落 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P9241)

* 3/19

没办法用贪心 数据只有20 可以用dfs暴力搜索

思路：枚举每个飞机下降的顺序 用vis记录是否降落

当p == n的时候表示所有飞机都顺利下落 返回true 标记flag为true 剪枝

否则就开始循环 找到还每下落的飞机 开始下落 

用l表示当前的时间     如果s < l表示当上一辆下降完成 的时候 我现在枚举到的这架飞机已经到达了 但是不能下降  要令s = l （当时间到达t的时候 这架飞机开始下落）要这样做的原因是 后面递归的时候 当前时间为 飞机开始下落的时间加上下落时长 如果s >= l 说明上一辆完成时 当前枚举到的这架飞机还没到达 要等到他到达才能开始下降 然后计算时间  所以时间要用s + nums[i].l 

既然时间要用s 前面就要修改s的值（s < l的时候） 

注意标注vis

主要是变量表示的意义不清楚 .

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

const int N = 100;
struct plane
{
    int t, d, l, e;
} nums[N];
int n;
bool flag, vis[N];
void dfs(int p, int l)
{
    if (p == n)
    {
        flag = true;
        return;
    }
    if (flag)
        return;

    for (int i = 0; i < n; i++)
    {
        if (!vis[i])
        {
            if (l <= nums[i].e)
            {
                int s = nums[i].t;
                if (s < l)
                {
                    s = l;
                }

                vis[i] = true;
                dfs(p + 1, s + nums[i].l);
                vis[i] = false;
            }
            else
                return;
        }
    }
    return;
}

void solve()
{
    flag = false;
    memset(vis, 0, sizeof(vis));
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i].t >> nums[i].d >> nums[i].l;
        nums[i].e = nums[i].t + nums[i].d;
    }
    dfs(0, -1);
    if (flag)
        puts("YES");
    else
        puts("NO");
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/)

* 3/22

爬楼梯变形 把原来每次爬1/2阶台阶 换成每次爬nums[i]次台阶

本来dp[i] += dp[i - 1] + dp[i - 2] 换成枚举每一个nums[i]

dp[i] 表示到i共有多少种走法

```C++
typedef unsigned long long ll;
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) 
    {
        int n = nums.size();
        vector<ll>dp(target + 1); // dp[i] 表示到i有多少种走法 那就是加上 dp[i - nums[j]]
        dp[0] = 1;
        for (int i = 1; i <= target; i++)
        {
            for (auto x: nums)
            {
                if (i >= x)
                {
                    dp[i] += dp[i - x];
                }
            }
        }
        return dp[target];
    }
};
```

## [2466. 统计构造好字符串的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-ways-to-build-good-strings/)

* 3/22

跟上题有点像 计算low到high的种数 其实只用一个个算 然后再循环加起来

还是求dp[i] 

注意1:数太大了 每次加都需要mod

注意2:初始化zero和one可能相等要用+=

```c++
const int mod = 1e9 + 7;
typedef unsigned long long ll;
class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) 
    {
        // dp表示i共有多少种 
        vector<ll>dp(high + 1);
        dp[zero] += 1;
        dp[one] += 1;
        for (int i = 0; i <= high; i++)
        {
            if (i >= zero)
            dp[i] = (dp[i] + dp[i - zero]) % mod;
            if (i >= one)
            dp[i] = (dp[i] + dp[i - one]) % mod;
        }
        ll ans = 0;
        for (int i = low; i <= high; i++)
        {
            ans = (ans + dp[i]) % mod;
        }
        return ans;
    }
};
```



## [P9234 [蓝桥杯 2023 省 A\] 买瓜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P9234)

* 3/21

dfs的思路比较简单  但是剪枝优化比较难

dfs分为 买 不买 卖一半  

需要排序  先买大的 更快凑齐需要的重量 

递归出口：i==n 和 sum==m

剪枝1：当当前切分数大于最小切分数的时候 不需要再切分 已经不可能更小了 return

剪枝2：当当前重量大于所需的重量 

最重要的剪枝：suf  因为从小到大排序了  suf计算一个后缀和 当当前的总和sum 再加上后缀和（就是把后面全部选上）都不够所需的重量 直接返回  这一步可以减去非常多计算 预见后面很多步

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
vector<double>nums(100), suf(100);
int n, m;
int mcnt = 2e9;
void  dfs(int i, double sum, int cnt)
{
    if (cnt >= m)return ;
    if (sum == m)
    {
        mcnt = min(cnt, mcnt);
        return ;
    }
    if (i == n || sum > m || suf[i] + sum < m)
    {
      //  cout<<sum<<endl;
        return ;
    }
    dfs(i + 1, sum + nums[i], cnt);
    dfs(i + 1, sum, cnt);
    dfs(i + 1, sum + nums[i] / 2, cnt + 1);
    
}

int main()
{
    // 请在此输入您的代码
    
    cin>>n>>m;
    for (int i = 0; i < n; i++)cin>>nums[i];
    sort(nums.begin(), nums.end(), greater<>());
    for (int i = n - 1; i >= 0; i--)suf[i] = suf[i + 1] + nums[i];
    dfs(0, 0, 0);
    mcnt == 2e9 ? cout<< -1 : cout<<mcnt;
    return 0;
}
```

## [2266. 统计打字方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-texts/)

仍然是求dp[i] 但是这个题多了一步 连续相同的字母合在一起计算

```C++
typedef unsigned long long ll;
const int mod = 1e9 + 7;
const int N = 1e5 + 10;
class Solution {
public:
int f[N], g[N];
    void init()
    {
        // dp[i] 表示到i共有多少种
        
        f[0] = g[0] = 1;
        f[1] = g[1] = 1;
        f[2] = g[2] = 2;
        f[3] = g[3] = 4;

        for (int i = 4; i < N; i++)
        {
            f[i] = (int)(((ll)f[i - 1] + f[i - 2] + f[i - 3]) % mod);
            g[i] = (int)(((ll)g[i - 1] + g[i - 2] + g[i - 3] + g[i - 4]) % mod);            
        }
    }
    int countTexts(string pressedKeys) 
    {
        int m = pressedKeys.size();
        int ans = 1, cnt = 0;
        init();
        for (int i = 0; i < m; i++)
        {
            cnt++;
            char c = pressedKeys[i];
            if (i == m - 1 || c != pressedKeys[i + 1])
            {
                ans = (int)((ll)ans * (c != '7' && c != '9' ? f[cnt]: g[cnt]) % mod);
                cnt = 0;
            }
        }
        return ans;
    }
};
```

## [322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/?envType=daily-question&envId=2024-03-24)

* 3/24

<img src="../images/$%7Bfiilename%7D/image-20240325073006172.png" alt="image-20240325073006172" style="zoom:25%;" />

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) 
    {
        //dp[i] 表示到i为止的最小硬币数
        if (amount == 0)return 0;
        int n = coins.size();
        vector<int>dp(amount + 1, 1e9);
        for (auto x:coins)
        {
            if (x <= amount)
            dp[x] = 1;
        }
        for (int i = 0; i <= amount; i++)
        {
            for (auto x: coins)
            {
                if (i >= x)
                    dp[i] = min(dp[i - x] + 1, dp[i]);
            }
        }
        return dp[amount] == 1e9 ? -1 : dp[amount];
    }
};
```

## [518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)

* 3/25
* <img src="../images/$%7Bfiilename%7D/image-20240325075300423.png" alt="image-20240325075300423" style="zoom:25%;" />

这个题目与上题有区别 一个是求排列数 一个是求组合数 

也就是说 上一题会把1 2 和2 1当成两种情况 但是这一题 视为同一种情况 如果按上面的写法 最后结果会偏大

本质原因是子问题的改变   我们需要加上对硬币的限制 1 2 和 2 1 是同种情况 因此可以枚举硬币而不是枚举总和  从小到大枚举硬币 就不会出现2 1这种情况

现在子问题变为 到第k个硬币 合成金额i的组合数

状态转移为dp[k] [i] = dp[k - 1] [i] + dp[k] [i - coins[k]]  (i > coins[k])

```c++
for (int i = 0; i < coins.size(); i++)
{
	dp[i][0] = 1;
}
for (int k = 0; k < coins.size(); k++)
{
    for (int i = 1; i <= amount; i++)
    {
        if (i >= coins[k - 1])
            dp[k][i] = dp[k][i - coins[k - 1]] + dp[k - 1][i];
        else
        {
            dp[k][i] = dp[k - 1][i];
        }
    }
}

```

此时就算交换两个for循环的顺序也不会影响结果 因为交换后子数组的状态转移方程不变 得到的结果也不变

如果要降成一维的数组 重新定义子问题为 必须选择第k个硬币的时候 凑成金额i的方案数  不能交换for循环的顺序 因为交换完之后 子问题的意义就是 对于金额i 有几种选择硬币的方案数（理解两个子问题的差别 一个是可重复一个不行）

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) 
    {
        vector<int>dp(amount + 1, 0); // dp[i] 表示必须选择第i个硬币时能凑成的金额的组合数
        dp[0] = 1;

        for (auto x: coins)
        {
            for (int i = 0; i <= amount; i++)
            {
                if (i >= x)
                dp[i] += dp[i - x];
            }
        }
        for (int i = 0; i <= amount; i++)
        {
            cout<<dp[i]<<" ";
        }
        return dp[amount];
    }
};
```

## [198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)

* 3/26

打家劫舍例题

```C++
class Solution {
public:
    int rob(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>dp(n + 1);// dp[i] 表示到i为止 最大收益是多少
        dp[0] = 0;
        dp[1] = nums[0];
        for (int i = 2; i <= n; i++)
        {
            // 状态计算 在第i位有选或不选两种方法 如果上一家劫了 这一家就不能劫 上一家没劫 为了达到最大 这一家必须劫
            dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]);
        }
        return dp[n];
    }
};
```

还可以进行压缩 因为观察可以发现 当前的状态i 只和前一时刻的状态i - 1 和i - 2有关 所以可以只用记录三个变量 而不用一个数组 空间复杂度降为$O(1)$

```C++
int rob(vector<int>& nums)
    {
        int f0 = 0, f1 = 0;
        for (int i = start; i < end; ++i) {
            int new_f = max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }
```



## [740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/description/)

* 3/26

打家劫舍变式  本来选一个之后 只需要跳过一个 就可以选下一个了

但是现在 每次可以选值为nums[i]的数 删除值为nums[i] - 1 和 nums[i] + 1的数

每次选择nums[i] 之后 肯定是要把所有的nums[i] 全部选上的 因为他不会被删除

因此可以把连续相同的nums[i]合并 成为now数组

接下来就是选不选的问题 更新到nums[i]的时候 只用考虑nums[i] - 1 即可  所以就在用一个数组记录now[i]和now[i - 1]所在的基础值是不是相差1 如果是的话 那就需要跳过nums[i] - 1

如果不是的话 就可以直接加上

比如nums= 2 4 6那么最大值就是2+4+6=12 全都可以选

状态定义与打家劫舍一样  关键是把原数组转换成适合使用这个定义的数组

```C++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) 
    {
        
        sort(nums.begin(), nums.end());
        int m = nums.size();
        vector<int>bj(m + 1, 0);
        vector<int>now(m + 1);
        int sum = nums[0];
        int k = 0;
        for (int i = 1; i < m; i++)
        {
            if (nums[i] == nums[i - 1])
                sum += nums[i];
            else 
                {
                    now[++k] = sum;
                    sum = nums[i];
                    if (nums[i] - nums[i - 1] == 1)
                    bj[k] = 1;
                }
        }
        
        now[++k] = sum;
        if (m > 1 && nums[m - 1] - nums[m - 2] == 1)
       
        bj[k] = 1;
        for (int i = 1; i <= k; i++)
        {
            cout<<now[i]<<endl;
            cout<<"*"<<bj[i]<<endl;
        }
        vector<int>dp(k + 1, 0);
        dp[0] = 0;
        dp[1] = now[1];
        for (int i = 2; i <= k; i++)
        {
            if (bj[i - 1])
            dp[i] = max(dp[i - 1],now[i] + dp[i - 2]);
            else
            dp[i] = dp[i - 1] + now[i];
        }
        for (int i = 1; i <= k; i++)
        cout<<dp[i]<<endl;
        int a = 0;
        for (int i = 1; i <= k; i++)
        {
            a = max(a, dp[i]);
        }
        return a;
    }
};
```

## [902. 最短编辑距离 - AcWing题库](https://www.acwing.com/problem/content/904/)

```
当a[i] == b[j]的时候 不用操作  
当a[i] == b[j - 1]的时候 要添加
    i
1 2 3
1 2 3   4
   j-1
当a[i - 1] == b[j]的时候 要删除
   i-1
1 2 3   4
1 2 3
  	j
当a[i - 1] == b[j - 1]的时候 可以选择替换
   i-1  i
1 2 3   5
1 2 3   4
   j-1  j
```

状态表示：dp[i] [j] 表示0~a[i] 和 0~b[j] 相等的最少操作次数（dp[i] [j]----->0~a[i] == 0~b[j]）

状态计算：

如果a[i] == b[j] （末位相等）那么可以直接从dp[i - 1] [j - 1]更新过来  也可以从dp[i - 1] [j] 或者dp[i] [j - 1]更新过来 （即通过添加或者删除操作 +1

否则 可以从dp[i - 1] [j - 1] 通过替换更新过来 也可以从dp[i - 1] [j] 或者dp[i] [j - 1]更新过来

初始化：当i=0的时候 j每多一个 就要多一次添加操作  j=0同理  

```C++
#include <iostream>
using namespace std;
int dp[1010][1010];
int main()
{
    int n, m;
    string a, b;
    cin>>n>>a;
    cin>>m>>b;
    a = ' ' + a;
    b = ' ' + b;
    for (int i = 1; i <= n; i++)dp[i][0] = i;
    for (int i = 1; i <= m; i++)dp[0][i] = i;
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (a[i] == b[j])dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1);
            else dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

## [2320. 统计放置房子的方式数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/)

* 3/27

<img src="../images/$%7Bfiilename%7D/image-20240327084907628.png" alt="image-20240327084907628" style="zoom:25%;" />

dp[i] 为单独一侧 前i个的放置方案 

状态计算：如果i放了 那么i - 1不能放 只能从i - 2更新过来    如果i不放 那么i - 1可放可不放 f[i] = f[i - 1]  则 f[i] = f[i - 1] + f[i - 2]  因为算的是总方案数 所以两个都要加上（放和不放的方案）

初始化 f[0] = 1 不放也是一种方案  f[1] = 2  放和不放两种

两侧的房屋相互独立 由乘法原理 ans = f[n] ^ 2

```C++
const int mod = 1e9 + 7;
class Solution {
public:
    int countHousePlacements(int n) 
    {
        vector<long long>dp(n + 10);
        dp[0] = 1;
        dp[1] = 2;

        for (int i = 2; i <= n; i++)
        {
            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
        }
        return dp[n] * dp[n] % mod;
    }
};
```

## [213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/submissions/517072916/)

* 3/27

<img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-27%20090620.png" style="zoom:25%;" />

先来看一波丑陋的代码  按照打家劫舍1的方法来写 由于头和尾相连 不能同时选 所以用两个数组表示选头和选尾 然后取最大值

```C++
class Solution {
public:
    int rob(vector<int>& nums) 
    {
        int n = nums.size();
        if (n == 1)return nums[0];
        vector<int>dp1(n);
        vector<int>dp(n);
        dp[0] = 0;
        dp[1] = nums[1];
        for (int i = 2; i < n; i++)
        {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        dp1[0] = nums[0];
        dp1[1] = max(nums[0], nums[1]);
        for (int i = 2; i < n - 1; i++)
        {
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);
        }
        return max(dp[n - 1], dp1[n - 2]);
    }
};
```

但是这样写太复杂了 （不是优雅的代码 

可以考虑直接调用打家劫舍1的代码  写成函数之后清晰很多

```C++
class Solution {
public:
    int rob1(vector<int>& nums, int start, int end)
    {
        int f0 = 0, f1 = 0;
        for (int i = start; i < end; ++i) {
            int new_f = max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }
    int rob(vector<int>& nums) 
    {
        int n = nums.size();
        return max(nums[0] + rob1(nums, 2, n - 1), rob1(nums, 1, n));
    }
};
```

## [1388. 3n 块披萨 - 力扣（LeetCode）](https://leetcode.cn/problems/pizza-with-3n-slices/)

* 3/27

<img src="../images/$%7Bfiilename%7D/image-20240327190933284.png" alt="image-20240327190933284" style="zoom:25%;" />

这个题和打家劫舍2很类似  但是如果直接套用打家劫舍的代码就会出错  主要是因为 打家劫舍选的数量不止n = m / 3个 因此要增加一个条件限制 返回选择n个的时候的最大值 

状态表示dp[i] [j] 表示到数组的第i个的时候 选了j块披萨的最大值 

状态计算 dp[i] [j] 当不选第i块披萨的时候（不选nums[i - 1] nums和dp的下标差 1）可以直接从nums[i - 1] [j] 转移

当选择第i块披萨的时候 就可以从dp[i - 2] [j - 1] 更新过来 再加上nums[i - 1]

取最大值

最后返回dp[m] [n] 表示在m块披萨中选n块得到的最大值

然后分类  选头和选尾 取最大值

```C++
class Solution {
public:
    int maxSizeSlices(vector<int>& slices) 
    {
        int n = slices.size() / 3;
        auto g = [&](vector<int>&nums) ->int
        {
            int m = nums.size();
            vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
            
            for (int i = 1; i <= m; i++)
            {
                for (int j = 1; j <= n; j++)
                {
                    f[i][j] = max(f[i - 1][j], (i >= 2 ? f[i - 2][j - 1]:0) + nums[i - 1]);
                }
            }
            return f[m][n];
        };
        vector<int>nums(slices.begin(), slices.end() - 1);
        int a = g(nums);
        nums = vector<int>(slices.begin() + 1, slices.end());
        int b = g(nums);
        return max(a, b);
    }
};
```

## [2597. 美丽子集的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/the-number-of-beautiful-subsets/)

* 3/27

<img src="../images/$%7Bfiilename%7D/image-20240327191015040.png" alt="image-20240327191015040" style="zoom:25%;" />

### 子集型回溯

写法1

讨论选或者不选 

先看可不可以选 用map记录已经选了的数 如果map中有数和当前的nums[i] 差为k的话 就不能选 

否则就可以选 

不选就没有条件 直接dfs(i + 1) 

递归出口为i == nums.size() 只要到了i 就是一种可行的集合

最后减去空集

```C++
class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) 
    {
        int ans = -1;
        map<int, int>mp;

        function<void(int)> dfs = [&](int i)
        {
            if (i == nums.size())
            {
                ans ++;
                return;
            }
            if (mp[nums[i] - k] == 0 && mp[nums[i] + k] == 0)
            {
                mp[nums[i]]++;
                dfs(i + 1);
                mp[nums[i]]--;
            }
            dfs(i + 1);
        }; 
        dfs(0);
    }
};
```

写法2

枚举选哪个  dfs(i) 表示在i到n中选

查找每一个数 看是否选择 每一次选择都是一个可行的集合

```C++
        function<void(int)> dfs = [&](int i)
        {
            ans++;
            if (i == nums.size())
            {
                return ;
            }
            
            for (int j = i; j < nums.size(); j++)
            {
                if (mp[nums[j] - k] == 0 && mp[ nums[j] + k] == 0)
                {
                    mp[nums[j]]++;
                    dfs(j + 1);
                    mp[nums[j]]--;
                }
            }
        };
        dfs(0);
```



# 枚举 / 模拟

## [1210. 连号区间数 - AcWing题库](https://www.acwing.com/problem/content/description/1212/)

* 3/1

有点偏技巧 关键要找到规律 怎么样求出一个区间是否连号   只要一个区间的最大值和最小值的差 等于 区间的长度就是连号的区间   比如3 2 4    4 - 2 = 2 区间长度（下标分别为0 1 2 ）为2 - 0 = 2   

因为当排好序之后 连号数列为minn x1 x2... maxn 则 maxn - minn = 区间长度

找到规律之后直接枚举 左右区间

```c++
#include <iostream>
using namespace std;
int nums[100010];
int main()
{
    int n;
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    int maxn = nums[0], minn = nums[0];
    int cnt = 0;
    for (int l = 0; l < n; l++)
    {
        maxn = minn = nums[l];
        for (int r = l; r < n; r++)
        {
            maxn = max(maxn, nums[r]);
            minn = min(minn, nums[r]);
            if (maxn - minn == r - l)cnt++;
        }
    }
    cout<<cnt;
}
```



## [1204. 错误票据 - AcWing题库](https://www.acwing.com/problem/content/1206/)

* 3/2

照题意模拟 用hash表存数 循环两次

```C++
#include <iostream>
using namespace std;
int nums[100010], has[100010];
int main()
{
    int n;
    cin>>n;
    int minn = 1e9+7, maxn = -1;
    int x;
    while (scanf("%d", &x) != EOF)
    {
        has[x]++;
        maxn = max(maxn, x);
        minn = min(minn, x);
    }
    int d, c;
    for (int i = minn; i <= maxn; i++)
    {
        if (has[i] == 0)d = i;
        if (has[i] == 2)c = i;
    }
    cout<<d<<" "<<c;
}
```

## [466. 回文日期 - AcWing题库](https://www.acwing.com/problem/content/468/)

* 3/2

枚举日期可能会超时 所以可以构造回文串然后判断是否是一个日期 是否在规定日期内 复杂度会降低很多

```C++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int months[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check(int date)
{
    int year = date / 10000;
    int month = date % 10000 / 100;
    int day = date % 100;

    if (!month || month >= 13 || !day) return false;

    if (month != 2 && day > months[month]) return false;
    if (month == 2)
    {
        bool leap = year % 4 == 0 && year % 100 || year % 400 == 0;
        if (day > 28 + leap) return false;
    }

    return true;
}

int main()
{
    int date1, date2;
    cin >> date1 >> date2;

    int res = 0;
    for (int i = 0; i < 10000; i ++ )
    {
        int x = i, r = i;
        for (int j = 0; j < 4; j ++ ) r = r * 10 + x % 10, x /= 10;

        if (r >= date1 && r <= date2 && check(r)) res ++ ;
    }

    printf("%d\n", res);
    return 0;
}

```

## [1219. 移动距离 - AcWing题库](https://www.acwing.com/problem/content/1221/)

* 3/2

```C++
#include <iostream>
using namespace std;
int w, m, n;
int r(int x)
{
    if (x % w == 0)
    {
        return x / w;
    }
    else return x / w + 1;
}
int c(int x, int f)
{
    if (f == 1)
    {
        return x % w;
    }
    else return (w - (x % w) + 1) % w;
}
int main()
{
    cin>>w>>m>>n;
    if (m > n)swap(m, n);
    int rn, rm;
    rn = r(n), rm = r(m);
    if (rn == rm)
    {
        cout<<abs(m - n);
        return 0;
    }
    int a = abs(rn - rm);
    
    int fn = rn % 2, fm = rm % 2;
    int cn = c(n, fn), cm = c(m, fm);
    int b = abs(cn - cm);
    
    cout<<a + b;
    
}
```

## [1229. 日期问题 - AcWing题库](https://www.acwing.com/problem/content/description/1231/)

* 3/2

由于数比较小 可以枚举 从19600101到20591231 

直接模拟不好写 可以先判断一下当前的数字是不是日期

如果是一个日期的话 再去看他符不符合三种排列的其中一种 输出即可（直接按提议模拟判断太多 写不了

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int mon[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int run(int y)
{
    return (y % 400 == 0) || (y % 100 != 0 && y % 4 == 0);
}
bool check(int y, int m, int d)
{
    if (m >= 1 && m <= 12)
    {
        mon[2] += run(y);
        if (d>=1 && d <= mon[m])
            {
                mon[2] = 28;
                return true;
            }
    }
    return false;
}
int main()
{
    int a,b,c;
    scanf("%d/%d/%d", &a, &b, &c);
    
    //构造
    for (int i = 19600101; i <= 20591231; i++)
    {
        int y = (i / 10000), m = (i % 10000) / 100, d = i % 100;
        if (check(y, m, d))
        {
            if ((y%100 == a && m == b && d == c)||
        (m == a && d == b && y%100 == c)||
        (d == a && m == b && y%100 == c))
            printf("%d-%02d-%02d\n", y, m, d);
        }
    }
    
}
```

## [1231. 航班时间 - AcWing题库](https://www.acwing.com/problem/content/1233/)

* 3/1

关键在于题目给的是**往返**的时间 去的时候 时间为B - A + H（时差）回来的时候时间为A - B + H  两趟的时间加起来刚好抵消了时差 所以可以不需要考虑时差 只用除以二即可

```C++
#include <iostream>
using namespace std;
int gettime()
{
    int h1,h2,m1,m2,s1,s2,a=0;
    scanf("%d:%d:%d %d:%d:%d (+%d)", &h1,&m1,&s1,&h2,&m2,&s2,&a);
    int t = a * 24 * 3600 + h2 * 3600 + m2 * 60 + s2 - (h1 * 3600 + m1 * 60 + s1);
    return t;
}
int main()
{
    int T;
    cin>>T;
    while (T--)
    {
        int t1 = gettime();
        int t2 = gettime();
        int t = t1 + t2 >> 1;
        printf("%02d:%02d:%02d\n", t / 3600, t % 3600 / 60, t % 60);
    }
}
```

## [1241. 外卖店优先级 - AcWing题库](https://www.acwing.com/problem/content/1243/)

* 3/2

1e5的规模 O(n2)的时间会超时 直接两层循环肯定是不行的 要降低复杂度 

不用枚举每分钟 每个商店的加减 而是枚举所有的**操作**记录上次操作的时间 分段地处理订单 这样处理就需要订单是有序的 所以要排序

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, t;
struct TD
{
    int t, d;  
}td[100010];
bool st[100010];
int last[100010];
int cnt[100010];
int main()
{
    cin>>n>>m>>t;
    for (int i = 0; i < m; i++)
    {
        int t, d;
        cin>>t>>d;
        td[i].t = t, td[i].d = d;
    }
    sort(td, td + m, [&](TD a, TD b){
        if (a.t == b.t)return a.d < b.d;
        else return a.t < b.t;
    });
    for (int i = 0; i < m;)
    {
        int j = i;
        int id = td[i].d, it = td[i].t;
        while (j < m && td[j].d == id && td[j].t == it)
        {
            j++;
        }
        
        int c = it - last[id] - 1;
        cnt[id] -= c;
        if (cnt[id] < 0)cnt[id] = 0;
        if (cnt[id] <= 3)st[id] = false;
        cnt[id] += 2 * (j - i);
        if (cnt[id] > 5) st[id] = true;
        last[id] = it;
        
        i = j;
    }
    for (int i = 1; i <= n; i++)
    {
        cnt[i] -= (t - last[i]);
        if (cnt[i] <= 3)st[i] = false;
    }
    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        if (st[i])res++;
    }
    cout<<res;
}
```

## [1238. 日志统计 - AcWing题库](https://www.acwing.com/problem/content/description/1240/)

* 3/3

这个题跟上一题有点像 但是又不一样  上一题是每个单位时间都在增减 这个题只用看当前这个博客他的上一次点赞  由于排好序了 所以博客点赞取消的时间也是有序的  用j来表示 当logs[i].x 也就是当前的时间 比j大超过d的时候 点赞取消 cnt要减少

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int cnt[N];
bool st[N];
typedef pair<int, int> PII;
#define x first
#define y second
int n, k, d;
PII logs[N];
int main()
{
    cin>>n>>d>>k;
    for (int i = 0; i < n; i++)cin>>logs[i].x>>logs[i].y;
    
    sort(logs, logs + n);
    for (int i = 0, j = 0; i < n; i++)
    {
        int id = logs[i].y, t = logs[i].x;
        cnt[id]++;
        // 时间超了
        while (logs[i].x - logs[j].x >= d)
        {
            cnt[logs[j].y]--;
            j++;
        }
        if (cnt[id] >= k)st[id] = true;
    }
    for (int i = 0; i < N; i++)if (st[i])cout<<i<<endl;
}
```



## [Problem - C - Codeforces](https://codeforces.com/contest/1933/problem/C)

* 3/1

比赛的时候一直感觉有复杂度低的做法  结果没想到就是暴力（ 但是不是枚举k 这样会超时  而是枚举x y

因为x y是幂次 1e6的数据x y到30就已经超出很多了  这样来看复杂度也就是900*O(pow)肯定是够的。。。

然后再注意一点 用set会比map简单一些

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
void solve()
{
    int a, b, l;
    cin >> a >> b >> l;
    set<int> s;
    for (int x = 0; x <= 30; x++)
    {
        for (int y = 0; y <= 30; y++)
        {
            if (l % (int)(pow(a, x) * pow(b, y)) == 0)
                s.insert(l / (pow(a, x) * pow(b, y)));
        }
    }
    cout << s.size() << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [3066. 超过阈值的最少操作数 II - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/submissions/506853271/)

[3065. 超过阈值的最少操作数 I - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/)

* 3/2

双周赛t1 t2 简单模拟

```C++
class Solution {
public:
    int minOperations(vector<int>& nums, int k) {
        priority_queue<long long>q;
        int n = nums.size();
        for (int i = 0; i < n; i++)
        {
            q.push(-nums[i]);
        }
        long long x = 0, cnt = 0;
        while (x <= k && !q.empty())
        {
            x = -q.top();
            q.pop();
            if (x >= k)break;
            long long y = -q.top();
            q.pop();
            q.push(-(min(x, y) * 2 + max(x, y)));
            cnt++;
        }
        return cnt;
    }
};
```

## [3071. 在矩阵上写出字母 Y 所需的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/submissions/506949217/)

* 3/3

周赛t3 哈希表 记录Y上的0 1 2 的数量 最后进行比较

```C++
class Solution {
public:
    int minimumOperationsToWriteY(vector<vector<int>>& g) 
    {
        int n = g.size();
        int zx = n / 2;
        int cy[3];
        for (int i = 0; i < zx; i++)
        {
            cy[g[i][n - i - 1]]++;
            cy[g[i][i]]++;
        }
        for (int i = zx; i < n; i++)
        {
            cy[g[i][zx]]++;
        }
        int ny[3];
        
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j< n; j++)
            {
                ny[g[i][j]]++;
            }
        }
        for (int i =0 ; i  <3; i++)
            ny[i] -= cy[i];
        
        int sumy[3], nsy[3];
        sumy[0] = sumy[1] = sumy[2] = (cy[0] + cy[1] + cy[2]);
        nsy[0] = nsy[1] = nsy[2] = (ny[0] + ny[1] + ny[2]);
        for (int i = 0; i < 3; i++)
        {
            sumy[i] -= cy[i];
            nsy[i] -= ny[i];
        }
        int res = 1e9;
        
        res = min(res, sumy[0] + min(nsy[1], nsy[2]));
        res = min(res, sumy[1] + min(nsy[0], nsy[2]));
        res = min(res, sumy[2] + min(nsy[0], nsy[1]));
        return res;
    }
};
```

## [100251. 数组中的最短非公共子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-uncommon-substring-in-an-array/description/)

* 3/10

周赛t3

核心思路 ：哈希表记录前面出现过的子字符串 

先枚举所有字符串的子字符串 放入哈希表 

然后再枚举所有字符串的子字符串 检查哈希表中其他字符是否也有这个子字符串

<img src="../images/$%7Bfiilename%7D/image-20240311091841329.png" alt="image-20240311091841329" style="zoom:25%;" />

```C++
class Solution {
public:
    vector<string> shortestSubstrings(vector<string>& arr) 
    {
        map<string, vector<int>>mp;
        for (int k = 0; k < arr.size(); k++)
        {
            int n = arr[k].size();
            for (int i = 0; i < n; i++) 
            {
                for (int j = i + 1; j <= n; j++) 
                {
                    string substring = arr[k].substr(i, j - i);
                    mp[substring].push_back(k);
                }
            }
        }
        vector<string>rets;
        
        for (int k = 0; k < arr.size(); k++)
        {
            int n = arr[k].size();
            string ret = "";
            for (int i = 0; i < n; i++) 
            {
                for (int j = i + 1; j <= n; j++) 
                {
                    string substring = arr[k].substr(i, j - i);
                    int flag = 0;
                    for (auto x: mp[substring])
                    {
                        if (x != k)
                        {
                            flag = 1;
                            break;
                        }
                    }
                    if (flag == 0)
                    {
                        if (ret == "")ret = substring;
                        else
                        {
                            if (ret.size() > substring.size())
                                ret = substring;
                            else if (ret.size() == substring.size() && ret > substring)
                                ret = substring;
                        }
                    }
                }
            }
            rets.push_back(ret);
        }
        return rets;
    }
};
```

## [Problem - A - Codeforces](https://codeforces.com/contest/1941/problem/A)

* 3/12

按题意模拟 左右各取硬币进行比较

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 100010;
int l[N], r[N];
void solve()
{
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 0; i < n; i++)
    {
        cin >> l[i];
    }
    for (int i = 0; i < m; i++)
    {
        cin >> r[i];
    }
    sort(l, l + n);
    sort(r, r + m);
    ll cnt = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (l[i] + r[j] <= k)
                cnt++;
            else
                break;
        }
        if (l[i] >= k)
            break;
    }
    cout << cnt << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - C - Codeforces](https://codeforces.com/contest/1941/problem/C)

* 3/11

字符串查找 关键是对每个子串进行分割 map 和pie都是只用破坏中间的字母就可以让他们变美 需要的最小代价为1

要注意mapie这样特殊的字符串 进行特判

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n;
    cin >> n;
    string s;
    cin >> s;
    ll cnt = 0;
    for (int i = 0; i < n - 2; i++)
    {
        string a = s.substr(i, 3);
        if (a == "map" || a == "pie")
            cnt++;
    }
    for (int i = 0; i < n - 4; i++)
    {
        string a = s.substr(i, 5);
        if (a == "mapie")
            cnt--;
    }
    cout << cnt << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - D - Codeforces](https://codeforces.com/contest/1941/problem/D)

* 3/11

记录每次传球可能传到的同学的下标 然后存入temp中 

当一轮全部传完再赋值给last 

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 300010;

void solve()
{

    int n, m, x;
    cin >> n >> m >> x;
    set<int> last;
    last.insert(x);
    for (int i = 0; i < m; i++)
    {
        int d;
        char c;
        cin >> d >> c;
        set<int> temp;

        for (auto a : last)
        {
            int now1 = (a + d) % n;
            int now2 = (a - d + n) % n;
            if (c == '0')
            {
                temp.insert(now1);
            }
            else if (c == '1')
            {
                temp.insert(now2);
            }
            else
            {
                temp.insert(now1);
                temp.insert(now2);
            }
        }
        last = temp;
    }
    int l = last.size();
    cout << l << endl;
    int flag = 0;
    for (auto a : last)
    {
        if (a != 0)
            cout << a << " ";
        else
            flag = 1;
    }
    if (flag)
        cout << n << " ";
    cout << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [成为 K 特殊字符串需要删除的最少字符数 - 力扣 (LeetCode) 竞赛](https://leetcode.cn/contest/weekly-contest-389/problems/minimum-deletions-to-make-string-k-special/)

* 3/17

比赛的时候调了一个多小时都没调出来。。。

是类似于滑动窗口的思想，先计算全部减少最大的字母 直到满足条件

然后删除一个最小的字母 再减少后面大的字母  直到满足条件

然后删除两个最小的字母 再减少后面大的字母 直到满足条件

... 直到删除所有的小字母

暴力枚举

```C++
class Solution {
public:
    int minimumDeletions(string word, int k) 
    {
        int cnt[26] = {0};
        for (auto x:word)
        {
            cnt[x - 'a']++;
        }
        sort(cnt, cnt + 26);
        int index = 0;
        for (int i = 0; i < 26; i++)
        {
            if (cnt[i] != 0)
                {index = i;
                 break;}
        }
        if (cnt[25] - cnt[index] <= k)return 0;
        int n = 26;
        int pre = 0;
        int res = 0;
        for (int i = index; i < n; i++)
        {
        	int now = pre;
            // 全部删后面
            for (int j = i + 1; j < n; j++)
            {
                if (cnt[j] > cnt[i] + k)
                	now += cnt[j] - cnt[i] - k;
            }
            res = min(res, now);
            pre += cnt[i];// 删一个最小的
        }
        return ret;
    }
};
```

 ## [2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/)

* 3/27

<img src="../images/$%7Bfiilename%7D/image-20240327081353922.png" alt="image-20240327081353922" style="zoom:25%;" />

区间合并 按左端点排序 之后维护一个最大右值maxr 如果下一个数的左端点小于maxr 就说明这是相连的区间 否则就是一个新的区间

由于相连的区间必须放在同一组 可以直接将相连的区间视为一个整体 算出区间的数量 然后利用排列 共有$2^n$种放法

```C++
const int mod = 1e9 + 7;
class Solution {
public:
    int countWays(vector<vector<int>>& ranges) 
    {
        sort(ranges.begin(), ranges.end(), [&](vector<int>a, vector<int>b)
        {
            return a[0] < b[0];
        });
        for (auto x:ranges)
        {
            cout<<x[0]<<" "<<x[1]<<endl;
        }
        int n = ranges.size();
        int cnt = 0;
        int maxr = -1;
        long long res = 1;

        for (int i = 0; i < n; i++)
        {
            if (ranges[i][0] > maxr)
                res = res * 2 % mod;
                
            maxr = max(maxr, ranges[i][1]);
            
        }
        
        return res;
    }
};
```



# 数学 / 贪心

## [Problem - A - Codeforces](https://codeforces.com/contest/1933/problem/A)

* 3/1

正数不需要换 负数需要换 全部变成整数即为最大

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int n;
    cin >> n;
    int res = 0;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        if (x >= 0)
            res += x;
        else
            res -= x;
    }
    cout << res << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - B - Codeforces⁤](https://codeforces.com/contest/1933/problem/B)

* 3/1

由于要模3  sum % 3只有0 1 2三种情况 当减去某个数之后可能整除3   注意 减去1 和减去4 的效果是一样的 所以用哈希表记录是否有模3为1 或2的然后看加还是减 可以得到整除3的数

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int nums[100010];
void solve()
{
    int n;
    cin >> n;
    ll sum = 0;
    int cnt[3] = {0};
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
        sum += nums[i];
        cnt[nums[i] % 3]++;
    }
    if (sum % 3 == 0)
    {
        cout << 0 << endl;
    }
    else if ((sum + 1) % 3 == 0 || ((sum - 1) % 3 == 0 && cnt[1] != 0) || ((sum - 2) % 3 == 0 && cnt[2] != 0))
    {
        cout << 1 << endl;
    }
    else
        cout << 2 << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - D - Codeforces](https://codeforces.com/contest/1933/problem/D)

* 3/1

尽量通过排列顺序凑出 **不等于0**

所有的数都去取模 最终不为0输出YES 否则输出NO

1. 观察可以发现  1 % 2 = 1   2 % 9 = 2  小数模大数 必定不可能为0   

2. 0 % x = 0  只要有两数相模为0 那么结果就肯定为0 就为NO

所以排序之后 把大数分别拿去模小数（模最小的nums[0]即可）如果不是0  那么说明可能出现不等于0 直接输出YES（只要一直用这个小数模大数就行）  2 2 3   可以3 % 2 = 1 得到的数为1         1 % 2 = 1 由于大数模小数可以得到比nums[0]更小的数  只要他大于0 小于nums[0] 那么就一定可以反复利用这个小数  最终结果不为0   [规则1]

最终如果nums[0] == nums[1] 就是两个一样的数相模 为0  就为NO  因为比如3 3 6 9         9 % 3 = 0 规则1失效 由于 [规则2]  虽然说3模6 3模9都不为0    但是3 % 3 = 0 所以最后要特判一下是否有和最小数nums[0] 一样的数



```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int nums[100010];
void solve()
{
    int n;
    cin >> n;

    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    sort(nums, nums + n);
    for (int i = n - 1; i > 0; i--)
    {
        if (nums[i] % nums[0] != 0)
        {
            cout << "YES" << endl;
            return;
        }
    }
    if (nums[0] == nums[1])
    {
        cout << "NO" << endl;
    }
    else
        cout << "YES" << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## 1224. [交换瓶子 - AcWing题库](https://www.acwing.com/problem/content/1226/)

3/8

置换群

每个长k的环需要k - 1次交换 则求n中有多少个环即可

```C++
#include <iostream>
using namespace std;

int nums[10010];
int vis[10010];
int main()
{
    int n = 0; 
    cin>>n;
    for (int i = 1; i <= n; i++)
    {
        cin>>nums[i];
    }
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        if (!vis[nums[i]])
        {
            cnt++;
            int j = i;
            while (!vis[nums[j]])
            {
                vis[nums[j]] = 1;
                j = nums[j];
            }
        }
    }
    cout<<n - cnt;
}
```

## [104. 货仓选址 - AcWing题库](https://www.acwing.com/problem/content/106/)

* 3/5

尽量选在中间位置 比如1  2   6 9

选择在2 6 中间   距离和为 2x - 3 + 15 - 2x = 12

选在6 9中间为 9 - x - 9 + 3x 并且x > 6  sum  > 12

所以在中间是最好的

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int nums[100010];
int main()
{
    int n;
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    
    sort(nums, nums + n);
    int left = 0, right = 0;
    for (int i = 0; i < n / 2; i++)
    {
        left += nums[i];
    }
    for (int i = n / 2 + n % 2; i < n; i++)
    {
        right += nums[i];
    }
    cout<<right - left<<endl;
}
```

## [0填充 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3519/learning/)

* 3/6

贪心的策略 从0到n 一旦遇到了两两凑成一对的 就直接计入结果并且跳过i + 1

如果遇到？ 大概有这几种情况 0??1   0?可以 ?1 可以

??11    ??可以

```C++
#include <iostream>
#include<cstring>
using namespace std;
int main()
{
  // 请在此输入您的代码
  string s;
  cin>>s;
  long long ans = 0;
  for (int i = 0; i < s.size() - 1; i++)
  {
      if (s[i] == s[i + 1] || s[i] == '?' || s[i + 1] == '?')
      {
          ans++;
          i++;
      }
  }
  cout<<ans;
  return 0;
}
```

## [122. 糖果传递 - AcWing题库](https://www.acwing.com/problem/content/124/)

* 3/12

[环形]均分纸牌问题

<img src="../images/$%7Bfiilename%7D/image-20240302163447063.png" alt="image-20240302163447063" style="zoom: 25%;" />

推公式：先设每个人要给左边的$x_i$个 从右边拿到$x_{i + 1}$个 （只需要给旁边的 因为就算跨着给 结果也是一样的 直接设只给旁边的好算） 

```C++
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
int a[N], temp[N], c[N];
int main()
{
    int n;
    cin>>n;
    ll sum = 0, ret = 0;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        sum += a[i];
    }
    ll ave = sum / n;
    for (int i = 0; i < n; i++)
    {
        temp[i] = ave - a[i];
    }
    c[0] = temp[0];
    for (int i = 1; i < n; i++)
    {
        c[i] = c[i - 1] + temp[i];
    }
    sort(c, c + n);
    int xn = c[n / 2];
    for (int i = 0; i < n; i++)
    {
        ret += abs(c[i] - xn);
    }
    cout<<ret;
}

```

## [112. 雷达设备 - AcWing题库](https://www.acwing.com/problem/content/114/)

* 3/11

本来想这样贪心：先按x从小到大 相同x的y从大到小排序 不断选取最右边的值 但是有些情况不符合 <img src="../images/$%7Bfiilename%7D/image-20240302195003434.png" alt="image-20240302195003434" style="zoom:25%;" />

所以要先求出每个岛的探测区间 然后再按区间合并的方法来做

按右端点排序 排完序后如果一个区间的左端点小于last区间的右端点 那么就说明他们可以共用一个雷达

```C++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
typedef pair<double, double> PII;
#define r first
#define l second
PII seg[100010];
const double INF = 1e10, eps = 1e-6;
int main()
{
    int n, d;
    cin >> n >> d;

    for (int i = 0; i < n; i++)
    {
        int x, y;
        cin>>x>>y;
        if (y > d)
        {
            cout << -1 << endl;
            return 0;
        }
        auto len = sqrt(d * d - y * y);
        seg[i] = {x + len, x - len};
    }
    
    sort(seg, seg + n);
    int res = 0;
    double last = -INF;
    for (int i = 0; i < n; i++)
    {
        if (seg[i].l > last + eps)
        {
            res++;
            last = seg[i].r;
        }
    }
    
    cout << res;
}
```

## [1235. 付账问题 - AcWing题库](https://www.acwing.com/problem/content/1237/)

求出平均值 当小于平均值的 时候  直接allin 当大于平均值的时候只需要给出平均值就行

关键在于不断地更新当前的平均值 

一开始想的贪心是 先把小于的全部给了 大于的把平均值给了 然后算差的钱的平均值 再从大的里面减 然后不够了再去... 这样要两层循环 是$O(n^2)$的 不行

可以对每一个数都更新一下当前的平均值 小于的全部给  但是由于小于平均值 这里要更新一下当前的平均值 因为这人给的不够 后面要多给   由于**排序**了 如果有人够了 就直接给平均值的钱就行 因为后面的必然够

注意同时计算sum

注意这题爆double了（哭   要用long double<img src="../images/$%7Bfiilename%7D/image-20240302205938546.png" alt="image-20240302205938546" style="zoom:25%;" />

```C++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int nums[500010];
int main()
{
    int n;
    long long s;
    cin>>n>>s;
    long double ave = s * 1.0 / n ;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    long double cur_ave = ave;
    long double sum = 0;
    sort(nums, nums + n);
    for (int i = 0; i < n; i++)
    {
        if (nums[i] <= cur_ave)
        {
            s -= nums[i];
            sum += (ave - nums[i]) * (ave - nums[i]);
            cur_ave = s  * 1.0 / (n - i - 1);
        }
        else 
        {
            sum += (cur_ave - ave) * (cur_ave - ave);
        }
    }
    printf("%.4llf",sqrt(sum / n));
}
```

## [1239. 乘积最大 - AcWing题库](https://www.acwing.com/problem/content/description/1241/)

* 3/7

```C++
/*
k是奇数则 如果全是负数 结果为负
否则先选一个正数（最大的） 变为k是偶数的情况
k是偶数则答案必然是正的 看负数的个数 
*/

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

typedef long long LL ;
const int N = 100010 , mod = 1000000009 ;
int a[N];

int main()
{
    int n , k ;
    scanf("%d%d",&n,&k);
    for(int i = 0 ; i < n ; i ++) scanf("%d",&a[i]);

    sort(a,a + n);

    LL res = 1 ; //乘积初始化
    int l = 0 , r = n - 1 ;//双指针初始化
    int sign = 1 ; // 符号初始化

    //由于4种情况除了 k 是奇数且 k < n 的时候需要特判一下处理一下符号 ,其他的时候都可以转化为双指针做法
    //k 是奇数是先选出最大的数, k-- 就是偶数,两边再同时取对,转化成相同的双指针做法
    if(k % 2 )
    {
        res =  a[r]; // 取出最大的一个数
        r -- ; //右指针移动
        k -- ; //个数减1

        if(res < 0) sign = -1;  // 如果最大值都是负数,就证明全是负数,那么符号要发生改变
    }
    while(k) // 双指针做法
    {
        LL x = (LL)a[l] * a[l + 1] , y = (LL)a[r] * a[r - 1];//两边同时取对
        //选择更大的一对,和归并排序思路相近
        if(x * sign > y * sign)
        {
            res = x % mod * res % mod; // 需要注意的是 :不可以写成(x * res) % mod ,也不可以写成是 res % mod * x % mod
                                       // 因为x最大是 10^10，如果不先取模的话，和res相乘的结果最大是 10^19,会暴long long。            
            l += 2; // 指针移动                                 
        }
        else 
        {
            res = y % mod * res % mod; 
            r -= 2; 
        }
        k -= 2; 
    }
    printf("%lld",res);
    return 0;
}

```

## [1247. 后缀表达式 - AcWing题库](https://www.acwing.com/problem/content/1249/)

* 3/12

一开始没读懂题意   后缀表达式关键在于他转换成中缀表达式 是可以随意添加括号的  所以说 根据负负得正的原则 我们可以将负数转化成正数 比如 -1 -2 -3   1 2 3   可以是1 +2+3-(-1-2-3)

贪心：先选最大的数作为基数 如果没有减号那就是全部相加 如果有一个减号 那就把所有负数变成正的  如果没有负的就要减去最小的正数   所以一开始直接减去最小的那个数 然后把1~n+m-1的数全部按绝对值加起来就可以

如果有多个减号  通过加括号 可以变成跟一个减号一样

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int nums[300010];
int main()
{
    int n, m;
    cin>>n >> m;
    for (int i = 0; i < n + m + 1; i++)
    {
        cin>>nums[i];
    }
    
    sort(nums, nums + n + m + 1);
    
    long long res = nums[n + m];
    if (m == 0)
    {
        for(int i = 0; i < n + m; i++)
        {
            res += nums[i];
        }
    }
    else 
    {
        res -= nums[0];
        for (int i = 1; i < n + m; i++)
        {
            res += abs(nums[i]);
        }
    }
    
    cout<<res;
}
```

## [1248. 灵能传输 - AcWing题库](https://www.acwing.com/problem/content/1250/)

* 3/4

太困难了 最后还是没看懂题解 但是学到了：

每次中间的给两边的能量 求最小的最大值  每次传输完能量后前缀和会由 s[i - 1] s[i] s[i + 1]变成s[i] s[i - 1] s[i + 1] 这就说明了所有的前缀和都可以任意排序 当顺序排序的时候差值最小 最大值就最小

## [1246. 等差数列 - AcWing题库](https://www.acwing.com/problem/content/1248/)

* 3/5

gcd 求最大公约数 背住gcd公式就行

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int nums[100010];
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
int main()
{
    int n;
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    sort(nums, nums + n);
    int d = nums[1] - nums[0];
    for (int i = 1; i < n; i++)
    {
        d = gcd(d, nums[i] - nums[i - 1]);
    }
    if (!d)cout<<n;
    else cout<<(nums[n - 1] - nums[0]) / d + 1;
}
```

## [1295. X的因子链 - AcWing题库](https://www.acwing.com/problem/content/description/1297/)

* 3/5

几个数论中很重要的内容 

首先是欧拉筛（线性筛）模板要背下来 [算法学习笔记 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1182444932760125440)可以看pecco的讲解

然后是公理  任意的数都可以被表示成质数的积的形式 $N=P_1^{a_1}*P_2^{a_2}*...P_n^{a_n}$其中p是质数  

补充：（所有约数的和为 $sum=(1+p_1+p_1^{2}...+p_1^{a_1})*(1+p_2+p_2^{2}...+p_2^{a_2})...(1+p_n+p_n^{2}...+p_n^{a_n})$）

因此我们可以用线性筛求出质因数 然后再算出每个质数的次数  其中$total=\sum_ia_i$就是最长的链（可以全部都乘上去） 

最长链的条数是 排列问题 比如2 2 2 5 5 7 7 7 不同的排列方式 就是$\frac{total!}{a_1!*a_2!...a_i!}$

细节问题 primes这个数组 第一位不用 直接primes[1] = 2 而不用primes[0]

```C++
#include <iostream>
#include <vector>
using namespace std;
const int N = (1<<20) + 10;
int min_t[N],primes[N];
bool in_primes[N];
int cnt;
void get_primes()
{
    for (int i = 2; i <= N; i++)
    {
        if (!in_primes[i])
            {
                primes[cnt++] = i;
                min_t[i] = i;
            }
        for (int j = 0; i * primes[j] <= N; j++)
        {
            in_primes[primes[j]*i] = true;
            min_t[i * primes[j]] = primes[j];
            if (i % primes[j] == 0)break;
        }
    }
}
int a[N];

int main()
{
    
    get_primes();
    int x;
    while (scanf("%d", &x) != EOF)
    {
        
        int total = 0;
        int k = 0;
        while (x > 1)
        {
            int p = min_t[x];
            a[k] = 0;
            while (x % p == 0)
            {
                
                a[k]++;
                total++;
                x /= p;
            }
            k++;
        }
        long long res = 1;
        for (int i = 2; i <= total; i++)res *= i;
        for (int i = 0; i < k; i++)
        {
            for (int j = 1; j <= a[i]; j++)
                res /= j;
        }
        printf("%d %lld\n", total, res);
    }
}
```



## [1296. 聪明的燕姿 - AcWing题库](https://www.acwing.com/problem/content/description/1298/)

* 3/5

数学结论在上面 

主要是 直接枚举会超时

这个时候我们就可以观察我们的约数和的公式
S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)

假设这个时候有一个约数和S满足(1+2)(1+2+2^2)(1+2+2^2+…+2^k)
3x5x9x17x33x65x129 = 635037975 就已经接近1e9的量级了，可见符合条件的项不会很多

那么这个时候我们就可以用dfs进行搜索，看我们能不能得到符合条件的(1+pk+pk^2+…+pk^ak)能够使得
S能够整除，即S % (1+pk+pk^2+…+pk^ak) == 0
然后S /= (1+pk+pk^2+…+pk^ak),再dfs到下一层

应该先从小到大枚举P

for(p : 2,3,5,7,...)
    for(a : 1,2,3,...)
        if(S mod (1+p1+p1^2+...+p1^a1) == 0)
            dfs(下一层)
这个时候我们还需要继续思考特殊情况

如果ai = 1的话，S = (1+Pi)的时候，因为Pi为质数，那么S-1也一定为质数，那么这个时候只需要判断S-1是否为质数即可

又S只会有两种情况，就是一种情况包括一个因子里面有(1+Pi)，另一种情况不包括(1+Pi)
S = (1+Pi)(1+Pj+Pj^2.....)
S = (1+Pi+Pi^2)(1+.....)

但是这两种情况都可以看出来Pi ^2 <= S
所以我们dfs枚举Pi的上限就是S
所以dfs应该设置成三个参数dfs(last,product,S)

1.last参数
表示上一个枚举的质数是谁，我们这样枚举的目的就是先把前面符合条件的质数枚举完了再枚举后面的质数，这样不会带来重复，降低了时间复杂度

比如质数为P = 2,3,5,7....

如果枚举2之后再dfs到下一层，那么这个时候就应该再从3开始进行枚举而不是再从头开始枚举

2.product参数
product表示 S = (1+p1+p1^2+…+p1^a1)(1+p2+p2^2+…+p2^a2)…(1+pn+pn^2+…+pn^an)中

当前进行到哪一个括号里面的最高次项Pi^ai的乘积和
比如S = (1+2+2^2)(1+3+3^2+3^3)(1+....)
则dfs到第三层的时候product = 2^2*3^3 (product : 1 – > 2^2 – > 2^2*3^3)

又由算术基本定理可知
一个数N = P1^a1 * P2^a2 * … * Pn^an

product = P1^a1 * P2^a2*.....

如果product要从第一层(一开始product初始化为1)进到第二层，此时product(2) = product(1) * P1^a1
S = S’ / (1+p1+p1^2+…+p1^a1)

然后再dfs(last,product(2),S) ==(等价于) dfs(last , product(1)*P1^a1 , S’/(1+p1+p1^2+…+p1^a1))

3.S参数
从上面的分析可知S参数就代表着从一开始的S除以(1+pk+pk^2+…+pk^ak)后剩余的乘积

所以每一层我们都应当判断S-1是否为质数，如果S-1是质数的话,也需要记录，但是不需要返回上一层继续往下搜即可
就比如24
24 = (1+23)
= (1+2)(1+7)
= (1+3)(1+5)
第一层的时候判断23是质数，所以记录res[len++] = 1*23
同时也需要继续往下做然后依次判断2、7 或者3、5能不能满足条件
只要有S-1为质数，说明就有满足条件的数，这个时候就需要记录结果
为什么S-1一定要大于上一层的质数？
因为我们要保证质数是从小到大枚举的，只有剩下的S-1是大于上一层的质数的时候，(1+S)才有可能成为最初的那个S的一个因子

因为我们要表示S’ = (1+ 2 + 2^2+…)(1 + 3 + 3^2 + …)…(1+S)
越往后枚举对应的那个Pi也越大，所以S-1一定要大于上一层的质数才能满足条件

S == 1对应的是什么情况？
S == 1对应的就是S’只由一个括号即只有一个P,S’ = (1+p+p^2+…+p^k)组成的情况
比如 7 = (1 + 2 + 2^2) ----->对应4
13 = (1 + 3 + 3^2) ----->对应9
15 = (1 + 2 + 2^2 + 2^3) ----->对应8
这种情况表明，我从p = primes[i]开始枚举，一个p得到的序列和就把一开始的S’给整除了或者说这个序列和与S’相等，即此时的p得到的序列和(1+p+p^2+…+p^k) == S’

所以此时S’ / (1+p+p^2+…) == 1
dfs到下一层直接就是dfs(last,p^k,1)
那么dfs到下一层S == 1的时候,product = p^k就是对应我们要找的那个数



```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 50000;
int primes[N], cnt;
bool st[N];
int s, res[N], len;

void get_prime()
{
    for (int i = 2; i <= N; i++)
    {
        if (!st[i])
            primes[cnt++] = i;
        for (int j = 0; i * primes[j] <= N; j++)
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0)
                break;
        }
    }
}

bool is_prime(int x)
{
    if (x < N)return !st[x];
    for (int i = 0; primes[i] <= x / primes[i]; i++)
    {
        if (x % primes[i] == 0)return false;
    }
    return true;
}

void dfs(int last, int product, int s)
{
    if (s == 1)
    {
        res[len++] = product;
        return ;
    }
    
    if (s - 1 > ((last < 0)? 0 :primes[last])&& is_prime(s - 1))
        res[len++] = product * (s - 1);
    
    for (int i = last + 1; primes[i] <= s / primes[i]; i++)
    {
        int p = primes[i];
        for (int j = 1 + p, t = p; j <= s; t *= p, j += t)
        {
            if (s % j == 0)
                dfs(i, product * t, s / j);
        }
    }
}

int main()
{
    get_prime();
    while (scanf("%d", &s) != EOF)
    {
        len = 0;
        dfs(-1, 1, s);
        cout<<len<<endl;
        if (len)
        {
            sort(res, res + len);
            for (int i = 0; i < len; i++)cout<<res[i]<<" ";
            cout<<endl;
        }
        
    }
}
```

## [1299. 五指山 - AcWing题库](https://www.acwing.com/problem/content/1301/)

* 3/6

扩展欧几里得 exgcd 返回值与gcd一样 是ab的最大公因数 可以求解ax+by=m是否有解 求ax+by=m的一组解 通解 最小整数解 (线性同余方程) 求逆元

```C++
int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}
```

通过扩展欧几里得求出来 x y   首先判断ax+by=m是否有解 

此时引入裴蜀定理:设a,b为正整数，则关于x,y的方程 ax+by=m有整数解当且仅当m是 gcd(a,b) 的倍数。即m%gcd==0

 判断有解后 开始求解  ax+by=m的x 和 y是其中一组特解 将x，y扩大$\frac{m}{gcd}$ 倍后得到$x_0\ y_0$ 通解就是 

$x_k=x_0+k*\frac{b}{gcd(a,b)}$

 $y_k=y_0-k*\frac{a}{gcd(a,b)}$

得到通解之后就可以求最小正整数解了

$y_{min}=y_0$%$ \frac{a}{gcd}$

$a_1=\frac{a}{gcd}$当有负数的时候要写成(y%a1+a1) % a1

```C++
#include <iostream>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

int main()
{
    int T;
    cin>>T;
    while (T--)
    {
        ll n, d, x, y, a, b;
        cin>>n>>d>>x>>y;
        
        ll gcd = exgcd(n, d, a, b);
        if ((y - x) % gcd)
        {
            cout<<"Impossible"<<endl;
        }
        else 
        {
            b *= (y - x) / gcd;
            n /= gcd;
            cout<<(b%n+n)%n<<endl;
        }
    }
}
```

## [xmuoj | 寻找蒙德大陆最宝贵的宝藏](https://www.xmuoj.com/contest/215/problem/1)

* 3/6

贪心+记录下标 上机的时候一直调不出来 下标还有格式错了（哭、

规定下标从1到n

贪心思路 用sum记录当前的和 如果当前和大于maxn的话就令maxn = sum同时ed=i  注意此时st = record   因为如果sum一直大于0的话 record是不会变的 只有当sum 小于0的时候record才会变成i+1（表示起点在当前点的下一个）所以没有影响 st不变  只有当刚开始 或者sum 小于0 才会使st变化

sum小于0的时候可以直接不选 让sum变成0

```C++
#include<iostream>
using namespace std;
int main() 
{
	int T;
	scanf("%d", &T);
	for (int p = 1; p <= T; p++)
	{
		int a[100002];
		int i = 0;
		int n;
		scanf("%d", &n);
		for (i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
		}
		int maxn = -1001, sum = 0, record = 1, st, ed;
		for (i = 1; i <= n; i++) {
			sum += a[i];
			if (sum > maxn) {
				st = record;
				maxn = sum;
				ed = i;
			}
			if (sum < 0) {
				record = i + 1;
				sum = 0;
			}
		}
		printf("Case %d:\n", p);
		printf("%d %d %d\n", maxn, st, ed);
		if (p != T) printf("\n");
	}
	return 0;
}

```

## [2575. 找出字符串的可整除数组 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/)

* 3/7

(a + b) % mod = a % mod + b % mod 不用把s具体值算出来 $10^5$位会爆 

但是可以算出来s是否能被mod整除

```C++
class Solution {
public:
    vector<int> divisibilityArray(string word, int m) 
    {
        int n = word.size();
        vector<int>ret(n);
        long long  s = 0;
        for (int i = 0; i < n; i++)
        {
            s = (s * 10 + (word[i] - '0')) % m;
            ret[i] = s==0;
        } 
        return ret;
    }
};
```

## [1223. 最大比例 - AcWing题库](https://www.acwing.com/problem/content/1225/)

* 3/7

更相减损术

<img src="../images/$%7Bfiilename%7D/image-20240307193114575.png" style="zoom:25%;" />

````C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 110;
typedef long long ll;
ll nums[N], a[N], b[N], cnt;

ll gcd(ll a, ll b)
{
    return b?gcd(b, a % b): a;
}

ll gcd_sub(ll a, ll b)
{
    if (a < b)swap(a, b);
    if (b == 1)return a;
    return gcd_sub(b, a / b);
}

int main()
{
    int n;
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>nums[i];
    }
    sort(nums, nums + n);
    
    for (int i = 1; i < n; i++)
    {
        if (nums[i - 1] != nums[i])
        {
            ll d = gcd(nums[i], nums[0]);
            a[cnt] = nums[i] / d;
            b[cnt] = nums[0] / d;
            cnt++;
        }
    }
    ll up = a[0], down = b[0];
    for (int i = 1; i < cnt; i++)
    {
        up = gcd_sub(a[i], up);
        down = gcd_sub(b[i], down);
    }
    cout<<up<<"/"<<down<<endl;
}
````

## [Problem - B - Codeforces](https://codeforces.com/contest/1941/problem/B)

* 3/12

每次第i位减2 i - 1和i + 1位减1

可以发现减的顺序不影响答案 因此直接从前往后贪心地写 每次都先让前面的数为0 尽可能多的造出0 

当i - 1为0的时候 要让i 和i + 1减去i - 1的值 当有负数说明不可能全减为0 可以返回false 否则到最后还需要再检查一遍倒数前三个是否都为0 

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 300010;
int nums[N];
void solve()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    for (int i = 1; i < n - 1; i++)
    {
        nums[i] -= (2 * nums[i - 1]);
        nums[i + 1] -= nums[i - 1];
        nums[i - 1] = 0;
        if (nums[i] < 0 || nums[i + 1] < 0)
        {
            cout << "NO" << endl;
            return;
        }
    }
    if (nums[n - 1] == 0 && nums[n - 2] == 0 && nums[n - 3] == 0)
        cout << "YES" << endl;
    else
        cout << "NO" << endl;
    return;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```



## [100249. 替换字符串中的问号使分数最小 - 力扣（LeetCode）](https://leetcode.cn/problems/replace-question-marks-in-string-to-minimize-its-value/)

* 3/18

最终的分数为 比如 a...a...a 那么分数就为 0 + 1 + 2 不论a在哪里 a一定能为答案提供c * (c + 1) / 2的分数

那么最终的分数 就只与字母出现的绝对次数有关 那就用堆 不断选择出现次数最少的字母  如果次数一样就选择字典序小的 然后再对选出来的 字母进行排序 填入？中 这样就可以保证字典序一定是最小的

```C++
/*只与字母最终出现的绝对次数有关*/
class Solution {
public:
    string minimizeStringValue(string s) 
    {
        int mp[26] = {0};
        int cnt = 0;
        for (auto x:s)
        {
            if (x != '?')
            mp[x - 'a']++;
            else cnt++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>q;
        for (int i = 0; i < 26; i++)
        {
            q.push({mp[i], i});
        }
        vector<char>c;
        for (int i = 0; i < cnt; i++)
        {
            auto t = q.top();
            c.push_back(t.second + 'a');
            q.pop();
            q.push({t.first + 1, t.second});
        }
        string ret = "";
        sort(c.begin(), c.end());
        
        int i = 0;
        for (auto x: s)
        {
            if (x != '?')
            ret += x;
            else 
            ret += c[i++];
        }
        return ret;
    }
};
```

## [1793. 好子数组的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/)

* 3/19

<img src="../images/$%7Bfiilename%7D/image-20240331114451084.png" alt="image-20240331114451084" style="zoom:25%;" />

贪心/双指针

由于这个题目要求包含k  所以可以 用双指针 以k为中心向两边扩展 关键在于最小值怎么更新：让nums[k]逐渐减小 然后每次左右扩展到比nums[k]大 这样就可以保证每次扩展的最小值

因为i = nums[k] 每次减小1 都是整数 所以左右两边的数 要么大于i 要么等于i 等于i就可以更新进去 并且每次更新完之后最小值就是i （比i小的进不来区间）而最大数是2e4 O(n)不会超时

```C++
class Solution {
public:
    int maximumScore(vector<int>& nums, int k) 
    {
        int n = nums.size();
        int l = k, r = k;
        int res = nums[k];
        for (int i = nums[k]; i > 0; i--)
        {
            while (r < n && nums[r] >= i)
            {
                r++;
            }
            while (l >= 0 && nums[l] >= i)
            {
                l--;
            }
            res = max(res, (r - l - 1)*i);
            if (l < 0 && r == n)break;
        }
        return res;
    }
};
```

也可以使用贪心的做法 以k为中心 优先向较大的一边进行更新

```C++
class Solution {
public:
    int maximumScore(vector<int>& nums, int k) 
    {
        int n = nums.size();
        int l = k, r = k;
        int res = nums[k];
        int minn = nums[k];
        while (l > 0 || r < n - 1)
        {
            if (l == 0)minn = min(minn, nums[++r]);
            else if (r == n - 1)minn = min(minn, nums[--l]);
            else
            {
                if (nums[l - 1] > nums[r + 1])minn = min(minn, nums[--l]);
                else minn = min(minn, nums[++r]);
            }
            res = max(res, minn * (r - l + 1));
        }
        return res;
    }
};
```

## [0数组分割 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3535/learning/)

3/18

数组分成两边 两边都是偶数  取一边为s1 另一边就是sum - s1

那么就需要sum为偶数  如果sum为奇数的话 那么绝对不可能分成两个偶数 就是0

我们可以数奇数的个数  奇数的个数如果为奇数  那说明sum为奇数

奇数的个数如果为0（全是偶数 ）那就随便组合 有2^n种

奇数的个数为偶数的时候 一边必须包含**偶数个奇数**相当于把两个奇数合成了一个偶数所以相当于少了一个数   所以就是 $2^{n-1}$

要边乘边mod

```C++
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
int cal(int n)
{
    int res = 1;
    while (n--)
    {
        res = res * 2 %mod;
    }
    return res;
}
void solve()
{
    int n;
    cin>>n;
    int x = 0, odd = 0;

    for (int i = 0; i < n; i++)
    {
        cin>>x;
        if (x % 2)odd++;
    }
    if (odd == 0)cout<<cal(n)<<endl;
    else 
    {
        if (odd % 2)cout<<0<<endl;
        else cout<<cal(n - 1)<<endl;
    }
}
int main()
{
    int T;
    cin>>T;
    while (T--)
    {
        solve();
    }
    return 0;
}
```

## [0矩形总面积 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3536/learning/)

* 3/19

要记得开ll 数组也要开  不然直接乘的时候会爆

<img src="../images/$%7Bfiilename%7D/uid2314845-20231022-1697949902971.png" alt="图片描述" style="zoom:25%;" />

多画点图 就可以看出来 情况其实不多

没有交集的时候 就是左上角小于右下角的时候 由于两个都可能在下面 所以要做两个判断

剩下的就是有交集的时候

那么有交集必定是有至少一个角在另一个里面 就是上面四种情况（加上包含）所以可以排序 排完序之后 交集就是(x2-x1) * (y2-y1)

但是其实不用排序也可以 因为这个交集的小矩形的边长就是min(x2, x4) - max(x1,x3)  y同理 

```C++
#include <iostream>
#include <cmath>
using namespace std;

typedef long long ll;
ll x[4], y[4];
int main()
{
    for (int i = 0; i < 4; i++)
    {
        cin>>x[i]>>y[i];
    }
    ll a = abs(x[1] - x[0]) * abs(y[1] - y[0]);
    ll b = abs(x[3] - x[2]) * abs(y[3] - y[2]);

    if (x[0] > x[3] || x[1] < x[2] || y[0] > y[3] || y[1] < y[2])
    {
        cout<<a + b;
    }
    else 
    {
        ll c = abs(max(x[0], x[2]) - min(x[1], x[3]));
        ll d = abs(max(y[0], y[2]) - min(y[1], y[3]));
        ll ans = c * d;
        ll n = a + b - ans;
        printf("%lld", n);
    }
    return 0;
}
```

## [1969. 数组元素的最小非零乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/)

* 3.20

<img src="../images/$%7Bfiilename%7D/image-20240320090945094.png" alt="image-20240320090945094" style="zoom:25%;" />

位运算+快速幂

两个数的位交换 两两之间差距越大 乘积就越小 所以要尽量扩大差距  最后换出来 应该是$2^{n-1}-1$个1 $2^{n-1}-1$个$2^n-2$还有一个$2^n-1$最后的公式为$(2^{n}-1)*(2^{n}-2)^{2^{n-1}-1}$

由于数太大 需要用快速幂来求

快速幂:[50. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/description/)

```C++
class Solution {
public:
    double myPow(double x, int n) 
    {
        if (x == 0.0)return 0.0;
        double res = 1.0;
        long b = n;
        if (b < 0)
        {
            x = 1/x;
            b = -b;
        }
        while (b)
        {
            if ((b & 1) == 1)res *= x;
            x *= x;
            b >>= 1;
        }
        return res;
    }
};
```



```C++
typedef long long ll;
class Solution {
public:
    const int mod = 1e9 + 7;

    ll mpow(ll x, ll p)
    {
        x %= mod;
        ll ans = 1;
        while (p)
        {
            if (p & 1)ans = ans * x % mod;
            x = x * x % mod;
            p >>= 1;
        }
        return ans;
    }
    int minNonZeroProduct(int p) 
    {
        ll k = (1LL << p) - 1;
        ll n = (1LL << (p-1)) - 1;
        return  k % mod * mpow(k - 1, n) % mod;
    }
};
```

## [100245. 每个字符最多出现两次的最长子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/submissions/515848010/)

* 3/24

<img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-25%20075414.png" style="zoom:25%;" />

滑动窗口  右移的同时观察当有三个相同字符的时候就开始收缩窗口（滑动左指针）

```C++
class Solution {
public:
    int maximumLengthSubstring(string s) 
    {
        int n = s.size();
        int maxn = 0;
        map<char, int>mp;
        int ans = 0;
        int j = 0;
        for (int i = 0; i < n; i++)
        {
            mp[s[i]]++;
            
            while (mp[s[i]] == 3)
            {
                mp[s[j++]]--;
            }
            ans = max(ans, i - j + 1);

        }
        return ans;
    }
};
```

## [100228. 执行操作使数据元素之和大于等于 K - 力扣（LeetCode）](https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/submissions/515851624/)

* 3/24

<img src="../images/$%7Bfiilename%7D/image-20240325075911567.png" alt="image-20240325075911567" style="zoom:25%;" />

数学题 找规律推公式 对数组中的数+1和复制数组中的数 要求最小操作数的话 根据贪心的策略 当然是先加再复制 收益更大 因为加每次只能加1 复制一次可以加很多

先加再复制的话 就枚举加的次数 复制的次数就是( target / 当前值)上取整

```C++
class Solution {
public:
    int minOperations(int k) 
    {
        if (k <= 1)return 0;
        int ans = 2e9;
        for (int i = 1; i <= sqrt(k); i++)
        {
            int now = ceil((double)k / i) + i - 2;
            ans = min(now,ans);
        }
        return ans;
    }
};
```

* 3/28 3/29

## [Problem - D - Codeforces](https://codeforces.com/contest/1950/problem/D)

div4D 由于数据范围是1e5 所以最多就是六位的“类”二进制数 可以先预处理出二进制数 直接打表

接下来就是连续除 最后看能不能整除  由于循环的基数比较小 只有64 所以时间复杂度很小

明明不难 比赛的时候调了半天  没看清题意 以为是一个数的倍数(哭)

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int nums[1000] = {0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, 10000, 10001, 10010, 10011, 10100, 10101, 10110, 10111, 11000, 11001, 11010, 11011, 11100, 11101, 11110, 11111, 100000, 100001, 100010, 100011, 100100, 100101, 100110, 100111, 101000, 101001, 101010, 101011, 101100, 101101, 101110, 101111, 110000, 110001, 110010, 110011, 110100, 110101, 110110, 110111, 111000, 111001, 111010, 111011, 111100, 111101, 111110, 111111};
void solve()
{
    int n;
    cin >> n;
    for (int i = 0; i < 64; i++)
    {
        if (nums[i] == n)
        {
            puts("YES");
            return;
        }
    }
    long long res = 1;

    for (int i = 2; i < 64; i++)
    {
        while (n % nums[i] == 0)
        {
            n /= nums[i];
        }
        if (n == 1)
        {
            puts("YES");
            return;
        }
    }

    puts("NO");
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - E - Codeforces](https://codeforces.com/contest/1950/problem/E)

div4E...调了2个小时都没调出来 

首先枚举长度 要判断是否可以分成整份 也就是求因子

然后枚举每一个长len的数组 作为基准数组 去和其他所有长len的数组比较 只要有一个符合就可以

主要是错在这一步 没有调出来。。写cf老是觉得会超时 时间复杂度太高 但是这里完全可以直接枚举所有的 我当时是准备找到第一个不相等的 将这个数组作为基准 也去做一遍比较 如果这两个都不行 那么这个长度就不符合 因为这两个不符合就说明至少有三个不一样的

其实思路没问题 关键是合在一个循环里面太乱了 要是当时能写两个循环 说不定都过了

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int n;
string s;

void solve()
{

    cin >> n >> s;
    vector<int> nums;
    for (int len = 1; len <= n; len++)
    {
        if (n % len != 0)
            continue;
        for (int i = 0; i < n && i <= len; i += len)
        {
            int cnt = 0;
            for (int j = 0; j < n; j++)
            {
                if (s[j] != s[i + j % len])
                    cnt++;
            }
            if (cnt <= 1)
            {
                cout << len << endl;
                return;
            }
        }
    }
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [Problem - F - Codeforces](https://codeforces.com/contest/1950/problem/F)

树形 但是数学题 

首先 要判断合不合格 由于0个结点的 上面可以接无限个1个结点的 所以重点是0 2结点

2个结点的 一定要比0个结点的少一个（二叉树的规律）

当2个结点的个数为0 那高度就是1个节点的个数 （下面接0）

当三个结点加起来为1的时候高度就是0

接下来就是考虑度为1 的结点的位置  尽量减少树的高度（因为度为2和0的结点位置固定）

<img src="../images/$%7Bfiilename%7D/image-20240329210439572.png" alt="image-20240329210439572" style="zoom:25%;" />

这张图是已经放上了全部 度为2的结点 其中rem 可能是度为1 或0  优先放在rem处可减小高度

rem放不下就一排排往下放 一排放满再放下一排  

主要就是用到log函数求当前的层

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

void solve()
{
    int x2, x1, x0;
    cin >> x2 >> x1 >> x0;

    if (x2 + 1 != x0)
    {
        cout << -1 << endl;
        return;
    }
    if (x2 + x1 + x0 == 1)
    {
        cout << 0 << endl;
        return;
    }
    if (x2 == 0)
    {
        cout << x1 << endl;
        return;
    }

    int d = ceil(log2(x2 + 1));
    int rem = (1 << d) - x2 - 1;
    if (x1 <= rem)
    {
        cout << d << endl;
        return;
    }
    x1 -= rem;
    int c = (x2 - (1 << (d - 1)) + 1) * 2 + rem;
    int add = ceil(x1 * 1.0 / c);
    cout << add + d << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [2952. 需要添加的硬币的最小数量 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/)

* 3/30

<img src="../images/$%7Bfiilename%7D/image-20240330214051238.png" alt="image-20240330214051238" style="zoom:25%;" />

贪心的做法 要得到1~target的所有数

要得到1 2 必须有1  2 然后通过1 2 可以合成3

```
添加/最大
1   / 1
2   / 3
4   / 7
8   / 15
```

贪心主要体现在 每次加上当前可以加的最大值 比如1 2 4数组 应该加上8 可以达到最大值15 如果加9的话 8就凑不出来 因此最大是8

对coins排序

设s为当前最大值 s如果比coins小的话 说明当前能凑到的最大值 距离下一次增加中间还有空挡 需要添加硬币（也就是加当前最大值） 否则就直接加上coins[i]

```C++
class Solution {
public:
    int minimumAddedCoins(vector<int>& coins, int target) 
    {
        int n = coins.size();
        sort(coins.begin(), coins.end());
        int s = 1, ans = 0, i = 0;
        while (s <= target)
        {
            if (i < n && coins[i] <= s)
            {
                s += coins[i++];
            }
            else
            {
                ans ++;
                s *= 2;
            }
        }
        return ans;
    }
};
```



# 二分

## [1236. 递增三元组 - AcWing题库](https://www.acwing.com/problem/content/1238/)

* 3/1

找这个三元组 主要是看中间一行 比如

```
A 1 4 5
B 5 6 9
C 4 6 7
```

就看B的5能和A结合几个 能和C结合几个

```
1 4 
5 
  6 7  
```

结果为2 * 2 = 4  

所以只需要对B的每一个数在A   C两个数组内进行二分 求出比他小的第一个数 和比他大的第一个数即可

然后注意一些下标的处理

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int nums[3][N];
int main()
{
    int n;
    cin>>n;
    
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin>>nums[i][j];
        }
        sort(nums[i], nums[i] + n);
    }
    
    long long res = 0;
    for (int i = 0; i < n; i++)
    {
        int key = nums[1][i];
        int pos1 = lower_bound(nums[0], nums[0] + n, key) - nums[0]; // 在A中找到第一个小于key的数
        int pos2 = upper_bound(nums[2], nums[2] + n, key) - nums[2] + 1; // 在C中找到第一个大于key的数
        
        res += (long long)(n - pos2 + 1) * pos1;
    }
    cout<<res;
}
```

## [Problem - E - Codeforces](https://codeforces.com/contest/1933/problem/E)

* 3/1

二分前缀和

首先预处理 求前缀和 二分前缀和 二分是前缀和 和u比较 

和以前的二分不一样的 最终结果不能直接输出 而是需要和ans - 1比较

因为可能超出 导致减少   

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
const int N = 100010;
int nums[N], qzh[N];
int l, u, le;

void solve()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> nums[i];
    }
    for (int i = 1; i <= n; i++)
    {
        qzh[i] = qzh[i - 1] + nums[i];
    }
    int q;
    cin >> q;

    for (int i = 0; i < q; i++)
    {
        cin >> l >> u;
        int le = l;
        int r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            int k = qzh[mid] - qzh[le - 1];

            if (k >= u)
                r = mid;
            else
                l = mid + 1;
        }
        auto f = [&](ll len, ll a1)
        {
            ll an = a1 - len + 1;
            return (a1 + an) * len / 2;
        };
        if (r - 1 >= le && f(qzh[r - 1] - qzh[le - 1], u) >= f(qzh[r] - qzh[le - 1], u))
            r--;
        cout << r << " ";
    }
    cout << endl;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int T;
    cin >> T;
    while (T--)
        solve();

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [4647. 青蛙过河 - AcWing题库](https://www.acwing.com/problem/content/4650/)

* 3/14

经典二分题 关键是check函数怎么写

可以发现 走过去和走过来是一样的 因此可以看作过去2x次

当跳跃一次能跳mid的时候  每个长度为mid的**区间的和**都需要大于2x

因为每个长为mid的区间都会被走到2x次 当有一个长为mid的区间少于2x的时候 就说明无法走过去

```C++
#include <iostream>
using namespace std;
typedef long long ll;
ll n, x;
const int N = 100010;
ll nums[N], s[N];

bool check(int mid)
{
    for (int i = 0; i <= n - mid - 1; i++)
    {
       if (s[i + mid - 1] - s[i - 1] < x)return false;
    }
    return true;
}

int main()
{
    cin>>n>>x;
    for (int i = 0; i < n - 1; i++)
    {
        cin>>nums[i];
    }
    x *= 2;
    s[0] = nums[0];
    for (int i = 1; i < n - 1; i++)
    {
        s[i] = s[i - 1] + nums[i];
    }
    int l = 1, r = n;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            r = mid;
        else l = mid + 1;
    }
    cout<<l<<endl;
}
```



# 前缀和

* 3/1

除了二分也可以用前缀和  比如b中的5  可以求出a中所有比5小的数 这时候就可以用哈希表＋前缀和 哈希表记录1 2 3 4 出现的次数 然后加起来 就可以得到比5小的数的个数

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int a[N], b[N], c[N], cnt1[N], cnt2[N], qzh1[N], qzh2[N];
int main()
{
    int n;
    cin>>n;
    
    for (int i = 1; i <= n; i++)
    {
        cin>>a[i];
        cnt1[++a[i]]++;
    }
    for (int i = 1; i <= n; i++)
    {
        cin>>b[i];
        b[i]++;
    }
    for (int i = 1; i <= n; i++)
    {
        cin>>c[i];
        cnt2[++c[i]]++;
    }
    qzh1[0] = cnt1[0];
    qzh2[0] = cnt2[0];
    for (int i = 1; i < N; i++)
    {
        qzh1[i] = qzh1[i - 1] + cnt1[i];
        qzh2[i] = qzh2[i - 1] + cnt2[i];
    }
    
    long long ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int k = b[i];
        ans += (long long)(qzh2[N - 1] - qzh2[k]) * qzh1[k - 1];
    }
    cout<<ans;
}
```

## [3070. 元素和小于等于 k 的子矩阵的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/submissions/506940450/)

* 3/3

二维前缀和

```C++
class Solution {
public:
    int countSubmatrices(vector<vector<int>>& grid, int k) 
    {
        int rows = grid.size();
        int cols = grid[0].size();

        vector<vector<int>> qzh(rows, vector<int>(cols, 0));
        
        qzh[0][0] = grid[0][0];
        for (int j = 1 ; j < cols; ++j) {
            qzh[0][j] = grid[0][j] + qzh[0][j - 1];
        }

        for (int i = 1; i < rows; ++i) {
            qzh[i][0] = grid[i][0] + qzh[i - 1][0];
        }

        for (int i = 1; i < rows; ++i) {
            for (int j = 1; j < cols; ++j) {
                qzh[i][j] = grid[i][j] + qzh[i - 1][j] + qzh[i][j - 1] - qzh[i - 1][j - 1];
            }
        }
        
        
        int cnt = 0;
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (qzh[i][j] <= k)cnt++;
            }
        }
        return cnt;
    }
};
```

## [4644. 求和 - AcWing题库⁤](https://www.acwing.com/problem/content/4647/)

* 3/14

```C++
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;

int main()
{
    int n;
    cin>>n;
    vector<ll>nums(n + 10);
    vector<ll>qzh(n + 10);
    for (int i = 0; i <n ;i++)
    {
        cin>>nums[i];
    }
    qzh[0] = nums[0];
    for (int i = 1; i < n; i++)
    {
        qzh[i] = qzh[i - 1] + nums[i];
    }
    ll res = 0;
    for (int i = 0; i < n; i++)
    {
        res += nums[i] * (qzh[n - 1] - qzh[i]);
    }
    cout<<res;
    
}
```

## [2909. 元素和最小的山形三元组 II - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/submissions/518117391/)

* 3/29

<img src="../images/$%7Bfiilename%7D/image-20240329200706728.png" alt="image-20240329200706728" style="zoom:25%;" />

* 三重循环暴力
* 前后缀分解 

对于这种三个三个的 一般是枚举中间的值 然后看两边是否有小于他的数 

因此可以分别求出前缀和后缀的数组 数组的意义为：到i为止 前/后 最小的数

```txt
nums 8 6 1 5 3
pre  8 6 1 1 1  
suf  1 1 1 3 3 
枚举到第i位就看pre和suf  分别代表前面/后面是否有比他小的  选最小的
```

```C++
class Solution {
public:
    int minimumSum(vector<int>& nums) 
    {
        int n = nums.size();
        int res = 2e9;
        vector<int>pre(n), sub(n);
        pre[0] = nums[0];
        sub[n - 1] = nums[n - 1];
        for (int i = 1; i < n; i++)
        {
            pre[i] = min(pre[i - 1], nums[i]);
        }
        for (int i =n - 2; i >= 0; i--)
        {
            sub[i] = min(sub[i + 1], nums[i]);
        }
        for(int i= 0; i < n; i++)
        {
            if (pre[i] < nums[i] && sub[i] < nums[i])
            res = min(res, nums[i] + pre[i] + sub[i]);
        }
        
        return res == 2e9?-1:res;
    }
};
```



# 图

## [2673. 使二叉树所有路径值相等的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/)

* 3/3

<img src="../images/$%7Bfiilename%7D/image-20240228173918182.png" alt="image-20240228173918182" style="zoom:25%;" />

最开始没读懂题目 后来发现中间节点也可以加 越上面的结点产生的效果越好 可以减小操作次数（原来用的BFS 会很麻烦

题目的二叉树是**满二叉树** 可以从兄弟节点两两一组来计算 兄弟节点 只需要加上两者的差 这样两个数就相等了 

又由于兄弟节点 从根节点到两兄弟的值是相同的 两者的差值就是 他们俩的子节点 因此可以从下往上计算  （每次把孩子结点更新为较大值 然后加到当前结点）

```C++
class Solution {
public:
    int minIncrements(int n, vector<int>& cost) 
    {
        int ans = 0;
        for (int i = n / 2; i > 0; i--) // 完全二叉树 倒数第二层即n / 2
        {
            ans += abs(cost[i * 2] - cost[i * 2 - 1]);
            cost[i - 1] += max(cost[i * 2], cost[i * 2 - 1]);
        }
        return ans;
    }
};
```

## [2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/reachable-nodes-with-restrictions/)

* 3/4

<img src="../images/$%7Bfiilename%7D/image-20240331115003018.png" alt="image-20240331115003018" style="zoom:25%;" />

```C++
class Solution {
public:
    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted)
    {
        vector<int>g[n];
        vector<bool>re(n, 1);
        for (auto x: edges)
        {
            g[x[0]].push_back(x[1]);
            g[x[1]].push_back(x[0]);
        }
        
        for (auto x: restricted)
        {
            re[x] = 0;
        }
        queue<int>q;
        q.push(0);
        re[0] = 0;
        int ans = 1;
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            for (auto y: g[x])
            {
                if (re[y])
                {
                    q.push(y);
                    re[y] = 0;
                    ans ++;
                }
            }
        }
        return ans;    
    }
};
```

## [1976. 到达目的地的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)

* 3/4

<img src="../images/$%7Bfiilename%7D/image-20240305083325908.png" alt="image-20240305083325908" style="zoom:25%;" />

最短路+DP 首先要打出最短路的模板（ 

然后就是分析DP  状态表示 f[i] 表示0~i的最短路径的数量  状态计算就是  x y  当从0到x 再从x到y 的路径比直接从0到y更短的时候 此时最短路就是0-x-y 那么0~y的最短路的数量就是0~x的最短路的数量（当前x-y只有一条）  如果路径长度相等的话  那说明 0-x-y 和 0-y都是最短路 那么从0-y的最短路数量就是两者相加 

最终返回0-n - 1的数量           f[0] = 1  自己到自己

```C++
typedef long long ll;
const int mod = 1e9 + 7;
class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) 
    {
        vector<vector<pair<int, int>>>g(n);
        for (auto &r: roads)
        {
            int x = r[0], y = r[1], z = r[2];
            g[x].emplace_back(y, z);
            g[y].emplace_back(x, z);
        }
		//用堆优化的dijkstra
        vector<ll>dis(n, LLONG_MAX);
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>>q;
        vector<ll>f(n);
        f[0] = 1;
        dis[0] = 0;
        q.emplace(0, 0);
        while (true)
        {
            auto [dx, x] = q.top();
            q.pop();

            if (x == n - 1)
                return f[n - 1];

            for (auto &[y, d]: g[x])
            {
                ll new_dis = dx + d;
                if (new_dis < dis[y])
                {
                    dis[y] = new_dis;
                    f[y] = f[x];
                    q.emplace(new_dis, y);
                }
                else if (new_dis == dis[y])
                {
                    f[y] = (f[y] + f[x]) % mod;
                }
            }
        }

    }
};
```

## [1261. 在受污染的二叉树中查找元素 - 力扣（LeetCode）](https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/submissions/511125292/)

* 3/12

<img src="../images/$%7Bfiilename%7D/image-20240313001702069.png" alt="image-20240313001702069" style="zoom:25%;" />

主要是检查的数据如何保存 

用一个全局的set来保存 方便后续查找 而不需要再写一个dfs

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
public:
set<int>s;
void dfs(TreeNode*root)
{
    if (root -> left != nullptr) 
    {
        root->left->val = root->val * 2 + 1;
        s.insert(root->left->val);
        dfs(root->left);
    }
    if (root -> right != nullptr)
    {
        root->right->val = root->val * 2 + 2;
        s.insert(root->right->val);
        dfs(root->right);
    }
}
    FindElements(TreeNode* root) 
    {
        if (root == nullptr)return ;
        root->val = 0;
        s.insert(0);
        dfs(root);
    }
    bool find(int target) 
    {
        return s.find(target) != s.end();
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
```

## [310. 最小高度树 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-height-trees/)

* 3/18

拓扑排序解法：因为要选出一个根 使得整棵树的高度最小 那就可以反向思考 从度为1的结点（最外面的一圈）出发 进行拓扑排序 向内BFS寻找 每次消除一层  根节点到这一层的每个点的距离都是相同的  最后消掉的一层就是可以作为根节点的一层 

tips ：map可以用来做邻接表！

```C++
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) 
    {
        if (n == 1)return {0};

        vector<int>degree(n);
        map<int, vector<int>>m;
        vector<int>res;
        for (auto x: edges)
        {
            degree[x[0]]++;
            degree[x[1]]++;
            m[x[0]].push_back(x[1]);
            m[x[1]].push_back(x[0]);
        }
        queue<int>q;
        // 度为一的结点入队列
        for (int i = 0; i < n; i++)
        {
            if(degree[i] == 1)
                q.push(i);
        }
        while (!q.empty())
        {
            res.clear();
            int sz = q.size();
            for (int i = 0; i < sz; i++)
            {
                int t = q.front();
                q.pop();
                res.push_back(t);
                degree[t]--;
                for (auto j: m[t])
                {
                    degree[j]--;
                    if(degree[j] == 1)
                        q.push(j);
                }
            }
        }
        return res;
    }
};
```

## [2642. 设计可以求最短路径的图类 - 力扣（LeetCode）](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/)

* 3/26

堆优化的dijkstra算法 注意用最小堆

```C++
typedef pair<int,int> PII;
class Graph {
public:
vector<vector<PII>> g;

int n;
    Graph(int m, vector<vector<int>>& edges) 
    {
        n = m;
        g.resize(n);
        for (auto &x: edges)
        {
            addEdge({x[0], x[1], x[2]});
        }
    }
    
    void addEdge(vector<int> edge) 
    {
        g[edge[0]].emplace_back(edge[1], edge[2]);
    }

    
    int shortestPath(int node1, int node2) 
    {
        vector<int>vis(n, 0), dis(n, 2e9);

        dis[node1] = 0;
        priority_queue<PII, vector<PII>, greater<>>q;
        q.push({0,node1});
        while (!q.empty())
        {
            auto [d, x] = q.top();
            q.pop();
            if (vis[x])continue;
            vis[x] = 1;
            for (auto &[y, w]: g[x])
            {
                if (d + w < dis[y])
                {
                    dis[y] = d + w;
                    q.push({dis[y], y});
                }
                
            }
        }

        return dis[node2] == 2e9 ? -1: dis[node2];
    }
};

/**
 * Your Graph object will be instantiated and called as such:
 * Graph* obj = new Graph(n, edges);
 * obj->addEdge(edge);
 * int param_2 = obj->shortestPath(node1,node2);
 */
```



# BFS/DFS

## [1096. 地牢大师 - AcWing题库](https://www.acwing.com/problem/content/1098/)

* 3/4

三维BFS 注意下标的对应关系

```C++
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
int l, r, c;
const int N = 110;
char g[N][N][N];
struct pos
{
    int x, y, z;
};
int step[N][N][N] = {0};
int dz[6] = {1, 0, -1, 0, 0, 0}, dy[6] = {0, 1, 0, -1, 0, 0}, dx[6] = {0, 0, 0, 0, 1, -1};

int bfs(int si, int sj, int sk)
{
    
    step[si][sj][sk] = 1;
    queue<pos>q;
    q.push({si, sj, sk});
    while (!q.empty())
    {
        pos t = q.front();
        q.pop();
        int x = t.x, y = t.y, z = t.z;
        for (int i = 0; i < 6; i++)
        {
            int nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];
            if (nx >= 0 && nx < l && ny >= 0 && ny < r && nz >= 0 && nz < c && g[nx][ny][nz] != '#' && step[nx][ny][nz] == 0)
            {
                step[nx][ny][nz] = step[x][y][z] + 1;
                if (g[nx][ny][nz] == 'E')return step[nx][ny][nz];
                q.push({nx, ny, nz});
            }
        }
    }
    return -1;
}
int main()
{
    while (1)
    {
        cin>>l>>r>>c;
        if (l == r && r == c && c == 0)break;
        memset(step, 0, sizeof(step));
        int si, sj, sk;
        for (int i = 0; i < l; i++)
            for (int j = 0; j < r; j++)
                for (int k = 0; k < c; k++)
                    {
                        cin>>g[i][j][k];
                        if (g[i][j][k] == 'S')
                            si = i, sj = j, sk = k;
                    }
        int res = bfs(si, sj, sk);
        
        if (res == -1)cout<<"Trapped!"<<endl;
        else printf("Escaped in %d minute(s).\n", res - 1);
    }
}
```

## [1233. 全球变暖 - AcWing题库](https://www.acwing.com/problem/content/1235/)

* 3/5

这题求的是 完全被淹没的岛屿的数量 可以先求所有的岛的数量 再求淹水后岛的数量 再相减

但是也可以直接求  如果一个岛屿被完全淹没了  说明他所有的陆地都与水相邻 **在dfs中判断是否有一块陆地不与水相连** 如果是 不会被淹 否则会

```C++
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1010;
int n;

char g[N][N];
int v[N][N];
int flag = 0;

int ans = 0;
int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
int vis[N][N];
void dfs(int x, int y)
{
    vis[x][y] = 1;
    if (g[x][y + 1] == '#' && g[x - 1][y] == '#' && g[x + 1][y] == '#' && g[x][y - 1] == '#')flag = 1;
    for (int i = 0; i < 4; i++)
    {
        int nx = dx[i] + x, ny = dy[i] + y;
        if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny] && g[nx][ny] == '#')
        {
            
            dfs(nx, ny);
        }
    }
}

int main()
{
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin>>g[i][j];
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (!vis[i][j] && g[i][j] == '#')
                {
                    flag = 0;
                    dfs(i, j);
                    if (flag == 0)ans ++;
                }
        }
    }
    cout<<ans;
}
```

## 1207. 大臣的旅费 - AcWing题库](https://www.acwing.com/problem/content/description/1209/)

* 3/8

求树的直径问题

要求相距最远的两个城市 也就是求树的直径 

先任取一点x 做dfs 求出离x最远的点y 再对y进行dfs所得到的离y最远的点maxu 这两点的连接就是树的直径

用dis记录任意点到i点的最远距离

复习了存图的方法和树的dfs的方法  dfs中需要添加father 防止回头

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n ;
int w[N] , e[N] , ne[N] , h[N] , idx ;
int maxu , maxd ;
int dis[N];
void add(int a , int b , int c )
{
    e[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;
}
void dfs(int u , int fa , int d)
{
    dis[u] = d;
    for(int i = h[u] ; i != -1 ; i = ne[i])
    {
        int j = e[i];
        if(j != fa)
            dfs(j,u,d + w[i]);
    }
}
int main()
{
    cin >> n ;
    memset(h,-1,sizeof h);
    for (int i = 0; i < n; i++)
    {
        int a , b , c ;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,-1,0);
    for (int i = 1 ; i <= n; i++)
    {
        if (dis[maxu] < dis[i]) 
        {   
            maxu = i;
            maxd = dis[maxu];
        }
    }
    
    dfs(maxu,-1,0);
    for (int i = 1 ; i <= n; i++)
    {
        if (dis[maxu] < dis[i]) 
        {   
            maxu = i;
            maxd = dis[maxu];
        }
    }
    cout << maxd * 10 + (maxd + 1ll) * maxd / 2 << endl ;
    return 0;
}

```

## [3067. 在带权树网络中统计可连接服务器对数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/)

* 3/2 

双周赛t3 枚举根DFS+乘法原理

由题意分析知道 要满足三个条件 

1不能用重复路径  那么枚举每一个根 如果两个数不在这个根的同一个子树上 那么就不会有重复路径

2 3  ac 和 bc路径和都能整除sig 这个可以在DFS的时候算出来

思路就是 枚举每个根的每条路径  dfs算路径和 如果能整除就加入ok数组中  最后把这个根的每条路径的ok数 两两相乘 即可得到答案

```C++
typedef pair<int, int> PII;
class Solution {
public:
    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges, int sig) 
    {
        int n = edges.size() + 1;
        vector<PII>g[1010];
        // 图论题常用的记录方式
        for (auto x: edges)
        {
            g[x[0]].push_back({x[1], x[2]});
            g[x[1]].push_back({x[0], x[2]});
        }
        vector<int>count(n);
        
        vector<int>ok(1010);
        int depth = 0;
        function<void(int, int, int, vector<int>&, int)> dfs = [&](int x, int fa, int i, vector<int>&ok, int d) ->void
        {
            if (d % sig == 0)
                ok[depth]++;
            for (auto p: g[x])
            {
                int y = p.first, w = p.second;
                if (y != fa)
                    dfs(y, x, i, ok, d + w);
            }
        };
        
        for (int i = 0; i < n; i++)
        {
            depth = 0;
            ok.clear();
            ok.resize(n);
            if (g[i].size() == 1)
            {
                count[i] = 0;
                continue;
            }
            for (auto p: g[i])
            {
                int y = p.first, w = p.second;
                dfs(y, i, i, ok, w);
                depth++;
            }
           
            long long ans = 0;
            for (int i = 0; i < depth; i++)
            {
                for (int j = i + 1; j < depth; j++)
                {
                    ans += ok[i] * ok[j];
                }
            }
            count[i] = ans;
        }
        return count;
    }
};
```

## [2386. 找出数组的第 K 大和 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-k-sum-of-an-array/)

* 3/9

sum是所有非负数之和 因为减去非负数和加上负数都是减去nums[i] 所以可以把负数转换成非负数 后面全部用减法 

要找出第k大的子序列 由于是子序列可以先排序 排完序之后再求第k小的子序列 用sum 减去这个子序列 就是第k大的子序列

用最小堆来生成所有子序列   以[1,2,3]为例

从[]开始

在 [][][] 末尾添加 111 得到 [1]。
在 [1] 末尾添加 222 得到 [1,2] 也可以把末尾的 111 替换成 222 得到 [2]
在 [2] 末尾添加 333 得到 [2,3] 也可以把末尾的 222 替换成 333 得到 [3]
在 [1,2] 末尾添加 333 得到 [1,2,3] 也可以把末尾的 222 替换成 333 得到 [1,3]

因为结合了最小堆 会自动排序 每次都取出当前最小的 然后由于数组也已经排序 每次取最小的 替换/加上nums[i] 就是由小到大的 

所以k次操作之后 最小的值就是 q.top()

```C++
typedef long long ll;

class Solution {
public:
    long long kSum(vector<int>& nums, int k) 
    {
        ll sum = 0L;
        for (auto &x: nums)
        {
            if (x >= 0)
                sum += x;
            else x = -x;
        }
        
        sort(nums.begin(), nums.end());
        priority_queue<pair<ll, int>,vector<pair<ll, int>>,greater<>>q;
        q.emplace(0, 0);
        while (--k)
        {
            auto [s, i] = q.top();
            q.pop();
            if (i < nums.size())
            {
                q.emplace(s + nums[i], i + 1);
                if (i)
                {
                    q.emplace(s + nums[i] - nums[i - 1], i + 1);
                }
            }
        }
        return sum - q.top().first;
    }
};
```



## [331. 验证二叉树的前序序列化 - 力扣（LeetCode）⁤](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)

* 3/31

栈+二叉树

遇到#结点直接放入 当累计两个的时候 就可以弹出#结点以及他的父节点 然后再放上一个#结点 表示这个结点已经到达空 接下来会访问右节点

最后 根节点左右都会是# 然后把根节点pop  如果最后剩下一个#说明是树的前序遍历

```c++
class Solution {
public:
    bool isValidSerialization(string preorder) 
    {
        vector<int>st;
        
        int n = preorder.size();

        for (int i = 0; i < n; i++)
        {
            int num = 0;
            while (i < n && preorder[i] != ',')
            {
                if (preorder[i] == '#')
                {
                    num = -1;
                    i++;
                    break;
                }
                num = num * 10 + preorder[i++] - '0';
            }
            cout<<"num"<<num<<endl;
            if (num >= 0)
                st.push_back(num);
            else
            {
                st.push_back(-1);
                while (st.size() >= 3 && st[st.size() - 1] == -1 && st[st.size() - 2] == -1 && st[st.size() - 3] != -1)
                {
                    st.pop_back();
                    st.pop_back();
                    st.pop_back();
                    st.push_back(-1);
                }
            }
        }
        if (st.size() == 1 && st[st.size() - 1] == -1)
        return true;
        return false;
    }
};
```



# 树状数组/线段树

## [3072. 将元素分配到两个数组中 II - 力扣（LeetCode）](https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/submissions/507364590/)

* 3/3

周赛t4 python的SortedList排序 可以在$O(logn)$完成 然后再加上二分查找的$O(logn)$ 可以在时间复杂度$O(nlogn)$内完成

因为数据范围为1e5 $O({n^2})$会超时 所以要用$O(nlogn)$的算法 当时最后想到了要多加两个数组 来记录有序的序列 再用二分 但是写C++的二分的时候好像出问题了 最后没写出来

用python自带的排序和二分库函数

```py
from sortedcontainers import SortedList
class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:

        def greatCount(arr, k):
            return len(arr) - arr.bisect_right(k)

        arr1, arr2 = SortedList([nums[0]]), SortedList([nums[1]])
        res1, res2 = [nums[0]], [nums[1]]
        for i in range(2, len(nums)):
            c1, c2 = greatCount(arr1, nums[i]), greatCount(arr2, nums[i])
            if c1 > c2 or (c1 == c2 and len(arr1) <= len(arr2)):
                arr1.add(nums[i])
                res1.append(nums[i])
            else:
                arr2.add(nums[i])
                res2.append(nums[i])
        return res1 + res2
```



树状数组板子

```C++
typedef long long ll;
class BiTree
{
    int MAXN;
    vector<int>tree;
    ll lowbit(ll x)
    {
        return x & (-x);
    }
public:
    BiTree(int _MAXN = 100010):MAXN(_MAXN)
    {
        tree.resize(MAXN);
    }
    void add(int index, int x)
    {
        for (int i = index; i < MAXN; i+=lowbit(i))
        {
            tree[i] += x;
        }
    }
    ll pre(int n)
    {
        ll sum = 0;
        for (int i = n; i; i -= lowbit(i))
        {
            sum += tree[i];
        }
        return sum;
    }
    // (l, r]
    ll pre(int l, int r)
    {
        return pre(r) - pre(l);
    }
};
```

## [307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/)

* 3/9

树状数组模板题 求不断修改数组的情况下的区间和 

主要是add函数 for循环结束条件是i < tree.size()

然后修改了数组元素 要把数组变为val 然后tree里面的值也相应地要修改  修改了**delta**

```C++
class NumArray {
private:
    vector<int>nums;
    vector<int>tree;
    int lowbit(int x)
    {
        return x & (-x);
    }
    int pre(int n)
    {
        int sum = 0;
        for (int i = n; i ; i -= lowbit(i))
        {
            sum += tree[i];
        }
        return sum;
    }
public:
    NumArray(vector<int>& nums):nums(nums.size()), tree(nums.size() + 1)
    {
        for (int i = 0; i < nums.size(); i++)
        {
            add(i, nums[i]);
        }
    }
    
    void add(int index, int val) 
    {
        int delta = val - nums[index];
        nums[index] = val;
        for (int i = index + 1; i < tree.size(); i += lowbit(i))
        {
            tree[i] += delta;
        }
    }
    
    int pre(int left, int right) 
    {
        return pre(right + 1) - pre(left);
    }
};

```



## [3072. 将元素分配到两个数组中 II - 力扣（LeetCode）](https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/)

离散化+树状数组

由于数的范围在1e9 太大了 数组开不下 所以要用离散化 为什么可以离散化  因为他只是为了比大小 那把数去重排序后映射到1~n的区间就行了  由于树状数组从1开始 建议映射也从1开始

用unordered_map把每个数映射



树状数组的部分 首先把板子打上

树状数组 存什么呢？ 别的题树状数组（如上题）可能是存前缀和 但是这个题目不一样 他主要是看前面有几个数比他大 我们又已经把数映射了 所以每次add的时候就加1表示index这个地方多了一个数 那么算出来的前缀和就是到1~n这个地方共有几个数 那就是比他小的数的个数  再用size减一下就得到比他大的数的个数

```C++
typedef long long ll;
class BiTree
{
    int MAXN;
    vector<int>tree;
    ll lowbit(ll x)
    {
        return x & (-x);
    }
public:
    BiTree(int _MAXN = 100010):MAXN(_MAXN)
    {
        tree.resize(MAXN);
    }
    void add(int index, int x)
    {
        for (int i = index; i < MAXN; i+=lowbit(i))
        {
            tree[i] += x;
        }
    }
    ll pre(int n)
    {
        ll sum = 0;
        for (int i = n; i; i -= lowbit(i))
        {
            sum += tree[i];
        }
        return sum;
    }
    // (l, r]
    ll pre(int l, int r)
    {
        return pre(r) - pre(l);
    }
};


class Solution {
public:
    vector<int> resultArray(vector<int>& nums) {
        unordered_map<int, int>mp;
        vector<int>tmp(nums);
        sort(tmp.begin(), tmp.end());
        tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());
        int m = tmp.size(), n = nums.size();
        for (int i = 0; i < m; i++)mp[tmp[i]] = i + 1;

        vector<int>a{nums[0]},b{nums[1]};
        BiTree t1(m + 1), t2(m + 1);
        t1.add(mp[nums[0]], 1);
        t2.add(mp[nums[1]], 1);

        for (int i = 2; i < n; i++)
        {
            int x = nums[i];
            int v = mp[nums[i]];
            int gc1 = a.size() - t1.pre(v);
            int gc2 = b.size() - t2.pre(v);

            if (gc1 > gc2 || (gc2 == gc1 && a.size() <= b.size()))
            {
                a.push_back(x);
                t1.add(v, 1);
            }
            else 
            {
                b.push_back(x);
                t2.add(v, 1);
            }
            
        }
        a.insert(a.end(), b.begin(), b.end());
        return a;
    }
};
```

## [1215. 小朋友排队 - AcWing题库](https://www.acwing.com/problem/content/1217/)

* 3/11

记录每个小朋友前面有多少个比他高的 后面有多少个比他矮的

树状数组里面存放数字出现的次数 而不是数字本身

```C++
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
typedef long long ll;
const int N = 100010;
ll nums[N], ret[N];

const int MAXN = 1000010;
ll tree[MAXN];
ll lowbit(ll x)
{
    return x & (-x);
}

void add(int index, int x)
{
    for (int i = index; i < MAXN; i+=lowbit(i))
    {
        tree[i] += x;
    }
}
ll query(int n)
{
    ll sum = 0;
    for (int i = n; i; i -= lowbit(i))
    {
        sum += tree[i];
    }
    return sum;
}


int main()
{
    int n;
    cin>>n;
    for (int i = 1; i <= n; i++)
    {
        cin>>nums[i];
        nums[i]++;
    }
    for (int i = 1; i <= n; i++)
    {
        add(nums[i], 1);
        ret[i] += (i - query(nums[i]));
    }
    ll ans = 0;
    memset(tree, 0, sizeof(tree));
    for (int i = n; i > 0; i--)
    {
        add(nums[i], 1);
        ret[i] += query(nums[i] - 1);
        
        ans += (ll)ret[i] * (ret[i] + 1) / 2;
    }
    cout<<ans;
    
}
```

## [797. 差分 - AcWing题库](https://www.acwing.com/problem/content/799/)

* 3/11

差分前缀和 用一个差分数组 在区间起点记录加数 在终点减去这个数 最后求前缀和 就可以把整个区间的数都加上 只用$O(n)$的时间  如果是每次都把整个区间直接加到数组上 就要$O(n^{2})$时间

```C++
#include <iostream>
using namespace std;
const int N = 100010;
int nums[N], diff[N];
int main()
{
    int n, m;
    cin>>n>>m;
    for (int i = 1; i <= n; i++)
    {
        cin>>nums[i];
    }

    for (int i = 1; i <= m; i++)
    {
        int l, r, c;
        cin>>l>>r>>c;
        diff[l] += c;
        diff[r + 1] -= c;
    }
    for (int i = 1; i <= n; i++)
    {
        diff[i] += diff[i - 1];
    }
    for (int i = 1; i <= n; i++)
    {
        cout<<nums[i] + diff[i]<<" ";
    }
}
```

## [798. 差分矩阵 - AcWing题库](https://www.acwing.com/problem/content/800/)

* 3/13

二维差分与一位差分不同 也需要前缀和 但是需要对原矩阵进行处理 求得原矩阵的差值矩阵 然后再用差分

```
diff[i][j] = nums[i][j] + nums[i - 1][j - 1] - nums[i - 1][j] - nums[i][j - 1];
是由
nums[i][j] = nums[i - 1][j - 1] - nums[i - 1][j] - nums[i][j - 1] + diff[i][j];得到的
```

然后还要注意差分数组加的地方 [x2 + 1] [y1]  [x1] [y2 + 1]  [x2 + 1] [y2 + 1]

```C++
#include <iostream>
using namespace std;
int n, m, q;
const int N = 1010;
int nums[N][N], diff[N][N], qzh[N][N];

int main()
{
    cin>>n>>m>>q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin>>nums[i][j];
            
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            diff[i][j] = nums[i][j] + nums[i - 1][j - 1] - nums[i - 1][j] - nums[i][j - 1];
            
    for (int i = 0; i < q; i++)
    {
        int x1, x2, y1, y2, c;
        cin>>x1>>y1>>x2>>y2>>c;
        diff[x1][y1]+=c;
        diff[x2 + 1][y2 + 1]+=c;
        diff[x2 + 1][y1] -= c;
        diff[x1][y2 + 1] -= c;
    }
    for(int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            diff[i][j] += -diff[i - 1][j - 1] + diff[i][j - 1] + diff[i - 1][j];
    for(int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cout<<diff[i][j]<<" ";
        }
        cout<<endl;
    }
}
```



# 位运算

## [2917. 找出数组中的 K-or 值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-k-or-of-an-array/)

* 3/6

简单模拟

<img src="../images/$%7Bfiilename%7D/image-20240306083318322.png" alt="image-20240306083318322" style="zoom:25%;" />

```C++
class Solution {
public:
    int findKOr(vector<int>& nums, int k) 
    {
        int cnt[33] = {0};
        for (int i = 0; i < 31; i++)
        {
            for (int x: nums)
            {
                if (x >> i & 1)cnt[i]++; 
            }
        }    
        int res = 0;
        for (int i = 0; i <= 32; i++)
        {
            if (cnt[i] >= k)res += 1 << i;
        }
        return res;
    }
};
```

## [5001. 异或和之和 - AcWing题库](https://www.acwing.com/problem/content/5004/)

* 3/16

直接暴力循环会超时（1e5数据 On2

贡献法 分别计算每一位的贡献 可以达到On 的复杂度

```txt
0        1 2 3 4 5
0000     0001 0010 0011 0100 0101  nums
0000     0001 0011 0000 0100 0001  qzh

看第0位的贡献 
对于R为2 只有2个 1~2和2~2 分别为 
0~2 qzh[2] ^ qzh[0] = 1 （相当于1~2）
1~2 qzh[2] ^ qzh[1] = 0 
对于R为3  第0位
0~3 qzh[3] ^ qzh[0] = 0   0^0=0
1~3 qzh[3] ^ qzh[1] = 1   0^1=1
2~3 qzh[3] ^ qzh[2] = 1   0^1=1
**那我要看第0位的贡献 不就是第0位是0   前面有2个1  贡献就是2 << 0**
qzh[b] ^ qzh[a] 表示 a到b区间的异或 所以只需要b这一位 分别和前面的 0~b-1分别异或一次就可以得到区间异或 
但是这样还是n^2复杂度
观察可以发现 现在只需要计算第j位这一位与前面每个数的异或 那 如果这一位是1 这一位前面有多少个0 那就是多少 所以可以在n的复杂度解决  只要记录每一位是0 还是1
就是把前面的0~3 1~3 2~3的计算 直接换成当前位0/1前面有多少个1/0 
```



```C++
#include <iostream>
using namespace std;
typedef long long ll;
ll nums[100010], qzh[100010];
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &nums[i]);
    
    for (int i = 1; i <= n; i++)
        qzh[i] = qzh[i - 1] ^ nums[i];
    
    ll res = 0;
    
    for (int j = 0; j < 21; j++)
    {
        int c0 = 1, c1 = 0; // j这一位0和1的个数
        ll now = 0;
        for (int i = 1; i <= n; i++)
        {
            if (qzh[i] >> j & 1)
            {
                c1++;
                now += c0;
            }
            else 
            {
                c0++;
                now += c1;
            }
        }
        res += now * (1 << j);
    }
    cout<<res;
}
```

# 二分图

结点由两个集合组成 两个集合内部没有边的图

也就是 存在一种方案 将结点划分成满足以上两个性质的集合

就是集合中的点都染成黑白 可以发现二分图中每条边都链接一个白点一个黑点

二分图不存在长为奇数的环（每条边都从一个集合走到另一个集合 偶数次才能回到同一个集合）

判断二分图：遍历：发现奇环就不是 否则是

## 二分图最大匹配[P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3386)

* 3/20

匈牙利算法（ntr算法哈哈

就是每次先配对 然后下一个人来配对的时候 遍历她所有可以访问的点 如果没被访问过并且没有配对 就配对 如果有配对了 就看看上一个人能不能让出来 

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/
int n, m, e;
const int N = 100010;
int vis[N], match[N];
struct Edge
{
    int v, ne;
} edge[N];
int head[N], idx;
void add(int a, int b)
{
    edge[++idx] = {b, head[a]};
    head[a] = idx;
}

bool dfs(int u)
{
    for (int i = head[u]; i; i = edge[i].ne)
    {
        int v = edge[i].v;
        if (vis[v])
            continue;
        vis[v] = 1;
        if (!match[v] || dfs(match[v]))
        {
            match[v] = u;
            return 1;
        }
    }
    return 0;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;

    cin >> n >> m >> e;
    for (int i = 0; i < e; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(vis, 0, sizeof(vis));
        if (dfs(i))
            ans++;
    }
    cout << ans;

    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

## [xmuoj | AI2024春《算法设计与分析》第三次上机](https://www.xmuoj.com/contest/221/problem/6)

* 3/20

棋盘覆盖问题  可以当作二分图来写：

这样思考 每个块都把他当作是两个点合在一起 假设中间是一个白点 （2，2）那么（1，2）（2，1）（3，2）（2，3）都是黑点 然后建边 这样就类似与上面的二分图了  对白点或者黑点进行二分图查找就可以找到最大匹配（一个匹配就相当于是放了一块木板）

难点在于想到用二分图的做法来做这个题 还有怎样去建边 

```C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using PII = pair<int, int>;

#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define endl '\n'

#define debug(x)                          \
    {                                     \
        cerr << #x << " = " << x << endl; \
    }
#define debugfull(x)                                                      \
    {                                                                     \
        cerr << #x << " = " << x << " (line " << __LINE__ << ")" << endl; \
    }

/*-------------------------------------------*/

const int N = 110;//N开太大会超时
int b[N][N], vis[N * N], match[N * N];// N*N才能过 不然数组太小
vector<int> e[N * N];
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
int ans = 0;
// 匈牙利算法
bool bfs(int u)
{
    for (auto v : e[u])
    {
        if (vis[v])
            continue;
        vis[v] = 1;
        if (!match[v] || bfs(match[v]))
        {
            match[v] = u;
            return 1;
        }
    }
    return 0;
}
int main()
{
    // clock_t st = clock(), ed;
    ios::sync_with_stdio(0);
    cin.tie(0);
    // cout << setprecision(15) << fixed;
    int n, t;
    cin >> n >> t;

    for (int i = 0; i < t; i++)
    {
        int x, y;
        cin >> x >> y;
        b[x][y] = 1;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (!b[i][j])
            {
                for (int k = 0; k < 4; k++)
                {
                    int x = dx[k] + i, y = dy[k] + j;
                    if (x >= 1 && x <= n && y >= 1 && y <= n && !b[x][y])
                    {
                        // 建边
                        e[i * n + j].push_back(x * n + y);
                        e[x * n + y].push_back(i * n + j);
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if ((i ^ j) & 1) // 枚举奇数结点
                continue;
            memset(vis, 0, sizeof(vis));//清空
            if (bfs(i * n + j))
                ans++;
        }
    }
    cout << ans;
    // ed = clock();
    // double endtime = (double)(ed - st) / CLOCKS_PER_SEC;
    // cout << "Total time: " << endtime << endl;
    return 0;
}

```

# 动态查询

## [100258. 最高频率的 ID - 力扣（LeetCode）](https://leetcode.cn/problems/most-frequent-ids/submissions/515906308/)

* 3/24

<img src="../images/$%7Bfiilename%7D/image-20240325082019545.png" alt="image-20240325082019545" style="zoom:25%;" />

一个感觉见过很多次的题。。周赛的时候大脑宕机了(哭

### 方法一 两个map

题目要求每次操作之后 最高的频率是多少  需要有一个map记录每个id的频率 还需要有一个 map 记录这个频率有多少个数  因为不同id的频率可能是一样的 但是答案只需要最大的频率 所以记录一下每个频率有几个数 最后返回最大频率即可  对id增加的时候直接加 减的时候只需要看是否减为0  减为0后需要让这个频率的数量减少 如果当前频率的数为0 要记得删除 否则map还会保存这个频率只不过数量为0 就无法直接取到最大的频率

关键是不需要求最大的id是哪个 只需要看最大频率 记录频率个数即可

```C++
typedef long long ll;
class Solution {
public:
    vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& fr) 
    {
        map<int, ll>cnt; // 记录这个id的频率
        map<ll, int>num; // 记录这个频率有多少个id
       for (int i = 0; i < nums.size(); i++)
       {
           int x = nums[i], f = fr[i];
           // 减去旧的频率
           if (cnt.count(x)) // map的count只有0 或1两种 其实就是检查x是否是cnt的键 
           {
               if (--num[cnt[x]] == 0)num.erase(cnt[x]);
           }
           // 添加新的频率
           cnt[x] += f;
           num[cnt[x]]++;
           if (num.empty())
           {
               ans[i] = 0;
           }
           else
               ans[i] = num.rbegin() -> first;// 通过rbegin取得最大值
       }
    }
};
```

### 方法二 懒删除堆

每次都直接插入堆中 用map记录当前每个id的频率

在取出最大频率的时候 开始判断 如果id的频率和map中相同 那说明这就是最大频率

否则就说明这是id变化之后 没有删掉的 现在把他删掉 直到频率、id 和map中匹配  就是真实的最大频率

```C++
![屏幕截图 2024-03-25 092730](../../../../Pictures/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-25%20092730.png)typedef long long ll;
class Solution {
public:
    vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& fr) 
    {
        priority_queue<pair<ll, int>>q; // <频率, id>
        map<int, ll>mp;
        int n = nums.size();
        vector<ll>ans(n);
        for (int i = 0; i < n; i++)
        {
            int x = nums[i], f = fr[i];
            mp[x] += f;
            q.push({mp[x], x});
            while (1)
            {
                auto t = q.top();
                if (mp[t.second] != t.first)
                {
                    q.pop();
                }
                else
                    break;
            }
            ans[i] = q.top().first;
        }
        return ans;
    }
};
```

<img src="../images/$%7Bfiilename%7D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-25%20092730.png" style="zoom:25%;" />

懒删除堆的效率更高

# 前缀树（Trie）

## [208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/)

* 3/25

<img src="../images/$%7Bfiilename%7D/image-20240326075542565.png" alt="image-20240326075542565" style="zoom:25%;" />

前缀树 多叉树 一般将单词等拆分成根到叶子的形式，每个结点一个字母。

通常用于判断前后缀

最重要的是Trie*next[26] 每个结点都有一个Trie *的数组分别表示26个字母（视情况而定）

然后就是isEnd 这个也是视题目而定 判断单词前缀的题 一般就是用isEnd判断这个单词是否结束 结束了的话就标记 后面一题 不需要判断是否结束 只需要判断是不是后缀 所以不用isEnd 改用别的参数

其余函数 整体的操作流程跟**链表**差不多（其实就是用链表实现的..）

插入函数 不断下移到字母对应位置 如果为空就创建结点 否则就继续往下 直到单词结束 打上End标记

查找函数 记得要用end判断

判前缀和查找一样  不过判断前缀不需要用End

```C++
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }
    
    void insert(string word) 
    {
        Trie* node = this;
        for (char c: word)
        {
            if (node->next[c - 'a'] == NULL)
                node->next[c - 'a'] = new Trie();
            
            node = node->next[c - 'a'];
        }
        node -> isEnd = true;
    }
    
    bool search(string word) 
    {
        Trie* node = this;
        for (char c: word)
        {
            node = node->next[c - 'a'];
            if (node == NULL)
                return false;
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) 
    {
        Trie* node = this;
        for (char c: prefix)
        {
            node = node->next[c - 'a'];
            if (node == NULL)
                return false;
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

 ## [3093. 最长公共后缀查询 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-suffix-queries/submissions/516608165/) 

* 3/25

周赛t4 没来得及写(被动态找点整破防了

<img src="../images/$%7Bfiilename%7D/image-20240326080744268.png" alt="image-20240326080744268" style="zoom:25%;" />

（不写成类的形式 更像是链表操作了）

题目要求在WordsContainer数组里面 找wordsQuery里每个单词的最长公共后缀 然后返回这个WordsContainer里面的拥有最长公共后缀的单词的下标

因为单词非常多 而每个wordsQuery又是在WordsContainer的全部里面去找  所以可以先用Trie树预处理所有的WordsContainer里面的单词（Trie树中倒着存WordsContainer的每个单词 因为要后缀）

然后再拿wordsQuery的每个单词去Trie树中匹配后缀

匹配原则：1最长公共后缀 2后缀长度相同优先单词长度短的 3前两个都相同 优先先出现的

这个判后缀就不需要isEnd标记了   但是可以存放这个后缀的答案（也就是这个后缀的长度和如果这个后缀匹配了 应该返回的下标）

比如abcd 和 bcd   Trie树为

```
 NULL (1,3)
   \
    d (1,3)
     \
      c (1,3)
       \
        b (1,3)
         \
          a (0,4)
```

这样假设cd 去匹配 后缀 最终会在c处返回 (1,3)  1就是bcd的下标1  3就是bcd的长度3  

如果是abcd去匹配后缀 就会在a处返回(0,4) 因为abcd后缀更长

根节点为NULL也需要存 因为题目中包含了空结点 

存下标 便于访问答案  存长度便于更新下标

```C++
struct Node
{
    Node* son[26]{};
    int min_l = INT_MAX, i;
};
class Solution {
public:
    vector<int> stringIndices(vector<string>& wordsContainer, vector<string>& wordsQuery) 
    {
        Node*root = new Node();
        // 存入全部的后缀
        for (int idx = 0; idx < wordsContainer.size(); idx++)
        {
            auto &s = wordsContainer[idx];
            int l = s.size();
            auto cur = root;
            // 空结点（根节点）的更新操作
            if (l < cur->min_l)
            {
                cur->min_l = l;
                cur->i = idx;
            }
            // 每个单词的后缀
            for (int i = s.size() - 1; i >= 0; i--)
            {
                int b = s[i] - 'a';
                if (cur->son[b] == nullptr)
                    cur->son[b] = new Node();
                cur = cur->son[b];
                if (l < cur->min_l)
                {
                    cur->min_l = l;
                    cur->i = idx;
                }
            }
        }

        vector<int>ans;
        // 开始cha
        for (auto &s: wordsQuery)
        {
            auto cur = root;
            for (int i = s.size() - 1; i >= 0; i--)
            {
                if (cur->son[s[i] - 'a'] == nullptr)break;
                cur = cur->son[s[i] - 'a'];
            }
            ans.push_back(cur->i);
        }
        return ans;
    }
};
```



