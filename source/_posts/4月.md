---
title: 4月
date: 2024-04-01 07:32:45
tags: 课程报告
---

# DP

## [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

* 4/1

<img src="../images/$%7Bfiilename%7D/image-20240401074028052.png" alt="image-20240401074028052" style="zoom:25%;" />

最大子段和 动态规划写法状态表示到i为止最大的字段和

 如果和左边拼起来 那就是f[i] = f[i - 1] + nums[i]

如果不和左边拼起来 那就是 f[i] = nums[i]

状态计算：f[i] = max(f[i - 1], 0) + nums[i]

发现只用到了f[i] 和f[i - 1] 可以进行压缩   只用f2来表示

用res 记录最大值

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        int f2 = 0;
        f2 = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++)
        {
            f2 = max(f2, 0) + nums[i];
            res = max(res, f2);
        }
        return res;
    }
};
```

## [2606. 找到最大开销的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-substring-with-maximum-cost/)

* 4/1

<img src="../images/$%7Bfiilename%7D/image-20240401075827824.png" alt="image-20240401075827824" style="zoom:25%;" />

同样是最大子段和  但是要注意和上题的区别 这题中可以一个都不取 也就是字符为空  当第一个为负数的时候 直接取空（0）是更大的  所以res初始化为max(0, nums[0])
```C++
class Solution {
public:
    int maximumCostSubstring(string s, string chars, vector<int>& vals) {
        vector<int>mp(26, 10000);
        for (int i = 0; i < chars.size(); i++)
        {
            mp[chars[i] - 'a'] = vals[i];
        }
        for (int i = 0; i < 26; i++)
        {
            if (mp[i] == 10000)
                mp[i] = i + 1;
        }
        int f2 = mp[s[0] - 'a'];
        int res = max(0, mp[s[0] - 'a']);
        for (int i = 1; i < s.size(); i++)
        {
            f2 = max(f2, 0) + mp[s[i] - 'a'];
            res = max(res, f2);
        }
        return res;
    }
};
```

## [1749. 任意子数组和的绝对值的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/submissions/518892405/)

* 4/1

<img src="../images/$%7Bfiilename%7D/image-20240401082601673.png" alt="image-20240401082601673" style="zoom:25%;" />

前面求最大子段和的时候用f2 表示到nums[i]为止的最大字段和

对应于fmax = max(fmax, 0) + x

但是这题可以取绝对值 因此可以再加一个fmin = min(fmin, 0) + x  取尽量小的数   因为越小的数 取反就越大

```C++
class Solution {
public:
    int maxAbsoluteSum(vector<int>& nums) 
    {
        int fmax = 0, res = 0, fmin = 0;
        for (auto x: nums)
        {
            fmax = max(fmax, 0) + x;
            fmin = min(fmin, 0) + x;
            res = max(res, max(fmax, -fmin));
        }
        return res;
    }
};
```

## [1191. K 次串联后最大子数组之和 - 力扣（LeetCode）](https://leetcode.cn/problems/k-concatenation-maximum-sum/submissions/518906997/)

* 4/1

<img src="../images/$%7Bfiilename%7D/image-20240401093700946.png" alt="image-20240401093700946" style="zoom:25%;" />

连续k段arr 的最大子段和 

分情况讨论  如果只有一段 直接算最大子段和

如果有两段就算两段的最大字段和

如果大于两段 算两段的最大子段和 将这两段视为左右两段 加上max（中间所有的和， 0）就是一个连续的子数组

<img src="../images/$%7Bfiilename%7D/37cb29513e8f1293b1296b6a8ad01136.jpg" alt="37cb29513e8f1293b1296b6a8ad01136" style="zoom:25%;" />

因为中间要是大于0的话 一定要取  可以变得更大 而两边的可以由中间接上

假设是-1 6 -4 -1 6 -4这样的 最大的就是中间连起来（上图2）  sum > 0 

假设是 sum <= 0的才会出现图1 这时候就不用连起来了 直接取最大值

```C++
const int mod = 1e9+7;
class Solution {
public:
    int kConcatenationMaxSum(vector<int>& arr, int k) 
    {
        int n = arr.size();
        long long sum = 0;
        
        long long f2 = 0, res = 0;
        for (int i= 0; i < n; i++)
        {
            sum = (arr[i] + sum) % mod;
        }
        for (int e = 0; e < min(k, 2); e++)
        for (int i = 0; i < arr.size(); i++)
        {
            f2 = (max(f2, (long long)0) + arr[i]);
            res = (max(res, f2));
        }
        if (k < 2)return res % mod;
        return (res % mod + max((long long)sum * (k - 2) % mod, (long long)0)) % mod;
    }
};
```

## [918. 环形子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

* 4/1

<img src="../images/$%7Bfiilename%7D/image-20240401130808479.png" alt="image-20240401130808479" style="zoom:25%;" />

**环形** 可以将数组*2之后求 但是太麻烦 需要判断最多只能取n个数

仔细思考发现只有两种情况 

1. 不利用到环形 本身直接取就可以取到最大  就是普通的最大子列和问题

2. 利用到环形 这时候就会选取数组前后端的数字 空出中间的  那么就可以计算中间的最小值 再用总和减去

上面两种情况分别如下图所示

<img src="../images/$%7Bfiilename%7D/image-20240401130901616.png" alt="image-20240401130901616" style="zoom:25%;" />

分析完后其实跟前两题 求绝对值的有点类似 

注意由于数组不能为空 当resx小于等于0的时候 此时sum - resn肯定为0（resn是尽量小 resx小于0 那么说明整个数组全为负数 resx没有可以选的  resn此时全部选上了）那么最后就会返回0

但是其实答案是resx   这种全负数的情况就没有分取不取环形 只需要找最大的负数  就相当于普通最大子列和 直接返回resx

```C++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) 
    {
        int minn = 0, maxn = 0, resx = nums[0], resn = nums[0], sum = 0;
        
        int n = nums.size();
        for (int i = 0; i < n; i++)
        {
            maxn = max(maxn, 0) + nums[i];
            minn = min(minn, 0) + nums[i];
            resx = max(resx, maxn);
            resn = min(resn, minn);
            sum += nums[i];
        }
        
        return resx > 0 ? max(resx, sum - resn): resx;
    }
};
```

## [2321. 拼接数组的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-score-of-spliced-array/)

* 4/2

<img src="../images/$%7Bfiilename%7D/image-20240402224213797.png" alt="image-20240402224213797" style="zoom:25%;" />

直接求的话很难算 可以转换成最大字段和来求解  令diff[i] = nums1[i] - nums2[i]  求出的最大子段和就是交换的区间 此时求出来的是1比2大的 把大的全部换到2中去 

diff[i] = nums2[i] - nums1[i] 求出的是2比1大的 把大的全部换到1中 然后二者取较大值

```C++
class Solution {
public:
    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) 
    {
        
        int n = nums1.size();
        vector<int>diff(n + 1, 0);
        int sum1 = 0,  sum2 = 0;
        for (int i = 0; i < n; i++)
        {
            diff[i] = nums1[i] - nums2[i];
            sum1 += nums1[i];
            sum2 += nums2[i];
        }
        int res = 0, f = 0, ans = 0;
        for (int i = 0; i < n; i++)
        {
            f = max(f + diff[i], 0) ;
            res = max(res, f);
        }
        int res1 = 0;
        f = 0;
        for (int i = 0; i < n; i++)
        {
            f = max(f - diff[i], 0);
            res1 = max(res1, f);
        }   
        ans = max(sum1 + res1, sum2 + res);
        return ans;
    }
};
```

## [363. 矩形区域不超过 K 的最大数值和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/)

* 4/2

### 前缀和+暴力

（前缀和数组->动态规划）

四重循环暴力求解 枚举每个矩形的解

```C++
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) 
    {
        int row = matrix.size(), col = matrix[0].size();
        vector<vector<int>>qzh(row + 2, vector<int>(col + 2, 0));
        
        for (int i = 1; i <= row; i++)
        {
            for (int j = 1; j <= col; j++)
            {
                qzh[i][j] = qzh[i][j - 1] + qzh[i - 1][j] - qzh[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        int res = -1e9;
        for (int i = 1; i <= row; i++)
        {
            for (int j = 1; j <= col; j++)
            {
                for (int ii = 0; ii < i; ii++)
                {
                    for (int jj = 0; jj < j; jj++)
                    {
                        
                        int u = qzh[i][j] - qzh[i][jj] - qzh[ii][j] + qzh[ii][jj];
                        cout<<u<<endl;
                        if (u <= k)
                        res = max(u, res);
                    }
                }
            }

        }
        // for (int i = 1; i <= row; i++)
        // {
        //     for (int j = 1; j <= col; j++)
        //     {
        //         cout<<qzh[i][j]<<endl;
        //     }
        // }
        return res;
    }
};
```

苦鲁西~四重暴力会超时

### 枚举左右边界+最大子列和

可以转为三重循环  枚举左 右边界 然后求每一行的前缀和   再求每一个前缀和的 **最大子列和** 就是最大的矩阵<img src="../images/$%7Bfiilename%7D/13fb1fcc1203665fe1c4ccc6221cef7e01921fe614b0e6b22a81a70eca4e79aa-image.png" alt="image.png" style="zoom: 80%;" />

把他转换成 每个最大子列和（左边的） 就是右边的一个黄色区域 将$O(n^2)$的复杂度的枚举转为$2O(n)$的前缀和+最大子列和

```C++
class Solution {
public:
    int dpmax(vector<int>rowsum, int k)
    {
        int maxn = rowsum[0], f = rowsum[0];
        for (int i = 1; i < rowsum.size(); i++)
        {
            f = max(f, 0) + rowsum[i];
            maxn = max(maxn, f);
        }
        if (maxn <= k)
            return maxn;

        maxn = INT_MIN;
        for (int i = 0; i < rowsum.size(); i++)
        {
            int sum = 0;
            for (int j = i; j < rowsum.size(); j++)
            {
                sum += rowsum[j];
                if (sum > maxn && sum <= k)
                    maxn = sum;
                if (maxn == k)return k;
            }
        }
        return maxn;
    }
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) 
    {
        int row = matrix.size(), col = matrix[0].size();
        
        int res = INT_MIN;
        
        for (int l = 0; l < col; l++) 
        {
            vector<int> rowsum(row, 0);
            for (int r = l; r < col; r++) 
            {
                for (int i = 0; i < row; i++)
                {
                    rowsum[i] += matrix[i][r];
                }
                res = max(res, dpmax(rowsum, k)); 
            }
        }
        return res;
    }
};
```

### 二分+前缀和

枚举上下边界和左边界  通过二分快速找有边界

```C++

    int m = mat.size(), n = mat[0].size();
        vector<vector<int>> sum(m + 1,vector<int>(n + 1,0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }

        int ans = INT_MIN;
        for (int top = 1; top <= m; top++)
        {
            for (int bot = top; bot <= m; bot++)
            {
                set<int>st;
                st.insert(0);
                for (int r = 1; r <= n; r++)
                {
                    int right = sum[bot][r] - sum[top - 1][r];
                    auto left = st.lower_bound(right - k);
                    if (left != st.end())
                    {
                        int cur = right - *left;
                        ans = max(ans, cur);
                    }
                    st.insert(right);
                }
            }
        }
        return ans;
```



## [894. 所有可能的真二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/all-possible-full-binary-trees/?envType=daily-question&envId=2024-04-02)

* 4/2

<img src="../images/$%7Bfiilename%7D/image-20240402092713887.png" alt="image-20240402092713887" style="zoom:25%;" />

对于二叉树相关的题目 一般就是先求左右的信息然后再合并

```C++
class Solution {
public:

    vector<TreeNode*> allPossibleFBT(int n) {
        return process(n);
    }
    vector<TreeNode*> process(int n)
    {
        vector<TreeNode*> res = ....;
        ....//根节点和基本操作
        vector<TreeNode*>lefttree = process();
        vector<TreeNode*>righttree = process();
        ....//合并
        return res;
    }
};
```

很容易想到n == 0  n == 1 n为偶数的时候 三个特判条件

要求按所有可能的结果返回  肯定需要遍历 

结点总数为n 可以枚举左子树的结点数 左子树结点数为i的时候 右子树结点数为n - i - 1   (其实就是左右节点再接上一个结点数较少的数)

```C++
for (int i = 1; i < n; i+=2) // 结点数至少为1 每次加两个
{
    lefttree = process(i);
    righttree = process(n - i - 1);
    // 得到了左右子树 现在需要合并 也就是把左右子树加到根节点 然后储存
    for (TreeNode* leftnode:leftsub)
            {
                for (TreeNode* rightnode:rightsub)
                {
                    TreeNode* root = new TreeNode(0, leftnode, rightnode);
                    ret.push_back(root);
                }
            }
}
```

关键在于对题目的分析 想到枚举左子树的节点数目

 ```C++
 /**
  * Definition for a binary tree node.
  * struct TreeNode {
  *     int val;
  *     TreeNode *left;
  *     TreeNode *right;
  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
  * };
  */
 class Solution {
 public:
 
     vector<TreeNode*> allPossibleFBT(int n) {
         vector<TreeNode*>ret;
 
         if (n % 2 == 0)return {};
         if (n == 1)return {new TreeNode(0)};
 
         for (int i = 1; i < n; i += 2)
         {
             vector<TreeNode*>leftsub = allPossibleFBT(i);
             vector<TreeNode*>rightsub = allPossibleFBT(n - i - 1);
             for (TreeNode* leftnode:leftsub)
             {
                 for (TreeNode* rightnode:rightsub)
                 {
                     TreeNode* root = new TreeNode(0, leftnode, rightnode);
                     ret.push_back(root);
                 }
             }
         }
         return ret;
 
     }
 };
 ```

## [xmuoj | 矩阵链乘法问题（附加）](https://www.xmuoj.com/contest/226/problem/6)

* 4/3

矩阵连乘问题 

状态表示为dp[i] [j]表示从i到j 的最少次数 

状态计算为在i j 中间选出一个分割点k 使dp[i] [j] = min(dp[i] [j], dp[i] [k] + dp[k + 1] [j] + nums[i - 1] * nums[k] * nums[j])

也就是i到k最少的次数 加上k + 1到j最少的次数 再加上两个合并到一起所需要的次数

需要注意 由于求得是最小值 如果k直接i到j循环取min的话 最后取出来全是0  所以得先给dp[i] [j]赋值为k = i的情况 然后枚举i + 1到j

枚举**区间长度**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
int nums[N];
int main()
{
	int n;
	cin >> n;
	int a, b;
	
	for (int i = 0; i < n; i++)
	{
		cin >> a >> b;
		nums[i] = a;
	}
	nums[n] = b;
	for (len = 2; len <= n; len++)
    {
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            dp[i][j] = dp[i][i] + dp[i + 1][j] + nums[i - 1] * nums[i] * nums[j];
            for (int k = i + 1; k < j; k++)
            {
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j]);
            }
        }
    }
    cout<<dp[1][n];
}
```

接下来再看如何构造最优子序列

添加一个s[i]数组 每次记录分割的地方

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
const int N = 1010;
int dp[N][N], s[N][N];
int nums[N];

void traceback(int i, int j)
{
    if (i == j)
    {
        cout<<"A"<<i;
    }
    cout<<"(";
    traceback(i, s[i][j]);
    traceback(s[i][j] + 1, j);
    cout<<")";
}

int main()
{
	int n;
	cin >> n;
	int a, b;
	
	for (int i = 0; i < n; i++)
	{
		cin >> a >> b;
		nums[i] = a;
	}
	nums[n] = b;
	for (len = 2; len <= n; len++)
    {
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            dp[i][j] = dp[i][i] + dp[i + 1][j] + nums[i - 1] * nums[i] * nums[j];
            s[i][j] = i;
            for (int k = i + 1; k < j; k++)
            {
                int t = dp[i][k] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j];
                if (t < dp[i][j])
                {
                    dp[i][j] = t;
                    s[i][j] = k;
                }
            }
        }
    }
    cout<<dp[1][n];
}
```



## [xmuoj | 元素共鸣：唤醒神之眼](https://www.xmuoj.com/contest/226/problem/1)

* 4/3

相邻的两座石柱合并  其实跟书上的矩阵连乘问题很类似 （如上题）

同样是在相邻的两个之间进行操作 并且每次操作都是寻找最小的划分区间 然后再计算合并所需的值（一般根据区间决定）

代码几乎一样  只不过在合并相加的时候有区别

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>

using namespace std;
const int N = 100010;
int nums[N], qzh[N];
int dp[500][500];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> nums[i];
	}
	qzh[0] = 0;
	for (int i = 1; i <= n; i++)
	{
		qzh[i] = qzh[i - 1] + nums[i];
	}

	for (int len = 2; len <= n; len++)
	{
		for (int i = 1; i + len - 1 <= n; i++) 
		{
			int j = i + len - 1;
          dp[i][j] = dp[i][i] + dp[i + 1][j] + qzh[j] - qzh[i - 1];
			for (int k = i + 1; k < j; k++)
			{
				dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j]  + qzh[j] - qzh[i - 1]);
			}
		}
	}
	cout << dp[1][n];
}
```

## [xmuoj | 元素共鸣：深层次的唤醒](https://www.xmuoj.com/contest/226/problem/2)

[1000. 合并石头的最低成本 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)

* 4/3

是上一题的变式 由于要合并k个区间 首先要判断什么区间不能合并  n堆变成1堆  减少了 n - 1堆  每次合并都减少k - 1堆 所以n - 1需要是k - 1的倍数 

状态表示 dp[i] [j] [k] 表示i到j分成k堆的最小消耗

状态计算 仍然是分成两份 一份1 一份k - 1 dp[i] [j] [k] = dp[i] [p] [1] + dp[p + 1] [j] [k - 1]  然后剩下的需要枚举的就是p了 枚举p就很简单 注意每次增加k - 1

然后在计算、合并完 得到dp[i] [j] [k] 的时候 再将他合并（到k个了 可以合并）dp[i] [j] [1]就为dp[i] [j] [k]加上消耗sum[j] - sum[i - 1]（这个消耗是每次合并产生的）

注意初始化 其实也可以直接用memset将dp全部变为1e9 然后dp[i] [i] [1] i i本来就是一堆 不需要代价 所以为0

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>
using namespace std;
const int N = 100010;
int nums[N], sum[N];
int dp[500][500][50];

int main()
{
	int n, k;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i];
	}
	// dp i j i到j的最小  状态计算-
	cin >> k;

	if ((n - 1) % (k - 1) != 0)
	{
		cout << -1;
		return 0;
	}

    for (int i = 1; i <= n; i++)sum[i] = sum[i - 1] + nums[i - 1];
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j <= n; j++)
        {
            for (int m = 2; m <= k; m++)
                dp[i][j][m] = 1e9;
        }
        dp[i][i][1] = 0;
    }
    for (int len = 2; len <= n; len++)
    {
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            for (int m = 2; m <= k; m++)
            {
                for (int p = i; p < j; p += k - 1)
                {
                    dp[i][j][m] = min(dp[i][j][m], dp[i][p][1] + dp[p + 1][j][m - 1]);
                }
            }
            dp[i][j][1] = dp[i][j][k] + sum[j] - sum[i - 1];
        }
    }
    cout << dp[1][n][1] << endl;
}
```



## [xmuoj | 提瓦特庆典策划](https://www.xmuoj.com/contest/226/problem/3)

* 4/3

经典树上DP 没有上司的舞会

首先要考虑数据的存储  每个人的情绪用nums[i]来存 上司和下属的关系可以用树的方式来存 用邻接表会简单很多（邻接矩阵也可以 但是浪费空间）

之后就是动态规划  树上dp用递归+备忘录的方法会更好写 也更符合直觉 dp[i] [0] 表示i不来的情况下 最大情绪  dp[i] [1]表示i来的情况下 最大情绪  

状态计算 dp[i] [0] += max(dp[son] [0], dp[son] [1])

dp[i] [1] += dp[son] [0] 这里的son表示i的下属 注意当i不来的时候 下属并不是一定都来  也有不来会更好的情况 所以用max

由状态转移方程可以很容易看出来 想算上司的 就要先把下属的算出来  所以递归要放在前面 先把下属的状态算好

然后要找出最大的上司 从他开始计算

```C++
#include <iostream>
#include <vector>
using namespace std;
const int N = 6005;
int n, nums[N], v[N], boss;
vector<int>son[N];
void dpmax(int x)
{
    // 初始化
    dp[x][0] = 0;
    dp[x][1] = nums[x];
    // 算当前这个人去/不去的最大价值
    for (auto y:son[x])
    {
        // 先算下属
        dpmax(y);
        dp[x][0] += max(dp[y][0], dp[y][1]);
        dp[x][1] += dp[y][0]; // x去y只能不去
    }
}
int main()
{
    cin>>n;
    for (int i = 1; i <= n; i++)
        cin>>nums[i];
    for (int i = 0; i < n; i++)
    {
        int p, q;
        cin>>p>>q;
        son[q].push_back(p);
        v[p] = 1;
    }
    for (int i = 1; i <= n; i++)
    {
        if (v[i] == 0)
        {
            boss = i;
            break;
        }
    }
    dpmax(boss);
    cout<<max(dp[boss][0], dp[boss][1]);
}
```

## [xmuoj | 装配线调度问题（附加）⁤](https://www.xmuoj.com/contest/226/problem/4)

* 4/3

一开始看到题目这么长有点懵 但是其实题意很简单 就是一个物品 从0走到n 每一步都可以选择在当前线装配 或者换一条线装配（换线需要时间）然后加上进厂出厂时间 得到最短出场时间

本来想用dp[i]表示到i的最短时间 但是这样状态没办法转移 不知道当前在哪条线上 所以可以多加一个维度 记录每一条线上到i的最短时间  

状态表示为dp[i] [0] dp[i] [1] (提交的时候写的是dp1[i]和dp2[i])

状态计算  到i的最短时间为 两条线的 i-1的时候的最短时间加上转移/不转移所需要的时间

```c++
#include <iostream>
using namespace std;
const int N = 10100;
int nums[3][N];
int change[3][N];
int e1, e2, x1, x2;
int dp1[N], dp2[N];
int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> nums[1][i];
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> nums[2][i];
	}
	for (int i = 1; i < n; i++)
	{
		cin >> change[1][i];
	}
	for (int i = 1; i < n; i++)
	{
		cin >> change[2][i];
	}
	cin >> e1 >> e2 >> x1 >> x2;
    
    dp1[0] = e1 + nums[1][1];
    dp2[0] = e2 + nums[2][1];
    
    for (int i = 2; i <= n; i++)
    {
        dp1[i] = min(dp1[i - 1] + nums[1][i], dp1[i - 1] + nums[1][i] + change[2][i - 1]);
        dp2[i] = min(dp2[i - 1] + nums[2][i], dp2[i - 1] + nums[2][i] + change[1][i - 1]);
    }
    cout<<min(dp1[n] + x1, dp2[n] + x2);
}
```

接下来构造最优子结构

添加 s1[N] s2[N]数组记录最优解的时候 第i - 1个配件是在第一条线还是第二条线 s记录最后那条线出来

```C++
#include <iostream>
using namespace std;
const int N = 10100;
int nums[3][N];
int change[3][N];
int e1, e2, x1, x2;
int dp1[N], dp2[N];
int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> nums[1][i];
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> nums[2][i];
	}
	for (int i = 1; i < n; i++)
	{
		cin >> change[1][i];
	}
	for (int i = 1; i < n; i++)
	{
		cin >> change[2][i];
	}
	cin >> e1 >> e2 >> x1 >> x2;
    
    dp1[0] = e1 + nums[1][1];
    dp2[0] = e2 + nums[2][1];
    
    for (int i = 2; i <= n; i++)
    {
        if (dp1[i - 1] + nums[1][i] < dp1[i - 1] + nums[1][i] + change[2][i - 1])
        {
            dp1[i] = dp1[i - 1] + nums[1][i];
            s1[i] = 1;
        }
        else
        {
            dp1[i] = dp1[i - 1] + nums[1][i] + change[2][i - 1];
            s1[i] = 2;
        }
        if (dp2[i - 1] + nums[2][i] < dp2[i - 1] + nums[2][i] + change[1][i - 1])
        {
            dp2[i] = dp2[i - 1] + nums[2][i];
            s2[i] = 2;
        }
        else
        {
            dp2[i] = dp2[i - 1] + nums[2][i] + change[1][i - 1];
            s2[i] = 1;
        }
    }
    int ans = 0, s = 0;
    if (dp1[n] + x1 < dp2[n] + x2)
    {
        ans = dp1[n] + x1;
        l = 1;
    }
    else 
    {
        ans = dp2[n] + x2;
        l = 2;
    }
	
    // traceback
    int i = l;
    cout<<"station"<<n<<" line"<<i<<endl;
    for (int j = n; j >= 2; j--)
    {
        if (i == 1)
            i = s1[j];
        else i = s2[j];
        cout<<"station"<<j - 1<<" line"<<i<<endl;// 第j个步骤 在i流水线
    }
}
```

## [LCR 166. 珠宝的最高价值 - 力扣（LeetCode）](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/)

从左上到右下，二维DP。

状态表示：dp[i] [j] 到第i行第j列的最高价值。

状态计算：dp[i] [j] = max(dp[i -1] [j], dp[i] [j - 1]) + frame[i] [j]表示从较大的位置转移

```C++
class Solution {
public:
    int jewelleryValue(vector<vector<int>>& frame) 
    {
        int n = frame.size();
        int m = frame[0].size();
        vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + frame[i - 1][j - 1];
            }
        }   
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            cout<<dp[i][j]<<" ";
            cout<<endl;
        }
        return dp[n][m];
    }
};
```

## [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/description/)

同样是网格图DP，相当于二维的爬楼梯

跟其他题不一样的在于初始化，第一行和第一列都是1，只有一种走法。

状态表示：dp[i] [j] 表示到第i行第j列的走法

状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。 

```C++
class Solution {
public:
    int uniquePaths(int m, int n) 
    {
        vector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++)dp[i][1] = 1;
        for (int j = 1; j <= n; j++)dp[1][j] = 1;
        for (int i = 2; i <= m; i++)
        {
            for (int j = 2; j <= n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        // debug
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
                cout<<dp[i][j]<<" ";
            cout<<endl;
        }
        return dp[m][n];
    }
};
```

## [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/)

上题的变式，图中增加了障碍物，只有在没有遇到障碍物的时候才可以转移，障碍物位设置为0，表示到这里有0种走法。

状态表示：dp[i] [j] 表示到第i行第j列的走法

状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
    {
        int row = obstacleGrid.size();
        int col = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1)return 0;
        
        vector<vector<int>>dp(row + 1, vector<int>(col + 1, 0));

        dp[1][1] = 1;
        for (int i = 1; i <= row; i++)
        {
            for (int j = 1; j <= col; j++)
            {
                if (i == 1 && j == 1)continue;
                if (obstacleGrid[i - 1][j - 1] == 0)
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                else dp[i][j] = 0;
            }
        }
        for (int i = 1; i <= row; i++)
        {
            for (int j = 1; j <= col; j++)
            {
                cout<<dp[i][j]<<" ";
            }
            cout<<endl;
        }
        return dp[row][col];
    }
};
```

 ## [120. 三角形最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/triangle/submissions/523893909/)

### 二维DP

状态表示：dp[i] [j] 到第i行第j列的最小路径和。

状态计算：每一步只能从上一行的j或j - 1列移动到当前行的第j列。

要特殊处理第0列（因为第0列只能由上一行的第0列转移）和第i列（第i列只能由i - 1列转移）

```C++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) 
    {
        int n = triangle.size();

        vector<vector<int>>dp(n + 1, vector<int>(n + 1, 0));
        dp[0][0] = triangle[0][0];
        for (int i = 1; i < n; i++)
        {
            dp[i][0] = triangle[i][0] + dp[i - 1][0];
            for (int j = 1; j < i; j++)
            {
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];
            }
            dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];
        }
        int ans = 2e9;
        for (int i = 0; i < n; i++)
        {
            ans = min(ans, dp[n - 1][i]);
        }
        return ans;
    }
};
```

### 一维DP

注意到只用了i和i - 1两行，可以进行状态压缩。直接更新到原来的位置上

```C++
vector<int>f(n + 1, 0);
        f[0] = triangle[0][0];
        for (int i = 1; i < n; i++)
        {
            f[i] = f[i - 1] + triangle[i][i];
            for (int j = i - 1; j > 0; j--)
            {
                f[j] = min(f[j], f[j - 1]) + triangle[i][j];
            }
            f[0] = f[0] + triangle[i][0];
        }
        int ans = 2e9;
        for (int i = 0; i < n; i++)
        {
            ans = min(ans, f[i]);
        }
        return ans;
```

## [312. 戳气球 - 力扣（LeetCode）](https://leetcode.cn/problems/burst-balloons/)

状态表示：dp[i] [j] 表示从i到j的最大数量

状态计算：枚举k（每一个断点）求出在每个k断开的sum。dp[i] [j] = max(sum)

初始化：注意两边的为1，所以一开始要初始化为1。

```C++
typedef long long ll;
class Solution {
public:
    int maxCoins(vector<int>& nums) 
    {
        int n = nums.size();
        vector<vector<ll>> dp(n + 2, vector<ll>(n + 2, 0));
        ll val[n + 2];
        val[0] = val[n + 1] = 1;
        for (int i = 1; i <= n; i++)
        {
            val[i] = nums[i - 1];
        }
        for (int i = n - 1; i >= 0; i--)
        {
            for (int j = i + 2; j <= n + 1; j++)
            {
                for (int k = i + 1; k < j; k++)
                {
                    ll sum = dp[i][k] + dp[k][j];
                    sum += val[i] * val[j] * val[k];
                    dp[i][j] = max(dp[i][j], sum);
                }
            }
        }
        return dp[0][n + 1];
    }
};
```

## [377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/)

还是爬楼梯问题，target为最终楼梯层数，dp[i] 表示到i有多少种走法

每次可以走nums[k]步

```py
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        """
        状态表示：dp[i] 1~i有多少种
        状态计算：dp[i - 1] = dp
        """


        # @cache
        # def dfs(i):
        #     if i == 0:
        #         return 1
        #     return sum(dfs(i - x) for x in nums if x <= i)
        # return dfs(target)
        
        n = len(nums)
        dp = [1] + [0] * target
        # for i in range(1, target + 1):    
        #     dp[i] += sum(dp[i - x] for x in nums if x <= i)

        for i in range(1, target + 1):
            for x in nums:
                if x <= i:
                    dp[i] += dp[i - x]
        return dp[target]
```

## 

# 图

## [2192. 有向无环图中一个节点的所有祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/submissions/520849062/?envType=daily-question&envId=2024-04-04)

* 4/4

<img src="../images/$%7Bfiilename%7D/image-20240407164600674.png" alt="image-20240407164600674" style="zoom:25%;" />

计算有向无环图的所有祖先 首先先用邻接矩阵存图 

然后用dfs的方法求每个点的祖先

### 反向遍历

存反图 循环到这个结点的时候 就反向往上走 直到根节点 记录下每次走的结点 加入数组中

```C++
vector<vector<int>>g(n);
        for (auto &e:edges)
        {
            g[e[1]].push_back(e[0]);
        }
        vector<vector<int>>ans(n);
        vector<int>vis(n);
        function<void(int)> dfs = [&](int x) {
            vis[x] = true; // 避免重复访问
            for (int y : g[x]) {
                if (!vis[y]) {
                    dfs(y); // 只递归没有访问过的点
                }
            }
        };

        for(int i = 0; i < n; i++)
        {
            ranges::fill(vis, 0);
            dfs(i);
            vis[i] = 0;
            for (int j = 0; j < n; j++)
            {
                if (vis[j])
                    ans[i].push_back(j);
            }
        }
        return ans;
```

### 正向遍历

存正图 但是遍历方式改变 不是对每个结点先找到他的所有祖先 而是对每个结点作为根 找他的孩子 然后在孩子数组中存入根

```C++
vector<vector<int>>g(n);

        for (auto &e: edges)
        {
            g[e[0]].push_back(e[1]);
        }   
        vector<vector<int>>ans(n);
        vector<int>vis(n, -1);
        int start;
        function<void(int)> dfs = [&](int x)
        {
            vis[x] = start;
            for (int y:g[x])
            {
                if (vis[y] != start)
                {
                    ans[y].push_back(start);
                    dfs(y);
                }
            }
        };

        for (start = 0; start < n; start++) {
            dfs(start); // 从 start 开始 DFS
        }

        return ans;
```

## [1026. 节点与其祖先之间的最大差值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/submissions/520874666/?envType=daily-question&envId=2024-04-05)

* 4/5

<img src="../images/$%7Bfiilename%7D/image-20240407170407950.png" alt="image-20240407170407950" style="zoom:25%;" />

遍历整棵树 在每个结点记录到当前节点为止最大和最小值

（回溯的思想）

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int ans = 0;
void dfs(TreeNode*root, int minn, int maxn)
{
    if (root == nullptr)return;
    ans = max(ans, abs(minn - root->val));
    ans = max(ans, abs(maxn - root->val));
    if (root->left)dfs(root->left, min(root->left->val, minn), max(root->left->val, maxn));
    if (root->right)dfs(root->right, min(root->right->val, minn), max(root->right->val, maxn));
}
    int maxAncestorDiff(TreeNode* root) 
    {
        dfs(root, root->val, root->val);
        return ans;

    }
};
```

## [1483. 树节点的第 K 个祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/submissions/520993127/?envType=daily-question&envId=2024-04-06)、

* 4/6

<img src="../images/$%7Bfiilename%7D/image-20240407172214527.png" alt="image-20240407172214527" style="zoom:25%;" />

直接暴力求解很简单 但是会超时 由于需要多次访问祖先  可以用倍增的思想 每次访问第1 2 4 8 ... $2^n$的祖先

用二维数组pa存每个结点x的祖先 pa[0] [0] 表示0的第1个祖先 pa[0] [1]表示0的第2个祖先（父节点的父节点）

pa[x] [0]=parent[x]父节点

pa[x] [1] = pa[pa[x] [0]] [0]爷爷节点

pa[x] [i + 1] = pa[pa[x] [i]] [i]表示x的第$2^i$个祖先结点  如果不够的话会直接存成根节点（因为最上面的祖先肯定存的是根）

注意循环初始化外层是i内层是x 因为必须先把所有第i层的x更新完 才能更新第i + 1层的 （i + 1层有用到i的 如果顺序反了可能有些没更新到就被使用了

```C++
class TreeAncestor {
public:
vector<vector<int>>pa;
    TreeAncestor(int n, vector<int>& parent) 
    {
        int m = 32;
        pa.resize(n, vector<int>(m, -1));
        for (int i = 0; i < n; i++)
            pa[i][0] = parent[i];
        for (int i = 0; i < 31; i++)
        {
            for (int x = 0; x < n; x++)
            {
                int p = pa[x][i]; 
                if (p != -1)
                {
                    pa[x][i + 1] = pa[p][i];
                }
            }
        }
    }
    
    int getKthAncestor(int node, int k) 
    {
        int m = 32;
        for (int i = 0; i < m; i++)
        {
            if ((k >> i) & 1)
            {
                node = pa[node][i];
                if (node < 0)break;
            }
        }
        return node;   
    }
};

/**
 * Your TreeAncestor object will be instantiated and called as such:
 * TreeAncestor* obj = new TreeAncestor(n, parent);
 * int param_1 = obj->getKthAncestor(node,k);
 */
```



## [1600. 王位继承顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/throne-inheritance/submissions/520803923/)

* 4/7

王位继承制 皇上-嫡长子-嫡长孙...这一脉亖绝了轮到次长子一脉

要记录的东西比较多 可以用map<string, vector<string\>>来记录每个人的儿子 用set来记录死亡的人

最后get的时候  用dfs 深搜  按每一脉的人来搜索 如果死了就不用记录

<img src="../images/$%7Bfiilename%7D/image-20240407164502464.png" alt="image-20240407164502464" style="zoom:25%;" />

## [924. 尽量减少恶意软件的传播 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-malware-spread/)

要读懂题意，假设以一个连通图中有两个以上的原始病毒，那么删除其中一个是**毫无作用**的，因此这个题就是要找**只有一个**原始病毒的最大连通图。

关键在于这么判断这个连通图中有多少原始病毒。

将node_id初始化为-1，第一次遇到原始病毒的时候，就更新为x，表示待删去的原始病毒。但是如果第二次再遇到了病毒，那么就要将这个结点置为-2，表示这个连通图不可能减少感染次数了。同时再dfs中记录连通图的大小。

最后如果node_id >= 0 并且size > max_size 或者size == max_size 但是下标较小（node_id < ans）就更新ans

```C++
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {   
        // 如果一个连通块有多个感染节点 去掉了跟没去掉一样
        // 找只有一个感染结点的连通块 最大连通数量

        int n = graph.size();
        set<int>st(initial.begin(), initial.end());
        vector<int>vis(n);

        sort(initial.begin(), initial.end());
        int ans = initial[0];
        int size = 0, node_id = 0;
        function<void(int)>dfs = [&](int x)
        {
            vis[x] = 1;
            size++;
            if (node_id != -2 && st.contains(x))
            {
                node_id = node_id == -1 ? x : -2;
            }
            for (int y = 0; y < n; y++)
            {
                if (graph[x][y] && !vis[y])
                {
                    dfs(y);
                }
            }
        };

        int max_size = 0;
        for (int x: initial)
        {
            if (vis[x])continue;

            node_id = -1;
            size = 0;
            dfs(x);
            if (node_id >= 0 && (size > max_size || size == max_size && node_id < ans))
            {
                ans = node_id;
                max_size = size;
            }
        }
        return ans;
    }
};
```



# 贪心

## [xmuoj | 蒙德冒险者的游戏](https://www.xmuoj.com/contest/229/problem/2)

显然可以发现 承受能力强的需要放下面 重量大的需要放下面 但是这里有两个条件 应该按什么标准来放呢  可以假设最有序列为$y_1y_2y_3...y_n$贪心所得的序列为$x_1x_2x_3...x_n$ 假设$x_k$与$x_i$交换可以得到更优的序列

```txt
ans1 = w1+w2...wk+..wn - si
ans2 = w1+w2...wi+..wn - sk
假设ans2 < ans1 则 wi-sk<wk-si即wi + si < wk + sk 而ans2更优说明wk+sk大的应该放下面
所以按w+s的和排序
```

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
typedef long long ll;
struct Man
{
	ll w, s, a;
}nums[N];
int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> nums[i].w >> nums[i].s;
		nums[i].a = nums[i].w + nums[i].s;
	}
	sort(nums, nums + n, [&](Man a, Man b) {
		if (a.a != b.a)return a.a <= b.a;
		return a.s <= b.s;
		});
	ll sum = 0;
	ll ans = -1e18;
	for (int i = 0; i < n; i++)
	{
		ans = max(ans, sum - nums[i].s);
		sum += nums[i].w;
	}

	
	cout << ans;
}
```



## [xmuoj | 宝藏探索](https://www.xmuoj.com/contest/229/problem/3)

贪心 关键是怎么贪，题目长条件多 要慢慢分析

贪心思路**优先选择鱼最多的湖** 关键是过去每个湖又需要时间 而且只能单向地走

但是可以换种思考方式  每次选择鱼最多的湖 比如先选了1 2 2 3 3 1 1 4  就可以认为是在1停留了3次 其实根往返是差不多的

然后就是过湖的时间 可以枚举每次走几个湖直接把过的时间算上  然后剩下的就是纯钓鱼的时间 然后在当前能去的几个湖里找最多的钓 然后这个湖被钓过了就递减一次 然后再循环找最大的...直到钓鱼时间耗尽 记录记录最大钓鱼数以及每个湖停留的时间 最后输出

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1000;
int main()
{
    int res[100][1000] = { 0 };
    int k = 0;
    int anss[100] = { 0 };
    int nu[100] = { 0 };
    while (1)
    {
        int n, h;
        cin >> n;
        if (n == 0)
            break;
        nu[k] = n;
        cin >> h;
        h *= 12;
        
        
        int f[1000] = { 0 };
        int d[1000] = { 0 };
        int t[1000] = { 0 };

        for (int i = 1; i <= n; i++)
            cin >> f[i];
        for (int i = 1; i <= n; i++)
            cin >> d[i];
        t[1] = 0;
        for (int i = 2; i <= n; i++)
            cin >> t[i];
        for (int i = 2; i <= n; i++)
            t[i] += t[i - 1];

        int maxpool = 0, maxfishtime = 0, maxfish = 0, ans = 0;
        int tempfish[N];
        for (int i = 1; i <= n; i++)
        {
            if (h > t[i])
            {
                int rec[1000] = { 0 };
                maxfishtime = h - t[i];
                for (int j = 1; j <= i; j++)
                {
                    tempfish[j] = f[j];
                }
                int nowpoolmax = 0;
                while (maxfishtime > 0)
                {
                    maxfish = -1e9;
                    maxpool = 0;
                    for (int k = 1; k <= i; k++)
                    {
                        if (maxfish < tempfish[k])
                        {
                            maxpool = k;
                            maxfish = tempfish[k];
                        }
                    }
                   
                    nowpoolmax += maxfish;
                    rec[maxpool]++;
                    if (tempfish[maxpool] > d[maxpool])
                        tempfish[maxpool] -= d[maxpool];
                    else
                        tempfish[maxpool] = 0;

                    maxfishtime--;
                }
                if (nowpoolmax > ans)
                {
                    ans = nowpoolmax;
                    for (int i = 1; i <= n; i++)
                        res[k][i] = rec[i];
                }
                anss[k] = ans;
            }
            else
                break;
        }
        k++;
    }
    for (int j = 0; j < k; j++)
    {
        for (int i = 1; i <= nu[j]; i++)
        {
          if(i != nu[j])
            cout << res[j][i] * 5 << " ";
          else cout<<res[j][i] * 5;
        }
        cout << endl;
        printf("%d\n", anss[j]);
        if (j != k - 1)cout << endl;
    }
}
```

## [1702. 修改后的最大二进制字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-string-after-change/?envType=daily-question&envId=2024-04-10)

* 4/10

<img src="../images/$%7Bfiilename%7D/image-20240411135815782.png" alt="image-20240411135815782" style="zoom:25%;" />

00->10  10->01要使最后的结果最大 就需要尽可能地将前面放上1 尽可能去除0 

从左往右 前面如果有1 就不用动了 当出现第一个0的时候 往后找 如果后面全是0 就全部变成10 比如0000->1110

如果后面有1 那就把1换到最右边 把0换到中间 这必然是可行的 比如101010011 把10换成01之后 1就可以再和后面的0结合成10 再换成01 因此可以把所有的0聚到中间 再使用00换成10 这样 最终**最多**只会剩下一个0就是中间所有0的最后一个位置

因此可以直接构造出最后的字符串 

```C++
		int n = binary.size();
        int i = binary.find('0');
        if (i == string::npos)
            return binary;

        int zeros = count(binary.begin(), binary.end(), '0');
        string ans(n,'1');
        ans[i + zeros - 1] = '0';
        return ans;
    
```

## [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)

### 动态规划

状态表示：dp[i] 表示1~i的最长上升子序列

状态计算：if(nums[i] > nums[j])dp[i] = max(dp[i], dp[j] + 1)

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        // int n = nums.size();
        // vector<int>dp(n);
        // for (int i = 0; i < n; i++)
        // {
        //     dp[i] = 1;
        //     for (int j = 0; j < i; j++)
        //     {
        //         if (nums[i] > nums[j])
        //             dp[i] = max(dp[i], dp[j] + 1);
        //     }
        // }
        // int ans = 1;
        // for (int i = 0; i < n; i++)
        // {
        //     ans = max(ans, dp[i]);
        // }
        // return ans;

        vector<int>g;
        for (auto x: nums)
        {
            auto it = lower_bound(g.begin(), g.end(), x);
            if (it == g.end())
                g.push_back(x);
            else
                *it = x;

        }
        return g.size();
    }
};
```

### 贪心

最长上升子序列，那就找尽可能小的数，排在后面，这样的话就可以排更多的数，就更长。所以用二分法找大于当前最后一个数的最小数lower_bound



# 滑动窗口

## [2009. 使数组连续的最少操作数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/submissions/521981730/?envType=daily-question&envId=2024-04-08)

* 4/9

<img src="../images/$%7Bfiilename%7D/image-20240411135914967.png" alt="image-20240411135914967" style="zoom:25%;" />

给定一个数组 求将这个数组变为连续的最小操作数 

正难则反 可以先求出最大连续的子数组 然后再用n减去 就是最小操作数

注意 这里的**最大连续**不是1 2 3 4这样连续 (因为1 3 4 5只需要修改1个数 关键是看修改次数少的 中间空一些也可以)而是求出来 当前这个a~b区间内 在这个区间内的有多少个数 可以用滑动窗口来处理

窗口大小为n    左端点为nums[left] 因此最大的数就是nums[left] + n - 1 将nums[i]与其比较 如果合适就加入窗口 每次滑动记录最大值

注意 可能出现重复的数字 因此需要去重

```C++
class Solution {
public:
    int minOperations(vector<int>& nums) 
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int left = 0, ans = 0;
        int m = unique(nums.begin(), nums.end()) - nums.begin();
        for (int i = 0; i < m; i++)
        {
            while (nums[left] < nums[i] - n + 1)
            {
                left++;
            }
            ans = max(ans, i - left + 1);
        }
        return n - ans;
    }
};
```

## [1052. 爱生气的书店老板 - 力扣（LeetCode）](https://leetcode.cn/problems/grumpy-bookstore-owner/)

让最多顾客感到满意 也就是让最少的顾客不满意 不满意的人数本来是固定的 现在老板控制了自己的情绪 

  其实就是求 最大子段和 使得这一段中 人最多 那就是减少不满意的人最多
    用滑动窗口 

答案为 减少不满意的人数+原来就满意的人数 

```py
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
       

        sump = 0
        for i, (c, x) in enumerate(zip(customers, grumpy)):
            if x == 1:
                grumpy[i] = c
            else:
                sump += c
        
        maxp = win = sum(grumpy[:minutes])
        
        for i in range(minutes, len(grumpy)):
            win = win + grumpy[i] - grumpy[i - minutes]
            maxp = max(maxp, win)
        
        return sump + maxp

```



# 哈希

## [2924. 找到冠军 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-champion-ii/description/?envType=daily-question&envId=2024-04-13)

图论题  但是可以用哈希过  冠军就是没有被打败过的队伍

```C++
class Solution {
public:
    int findChampion(int n, vector<vector<int>>& edges) 
    {
        vector<int>ans(n, 0);
        for (auto e: edges)
        {
            ans[e[1]] = 1;
        }
        int res = -1;
…        return res;
    }
};
```

# 分治

## [169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/)

区间的众数一定是左半区间的众数并且也是右半区间的众数。

每次选出左半区间的众数，和右半区间的众数 如果相同就直接返回。

```C++
class Solution {
public:

    int count_in_range(vector<int>&nums, int target, int l, int r)
    {
        int count = 0;
        for (int i = l; i <= r; i++)
            if (nums[i] == target)
                count++;
        return count;
    }

    int majority_element_rec(vector<int>&nums, int l, int r)
    {
        if (l == r)return nums[l];

        int mid = l + r >> 1;
        int left_majority = majority_element_rec(nums, l, mid);
        int right_majority = majority_element_rec(nums, mid + 1, r);

        if (count_in_range(nums, left_majority, l, r) > (r - l + 1) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, l, r) > (r - l + 1) / 2)
            return right_majority;
        
        return -1;
    }

    int majorityElement(vector<int>& nums)
    {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
```

