

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Brtulien">
  <meta name="keywords" content="blog">
  
    <meta name="description" content="DP53. 最大子数组和 - 力扣（LeetCode） 4&#x2F;1    最大子段和 动态规划写法状态表示到i为止最大的字段和  如果和左边拼起来 那就是f[i] &#x3D; f[i - 1] + nums[i] 如果不和左边拼起来 那就是 f[i] &#x3D; nums[i] 状态计算：f[i] &#x3D; max(f[i - 1], 0) + nums[i] 发现只用到了f[i]">
<meta property="og:type" content="article">
<meta property="og:title" content="4月">
<meta property="og:url" content="https://brtulien.github.io/2024/03/31/4%E6%9C%88/index.html">
<meta property="og:site_name" content="Brtulien">
<meta property="og:description" content="DP53. 最大子数组和 - 力扣（LeetCode） 4&#x2F;1    最大子段和 动态规划写法状态表示到i为止最大的字段和  如果和左边拼起来 那就是f[i] &#x3D; f[i - 1] + nums[i] 如果不和左边拼起来 那就是 f[i] &#x3D; nums[i] 状态计算：f[i] &#x3D; max(f[i - 1], 0) + nums[i] 发现只用到了f[i]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401074028052.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401075827824.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401082601673.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401093700946.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/37cb29513e8f1293b1296b6a8ad01136.jpg">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401130808479.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401130901616.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240402224213797.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/13fb1fcc1203665fe1c4ccc6221cef7e01921fe614b0e6b22a81a70eca4e79aa-image.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240402092713887.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240407164600674.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240407170407950.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240407172214527.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240407164502464.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240411135815782.png">
<meta property="og:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240411135914967.png">
<meta property="article:published_time" content="2024-03-31T23:32:45.000Z">
<meta property="article:modified_time" content="2024-06-21T06:12:27.118Z">
<meta property="article:author" content="Brtulien">
<meta property="article:tag" content="课程报告">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://brtulien.github.io/2024/03/31/images/$%7Bfiilename%7D/image-20240401074028052.png">
  
  
  
  <title>4月 - Brtulien</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"brtulien.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="4月"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Brtulien
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-01 07:32" pubdate>
          2024年4月1日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          248 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">4月</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="53-最大子数组和-力扣（LeetCode）"><a href="#53-最大子数组和-力扣（LeetCode）" class="headerlink" title="53. 最大子数组和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;1</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240401074028052.png" srcset="/img/loading.gif" lazyload alt="image-20240401074028052" style="zoom:25%;" />

<p>最大子段和 动态规划写法状态表示到i为止最大的字段和</p>
<p> 如果和左边拼起来 那就是f[i] &#x3D; f[i - 1] + nums[i]</p>
<p>如果不和左边拼起来 那就是 f[i] &#x3D; nums[i]</p>
<p>状态计算：f[i] &#x3D; max(f[i - 1], 0) + nums[i]</p>
<p>发现只用到了f[i] 和f[i - 1] 可以进行压缩   只用f2来表示</p>
<p>用res 记录最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> f2 = <span class="hljs-number">0</span>;<br>        f2 = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = <span class="hljs-built_in">max</span>(f2, <span class="hljs-number">0</span>) + nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, f2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2606-找到最大开销的子字符串-力扣（LeetCode）"><a href="#2606-找到最大开销的子字符串-力扣（LeetCode）" class="headerlink" title="2606. 找到最大开销的子字符串 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">2606. 找到最大开销的子字符串 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;1</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240401075827824.png" srcset="/img/loading.gif" lazyload alt="image-20240401075827824" style="zoom:25%;" />

<p>同样是最大子段和  但是要注意和上题的区别 这题中可以一个都不取 也就是字符为空  当第一个为负数的时候 直接取空（0）是更大的  所以res初始化为max(0, nums[0])</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumCostSubstring</span><span class="hljs-params">(string s, string chars, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vals)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">mp</span>(<span class="hljs-number">26</span>, <span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            mp[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = vals[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">10000</span>)<br>                mp[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> f2 = mp[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, mp[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = <span class="hljs-built_in">max</span>(f2, <span class="hljs-number">0</span>) + mp[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            res = <span class="hljs-built_in">max</span>(res, f2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1749-任意子数组和的绝对值的最大值-力扣（LeetCode）"><a href="#1749-任意子数组和的绝对值的最大值-力扣（LeetCode）" class="headerlink" title="1749. 任意子数组和的绝对值的最大值 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/submissions/518892405/">1749. 任意子数组和的绝对值的最大值 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;1</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240401082601673.png" srcset="/img/loading.gif" lazyload alt="image-20240401082601673" style="zoom:25%;" />

<p>前面求最大子段和的时候用f2 表示到nums[i]为止的最大字段和</p>
<p>对应于fmax &#x3D; max(fmax, 0) + x</p>
<p>但是这题可以取绝对值 因此可以再加一个fmin &#x3D; min(fmin, 0) + x  取尽量小的数   因为越小的数 取反就越大</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAbsoluteSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> fmax = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, fmin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>        &#123;<br>            fmax = <span class="hljs-built_in">max</span>(fmax, <span class="hljs-number">0</span>) + x;<br>            fmin = <span class="hljs-built_in">min</span>(fmin, <span class="hljs-number">0</span>) + x;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(fmax, -fmin));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1191-K-次串联后最大子数组之和-力扣（LeetCode）"><a href="#1191-K-次串联后最大子数组之和-力扣（LeetCode）" class="headerlink" title="1191. K 次串联后最大子数组之和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-concatenation-maximum-sum/submissions/518906997/">1191. K 次串联后最大子数组之和 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;1</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240401093700946.png" srcset="/img/loading.gif" lazyload alt="image-20240401093700946" style="zoom:25%;" />

<p>连续k段arr 的最大子段和 </p>
<p>分情况讨论  如果只有一段 直接算最大子段和</p>
<p>如果有两段就算两段的最大字段和</p>
<p>如果大于两段 算两段的最大子段和 将这两段视为左右两段 加上max（中间所有的和， 0）就是一个连续的子数组</p>
<img src="../images/$%7Bfiilename%7D/37cb29513e8f1293b1296b6a8ad01136.jpg" srcset="/img/loading.gif" lazyload alt="37cb29513e8f1293b1296b6a8ad01136" style="zoom:25%;" />

<p>因为中间要是大于0的话 一定要取  可以变得更大 而两边的可以由中间接上</p>
<p>假设是-1 6 -4 -1 6 -4这样的 最大的就是中间连起来（上图2）  sum &gt; 0 </p>
<p>假设是 sum &lt;&#x3D; 0的才会出现图1 这时候就不用连起来了 直接取最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> f2 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            sum = (arr[i] + sum) % mod;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">0</span>; e &lt; <span class="hljs-built_in">min</span>(k, <span class="hljs-number">2</span>); e++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f2 = (<span class="hljs-built_in">max</span>(f2, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">0</span>) + arr[i]);<br>            res = (<span class="hljs-built_in">max</span>(res, f2));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> res % mod;<br>        <span class="hljs-keyword">return</span> (res % mod + <span class="hljs-built_in">max</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)sum * (k - <span class="hljs-number">2</span>) % mod, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">0</span>)) % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="918-环形子数组的最大和-力扣（LeetCode）"><a href="#918-环形子数组的最大和-力扣（LeetCode）" class="headerlink" title="918. 环形子数组的最大和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;1</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240401130808479.png" srcset="/img/loading.gif" lazyload alt="image-20240401130808479" style="zoom:25%;" />

<p><strong>环形</strong> 可以将数组*2之后求 但是太麻烦 需要判断最多只能取n个数</p>
<p>仔细思考发现只有两种情况 </p>
<ol>
<li><p>不利用到环形 本身直接取就可以取到最大  就是普通的最大子列和问题</p>
</li>
<li><p>利用到环形 这时候就会选取数组前后端的数字 空出中间的  那么就可以计算中间的最小值 再用总和减去</p>
</li>
</ol>
<p>上面两种情况分别如下图所示</p>
<img src="../images/$%7Bfiilename%7D/image-20240401130901616.png" srcset="/img/loading.gif" lazyload alt="image-20240401130901616" style="zoom:25%;" />

<p>分析完后其实跟前两题 求绝对值的有点类似 </p>
<p>注意由于数组不能为空 当resx小于等于0的时候 此时sum - resn肯定为0（resn是尽量小 resx小于0 那么说明整个数组全为负数 resx没有可以选的  resn此时全部选上了）那么最后就会返回0</p>
<p>但是其实答案是resx   这种全负数的情况就没有分取不取环形 只需要找最大的负数  就相当于普通最大子列和 直接返回resx</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">0</span>, maxn = <span class="hljs-number">0</span>, resx = nums[<span class="hljs-number">0</span>], resn = nums[<span class="hljs-number">0</span>], sum = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, <span class="hljs-number">0</span>) + nums[i];<br>            minn = <span class="hljs-built_in">min</span>(minn, <span class="hljs-number">0</span>) + nums[i];<br>            resx = <span class="hljs-built_in">max</span>(resx, maxn);<br>            resn = <span class="hljs-built_in">min</span>(resn, minn);<br>            sum += nums[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> resx &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">max</span>(resx, sum - resn): resx;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2321-拼接数组的最大分数-力扣（LeetCode）"><a href="#2321-拼接数组的最大分数-力扣（LeetCode）" class="headerlink" title="2321. 拼接数组的最大分数 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">2321. 拼接数组的最大分数 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;2</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240402224213797.png" srcset="/img/loading.gif" lazyload alt="image-20240402224213797" style="zoom:25%;" />

<p>直接求的话很难算 可以转换成最大字段和来求解  令diff[i] &#x3D; nums1[i] - nums2[i]  求出的最大子段和就是交换的区间 此时求出来的是1比2大的 把大的全部换到2中去 </p>
<p>diff[i] &#x3D; nums2[i] - nums1[i] 求出的是2比1大的 把大的全部换到1中 然后二者取较大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumsSplicedArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">diff</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>,  sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            diff[i] = nums1[i] - nums2[i];<br>            sum1 += nums1[i];<br>            sum2 += nums2[i];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f + diff[i], <span class="hljs-number">0</span>) ;<br>            res = <span class="hljs-built_in">max</span>(res, f);<br>        &#125;<br>        <span class="hljs-type">int</span> res1 = <span class="hljs-number">0</span>;<br>        f = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f - diff[i], <span class="hljs-number">0</span>);<br>            res1 = <span class="hljs-built_in">max</span>(res1, f);<br>        &#125;   <br>        ans = <span class="hljs-built_in">max</span>(sum1 + res1, sum2 + res);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="363-矩形区域不超过-K-的最大数值和-力扣（LeetCode）"><a href="#363-矩形区域不超过-K-的最大数值和-力扣（LeetCode）" class="headerlink" title="363. 矩形区域不超过 K 的最大数值和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;2</li>
</ul>
<h3 id="前缀和-暴力"><a href="#前缀和-暴力" class="headerlink" title="前缀和+暴力"></a>前缀和+暴力</h3><p>（前缀和数组-&gt;动态规划）</p>
<p>四重循环暴力求解 枚举每个矩形的解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>(), col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">qzh</span>(row + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                qzh[i][j] = qzh[i][j - <span class="hljs-number">1</span>] + qzh[i - <span class="hljs-number">1</span>][j] - qzh[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; i; ii++)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">0</span>; jj &lt; j; jj++)<br>                    &#123;<br>                        <br>                        <span class="hljs-type">int</span> u = qzh[i][j] - qzh[i][jj] - qzh[ii][j] + qzh[ii][jj];<br>                        cout&lt;&lt;u&lt;&lt;endl;<br>                        <span class="hljs-keyword">if</span> (u &lt;= k)<br>                        res = <span class="hljs-built_in">max</span>(u, res);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-comment">// for (int i = 1; i &lt;= row; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt;= col; j++)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         cout&lt;&lt;qzh[i][j]&lt;&lt;endl;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>苦鲁西~四重暴力会超时</p>
<h3 id="枚举左右边界-最大子列和"><a href="#枚举左右边界-最大子列和" class="headerlink" title="枚举左右边界+最大子列和"></a>枚举左右边界+最大子列和</h3><p>可以转为三重循环  枚举左 右边界 然后求每一行的前缀和   再求每一个前缀和的 <strong>最大子列和</strong> 就是最大的矩阵<img src="../images/$%7Bfiilename%7D/13fb1fcc1203665fe1c4ccc6221cef7e01921fe614b0e6b22a81a70eca4e79aa-image.png" srcset="/img/loading.gif" lazyload alt="image.png" style="zoom: 80%;" /></p>
<p>把他转换成 每个最大子列和（左边的） 就是右边的一个黄色区域 将$O(n^2)$的复杂度的枚举转为$2O(n)$的前缀和+最大子列和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dpmax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;rowsum, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxn = rowsum[<span class="hljs-number">0</span>], f = rowsum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; rowsum.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            f = <span class="hljs-built_in">max</span>(f, <span class="hljs-number">0</span>) + rowsum[i];<br>            maxn = <span class="hljs-built_in">max</span>(maxn, f);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maxn &lt;= k)<br>            <span class="hljs-keyword">return</span> maxn;<br><br>        maxn = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rowsum.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; rowsum.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                sum += rowsum[j];<br>                <span class="hljs-keyword">if</span> (sum &gt; maxn &amp;&amp; sum &lt;= k)<br>                    maxn = sum;<br>                <span class="hljs-keyword">if</span> (maxn == k)<span class="hljs-keyword">return</span> k;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>(), col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; col; l++) <br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rowsum</span><span class="hljs-params">(row, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; col; r++) <br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>                &#123;<br>                    rowsum[i] += matrix[i][r];<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dpmax</span>(rowsum, k)); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="二分-前缀和"><a href="#二分-前缀和" class="headerlink" title="二分+前缀和"></a>二分+前缀和</h3><p>枚举上下边界和左边界  通过二分快速找有边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>(), n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">sum</span>(m + <span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> top = <span class="hljs-number">1</span>; top &lt;= m; top++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bot = top; bot &lt;= m; bot++)<br>        &#123;<br>            set&lt;<span class="hljs-type">int</span>&gt;st;<br>            st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt;= n; r++)<br>            &#123;<br>                <span class="hljs-type">int</span> right = sum[bot][r] - sum[top - <span class="hljs-number">1</span>][r];<br>                <span class="hljs-keyword">auto</span> left = st.<span class="hljs-built_in">lower_bound</span>(right - k);<br>                <span class="hljs-keyword">if</span> (left != st.<span class="hljs-built_in">end</span>())<br>                &#123;<br>                    <span class="hljs-type">int</span> cur = right - *left;<br>                    ans = <span class="hljs-built_in">max</span>(ans, cur);<br>                &#125;<br>                st.<span class="hljs-built_in">insert</span>(right);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>



<h2 id="894-所有可能的真二叉树-力扣（LeetCode）"><a href="#894-所有可能的真二叉树-力扣（LeetCode）" class="headerlink" title="894. 所有可能的真二叉树 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-possible-full-binary-trees/?envType=daily-question&envId=2024-04-02">894. 所有可能的真二叉树 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;2</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240402092713887.png" srcset="/img/loading.gif" lazyload alt="image-20240402092713887" style="zoom:25%;" />

<p>对于二叉树相关的题目 一般就是先求左右的信息然后再合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">process</span>(n);<br>    &#125;<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;TreeNode*&gt; res = ....;<br>        ....<span class="hljs-comment">//根节点和基本操作</span><br>        vector&lt;TreeNode*&gt;lefttree = <span class="hljs-built_in">process</span>();<br>        vector&lt;TreeNode*&gt;righttree = <span class="hljs-built_in">process</span>();<br>        ....<span class="hljs-comment">//合并</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>很容易想到n &#x3D;&#x3D; 0  n &#x3D;&#x3D; 1 n为偶数的时候 三个特判条件</p>
<p>要求按所有可能的结果返回  肯定需要遍历 </p>
<p>结点总数为n 可以枚举左子树的结点数 左子树结点数为i的时候 右子树结点数为n - i - 1   (其实就是左右节点再接上一个结点数较少的数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i+=<span class="hljs-number">2</span>) <span class="hljs-comment">// 结点数至少为1 每次加两个</span><br>&#123;<br>    lefttree = <span class="hljs-built_in">process</span>(i);<br>    righttree = <span class="hljs-built_in">process</span>(n - i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 得到了左右子树 现在需要合并 也就是把左右子树加到根节点 然后储存</span><br>    <span class="hljs-keyword">for</span> (TreeNode* leftnode:leftsub)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode* rightnode:rightsub)<br>                &#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, leftnode, rightnode);<br>                    ret.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键在于对题目的分析 想到枚举左子树的节点数目</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt;ret;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>)&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>)<br>        &#123;<br>            vector&lt;TreeNode*&gt;leftsub = <span class="hljs-built_in">allPossibleFBT</span>(i);<br>            vector&lt;TreeNode*&gt;rightsub = <span class="hljs-built_in">allPossibleFBT</span>(n - i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (TreeNode* leftnode:leftsub)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode* rightnode:rightsub)<br>                &#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, leftnode, rightnode);<br>                    ret.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="xmuoj-矩阵链乘法问题（附加）"><a href="#xmuoj-矩阵链乘法问题（附加）" class="headerlink" title="xmuoj | 矩阵链乘法问题（附加）"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/226/problem/6">xmuoj | 矩阵链乘法问题（附加）</a></h2><ul>
<li>4&#x2F;3</li>
</ul>
<p>矩阵连乘问题 </p>
<p>状态表示为dp[i] [j]表示从i到j 的最少次数 </p>
<p>状态计算为在i j 中间选出一个分割点k 使dp[i] [j] &#x3D; min(dp[i] [j], dp[i] [k] + dp[k + 1] [j] + nums[i - 1] * nums[k] * nums[j])</p>
<p>也就是i到k最少的次数 加上k + 1到j最少的次数 再加上两个合并到一起所需要的次数</p>
<p>需要注意 由于求得是最小值 如果k直接i到j循环取min的话 最后取出来全是0  所以得先给dp[i] [j]赋值为k &#x3D; i的情况 然后枚举i + 1到j</p>
<p>枚举<strong>区间长度</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-type">int</span> a, b;<br>	<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		nums[i] = a;<br>	&#125;<br>	nums[n] = b;<br>	<span class="hljs-keyword">for</span> (len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[i] * nums[j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[k] * nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来再看如何构造最优子序列</p>
<p>添加一个s[i]数组 每次记录分割的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> dp[N][N], s[N][N];<br><span class="hljs-type">int</span> nums[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i == j)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A&quot;</span>&lt;&lt;i;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>;<br>    <span class="hljs-built_in">traceback</span>(i, s[i][j]);<br>    <span class="hljs-built_in">traceback</span>(s[i][j] + <span class="hljs-number">1</span>, j);<br>    cout&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-type">int</span> a, b;<br>	<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		nums[i] = a;<br>	&#125;<br>	nums[n] = b;<br>	<span class="hljs-keyword">for</span> (len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[i] * nums[j];<br>            s[i][j] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>            &#123;<br>                <span class="hljs-type">int</span> t = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + nums[i - <span class="hljs-number">1</span>] * nums[k] * nums[j];<br>                <span class="hljs-keyword">if</span> (t &lt; dp[i][j])<br>                &#123;<br>                    dp[i][j] = t;<br>                    s[i][j] = k;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="xmuoj-元素共鸣：唤醒神之眼"><a href="#xmuoj-元素共鸣：唤醒神之眼" class="headerlink" title="xmuoj | 元素共鸣：唤醒神之眼"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/226/problem/1">xmuoj | 元素共鸣：唤醒神之眼</a></h2><ul>
<li>4&#x2F;3</li>
</ul>
<p>相邻的两座石柱合并  其实跟书上的矩阵连乘问题很类似 （如上题）</p>
<p>同样是在相邻的两个之间进行操作 并且每次操作都是寻找最小的划分区间 然后再计算合并所需的值（一般根据区间决定）</p>
<p>代码几乎一样  只不过在合并相加的时候有区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], qzh[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">500</span>][<span class="hljs-number">500</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[i];<br>	&#125;<br>	qzh[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		qzh[i] = qzh[i - <span class="hljs-number">1</span>] + nums[i];<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) <br>		&#123;<br>			<span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>          dp[i][j] = dp[i][i] + dp[i + <span class="hljs-number">1</span>][j] + qzh[j] - qzh[i - <span class="hljs-number">1</span>];<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>			&#123;<br>				dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i][k] + dp[k + <span class="hljs-number">1</span>][j]  + qzh[j] - qzh[i - <span class="hljs-number">1</span>]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="xmuoj-元素共鸣：深层次的唤醒"><a href="#xmuoj-元素共鸣：深层次的唤醒" class="headerlink" title="xmuoj | 元素共鸣：深层次的唤醒"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/226/problem/2">xmuoj | 元素共鸣：深层次的唤醒</a></h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">1000. 合并石头的最低成本 - 力扣（LeetCode）</a></p>
<ul>
<li>4&#x2F;3</li>
</ul>
<p>是上一题的变式 由于要合并k个区间 首先要判断什么区间不能合并  n堆变成1堆  减少了 n - 1堆  每次合并都减少k - 1堆 所以n - 1需要是k - 1的倍数 </p>
<p>状态表示 dp[i] [j] [k] 表示i到j分成k堆的最小消耗</p>
<p>状态计算 仍然是分成两份 一份1 一份k - 1 dp[i] [j] [k] &#x3D; dp[i] [p] [1] + dp[p + 1] [j] [k - 1]  然后剩下的需要枚举的就是p了 枚举p就很简单 注意每次增加k - 1</p>
<p>然后在计算、合并完 得到dp[i] [j] [k] 的时候 再将他合并（到k个了 可以合并）dp[i] [j] [1]就为dp[i] [j] [k]加上消耗sum[j] - sum[i - 1]（这个消耗是每次合并产生的）</p>
<p>注意初始化 其实也可以直接用memset将dp全部变为1e9 然后dp[i] [i] [1] i i本来就是一堆 不需要代价 所以为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> nums[N], sum[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">500</span>][<span class="hljs-number">500</span>][<span class="hljs-number">50</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, k;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[i];<br>	&#125;<br>	<span class="hljs-comment">// dp i j i到j的最小  状态计算-</span><br>	cin &gt;&gt; k;<br><br>	<span class="hljs-keyword">if</span> ((n - <span class="hljs-number">1</span>) % (k - <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">2</span>; m &lt;= k; m++)<br>                dp[i][j][m] = <span class="hljs-number">1e9</span>;<br>        &#125;<br>        dp[i][i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">2</span>; m &lt;= k; m++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = i; p &lt; j; p += k - <span class="hljs-number">1</span>)<br>                &#123;<br>                    dp[i][j][m] = <span class="hljs-built_in">min</span>(dp[i][j][m], dp[i][p][<span class="hljs-number">1</span>] + dp[p + <span class="hljs-number">1</span>][j][m - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            dp[i][j][<span class="hljs-number">1</span>] = dp[i][j][k] + sum[j] - sum[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="xmuoj-提瓦特庆典策划"><a href="#xmuoj-提瓦特庆典策划" class="headerlink" title="xmuoj | 提瓦特庆典策划"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/226/problem/3">xmuoj | 提瓦特庆典策划</a></h2><ul>
<li>4&#x2F;3</li>
</ul>
<p>经典树上DP 没有上司的舞会</p>
<p>首先要考虑数据的存储  每个人的情绪用nums[i]来存 上司和下属的关系可以用树的方式来存 用邻接表会简单很多（邻接矩阵也可以 但是浪费空间）</p>
<p>之后就是动态规划  树上dp用递归+备忘录的方法会更好写 也更符合直觉 dp[i] [0] 表示i不来的情况下 最大情绪  dp[i] [1]表示i来的情况下 最大情绪  </p>
<p>状态计算 dp[i] [0] +&#x3D; max(dp[son] [0], dp[son] [1])</p>
<p>dp[i] [1] +&#x3D; dp[son] [0] 这里的son表示i的下属 注意当i不来的时候 下属并不是一定都来  也有不来会更好的情况 所以用max</p>
<p>由状态转移方程可以很容易看出来 想算上司的 就要先把下属的算出来  所以递归要放在前面 先把下属的状态算好</p>
<p>然后要找出最大的上司 从他开始计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6005</span>;<br><span class="hljs-type">int</span> n, nums[N], v[N], boss;<br>vector&lt;<span class="hljs-type">int</span>&gt;son[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dpmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[x][<span class="hljs-number">1</span>] = nums[x];<br>    <span class="hljs-comment">// 算当前这个人去/不去的最大价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y:son[x])<br>    &#123;<br>        <span class="hljs-comment">// 先算下属</span><br>        <span class="hljs-built_in">dpmax</span>(y);<br>        dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[y][<span class="hljs-number">0</span>], dp[y][<span class="hljs-number">1</span>]);<br>        dp[x][<span class="hljs-number">1</span>] += dp[y][<span class="hljs-number">0</span>]; <span class="hljs-comment">// x去y只能不去</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin&gt;&gt;nums[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> p, q;<br>        cin&gt;&gt;p&gt;&gt;q;<br>        son[q].<span class="hljs-built_in">push_back</span>(p);<br>        v[p] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            boss = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dpmax</span>(boss);<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[boss][<span class="hljs-number">0</span>], dp[boss][<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="xmuoj-装配线调度问题（附加）⁤"><a href="#xmuoj-装配线调度问题（附加）⁤" class="headerlink" title="xmuoj | 装配线调度问题（附加）⁤"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/226/problem/4">xmuoj | 装配线调度问题（附加）⁤</a></h2><ul>
<li>4&#x2F;3</li>
</ul>
<p>一开始看到题目这么长有点懵 但是其实题意很简单 就是一个物品 从0走到n 每一步都可以选择在当前线装配 或者换一条线装配（换线需要时间）然后加上进厂出厂时间 得到最短出场时间</p>
<p>本来想用dp[i]表示到i的最短时间 但是这样状态没办法转移 不知道当前在哪条线上 所以可以多加一个维度 记录每一条线上到i的最短时间  </p>
<p>状态表示为dp[i] [0] dp[i] [1] (提交的时候写的是dp1[i]和dp2[i])</p>
<p>状态计算  到i的最短时间为 两条线的 i-1的时候的最短时间加上转移&#x2F;不转移所需要的时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> change[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> e1, e2, x1, x2;<br><span class="hljs-type">int</span> dp1[N], dp2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[<span class="hljs-number">1</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[<span class="hljs-number">2</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; change[<span class="hljs-number">1</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; change[<span class="hljs-number">2</span>][i];<br>	&#125;<br>	cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; x1 &gt;&gt; x2;<br>    <br>    dp1[<span class="hljs-number">0</span>] = e1 + nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    dp2[<span class="hljs-number">0</span>] = e2 + nums[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        dp1[i] = <span class="hljs-built_in">min</span>(dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i], dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>]);<br>        dp2[i] = <span class="hljs-built_in">min</span>(dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i], dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(dp1[n] + x1, dp2[n] + x2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来构造最优子结构</p>
<p>添加 s1[N] s2[N]数组记录最优解的时候 第i - 1个配件是在第一条线还是第二条线 s记录最后那条线出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> change[<span class="hljs-number">3</span>][N];<br><span class="hljs-type">int</span> e1, e2, x1, x2;<br><span class="hljs-type">int</span> dp1[N], dp2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[<span class="hljs-number">1</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[<span class="hljs-number">2</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; change[<span class="hljs-number">1</span>][i];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; change[<span class="hljs-number">2</span>][i];<br>	&#125;<br>	cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; x1 &gt;&gt; x2;<br>    <br>    dp1[<span class="hljs-number">0</span>] = e1 + nums[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    dp2[<span class="hljs-number">0</span>] = e2 + nums[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] &lt; dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>])<br>        &#123;<br>            dp1[i] = dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i];<br>            s1[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp1[i] = dp1[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">1</span>][i] + change[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>];<br>            s1[i] = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] &lt; dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])<br>        &#123;<br>            dp2[i] = dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i];<br>            s2[i] = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp2[i] = dp2[i - <span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>][i] + change[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br>            s2[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (dp1[n] + x1 &lt; dp2[n] + x2)<br>    &#123;<br>        ans = dp1[n] + x1;<br>        l = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        ans = dp2[n] + x2;<br>        l = <span class="hljs-number">2</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">// traceback</span><br>    <span class="hljs-type">int</span> i = l;<br>    cout&lt;&lt;<span class="hljs-string">&quot;station&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot; line&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= <span class="hljs-number">2</span>; j--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>            i = s1[j];<br>        <span class="hljs-keyword">else</span> i = s2[j];<br>        cout&lt;&lt;<span class="hljs-string">&quot;station&quot;</span>&lt;&lt;j - <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; line&quot;</span>&lt;&lt;i&lt;&lt;endl;<span class="hljs-comment">// 第j个步骤 在i流水线</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="LCR-166-珠宝的最高价值-力扣（LeetCode）"><a href="#LCR-166-珠宝的最高价值-力扣（LeetCode）" class="headerlink" title="LCR 166. 珠宝的最高价值 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/">LCR 166. 珠宝的最高价值 - 力扣（LeetCode）</a></h2><p>从左上到右下，二维DP。</p>
<p>状态表示：dp[i] [j] 到第i行第j列的最高价值。</p>
<p>状态计算：dp[i] [j] &#x3D; max(dp[i -1] [j], dp[i] [j - 1]) + frame[i] [j]表示从较大的位置转移</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jewelleryValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; frame)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = frame.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = frame[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + frame[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></h2><p>同样是网格图DP，相当于二维的爬楼梯</p>
<p>跟其他题不一样的在于初始化，第一行和第一列都是1，只有一种走法。</p>
<p>状态表示：dp[i] [j] 表示到第i行第j列的走法</p>
<p>状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++)<br>            &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// debug</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="63-不同路径-II-力扣（LeetCode）"><a href="#63-不同路径-II-力扣（LeetCode）" class="headerlink" title="63. 不同路径 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></h2><p>上题的变式，图中增加了障碍物，只有在没有遇到障碍物的时候才可以转移，障碍物位设置为0，表示到这里有0种走法。</p>
<p>状态表示：dp[i] [j] 表示到第i行第j列的走法</p>
<p>状态计算：dp[i - 1] [j] + dp[i] [j - 1] 表示到i - 1 j的走法和i j - 1的走法相加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> row = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(row + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++)<br>            &#123;<br>                cout&lt;&lt;dp[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][col];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="120-三角形最小路径和-力扣（LeetCode）"><a href="#120-三角形最小路径和-力扣（LeetCode）" class="headerlink" title="120. 三角形最小路径和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/submissions/523893909/">120. 三角形最小路径和 - 力扣（LeetCode）</a></h2><h3 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h3><p>状态表示：dp[i] [j] 到第i行第j列的最小路径和。</p>
<p>状态计算：每一步只能从上一行的j或j - 1列移动到当前行的第j列。</p>
<p>要特殊处理第0列（因为第0列只能由上一行的第0列转移）和第i列（第i列只能由i - 1列转移）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = triangle[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + triangle[i][j];<br>            &#125;<br>            dp[i][i] = dp[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + triangle[i][i];<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, dp[n - <span class="hljs-number">1</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h3><p>注意到只用了i和i - 1两行，可以进行状态压缩。直接更新到原来的位置上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        f[<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + triangle[i][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--)<br>            &#123;<br>                f[j] = <span class="hljs-built_in">min</span>(f[j], f[j - <span class="hljs-number">1</span>]) + triangle[i][j];<br>            &#125;<br>            f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">0</span>] + triangle[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h2 id="312-戳气球-力扣（LeetCode）"><a href="#312-戳气球-力扣（LeetCode）" class="headerlink" title="312. 戳气球 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球 - 力扣（LeetCode）</a></h2><p>状态表示：dp[i] [j] 表示从i到j的最大数量</p>
<p>状态计算：枚举k（每一个断点）求出在每个k断开的sum。dp[i] [j] &#x3D; max(sum)</p>
<p>初始化：注意两边的为1，所以一开始要初始化为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        ll val[n + <span class="hljs-number">2</span>];<br>        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            val[i] = nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)<br>                &#123;<br>                    ll sum = dp[i][k] + dp[k][j];<br>                    sum += val[i] * val[j] * val[k];<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="377-组合总和-Ⅳ-力扣（LeetCode）"><a href="#377-组合总和-Ⅳ-力扣（LeetCode）" class="headerlink" title="377. 组合总和 Ⅳ - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></h2><p>还是爬楼梯问题，target为最终楼梯层数，dp[i] 表示到i有多少种走法</p>
<p>每次可以走nums[k]步</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum4</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        状态表示：dp[i] 1~i有多少种</span><br><span class="hljs-string">        状态计算：dp[i - 1] = dp</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br><br>        <span class="hljs-comment"># @cache</span><br>        <span class="hljs-comment"># def dfs(i):</span><br>        <span class="hljs-comment">#     if i == 0:</span><br>        <span class="hljs-comment">#         return 1</span><br>        <span class="hljs-comment">#     return sum(dfs(i - x) for x in nums if x &lt;= i)</span><br>        <span class="hljs-comment"># return dfs(target)</span><br>        <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * target<br>        <span class="hljs-comment"># for i in range(1, target + 1):    </span><br>        <span class="hljs-comment">#     dp[i] += sum(dp[i - x] for x in nums if x &lt;= i)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> x &lt;= i:<br>                    dp[i] += dp[i - x]<br>        <span class="hljs-keyword">return</span> dp[target]<br></code></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="2192-有向无环图中一个节点的所有祖先-力扣（LeetCode）"><a href="#2192-有向无环图中一个节点的所有祖先-力扣（LeetCode）" class="headerlink" title="2192. 有向无环图中一个节点的所有祖先 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/submissions/520849062/?envType=daily-question&envId=2024-04-04">2192. 有向无环图中一个节点的所有祖先 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;4</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240407164600674.png" srcset="/img/loading.gif" lazyload alt="image-20240407164600674" style="zoom:25%;" />

<p>计算有向无环图的所有祖先 首先先用邻接矩阵存图 </p>
<p>然后用dfs的方法求每个点的祖先</p>
<h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3><p>存反图 循环到这个结点的时候 就反向往上走 直到根节点 记录下每次走的结点 加入数组中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e:edges)<br>        &#123;<br>            g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">ans</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n);<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            vis[x] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 避免重复访问</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : g[x]) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[y]) &#123;<br>                    <span class="hljs-built_in">dfs</span>(y); <span class="hljs-comment">// 只递归没有访问过的点</span><br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            ranges::<span class="hljs-built_in">fill</span>(vis, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">dfs</span>(i);<br>            vis[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (vis[j])<br>                    ans[i].<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h3 id="正向遍历"><a href="#正向遍历" class="headerlink" title="正向遍历"></a>正向遍历</h3><p>存正图 但是遍历方式改变 不是对每个结点先找到他的所有祖先 而是对每个结点作为根 找他的孩子 然后在孩子数组中存入根</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">g</span>(n);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: edges)<br>        &#123;<br>            g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        &#125;   <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">ans</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> start;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x)<br>        &#123;<br>            vis[x] = start;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y:g[x])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (vis[y] != start)<br>                &#123;<br>                    ans[y].<span class="hljs-built_in">push_back</span>(start);<br>                    <span class="hljs-built_in">dfs</span>(y);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; n; start++) &#123;<br>            <span class="hljs-built_in">dfs</span>(start); <span class="hljs-comment">// 从 start 开始 DFS</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h2 id="1026-节点与其祖先之间的最大差值-力扣（LeetCode）"><a href="#1026-节点与其祖先之间的最大差值-力扣（LeetCode）" class="headerlink" title="1026. 节点与其祖先之间的最大差值 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/submissions/520874666/?envType=daily-question&envId=2024-04-05">1026. 节点与其祖先之间的最大差值 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;5</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240407170407950.png" srcset="/img/loading.gif" lazyload alt="image-20240407170407950" style="zoom:25%;" />

<p>遍历整棵树 在每个结点记录到当前节点为止最大和最小值</p>
<p>（回溯的思想）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode*root, <span class="hljs-type">int</span> minn, <span class="hljs-type">int</span> maxn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;<br>    ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(minn - root-&gt;val));<br>    ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(maxn - root-&gt;val));<br>    <span class="hljs-keyword">if</span> (root-&gt;left)<span class="hljs-built_in">dfs</span>(root-&gt;left, <span class="hljs-built_in">min</span>(root-&gt;left-&gt;val, minn), <span class="hljs-built_in">max</span>(root-&gt;left-&gt;val, maxn));<br>    <span class="hljs-keyword">if</span> (root-&gt;right)<span class="hljs-built_in">dfs</span>(root-&gt;right, <span class="hljs-built_in">min</span>(root-&gt;right-&gt;val, minn), <span class="hljs-built_in">max</span>(root-&gt;right-&gt;val, maxn));<br>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAncestorDiff</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, root-&gt;val, root-&gt;val);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1483-树节点的第-K-个祖先-力扣（LeetCode）、"><a href="#1483-树节点的第-K-个祖先-力扣（LeetCode）、" class="headerlink" title="1483. 树节点的第 K 个祖先 - 力扣（LeetCode）、"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/submissions/520993127/?envType=daily-question&envId=2024-04-06">1483. 树节点的第 K 个祖先 - 力扣（LeetCode）</a>、</h2><ul>
<li>4&#x2F;6</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240407172214527.png" srcset="/img/loading.gif" lazyload alt="image-20240407172214527" style="zoom:25%;" />

<p>直接暴力求解很简单 但是会超时 由于需要多次访问祖先  可以用倍增的思想 每次访问第1 2 4 8 … $2^n$的祖先</p>
<p>用二维数组pa存每个结点x的祖先 pa[0] [0] 表示0的第1个祖先 pa[0] [1]表示0的第2个祖先（父节点的父节点）</p>
<p>pa[x] [0]&#x3D;parent[x]父节点</p>
<p>pa[x] [1] &#x3D; pa[pa[x] [0]] [0]爷爷节点</p>
<p>pa[x] [i + 1] &#x3D; pa[pa[x] [i]] [i]表示x的第$2^i$个祖先结点  如果不够的话会直接存成根节点（因为最上面的祖先肯定存的是根）</p>
<p>注意循环初始化外层是i内层是x 因为必须先把所有第i层的x更新完 才能更新第i + 1层的 （i + 1层有用到i的 如果顺序反了可能有些没更新到就被使用了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;pa;<br>    <span class="hljs-built_in">TreeAncestor</span>(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent) <br>    &#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span>;<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            pa[i][<span class="hljs-number">0</span>] = parent[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">31</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++)<br>            &#123;<br>                <span class="hljs-type">int</span> p = pa[x][i]; <br>                <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span>)<br>                &#123;<br>                    pa[x][i + <span class="hljs-number">1</span>] = pa[p][i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKthAncestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((k &gt;&gt; i) &amp; <span class="hljs-number">1</span>)<br>            &#123;<br>                node = pa[node][i];<br>                <span class="hljs-keyword">if</span> (node &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;   <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TreeAncestor object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h2 id="1600-王位继承顺序-力扣（LeetCode）"><a href="#1600-王位继承顺序-力扣（LeetCode）" class="headerlink" title="1600. 王位继承顺序 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/throne-inheritance/submissions/520803923/">1600. 王位继承顺序 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;7</li>
</ul>
<p>王位继承制 皇上-嫡长子-嫡长孙…这一脉亖绝了轮到次长子一脉</p>
<p>要记录的东西比较多 可以用map&lt;string, vector&lt;string&gt;&gt;来记录每个人的儿子 用set来记录死亡的人</p>
<p>最后get的时候  用dfs 深搜  按每一脉的人来搜索 如果死了就不用记录</p>
<img src="../images/$%7Bfiilename%7D/image-20240407164502464.png" srcset="/img/loading.gif" lazyload alt="image-20240407164502464" style="zoom:25%;" />

<h2 id="924-尽量减少恶意软件的传播-力扣（LeetCode）"><a href="#924-尽量减少恶意软件的传播-力扣（LeetCode）" class="headerlink" title="924. 尽量减少恶意软件的传播 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播 - 力扣（LeetCode）</a></h2><p>要读懂题意，假设以一个连通图中有两个以上的原始病毒，那么删除其中一个是<strong>毫无作用</strong>的，因此这个题就是要找<strong>只有一个</strong>原始病毒的最大连通图。</p>
<p>关键在于这么判断这个连通图中有多少原始病毒。</p>
<p>将node_id初始化为-1，第一次遇到原始病毒的时候，就更新为x，表示待删去的原始病毒。但是如果第二次再遇到了病毒，那么就要将这个结点置为-2，表示这个连通图不可能减少感染次数了。同时再dfs中记录连通图的大小。</p>
<p>最后如果node_id &gt;&#x3D; 0 并且size &gt; max_size 或者size &#x3D;&#x3D; max_size 但是下标较小（node_id &lt; ans）就更新ans</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMalwareSpread</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; initial)</span> </span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-comment">// 如果一个连通块有多个感染节点 去掉了跟没去掉一样</span><br>        <span class="hljs-comment">// 找只有一个感染结点的连通块 最大连通数量</span><br><br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">st</span>(initial.<span class="hljs-built_in">begin</span>(), initial.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">vis</span>(n);<br><br>        <span class="hljs-built_in">sort</span>(initial.<span class="hljs-built_in">begin</span>(), initial.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans = initial[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>, node_id = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;dfs = [&amp;](<span class="hljs-type">int</span> x)<br>        &#123;<br>            vis[x] = <span class="hljs-number">1</span>;<br>            size++;<br>            <span class="hljs-keyword">if</span> (node_id != <span class="hljs-number">-2</span> &amp;&amp; st.<span class="hljs-built_in">contains</span>(x))<br>            &#123;<br>                node_id = node_id == <span class="hljs-number">-1</span> ? x : <span class="hljs-number">-2</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (graph[x][y] &amp;&amp; !vis[y])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(y);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> max_size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: initial)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[x])<span class="hljs-keyword">continue</span>;<br><br>            node_id = <span class="hljs-number">-1</span>;<br>            size = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(x);<br>            <span class="hljs-keyword">if</span> (node_id &gt;= <span class="hljs-number">0</span> &amp;&amp; (size &gt; max_size || size == max_size &amp;&amp; node_id &lt; ans))<br>            &#123;<br>                ans = node_id;<br>                max_size = size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="xmuoj-蒙德冒险者的游戏"><a href="#xmuoj-蒙德冒险者的游戏" class="headerlink" title="xmuoj | 蒙德冒险者的游戏"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/229/problem/2">xmuoj | 蒙德冒险者的游戏</a></h2><p>显然可以发现 承受能力强的需要放下面 重量大的需要放下面 但是这里有两个条件 应该按什么标准来放呢  可以假设最有序列为$y_1y_2y_3…y_n$贪心所得的序列为$x_1x_2x_3…x_n$ 假设$x_k$与$x_i$交换可以得到更优的序列</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">ans1 = w1+w2...wk+..wn - si<br>ans2 = w1+w2...wi+..wn - sk<br>假设ans2 &lt; ans1 则 wi-sk&lt;wk-si即wi + si &lt; wk + sk 而ans2更优说明wk+sk大的应该放下面<br>所以按w+s的和排序<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span><br>&#123;<br>	ll w, s, a;<br>&#125;nums[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		cin &gt;&gt; nums[i].w &gt;&gt; nums[i].s;<br>		nums[i].a = nums[i].w + nums[i].s;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(nums, nums + n, [&amp;](Man a, Man b) &#123;<br>		<span class="hljs-keyword">if</span> (a.a != b.a)<span class="hljs-keyword">return</span> a.a &lt;= b.a;<br>		<span class="hljs-keyword">return</span> a.s &lt;= b.s;<br>		&#125;);<br>	ll sum = <span class="hljs-number">0</span>;<br>	ll ans = <span class="hljs-number">-1e18</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		ans = <span class="hljs-built_in">max</span>(ans, sum - nums[i].s);<br>		sum += nums[i].w;<br>	&#125;<br><br>	<br>	cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="xmuoj-宝藏探索"><a href="#xmuoj-宝藏探索" class="headerlink" title="xmuoj | 宝藏探索"></a><a target="_blank" rel="noopener" href="https://www.xmuoj.com/contest/229/problem/3">xmuoj | 宝藏探索</a></h2><p>贪心 关键是怎么贪，题目长条件多 要慢慢分析</p>
<p>贪心思路<strong>优先选择鱼最多的湖</strong> 关键是过去每个湖又需要时间 而且只能单向地走</p>
<p>但是可以换种思考方式  每次选择鱼最多的湖 比如先选了1 2 2 3 3 1 1 4  就可以认为是在1停留了3次 其实根往返是差不多的</p>
<p>然后就是过湖的时间 可以枚举每次走几个湖直接把过的时间算上  然后剩下的就是纯钓鱼的时间 然后在当前能去的几个湖里找最多的钓 然后这个湖被钓过了就递减一次 然后再循环找最大的…直到钓鱼时间耗尽 记录记录最大钓鱼数以及每个湖停留的时间 最后输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">100</span>][<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> anss[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> nu[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> n, h;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        nu[k] = n;<br>        cin &gt;&gt; h;<br>        h *= <span class="hljs-number">12</span>;<br>        <br>        <br>        <span class="hljs-type">int</span> f[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> d[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> t[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            cin &gt;&gt; f[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            cin &gt;&gt; d[i];<br>        t[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            cin &gt;&gt; t[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            t[i] += t[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">int</span> maxpool = <span class="hljs-number">0</span>, maxfishtime = <span class="hljs-number">0</span>, maxfish = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tempfish[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (h &gt; t[i])<br>            &#123;<br>                <span class="hljs-type">int</span> rec[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>                maxfishtime = h - t[i];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>                &#123;<br>                    tempfish[j] = f[j];<br>                &#125;<br>                <span class="hljs-type">int</span> nowpoolmax = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (maxfishtime &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    maxfish = <span class="hljs-number">-1e9</span>;<br>                    maxpool = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= i; k++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (maxfish &lt; tempfish[k])<br>                        &#123;<br>                            maxpool = k;<br>                            maxfish = tempfish[k];<br>                        &#125;<br>                    &#125;<br>                   <br>                    nowpoolmax += maxfish;<br>                    rec[maxpool]++;<br>                    <span class="hljs-keyword">if</span> (tempfish[maxpool] &gt; d[maxpool])<br>                        tempfish[maxpool] -= d[maxpool];<br>                    <span class="hljs-keyword">else</span><br>                        tempfish[maxpool] = <span class="hljs-number">0</span>;<br><br>                    maxfishtime--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nowpoolmax &gt; ans)<br>                &#123;<br>                    ans = nowpoolmax;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>                        res[k][i] = rec[i];<br>                &#125;<br>                anss[k] = ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nu[j]; i++)<br>        &#123;<br>          <span class="hljs-keyword">if</span>(i != nu[j])<br>            cout &lt;&lt; res[j][i] * <span class="hljs-number">5</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>          <span class="hljs-keyword">else</span> cout&lt;&lt;res[j][i] * <span class="hljs-number">5</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, anss[j]);<br>        <span class="hljs-keyword">if</span> (j != k - <span class="hljs-number">1</span>)cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1702-修改后的最大二进制字符串-力扣（LeetCode）"><a href="#1702-修改后的最大二进制字符串-力扣（LeetCode）" class="headerlink" title="1702. 修改后的最大二进制字符串 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-string-after-change/?envType=daily-question&envId=2024-04-10">1702. 修改后的最大二进制字符串 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;10</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240411135815782.png" srcset="/img/loading.gif" lazyload alt="image-20240411135815782" style="zoom:25%;" />

<p>00-&gt;10  10-&gt;01要使最后的结果最大 就需要尽可能地将前面放上1 尽可能去除0 </p>
<p>从左往右 前面如果有1 就不用动了 当出现第一个0的时候 往后找 如果后面全是0 就全部变成10 比如0000-&gt;1110</p>
<p>如果后面有1 那就把1换到最右边 把0换到中间 这必然是可行的 比如101010011 把10换成01之后 1就可以再和后面的0结合成10 再换成01 因此可以把所有的0聚到中间 再使用00换成10 这样 最终<strong>最多</strong>只会剩下一个0就是中间所有0的最后一个位置</p>
<p>因此可以直接构造出最后的字符串 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n = binary.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-type">int</span> i = binary.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>      <span class="hljs-keyword">if</span> (i == string::npos)<br>          <span class="hljs-keyword">return</span> binary;<br><br>      <span class="hljs-type">int</span> zeros = <span class="hljs-built_in">count</span>(binary.<span class="hljs-built_in">begin</span>(), binary.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;0&#x27;</span>);<br>      <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br>      ans[i + zeros - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>      <span class="hljs-keyword">return</span> ans;<br>  <br></code></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列-力扣（LeetCode）"><a href="#300-最长递增子序列-力扣（LeetCode）" class="headerlink" title="300. 最长递增子序列 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>状态表示：dp[i] 表示1~i的最长上升子序列</p>
<p>状态计算：if(nums[i] &gt; nums[j])dp[i] &#x3D; max(dp[i], dp[j] + 1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// int n = nums.size();</span><br>        <span class="hljs-comment">// vector&lt;int&gt;dp(n);</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     dp[i] = 1;</span><br>        <span class="hljs-comment">//     for (int j = 0; j &lt; i; j++)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         if (nums[i] &gt; nums[j])</span><br>        <span class="hljs-comment">//             dp[i] = max(dp[i], dp[j] + 1);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// int ans = 1;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     ans = max(ans, dp[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return ans;</span><br><br>        vector&lt;<span class="hljs-type">int</span>&gt;g;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), x);<br>            <span class="hljs-keyword">if</span> (it == g.<span class="hljs-built_in">end</span>())<br>                g.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-keyword">else</span><br>                *it = x;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> g.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>最长上升子序列，那就找尽可能小的数，排在后面，这样的话就可以排更多的数，就更长。所以用二分法找大于当前最后一个数的最小数lower_bound</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2009-使数组连续的最少操作数-力扣（LeetCode）"><a href="#2009-使数组连续的最少操作数-力扣（LeetCode）" class="headerlink" title="2009. 使数组连续的最少操作数 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/submissions/521981730/?envType=daily-question&envId=2024-04-08">2009. 使数组连续的最少操作数 - 力扣（LeetCode）</a></h2><ul>
<li>4&#x2F;9</li>
</ul>
<img src="../images/$%7Bfiilename%7D/image-20240411135914967.png" srcset="/img/loading.gif" lazyload alt="image-20240411135914967" style="zoom:25%;" />

<p>给定一个数组 求将这个数组变为连续的最小操作数 </p>
<p>正难则反 可以先求出最大连续的子数组 然后再用n减去 就是最小操作数</p>
<p>注意 这里的<strong>最大连续</strong>不是1 2 3 4这样连续 (因为1 3 4 5只需要修改1个数 关键是看修改次数少的 中间空一些也可以)而是求出来 当前这个a~b区间内 在这个区间内的有多少个数 可以用滑动窗口来处理</p>
<p>窗口大小为n    左端点为nums[left] 因此最大的数就是nums[left] + n - 1 将nums[i]与其比较 如果合适就加入窗口 每次滑动记录最大值</p>
<p>注意 可能出现重复的数字 因此需要去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()) - nums.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[left] &lt; nums[i] - n + <span class="hljs-number">1</span>)<br>            &#123;<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, i - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1052-爱生气的书店老板-力扣（LeetCode）"><a href="#1052-爱生气的书店老板-力扣（LeetCode）" class="headerlink" title="1052. 爱生气的书店老板 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板 - 力扣（LeetCode）</a></h2><p>让最多顾客感到满意 也就是让最少的顾客不满意 不满意的人数本来是固定的 现在老板控制了自己的情绪 </p>
<p>  其实就是求 最大子段和 使得这一段中 人最多 那就是减少不满意的人最多<br>    用滑动窗口 </p>
<p>答案为 减少不满意的人数+原来就满意的人数 </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSatisfied</span>(<span class="hljs-params">self, customers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], grumpy: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], minutes: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>       <br><br>        sump = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, (c, x) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(customers, grumpy)):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>                grumpy[i] = c<br>            <span class="hljs-keyword">else</span>:<br>                sump += c<br>        <br>        maxp = win = <span class="hljs-built_in">sum</span>(grumpy[:minutes])<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(minutes, <span class="hljs-built_in">len</span>(grumpy)):<br>            win = win + grumpy[i] - grumpy[i - minutes]<br>            maxp = <span class="hljs-built_in">max</span>(maxp, win)<br>        <br>        <span class="hljs-keyword">return</span> sump + maxp<br><br></code></pre></td></tr></table></figure>



<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="2924-找到冠军-II-力扣（LeetCode）"><a href="#2924-找到冠军-II-力扣（LeetCode）" class="headerlink" title="2924. 找到冠军 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-champion-ii/description/?envType=daily-question&envId=2024-04-13">2924. 找到冠军 II - 力扣（LeetCode）</a></h2><p>图论题  但是可以用哈希过  冠军就是没有被打败过的队伍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findChampion</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: edges)<br>        &#123;<br>            ans[e[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>…        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="169-多数元素-力扣（LeetCode）"><a href="#169-多数元素-力扣（LeetCode）" class="headerlink" title="169. 多数元素 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素 - 力扣（LeetCode）</a></h2><p>区间的众数一定是左半区间的众数并且也是右半区间的众数。</p>
<p>每次选出左半区间的众数，和右半区间的众数 如果相同就直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_in_range</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++)<br>            <span class="hljs-keyword">if</span> (nums[i] == target)<br>                count++;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<span class="hljs-keyword">return</span> nums[l];<br><br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, l, mid);<br>        <span class="hljs-type">int</span> right_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, mid + <span class="hljs-number">1</span>, r);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, left_majority, l, r) &gt; (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left_majority;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, right_majority, l, r) &gt; (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> right_majority;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majority_element_rec</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/" class="print-no-link">#课程报告</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>4月</div>
      <div>https://brtulien.github.io/2024/03/31/4月/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Brtulien</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月1日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年6月21日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/13/5%E6%9C%88/" title="5月">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">5月</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/20/%E4%BA%8C%E5%88%86%E5%9B%BE/" title="二分图">
                        <span class="hidden-mobile">二分图</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"chasestar1/chasestar1.github.io","repo-id":"R_kgDOJ-WRYw","category":"Announcements","category-id":"DIC_kwDOJ-WRY84CYKx3","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","shortname":"fluid"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":{"opacity":0.7},"log":false});</script></body>
</html>
